/*! For license information please see main.55234c0e.js.LICENSE.txt */
(()=>{var e={4:(e,t,n)=>{"use strict";var r=n(853),s=n(43),a=n(950);function i(e){var t="https://react.dev/errors/"+e;if(1<arguments.length){t+="?args[]="+encodeURIComponent(arguments[1]);for(var n=2;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n])}return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function o(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType)}function l(e){var t=e,n=e;if(e.alternate)for(;t.return;)t=t.return;else{e=t;do{0!==(4098&(t=e).flags)&&(n=t.return),e=t.return}while(e)}return 3===t.tag?n:null}function u(e){if(13===e.tag){var t=e.memoizedState;if(null===t&&(null!==(e=e.alternate)&&(t=e.memoizedState)),null!==t)return t.dehydrated}return null}function c(e){if(l(e)!==e)throw Error(i(188))}function h(e){var t=e.tag;if(5===t||26===t||27===t||6===t)return e;for(e=e.child;null!==e;){if(null!==(t=h(e)))return t;e=e.sibling}return null}var d=Object.assign,p=Symbol.for("react.element"),f=Symbol.for("react.transitional.element"),m=Symbol.for("react.portal"),g=Symbol.for("react.fragment"),y=Symbol.for("react.strict_mode"),b=Symbol.for("react.profiler"),v=Symbol.for("react.provider"),x=Symbol.for("react.consumer"),w=Symbol.for("react.context"),k=Symbol.for("react.forward_ref"),S=Symbol.for("react.suspense"),N=Symbol.for("react.suspense_list"),I=Symbol.for("react.memo"),C=Symbol.for("react.lazy");Symbol.for("react.scope");var T=Symbol.for("react.activity");Symbol.for("react.legacy_hidden"),Symbol.for("react.tracing_marker");var A=Symbol.for("react.memo_cache_sentinel");Symbol.for("react.view_transition");var E=Symbol.iterator;function $(e){return null===e||"object"!==typeof e?null:"function"===typeof(e=E&&e[E]||e["@@iterator"])?e:null}var R=Symbol.for("react.client.reference");function D(e){if(null==e)return null;if("function"===typeof e)return e.$$typeof===R?null:e.displayName||e.name||null;if("string"===typeof e)return e;switch(e){case g:return"Fragment";case b:return"Profiler";case y:return"StrictMode";case S:return"Suspense";case N:return"SuspenseList";case T:return"Activity"}if("object"===typeof e)switch(e.$$typeof){case m:return"Portal";case w:return(e.displayName||"Context")+".Provider";case x:return(e._context.displayName||"Context")+".Consumer";case k:var t=e.render;return(e=e.displayName)||(e=""!==(e=t.displayName||t.name||"")?"ForwardRef("+e+")":"ForwardRef"),e;case I:return null!==(t=e.displayName||null)?t:D(e.type)||"Memo";case C:t=e._payload,e=e._init;try{return D(e(t))}catch(n){}}return null}var O=Array.isArray,_=s.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,F=a.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,M={pending:!1,data:null,method:null,action:null},L=[],P=-1;function z(e){return{current:e}}function B(e){0>P||(e.current=L[P],L[P]=null,P--)}function V(e,t){P++,L[P]=e.current,e.current=t}var W=z(null),U=z(null),j=z(null),G=z(null);function H(e,t){switch(V(j,t),V(U,e),V(W,null),t.nodeType){case 9:case 11:e=(e=t.documentElement)&&(e=e.namespaceURI)?sh(e):0;break;default:if(e=t.tagName,t=t.namespaceURI)e=ah(t=sh(t),e);else switch(e){case"svg":e=1;break;case"math":e=2;break;default:e=0}}B(W),V(W,e)}function q(){B(W),B(U),B(j)}function K(e){null!==e.memoizedState&&V(G,e);var t=W.current,n=ah(t,e.type);t!==n&&(V(U,e),V(W,n))}function X(e){U.current===e&&(B(W),B(U)),G.current===e&&(B(G),Kh._currentValue=M)}var Q=Object.prototype.hasOwnProperty,Y=r.unstable_scheduleCallback,Z=r.unstable_cancelCallback,J=r.unstable_shouldYield,ee=r.unstable_requestPaint,te=r.unstable_now,ne=r.unstable_getCurrentPriorityLevel,re=r.unstable_ImmediatePriority,se=r.unstable_UserBlockingPriority,ae=r.unstable_NormalPriority,ie=r.unstable_LowPriority,oe=r.unstable_IdlePriority,le=r.log,ue=r.unstable_setDisableYieldValue,ce=null,he=null;function de(e){if("function"===typeof le&&ue(e),he&&"function"===typeof he.setStrictMode)try{he.setStrictMode(ce,e)}catch(t){}}var pe=Math.clz32?Math.clz32:function(e){return 0===(e>>>=0)?32:31-(fe(e)/me|0)|0},fe=Math.log,me=Math.LN2;var ge=256,ye=4194304;function be(e){var t=42&e;if(0!==t)return t;switch(e&-e){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:return 128;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return 4194048&e;case 4194304:case 8388608:case 16777216:case 33554432:return 62914560&e;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return e}}function ve(e,t,n){var r=e.pendingLanes;if(0===r)return 0;var s=0,a=e.suspendedLanes,i=e.pingedLanes;e=e.warmLanes;var o=134217727&r;return 0!==o?0!==(r=o&~a)?s=be(r):0!==(i&=o)?s=be(i):n||0!==(n=o&~e)&&(s=be(n)):0!==(o=r&~a)?s=be(o):0!==i?s=be(i):n||0!==(n=r&~e)&&(s=be(n)),0===s?0:0!==t&&t!==s&&0===(t&a)&&((a=s&-s)>=(n=t&-t)||32===a&&0!==(4194048&n))?t:s}function xe(e,t){return 0===(e.pendingLanes&~(e.suspendedLanes&~e.pingedLanes)&t)}function we(e,t){switch(e){case 1:case 2:case 4:case 8:case 64:return t+250;case 16:case 32:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return t+5e3;default:return-1}}function ke(){var e=ge;return 0===(4194048&(ge<<=1))&&(ge=256),e}function Se(){var e=ye;return 0===(62914560&(ye<<=1))&&(ye=4194304),e}function Ne(e){for(var t=[],n=0;31>n;n++)t.push(e);return t}function Ie(e,t){e.pendingLanes|=t,268435456!==t&&(e.suspendedLanes=0,e.pingedLanes=0,e.warmLanes=0)}function Ce(e,t,n){e.pendingLanes|=t,e.suspendedLanes&=~t;var r=31-pe(t);e.entangledLanes|=t,e.entanglements[r]=1073741824|e.entanglements[r]|4194090&n}function Te(e,t){var n=e.entangledLanes|=t;for(e=e.entanglements;n;){var r=31-pe(n),s=1<<r;s&t|e[r]&t&&(e[r]|=t),n&=~s}}function Ae(e){switch(e){case 2:e=1;break;case 8:e=4;break;case 32:e=16;break;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:e=128;break;case 268435456:e=134217728;break;default:e=0}return e}function Ee(e){return 2<(e&=-e)?8<e?0!==(134217727&e)?32:268435456:8:2}function $e(){var e=F.p;return 0!==e?e:void 0===(e=window.event)?32:ud(e.type)}var Re=Math.random().toString(36).slice(2),De="__reactFiber$"+Re,Oe="__reactProps$"+Re,_e="__reactContainer$"+Re,Fe="__reactEvents$"+Re,Me="__reactListeners$"+Re,Le="__reactHandles$"+Re,Pe="__reactResources$"+Re,ze="__reactMarker$"+Re;function Be(e){delete e[De],delete e[Oe],delete e[Fe],delete e[Me],delete e[Le]}function Ve(e){var t=e[De];if(t)return t;for(var n=e.parentNode;n;){if(t=n[_e]||n[De]){if(n=t.alternate,null!==t.child||null!==n&&null!==n.child)for(e=vh(e);null!==e;){if(n=e[De])return n;e=vh(e)}return t}n=(e=n).parentNode}return null}function We(e){if(e=e[De]||e[_e]){var t=e.tag;if(5===t||6===t||13===t||26===t||27===t||3===t)return e}return null}function Ue(e){var t=e.tag;if(5===t||26===t||27===t||6===t)return e.stateNode;throw Error(i(33))}function je(e){var t=e[Pe];return t||(t=e[Pe]={hoistableStyles:new Map,hoistableScripts:new Map}),t}function Ge(e){e[ze]=!0}var He=new Set,qe={};function Ke(e,t){Xe(e,t),Xe(e+"Capture",t)}function Xe(e,t){for(qe[e]=t,e=0;e<t.length;e++)He.add(t[e])}var Qe,Ye,Ze=RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),Je={},et={};function tt(e,t,n){if(s=t,Q.call(et,s)||!Q.call(Je,s)&&(Ze.test(s)?et[s]=!0:(Je[s]=!0,0)))if(null===n)e.removeAttribute(t);else{switch(typeof n){case"undefined":case"function":case"symbol":return void e.removeAttribute(t);case"boolean":var r=t.toLowerCase().slice(0,5);if("data-"!==r&&"aria-"!==r)return void e.removeAttribute(t)}e.setAttribute(t,""+n)}var s}function nt(e,t,n){if(null===n)e.removeAttribute(t);else{switch(typeof n){case"undefined":case"function":case"symbol":case"boolean":return void e.removeAttribute(t)}e.setAttribute(t,""+n)}}function rt(e,t,n,r){if(null===r)e.removeAttribute(n);else{switch(typeof r){case"undefined":case"function":case"symbol":case"boolean":return void e.removeAttribute(n)}e.setAttributeNS(t,n,""+r)}}function st(e){if(void 0===Qe)try{throw Error()}catch(n){var t=n.stack.trim().match(/\n( *(at )?)/);Qe=t&&t[1]||"",Ye=-1<n.stack.indexOf("\n    at")?" (<anonymous>)":-1<n.stack.indexOf("@")?"@unknown:0:0":""}return"\n"+Qe+e+Ye}var at=!1;function it(e,t){if(!e||at)return"";at=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var r={DetermineComponentFrameRoot:function(){try{if(t){var n=function(){throw Error()};if(Object.defineProperty(n.prototype,"props",{set:function(){throw Error()}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(n,[])}catch(s){var r=s}Reflect.construct(e,[],n)}else{try{n.call()}catch(a){r=a}e.call(n.prototype)}}else{try{throw Error()}catch(i){r=i}(n=e())&&"function"===typeof n.catch&&n.catch((function(){}))}}catch(o){if(o&&r&&"string"===typeof o.stack)return[o.stack,r.stack]}return[null,null]}};r.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var s=Object.getOwnPropertyDescriptor(r.DetermineComponentFrameRoot,"name");s&&s.configurable&&Object.defineProperty(r.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var a=r.DetermineComponentFrameRoot(),i=a[0],o=a[1];if(i&&o){var l=i.split("\n"),u=o.split("\n");for(s=r=0;r<l.length&&!l[r].includes("DetermineComponentFrameRoot");)r++;for(;s<u.length&&!u[s].includes("DetermineComponentFrameRoot");)s++;if(r===l.length||s===u.length)for(r=l.length-1,s=u.length-1;1<=r&&0<=s&&l[r]!==u[s];)s--;for(;1<=r&&0<=s;r--,s--)if(l[r]!==u[s]){if(1!==r||1!==s)do{if(r--,0>--s||l[r]!==u[s]){var c="\n"+l[r].replace(" at new "," at ");return e.displayName&&c.includes("<anonymous>")&&(c=c.replace("<anonymous>",e.displayName)),c}}while(1<=r&&0<=s);break}}}finally{at=!1,Error.prepareStackTrace=n}return(n=e?e.displayName||e.name:"")?st(n):""}function ot(e){switch(e.tag){case 26:case 27:case 5:return st(e.type);case 16:return st("Lazy");case 13:return st("Suspense");case 19:return st("SuspenseList");case 0:case 15:return it(e.type,!1);case 11:return it(e.type.render,!1);case 1:return it(e.type,!0);case 31:return st("Activity");default:return""}}function lt(e){try{var t="";do{t+=ot(e),e=e.return}while(e);return t}catch(n){return"\nError generating stack: "+n.message+"\n"+n.stack}}function ut(e){switch(typeof e){case"bigint":case"boolean":case"number":case"string":case"undefined":case"object":return e;default:return""}}function ct(e){var t=e.type;return(e=e.nodeName)&&"input"===e.toLowerCase()&&("checkbox"===t||"radio"===t)}function ht(e){e._valueTracker||(e._valueTracker=function(e){var t=ct(e)?"checked":"value",n=Object.getOwnPropertyDescriptor(e.constructor.prototype,t),r=""+e[t];if(!e.hasOwnProperty(t)&&"undefined"!==typeof n&&"function"===typeof n.get&&"function"===typeof n.set){var s=n.get,a=n.set;return Object.defineProperty(e,t,{configurable:!0,get:function(){return s.call(this)},set:function(e){r=""+e,a.call(this,e)}}),Object.defineProperty(e,t,{enumerable:n.enumerable}),{getValue:function(){return r},setValue:function(e){r=""+e},stopTracking:function(){e._valueTracker=null,delete e[t]}}}}(e))}function dt(e){if(!e)return!1;var t=e._valueTracker;if(!t)return!0;var n=t.getValue(),r="";return e&&(r=ct(e)?e.checked?"true":"false":e.value),(e=r)!==n&&(t.setValue(e),!0)}function pt(e){if("undefined"===typeof(e=e||("undefined"!==typeof document?document:void 0)))return null;try{return e.activeElement||e.body}catch(t){return e.body}}var ft=/[\n"\\]/g;function mt(e){return e.replace(ft,(function(e){return"\\"+e.charCodeAt(0).toString(16)+" "}))}function gt(e,t,n,r,s,a,i,o){e.name="",null!=i&&"function"!==typeof i&&"symbol"!==typeof i&&"boolean"!==typeof i?e.type=i:e.removeAttribute("type"),null!=t?"number"===i?(0===t&&""===e.value||e.value!=t)&&(e.value=""+ut(t)):e.value!==""+ut(t)&&(e.value=""+ut(t)):"submit"!==i&&"reset"!==i||e.removeAttribute("value"),null!=t?bt(e,i,ut(t)):null!=n?bt(e,i,ut(n)):null!=r&&e.removeAttribute("value"),null==s&&null!=a&&(e.defaultChecked=!!a),null!=s&&(e.checked=s&&"function"!==typeof s&&"symbol"!==typeof s),null!=o&&"function"!==typeof o&&"symbol"!==typeof o&&"boolean"!==typeof o?e.name=""+ut(o):e.removeAttribute("name")}function yt(e,t,n,r,s,a,i,o){if(null!=a&&"function"!==typeof a&&"symbol"!==typeof a&&"boolean"!==typeof a&&(e.type=a),null!=t||null!=n){if(!("submit"!==a&&"reset"!==a||void 0!==t&&null!==t))return;n=null!=n?""+ut(n):"",t=null!=t?""+ut(t):n,o||t===e.value||(e.value=t),e.defaultValue=t}r="function"!==typeof(r=null!=r?r:s)&&"symbol"!==typeof r&&!!r,e.checked=o?e.checked:!!r,e.defaultChecked=!!r,null!=i&&"function"!==typeof i&&"symbol"!==typeof i&&"boolean"!==typeof i&&(e.name=i)}function bt(e,t,n){"number"===t&&pt(e.ownerDocument)===e||e.defaultValue===""+n||(e.defaultValue=""+n)}function vt(e,t,n,r){if(e=e.options,t){t={};for(var s=0;s<n.length;s++)t["$"+n[s]]=!0;for(n=0;n<e.length;n++)s=t.hasOwnProperty("$"+e[n].value),e[n].selected!==s&&(e[n].selected=s),s&&r&&(e[n].defaultSelected=!0)}else{for(n=""+ut(n),t=null,s=0;s<e.length;s++){if(e[s].value===n)return e[s].selected=!0,void(r&&(e[s].defaultSelected=!0));null!==t||e[s].disabled||(t=e[s])}null!==t&&(t.selected=!0)}}function xt(e,t,n){null==t||((t=""+ut(t))!==e.value&&(e.value=t),null!=n)?e.defaultValue=null!=n?""+ut(n):"":e.defaultValue!==t&&(e.defaultValue=t)}function wt(e,t,n,r){if(null==t){if(null!=r){if(null!=n)throw Error(i(92));if(O(r)){if(1<r.length)throw Error(i(93));r=r[0]}n=r}null==n&&(n=""),t=n}n=ut(t),e.defaultValue=n,(r=e.textContent)===n&&""!==r&&null!==r&&(e.value=r)}function kt(e,t){if(t){var n=e.firstChild;if(n&&n===e.lastChild&&3===n.nodeType)return void(n.nodeValue=t)}e.textContent=t}var St=new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));function Nt(e,t,n){var r=0===t.indexOf("--");null==n||"boolean"===typeof n||""===n?r?e.setProperty(t,""):"float"===t?e.cssFloat="":e[t]="":r?e.setProperty(t,n):"number"!==typeof n||0===n||St.has(t)?"float"===t?e.cssFloat=n:e[t]=(""+n).trim():e[t]=n+"px"}function It(e,t,n){if(null!=t&&"object"!==typeof t)throw Error(i(62));if(e=e.style,null!=n){for(var r in n)!n.hasOwnProperty(r)||null!=t&&t.hasOwnProperty(r)||(0===r.indexOf("--")?e.setProperty(r,""):"float"===r?e.cssFloat="":e[r]="");for(var s in t)r=t[s],t.hasOwnProperty(s)&&n[s]!==r&&Nt(e,s,r)}else for(var a in t)t.hasOwnProperty(a)&&Nt(e,a,t[a])}function Ct(e){if(-1===e.indexOf("-"))return!1;switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var Tt=new Map([["acceptCharset","accept-charset"],["htmlFor","for"],["httpEquiv","http-equiv"],["crossOrigin","crossorigin"],["accentHeight","accent-height"],["alignmentBaseline","alignment-baseline"],["arabicForm","arabic-form"],["baselineShift","baseline-shift"],["capHeight","cap-height"],["clipPath","clip-path"],["clipRule","clip-rule"],["colorInterpolation","color-interpolation"],["colorInterpolationFilters","color-interpolation-filters"],["colorProfile","color-profile"],["colorRendering","color-rendering"],["dominantBaseline","dominant-baseline"],["enableBackground","enable-background"],["fillOpacity","fill-opacity"],["fillRule","fill-rule"],["floodColor","flood-color"],["floodOpacity","flood-opacity"],["fontFamily","font-family"],["fontSize","font-size"],["fontSizeAdjust","font-size-adjust"],["fontStretch","font-stretch"],["fontStyle","font-style"],["fontVariant","font-variant"],["fontWeight","font-weight"],["glyphName","glyph-name"],["glyphOrientationHorizontal","glyph-orientation-horizontal"],["glyphOrientationVertical","glyph-orientation-vertical"],["horizAdvX","horiz-adv-x"],["horizOriginX","horiz-origin-x"],["imageRendering","image-rendering"],["letterSpacing","letter-spacing"],["lightingColor","lighting-color"],["markerEnd","marker-end"],["markerMid","marker-mid"],["markerStart","marker-start"],["overlinePosition","overline-position"],["overlineThickness","overline-thickness"],["paintOrder","paint-order"],["panose-1","panose-1"],["pointerEvents","pointer-events"],["renderingIntent","rendering-intent"],["shapeRendering","shape-rendering"],["stopColor","stop-color"],["stopOpacity","stop-opacity"],["strikethroughPosition","strikethrough-position"],["strikethroughThickness","strikethrough-thickness"],["strokeDasharray","stroke-dasharray"],["strokeDashoffset","stroke-dashoffset"],["strokeLinecap","stroke-linecap"],["strokeLinejoin","stroke-linejoin"],["strokeMiterlimit","stroke-miterlimit"],["strokeOpacity","stroke-opacity"],["strokeWidth","stroke-width"],["textAnchor","text-anchor"],["textDecoration","text-decoration"],["textRendering","text-rendering"],["transformOrigin","transform-origin"],["underlinePosition","underline-position"],["underlineThickness","underline-thickness"],["unicodeBidi","unicode-bidi"],["unicodeRange","unicode-range"],["unitsPerEm","units-per-em"],["vAlphabetic","v-alphabetic"],["vHanging","v-hanging"],["vIdeographic","v-ideographic"],["vMathematical","v-mathematical"],["vectorEffect","vector-effect"],["vertAdvY","vert-adv-y"],["vertOriginX","vert-origin-x"],["vertOriginY","vert-origin-y"],["wordSpacing","word-spacing"],["writingMode","writing-mode"],["xmlnsXlink","xmlns:xlink"],["xHeight","x-height"]]),At=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;function Et(e){return At.test(""+e)?"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')":e}var $t=null;function Rt(e){return(e=e.target||e.srcElement||window).correspondingUseElement&&(e=e.correspondingUseElement),3===e.nodeType?e.parentNode:e}var Dt=null,Ot=null;function _t(e){var t=We(e);if(t&&(e=t.stateNode)){var n=e[Oe]||null;e:switch(e=t.stateNode,t.type){case"input":if(gt(e,n.value,n.defaultValue,n.defaultValue,n.checked,n.defaultChecked,n.type,n.name),t=n.name,"radio"===n.type&&null!=t){for(n=e;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll('input[name="'+mt(""+t)+'"][type="radio"]'),t=0;t<n.length;t++){var r=n[t];if(r!==e&&r.form===e.form){var s=r[Oe]||null;if(!s)throw Error(i(90));gt(r,s.value,s.defaultValue,s.defaultValue,s.checked,s.defaultChecked,s.type,s.name)}}for(t=0;t<n.length;t++)(r=n[t]).form===e.form&&dt(r)}break e;case"textarea":xt(e,n.value,n.defaultValue);break e;case"select":null!=(t=n.value)&&vt(e,!!n.multiple,t,!1)}}}var Ft=!1;function Mt(e,t,n){if(Ft)return e(t,n);Ft=!0;try{return e(t)}finally{if(Ft=!1,(null!==Dt||null!==Ot)&&(Vu(),Dt&&(t=Dt,e=Ot,Ot=Dt=null,_t(t),e)))for(t=0;t<e.length;t++)_t(e[t])}}function Lt(e,t){var n=e.stateNode;if(null===n)return null;var r=n[Oe]||null;if(null===r)return null;n=r[t];e:switch(t){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(r=!r.disabled)||(r=!("button"===(e=e.type)||"input"===e||"select"===e||"textarea"===e)),e=!r;break e;default:e=!1}if(e)return null;if(n&&"function"!==typeof n)throw Error(i(231,t,typeof n));return n}var Pt=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),zt=!1;if(Pt)try{var Bt={};Object.defineProperty(Bt,"passive",{get:function(){zt=!0}}),window.addEventListener("test",Bt,Bt),window.removeEventListener("test",Bt,Bt)}catch(Od){zt=!1}var Vt=null,Wt=null,Ut=null;function jt(){if(Ut)return Ut;var e,t,n=Wt,r=n.length,s="value"in Vt?Vt.value:Vt.textContent,a=s.length;for(e=0;e<r&&n[e]===s[e];e++);var i=r-e;for(t=1;t<=i&&n[r-t]===s[a-t];t++);return Ut=s.slice(e,1<t?1-t:void 0)}function Gt(e){var t=e.keyCode;return"charCode"in e?0===(e=e.charCode)&&13===t&&(e=13):e=t,10===e&&(e=13),32<=e||13===e?e:0}function Ht(){return!0}function qt(){return!1}function Kt(e){function t(t,n,r,s,a){for(var i in this._reactName=t,this._targetInst=r,this.type=n,this.nativeEvent=s,this.target=a,this.currentTarget=null,e)e.hasOwnProperty(i)&&(t=e[i],this[i]=t?t(s):s[i]);return this.isDefaultPrevented=(null!=s.defaultPrevented?s.defaultPrevented:!1===s.returnValue)?Ht:qt,this.isPropagationStopped=qt,this}return d(t.prototype,{preventDefault:function(){this.defaultPrevented=!0;var e=this.nativeEvent;e&&(e.preventDefault?e.preventDefault():"unknown"!==typeof e.returnValue&&(e.returnValue=!1),this.isDefaultPrevented=Ht)},stopPropagation:function(){var e=this.nativeEvent;e&&(e.stopPropagation?e.stopPropagation():"unknown"!==typeof e.cancelBubble&&(e.cancelBubble=!0),this.isPropagationStopped=Ht)},persist:function(){},isPersistent:Ht}),t}var Xt,Qt,Yt,Zt={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},Jt=Kt(Zt),en=d({},Zt,{view:0,detail:0}),tn=Kt(en),nn=d({},en,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:fn,button:0,buttons:0,relatedTarget:function(e){return void 0===e.relatedTarget?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==Yt&&(Yt&&"mousemove"===e.type?(Xt=e.screenX-Yt.screenX,Qt=e.screenY-Yt.screenY):Qt=Xt=0,Yt=e),Xt)},movementY:function(e){return"movementY"in e?e.movementY:Qt}}),rn=Kt(nn),sn=Kt(d({},nn,{dataTransfer:0})),an=Kt(d({},en,{relatedTarget:0})),on=Kt(d({},Zt,{animationName:0,elapsedTime:0,pseudoElement:0})),ln=Kt(d({},Zt,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}})),un=Kt(d({},Zt,{data:0})),cn={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},hn={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},dn={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function pn(e){var t=this.nativeEvent;return t.getModifierState?t.getModifierState(e):!!(e=dn[e])&&!!t[e]}function fn(){return pn}var mn=Kt(d({},en,{key:function(e){if(e.key){var t=cn[e.key]||e.key;if("Unidentified"!==t)return t}return"keypress"===e.type?13===(e=Gt(e))?"Enter":String.fromCharCode(e):"keydown"===e.type||"keyup"===e.type?hn[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:fn,charCode:function(e){return"keypress"===e.type?Gt(e):0},keyCode:function(e){return"keydown"===e.type||"keyup"===e.type?e.keyCode:0},which:function(e){return"keypress"===e.type?Gt(e):"keydown"===e.type||"keyup"===e.type?e.keyCode:0}})),gn=Kt(d({},nn,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0})),yn=Kt(d({},en,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:fn})),bn=Kt(d({},Zt,{propertyName:0,elapsedTime:0,pseudoElement:0})),vn=Kt(d({},nn,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0})),xn=Kt(d({},Zt,{newState:0,oldState:0})),wn=[9,13,27,32],kn=Pt&&"CompositionEvent"in window,Sn=null;Pt&&"documentMode"in document&&(Sn=document.documentMode);var Nn=Pt&&"TextEvent"in window&&!Sn,In=Pt&&(!kn||Sn&&8<Sn&&11>=Sn),Cn=String.fromCharCode(32),Tn=!1;function An(e,t){switch(e){case"keyup":return-1!==wn.indexOf(t.keyCode);case"keydown":return 229!==t.keyCode;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function En(e){return"object"===typeof(e=e.detail)&&"data"in e?e.data:null}var $n=!1;var Rn={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Dn(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return"input"===t?!!Rn[e.type]:"textarea"===t}function On(e,t,n,r){Dt?Ot?Ot.push(r):Ot=[r]:Dt=r,0<(t=jc(t,"onChange")).length&&(n=new Jt("onChange","change",null,n,r),e.push({event:n,listeners:t}))}var _n=null,Fn=null;function Mn(e){Mc(e,0)}function Ln(e){if(dt(Ue(e)))return e}function Pn(e,t){if("change"===e)return t}var zn=!1;if(Pt){var Bn;if(Pt){var Vn="oninput"in document;if(!Vn){var Wn=document.createElement("div");Wn.setAttribute("oninput","return;"),Vn="function"===typeof Wn.oninput}Bn=Vn}else Bn=!1;zn=Bn&&(!document.documentMode||9<document.documentMode)}function Un(){_n&&(_n.detachEvent("onpropertychange",jn),Fn=_n=null)}function jn(e){if("value"===e.propertyName&&Ln(Fn)){var t=[];On(t,Fn,e,Rt(e)),Mt(Mn,t)}}function Gn(e,t,n){"focusin"===e?(Un(),Fn=n,(_n=t).attachEvent("onpropertychange",jn)):"focusout"===e&&Un()}function Hn(e){if("selectionchange"===e||"keyup"===e||"keydown"===e)return Ln(Fn)}function qn(e,t){if("click"===e)return Ln(t)}function Kn(e,t){if("input"===e||"change"===e)return Ln(t)}var Xn="function"===typeof Object.is?Object.is:function(e,t){return e===t&&(0!==e||1/e===1/t)||e!==e&&t!==t};function Qn(e,t){if(Xn(e,t))return!0;if("object"!==typeof e||null===e||"object"!==typeof t||null===t)return!1;var n=Object.keys(e),r=Object.keys(t);if(n.length!==r.length)return!1;for(r=0;r<n.length;r++){var s=n[r];if(!Q.call(t,s)||!Xn(e[s],t[s]))return!1}return!0}function Yn(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function Zn(e,t){var n,r=Yn(e);for(e=0;r;){if(3===r.nodeType){if(n=e+r.textContent.length,e<=t&&n>=t)return{node:r,offset:t-e};e=n}e:{for(;r;){if(r.nextSibling){r=r.nextSibling;break e}r=r.parentNode}r=void 0}r=Yn(r)}}function Jn(e,t){return!(!e||!t)&&(e===t||(!e||3!==e.nodeType)&&(t&&3===t.nodeType?Jn(e,t.parentNode):"contains"in e?e.contains(t):!!e.compareDocumentPosition&&!!(16&e.compareDocumentPosition(t))))}function er(e){for(var t=pt((e=null!=e&&null!=e.ownerDocument&&null!=e.ownerDocument.defaultView?e.ownerDocument.defaultView:window).document);t instanceof e.HTMLIFrameElement;){try{var n="string"===typeof t.contentWindow.location.href}catch(r){n=!1}if(!n)break;t=pt((e=t.contentWindow).document)}return t}function tr(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t&&("input"===t&&("text"===e.type||"search"===e.type||"tel"===e.type||"url"===e.type||"password"===e.type)||"textarea"===t||"true"===e.contentEditable)}var nr=Pt&&"documentMode"in document&&11>=document.documentMode,rr=null,sr=null,ar=null,ir=!1;function or(e,t,n){var r=n.window===n?n.document:9===n.nodeType?n:n.ownerDocument;ir||null==rr||rr!==pt(r)||("selectionStart"in(r=rr)&&tr(r)?r={start:r.selectionStart,end:r.selectionEnd}:r={anchorNode:(r=(r.ownerDocument&&r.ownerDocument.defaultView||window).getSelection()).anchorNode,anchorOffset:r.anchorOffset,focusNode:r.focusNode,focusOffset:r.focusOffset},ar&&Qn(ar,r)||(ar=r,0<(r=jc(sr,"onSelect")).length&&(t=new Jt("onSelect","select",null,t,n),e.push({event:t,listeners:r}),t.target=rr)))}function lr(e,t){var n={};return n[e.toLowerCase()]=t.toLowerCase(),n["Webkit"+e]="webkit"+t,n["Moz"+e]="moz"+t,n}var ur={animationend:lr("Animation","AnimationEnd"),animationiteration:lr("Animation","AnimationIteration"),animationstart:lr("Animation","AnimationStart"),transitionrun:lr("Transition","TransitionRun"),transitionstart:lr("Transition","TransitionStart"),transitioncancel:lr("Transition","TransitionCancel"),transitionend:lr("Transition","TransitionEnd")},cr={},hr={};function dr(e){if(cr[e])return cr[e];if(!ur[e])return e;var t,n=ur[e];for(t in n)if(n.hasOwnProperty(t)&&t in hr)return cr[e]=n[t];return e}Pt&&(hr=document.createElement("div").style,"AnimationEvent"in window||(delete ur.animationend.animation,delete ur.animationiteration.animation,delete ur.animationstart.animation),"TransitionEvent"in window||delete ur.transitionend.transition);var pr=dr("animationend"),fr=dr("animationiteration"),mr=dr("animationstart"),gr=dr("transitionrun"),yr=dr("transitionstart"),br=dr("transitioncancel"),vr=dr("transitionend"),xr=new Map,wr="abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function kr(e,t){xr.set(e,t),Ke(t,[e])}wr.push("scrollEnd");var Sr=new WeakMap;function Nr(e,t){if("object"===typeof e&&null!==e){var n=Sr.get(e);return void 0!==n?n:(t={value:e,source:t,stack:lt(t)},Sr.set(e,t),t)}return{value:e,source:t,stack:lt(t)}}var Ir=[],Cr=0,Tr=0;function Ar(){for(var e=Cr,t=Tr=Cr=0;t<e;){var n=Ir[t];Ir[t++]=null;var r=Ir[t];Ir[t++]=null;var s=Ir[t];Ir[t++]=null;var a=Ir[t];if(Ir[t++]=null,null!==r&&null!==s){var i=r.pending;null===i?s.next=s:(s.next=i.next,i.next=s),r.pending=s}0!==a&&Dr(n,s,a)}}function Er(e,t,n,r){Ir[Cr++]=e,Ir[Cr++]=t,Ir[Cr++]=n,Ir[Cr++]=r,Tr|=r,e.lanes|=r,null!==(e=e.alternate)&&(e.lanes|=r)}function $r(e,t,n,r){return Er(e,t,n,r),Or(e)}function Rr(e,t){return Er(e,null,null,t),Or(e)}function Dr(e,t,n){e.lanes|=n;var r=e.alternate;null!==r&&(r.lanes|=n);for(var s=!1,a=e.return;null!==a;)a.childLanes|=n,null!==(r=a.alternate)&&(r.childLanes|=n),22===a.tag&&(null===(e=a.stateNode)||1&e._visibility||(s=!0)),e=a,a=a.return;return 3===e.tag?(a=e.stateNode,s&&null!==t&&(s=31-pe(n),null===(r=(e=a.hiddenUpdates)[s])?e[s]=[t]:r.push(t),t.lane=536870912|n),a):null}function Or(e){if(50<Du)throw Du=0,Ou=null,Error(i(185));for(var t=e.return;null!==t;)t=(e=t).return;return 3===e.tag?e.stateNode:null}var _r={};function Fr(e,t,n,r){this.tag=e,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=t,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=r,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Mr(e,t,n,r){return new Fr(e,t,n,r)}function Lr(e){return!(!(e=e.prototype)||!e.isReactComponent)}function Pr(e,t){var n=e.alternate;return null===n?((n=Mr(e.tag,t,e.key,e.mode)).elementType=e.elementType,n.type=e.type,n.stateNode=e.stateNode,n.alternate=e,e.alternate=n):(n.pendingProps=t,n.type=e.type,n.flags=0,n.subtreeFlags=0,n.deletions=null),n.flags=65011712&e.flags,n.childLanes=e.childLanes,n.lanes=e.lanes,n.child=e.child,n.memoizedProps=e.memoizedProps,n.memoizedState=e.memoizedState,n.updateQueue=e.updateQueue,t=e.dependencies,n.dependencies=null===t?null:{lanes:t.lanes,firstContext:t.firstContext},n.sibling=e.sibling,n.index=e.index,n.ref=e.ref,n.refCleanup=e.refCleanup,n}function zr(e,t){e.flags&=65011714;var n=e.alternate;return null===n?(e.childLanes=0,e.lanes=t,e.child=null,e.subtreeFlags=0,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null,e.stateNode=null):(e.childLanes=n.childLanes,e.lanes=n.lanes,e.child=n.child,e.subtreeFlags=0,e.deletions=null,e.memoizedProps=n.memoizedProps,e.memoizedState=n.memoizedState,e.updateQueue=n.updateQueue,e.type=n.type,t=n.dependencies,e.dependencies=null===t?null:{lanes:t.lanes,firstContext:t.firstContext}),e}function Br(e,t,n,r,s,a){var o=0;if(r=e,"function"===typeof e)Lr(e)&&(o=1);else if("string"===typeof e)o=function(e,t,n){if(1===n||null!=t.itemProp)return!1;switch(e){case"meta":case"title":return!0;case"style":if("string"!==typeof t.precedence||"string"!==typeof t.href||""===t.href)break;return!0;case"link":if("string"!==typeof t.rel||"string"!==typeof t.href||""===t.href||t.onLoad||t.onError)break;return"stylesheet"!==t.rel||(e=t.disabled,"string"===typeof t.precedence&&null==e);case"script":if(t.async&&"function"!==typeof t.async&&"symbol"!==typeof t.async&&!t.onLoad&&!t.onError&&t.src&&"string"===typeof t.src)return!0}return!1}(e,n,W.current)?26:"html"===e||"head"===e||"body"===e?27:5;else e:switch(e){case T:return(e=Mr(31,n,t,s)).elementType=T,e.lanes=a,e;case g:return Vr(n.children,s,a,t);case y:o=8,s|=24;break;case b:return(e=Mr(12,n,t,2|s)).elementType=b,e.lanes=a,e;case S:return(e=Mr(13,n,t,s)).elementType=S,e.lanes=a,e;case N:return(e=Mr(19,n,t,s)).elementType=N,e.lanes=a,e;default:if("object"===typeof e&&null!==e)switch(e.$$typeof){case v:case w:o=10;break e;case x:o=9;break e;case k:o=11;break e;case I:o=14;break e;case C:o=16,r=null;break e}o=29,n=Error(i(130,null===e?"null":typeof e,"")),r=null}return(t=Mr(o,n,t,s)).elementType=e,t.type=r,t.lanes=a,t}function Vr(e,t,n,r){return(e=Mr(7,e,r,t)).lanes=n,e}function Wr(e,t,n){return(e=Mr(6,e,null,t)).lanes=n,e}function Ur(e,t,n){return(t=Mr(4,null!==e.children?e.children:[],e.key,t)).lanes=n,t.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},t}var jr=[],Gr=0,Hr=null,qr=0,Kr=[],Xr=0,Qr=null,Yr=1,Zr="";function Jr(e,t){jr[Gr++]=qr,jr[Gr++]=Hr,Hr=e,qr=t}function es(e,t,n){Kr[Xr++]=Yr,Kr[Xr++]=Zr,Kr[Xr++]=Qr,Qr=e;var r=Yr;e=Zr;var s=32-pe(r)-1;r&=~(1<<s),n+=1;var a=32-pe(t)+s;if(30<a){var i=s-s%5;a=(r&(1<<i)-1).toString(32),r>>=i,s-=i,Yr=1<<32-pe(t)+s|n<<s|r,Zr=a+e}else Yr=1<<a|n<<s|r,Zr=e}function ts(e){null!==e.return&&(Jr(e,1),es(e,1,0))}function ns(e){for(;e===Hr;)Hr=jr[--Gr],jr[Gr]=null,qr=jr[--Gr],jr[Gr]=null;for(;e===Qr;)Qr=Kr[--Xr],Kr[Xr]=null,Zr=Kr[--Xr],Kr[Xr]=null,Yr=Kr[--Xr],Kr[Xr]=null}var rs=null,ss=null,as=!1,is=null,os=!1,ls=Error(i(519));function us(e){throw ms(Nr(Error(i(418,"")),e)),ls}function cs(e){var t=e.stateNode,n=e.type,r=e.memoizedProps;switch(t[De]=e,t[Oe]=r,n){case"dialog":Lc("cancel",t),Lc("close",t);break;case"iframe":case"object":case"embed":Lc("load",t);break;case"video":case"audio":for(n=0;n<_c.length;n++)Lc(_c[n],t);break;case"source":Lc("error",t);break;case"img":case"image":case"link":Lc("error",t),Lc("load",t);break;case"details":Lc("toggle",t);break;case"input":Lc("invalid",t),yt(t,r.value,r.defaultValue,r.checked,r.defaultChecked,r.type,r.name,!0),ht(t);break;case"select":Lc("invalid",t);break;case"textarea":Lc("invalid",t),wt(t,r.value,r.defaultValue,r.children),ht(t)}"string"!==typeof(n=r.children)&&"number"!==typeof n&&"bigint"!==typeof n||t.textContent===""+n||!0===r.suppressHydrationWarning||Qc(t.textContent,n)?(null!=r.popover&&(Lc("beforetoggle",t),Lc("toggle",t)),null!=r.onScroll&&Lc("scroll",t),null!=r.onScrollEnd&&Lc("scrollend",t),null!=r.onClick&&(t.onclick=Yc),t=!0):t=!1,t||us(e)}function hs(e){for(rs=e.return;rs;)switch(rs.tag){case 5:case 13:return void(os=!1);case 27:case 3:return void(os=!0);default:rs=rs.return}}function ds(e){if(e!==rs)return!1;if(!as)return hs(e),as=!0,!1;var t,n=e.tag;if((t=3!==n&&27!==n)&&((t=5===n)&&(t=!("form"!==(t=e.type)&&"button"!==t)||ih(e.type,e.memoizedProps)),t=!t),t&&ss&&us(e),hs(e),13===n){if(!(e=null!==(e=e.memoizedState)?e.dehydrated:null))throw Error(i(317));e:{for(e=e.nextSibling,n=0;e;){if(8===e.nodeType)if("/$"===(t=e.data)){if(0===n){ss=yh(e.nextSibling);break e}n--}else"$"!==t&&"$!"!==t&&"$?"!==t||n++;e=e.nextSibling}ss=null}}else 27===n?(n=ss,ph(e.type)?(e=bh,bh=null,ss=e):ss=n):ss=rs?yh(e.stateNode.nextSibling):null;return!0}function ps(){ss=rs=null,as=!1}function fs(){var e=is;return null!==e&&(null===vu?vu=e:vu.push.apply(vu,e),is=null),e}function ms(e){null===is?is=[e]:is.push(e)}var gs=z(null),ys=null,bs=null;function vs(e,t,n){V(gs,t._currentValue),t._currentValue=n}function xs(e){e._currentValue=gs.current,B(gs)}function ws(e,t,n){for(;null!==e;){var r=e.alternate;if((e.childLanes&t)!==t?(e.childLanes|=t,null!==r&&(r.childLanes|=t)):null!==r&&(r.childLanes&t)!==t&&(r.childLanes|=t),e===n)break;e=e.return}}function ks(e,t,n,r){var s=e.child;for(null!==s&&(s.return=e);null!==s;){var a=s.dependencies;if(null!==a){var o=s.child;a=a.firstContext;e:for(;null!==a;){var l=a;a=s;for(var u=0;u<t.length;u++)if(l.context===t[u]){a.lanes|=n,null!==(l=a.alternate)&&(l.lanes|=n),ws(a.return,n,e),r||(o=null);break e}a=l.next}}else if(18===s.tag){if(null===(o=s.return))throw Error(i(341));o.lanes|=n,null!==(a=o.alternate)&&(a.lanes|=n),ws(o,n,e),o=null}else o=s.child;if(null!==o)o.return=s;else for(o=s;null!==o;){if(o===e){o=null;break}if(null!==(s=o.sibling)){s.return=o.return,o=s;break}o=o.return}s=o}}function Ss(e,t,n,r){e=null;for(var s=t,a=!1;null!==s;){if(!a)if(0!==(524288&s.flags))a=!0;else if(0!==(262144&s.flags))break;if(10===s.tag){var o=s.alternate;if(null===o)throw Error(i(387));if(null!==(o=o.memoizedProps)){var l=s.type;Xn(s.pendingProps.value,o.value)||(null!==e?e.push(l):e=[l])}}else if(s===G.current){if(null===(o=s.alternate))throw Error(i(387));o.memoizedState.memoizedState!==s.memoizedState.memoizedState&&(null!==e?e.push(Kh):e=[Kh])}s=s.return}null!==e&&ks(t,e,n,r),t.flags|=262144}function Ns(e){for(e=e.firstContext;null!==e;){if(!Xn(e.context._currentValue,e.memoizedValue))return!0;e=e.next}return!1}function Is(e){ys=e,bs=null,null!==(e=e.dependencies)&&(e.firstContext=null)}function Cs(e){return As(ys,e)}function Ts(e,t){return null===ys&&Is(e),As(e,t)}function As(e,t){var n=t._currentValue;if(t={context:t,memoizedValue:n,next:null},null===bs){if(null===e)throw Error(i(308));bs=t,e.dependencies={lanes:0,firstContext:t},e.flags|=524288}else bs=bs.next=t;return n}var Es="undefined"!==typeof AbortController?AbortController:function(){var e=[],t=this.signal={aborted:!1,addEventListener:function(t,n){e.push(n)}};this.abort=function(){t.aborted=!0,e.forEach((function(e){return e()}))}},$s=r.unstable_scheduleCallback,Rs=r.unstable_NormalPriority,Ds={$$typeof:w,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0};function Os(){return{controller:new Es,data:new Map,refCount:0}}function _s(e){e.refCount--,0===e.refCount&&$s(Rs,(function(){e.controller.abort()}))}var Fs=null,Ms=0,Ls=0,Ps=null;function zs(){if(0===--Ms&&null!==Fs){null!==Ps&&(Ps.status="fulfilled");var e=Fs;Fs=null,Ls=0,Ps=null;for(var t=0;t<e.length;t++)(0,e[t])()}}var Bs=_.S;_.S=function(e,t){"object"===typeof t&&null!==t&&"function"===typeof t.then&&function(e,t){if(null===Fs){var n=Fs=[];Ms=0,Ls=Ec(),Ps={status:"pending",value:void 0,then:function(e){n.push(e)}}}Ms++,t.then(zs,zs)}(0,t),null!==Bs&&Bs(e,t)};var Vs=z(null);function Ws(){var e=Vs.current;return null!==e?e:ru.pooledCache}function Us(e,t){V(Vs,null===t?Vs.current:t.pool)}function js(){var e=Ws();return null===e?null:{parent:Ds._currentValue,pool:e}}var Gs=Error(i(460)),Hs=Error(i(474)),qs=Error(i(542)),Ks={then:function(){}};function Xs(e){return"fulfilled"===(e=e.status)||"rejected"===e}function Qs(){}function Ys(e,t,n){switch(void 0===(n=e[n])?e.push(t):n!==t&&(t.then(Qs,Qs),t=n),t.status){case"fulfilled":return t.value;case"rejected":throw ea(e=t.reason),e;default:if("string"===typeof t.status)t.then(Qs,Qs);else{if(null!==(e=ru)&&100<e.shellSuspendCounter)throw Error(i(482));(e=t).status="pending",e.then((function(e){if("pending"===t.status){var n=t;n.status="fulfilled",n.value=e}}),(function(e){if("pending"===t.status){var n=t;n.status="rejected",n.reason=e}}))}switch(t.status){case"fulfilled":return t.value;case"rejected":throw ea(e=t.reason),e}throw Zs=t,Gs}}var Zs=null;function Js(){if(null===Zs)throw Error(i(459));var e=Zs;return Zs=null,e}function ea(e){if(e===Gs||e===qs)throw Error(i(483))}var ta=!1;function na(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function ra(e,t){e=e.updateQueue,t.updateQueue===e&&(t.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,callbacks:null})}function sa(e){return{lane:e,tag:0,payload:null,callback:null,next:null}}function aa(e,t,n){var r=e.updateQueue;if(null===r)return null;if(r=r.shared,0!==(2&nu)){var s=r.pending;return null===s?t.next=t:(t.next=s.next,s.next=t),r.pending=t,t=Or(e),Dr(e,null,n),t}return Er(e,r,t,n),Or(e)}function ia(e,t,n){if(null!==(t=t.updateQueue)&&(t=t.shared,0!==(4194048&n))){var r=t.lanes;n|=r&=e.pendingLanes,t.lanes=n,Te(e,n)}}function oa(e,t){var n=e.updateQueue,r=e.alternate;if(null!==r&&n===(r=r.updateQueue)){var s=null,a=null;if(null!==(n=n.firstBaseUpdate)){do{var i={lane:n.lane,tag:n.tag,payload:n.payload,callback:null,next:null};null===a?s=a=i:a=a.next=i,n=n.next}while(null!==n);null===a?s=a=t:a=a.next=t}else s=a=t;return n={baseState:r.baseState,firstBaseUpdate:s,lastBaseUpdate:a,shared:r.shared,callbacks:r.callbacks},void(e.updateQueue=n)}null===(e=n.lastBaseUpdate)?n.firstBaseUpdate=t:e.next=t,n.lastBaseUpdate=t}var la=!1;function ua(){if(la){if(null!==Ps)throw Ps}}function ca(e,t,n,r){la=!1;var s=e.updateQueue;ta=!1;var a=s.firstBaseUpdate,i=s.lastBaseUpdate,o=s.shared.pending;if(null!==o){s.shared.pending=null;var l=o,u=l.next;l.next=null,null===i?a=u:i.next=u,i=l;var c=e.alternate;null!==c&&((o=(c=c.updateQueue).lastBaseUpdate)!==i&&(null===o?c.firstBaseUpdate=u:o.next=u,c.lastBaseUpdate=l))}if(null!==a){var h=s.baseState;for(i=0,c=u=l=null,o=a;;){var p=-536870913&o.lane,f=p!==o.lane;if(f?(au&p)===p:(r&p)===p){0!==p&&p===Ls&&(la=!0),null!==c&&(c=c.next={lane:0,tag:o.tag,payload:o.payload,callback:null,next:null});e:{var m=e,g=o;p=t;var y=n;switch(g.tag){case 1:if("function"===typeof(m=g.payload)){h=m.call(y,h,p);break e}h=m;break e;case 3:m.flags=-65537&m.flags|128;case 0:if(null===(p="function"===typeof(m=g.payload)?m.call(y,h,p):m)||void 0===p)break e;h=d({},h,p);break e;case 2:ta=!0}}null!==(p=o.callback)&&(e.flags|=64,f&&(e.flags|=8192),null===(f=s.callbacks)?s.callbacks=[p]:f.push(p))}else f={lane:p,tag:o.tag,payload:o.payload,callback:o.callback,next:null},null===c?(u=c=f,l=h):c=c.next=f,i|=p;if(null===(o=o.next)){if(null===(o=s.shared.pending))break;o=(f=o).next,f.next=null,s.lastBaseUpdate=f,s.shared.pending=null}}null===c&&(l=h),s.baseState=l,s.firstBaseUpdate=u,s.lastBaseUpdate=c,null===a&&(s.shared.lanes=0),pu|=i,e.lanes=i,e.memoizedState=h}}function ha(e,t){if("function"!==typeof e)throw Error(i(191,e));e.call(t)}function da(e,t){var n=e.callbacks;if(null!==n)for(e.callbacks=null,e=0;e<n.length;e++)ha(n[e],t)}var pa=z(null),fa=z(0);function ma(e,t){V(fa,e=hu),V(pa,t),hu=e|t.baseLanes}function ga(){V(fa,hu),V(pa,pa.current)}function ya(){hu=fa.current,B(pa),B(fa)}var ba=0,va=null,xa=null,wa=null,ka=!1,Sa=!1,Na=!1,Ia=0,Ca=0,Ta=null,Aa=0;function Ea(){throw Error(i(321))}function $a(e,t){if(null===t)return!1;for(var n=0;n<t.length&&n<e.length;n++)if(!Xn(e[n],t[n]))return!1;return!0}function Ra(e,t,n,r,s,a){return ba=a,va=t,t.memoizedState=null,t.updateQueue=null,t.lanes=0,_.H=null===e||null===e.memoizedState?Gi:Hi,Na=!1,a=n(r,s),Na=!1,Sa&&(a=Oa(t,n,r,s)),Da(e),a}function Da(e){_.H=ji;var t=null!==xa&&null!==xa.next;if(ba=0,wa=xa=va=null,ka=!1,Ca=0,Ta=null,t)throw Error(i(300));null===e||To||null!==(e=e.dependencies)&&Ns(e)&&(To=!0)}function Oa(e,t,n,r){va=e;var s=0;do{if(Sa&&(Ta=null),Ca=0,Sa=!1,25<=s)throw Error(i(301));if(s+=1,wa=xa=null,null!=e.updateQueue){var a=e.updateQueue;a.lastEffect=null,a.events=null,a.stores=null,null!=a.memoCache&&(a.memoCache.index=0)}_.H=qi,a=t(n,r)}while(Sa);return a}function _a(){var e=_.H,t=e.useState()[0];return t="function"===typeof t.then?Ba(t):t,e=e.useState()[0],(null!==xa?xa.memoizedState:null)!==e&&(va.flags|=1024),t}function Fa(){var e=0!==Ia;return Ia=0,e}function Ma(e,t,n){t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~n}function La(e){if(ka){for(e=e.memoizedState;null!==e;){var t=e.queue;null!==t&&(t.pending=null),e=e.next}ka=!1}ba=0,wa=xa=va=null,Sa=!1,Ca=Ia=0,Ta=null}function Pa(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return null===wa?va.memoizedState=wa=e:wa=wa.next=e,wa}function za(){if(null===xa){var e=va.alternate;e=null!==e?e.memoizedState:null}else e=xa.next;var t=null===wa?va.memoizedState:wa.next;if(null!==t)wa=t,xa=e;else{if(null===e){if(null===va.alternate)throw Error(i(467));throw Error(i(310))}e={memoizedState:(xa=e).memoizedState,baseState:xa.baseState,baseQueue:xa.baseQueue,queue:xa.queue,next:null},null===wa?va.memoizedState=wa=e:wa=wa.next=e}return wa}function Ba(e){var t=Ca;return Ca+=1,null===Ta&&(Ta=[]),e=Ys(Ta,e,t),t=va,null===(null===wa?t.memoizedState:wa.next)&&(t=t.alternate,_.H=null===t||null===t.memoizedState?Gi:Hi),e}function Va(e){if(null!==e&&"object"===typeof e){if("function"===typeof e.then)return Ba(e);if(e.$$typeof===w)return Cs(e)}throw Error(i(438,String(e)))}function Wa(e){var t=null,n=va.updateQueue;if(null!==n&&(t=n.memoCache),null==t){var r=va.alternate;null!==r&&(null!==(r=r.updateQueue)&&(null!=(r=r.memoCache)&&(t={data:r.data.map((function(e){return e.slice()})),index:0})))}if(null==t&&(t={data:[],index:0}),null===n&&(n={lastEffect:null,events:null,stores:null,memoCache:null},va.updateQueue=n),n.memoCache=t,void 0===(n=t.data[t.index]))for(n=t.data[t.index]=Array(e),r=0;r<e;r++)n[r]=A;return t.index++,n}function Ua(e,t){return"function"===typeof t?t(e):t}function ja(e){return Ga(za(),xa,e)}function Ga(e,t,n){var r=e.queue;if(null===r)throw Error(i(311));r.lastRenderedReducer=n;var s=e.baseQueue,a=r.pending;if(null!==a){if(null!==s){var o=s.next;s.next=a.next,a.next=o}t.baseQueue=s=a,r.pending=null}if(a=e.baseState,null===s)e.memoizedState=a;else{var l=o=null,u=null,c=t=s.next,h=!1;do{var d=-536870913&c.lane;if(d!==c.lane?(au&d)===d:(ba&d)===d){var p=c.revertLane;if(0===p)null!==u&&(u=u.next={lane:0,revertLane:0,action:c.action,hasEagerState:c.hasEagerState,eagerState:c.eagerState,next:null}),d===Ls&&(h=!0);else{if((ba&p)===p){c=c.next,p===Ls&&(h=!0);continue}d={lane:0,revertLane:c.revertLane,action:c.action,hasEagerState:c.hasEagerState,eagerState:c.eagerState,next:null},null===u?(l=u=d,o=a):u=u.next=d,va.lanes|=p,pu|=p}d=c.action,Na&&n(a,d),a=c.hasEagerState?c.eagerState:n(a,d)}else p={lane:d,revertLane:c.revertLane,action:c.action,hasEagerState:c.hasEagerState,eagerState:c.eagerState,next:null},null===u?(l=u=p,o=a):u=u.next=p,va.lanes|=d,pu|=d;c=c.next}while(null!==c&&c!==t);if(null===u?o=a:u.next=l,!Xn(a,e.memoizedState)&&(To=!0,h&&null!==(n=Ps)))throw n;e.memoizedState=a,e.baseState=o,e.baseQueue=u,r.lastRenderedState=a}return null===s&&(r.lanes=0),[e.memoizedState,r.dispatch]}function Ha(e){var t=za(),n=t.queue;if(null===n)throw Error(i(311));n.lastRenderedReducer=e;var r=n.dispatch,s=n.pending,a=t.memoizedState;if(null!==s){n.pending=null;var o=s=s.next;do{a=e(a,o.action),o=o.next}while(o!==s);Xn(a,t.memoizedState)||(To=!0),t.memoizedState=a,null===t.baseQueue&&(t.baseState=a),n.lastRenderedState=a}return[a,r]}function qa(e,t,n){var r=va,s=za(),a=as;if(a){if(void 0===n)throw Error(i(407));n=n()}else n=t();var o=!Xn((xa||s).memoizedState,n);if(o&&(s.memoizedState=n,To=!0),s=s.queue,gi(2048,8,Qa.bind(null,r,s,e),[e]),s.getSnapshot!==t||o||null!==wa&&1&wa.memoizedState.tag){if(r.flags|=2048,pi(9,{destroy:void 0,resource:void 0},Xa.bind(null,r,s,n,t),null),null===ru)throw Error(i(349));a||0!==(124&ba)||Ka(r,t,n)}return n}function Ka(e,t,n){e.flags|=16384,e={getSnapshot:t,value:n},null===(t=va.updateQueue)?(t={lastEffect:null,events:null,stores:null,memoCache:null},va.updateQueue=t,t.stores=[e]):null===(n=t.stores)?t.stores=[e]:n.push(e)}function Xa(e,t,n,r){t.value=n,t.getSnapshot=r,Ya(t)&&Za(e)}function Qa(e,t,n){return n((function(){Ya(t)&&Za(e)}))}function Ya(e){var t=e.getSnapshot;e=e.value;try{var n=t();return!Xn(e,n)}catch(r){return!0}}function Za(e){var t=Rr(e,2);null!==t&&Mu(t,e,2)}function Ja(e){var t=Pa();if("function"===typeof e){var n=e;if(e=n(),Na){de(!0);try{n()}finally{de(!1)}}}return t.memoizedState=t.baseState=e,t.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:Ua,lastRenderedState:e},t}function ei(e,t,n,r){return e.baseState=n,Ga(e,xa,"function"===typeof r?r:Ua)}function ti(e,t,n,r,s){if(Vi(e))throw Error(i(485));if(null!==(e=t.action)){var a={payload:s,action:e,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(e){a.listeners.push(e)}};null!==_.T?n(!0):a.isTransition=!1,r(a),null===(n=t.pending)?(a.next=t.pending=a,ni(t,a)):(a.next=n.next,t.pending=n.next=a)}}function ni(e,t){var n=t.action,r=t.payload,s=e.state;if(t.isTransition){var a=_.T,i={};_.T=i;try{var o=n(s,r),l=_.S;null!==l&&l(i,o),ri(e,t,o)}catch(u){ai(e,t,u)}finally{_.T=a}}else try{ri(e,t,a=n(s,r))}catch(c){ai(e,t,c)}}function ri(e,t,n){null!==n&&"object"===typeof n&&"function"===typeof n.then?n.then((function(n){si(e,t,n)}),(function(n){return ai(e,t,n)})):si(e,t,n)}function si(e,t,n){t.status="fulfilled",t.value=n,ii(t),e.state=n,null!==(t=e.pending)&&((n=t.next)===t?e.pending=null:(n=n.next,t.next=n,ni(e,n)))}function ai(e,t,n){var r=e.pending;if(e.pending=null,null!==r){r=r.next;do{t.status="rejected",t.reason=n,ii(t),t=t.next}while(t!==r)}e.action=null}function ii(e){e=e.listeners;for(var t=0;t<e.length;t++)(0,e[t])()}function oi(e,t){return t}function li(e,t){if(as){var n=ru.formState;if(null!==n){e:{var r=va;if(as){if(ss){t:{for(var s=ss,a=os;8!==s.nodeType;){if(!a){s=null;break t}if(null===(s=yh(s.nextSibling))){s=null;break t}}s="F!"===(a=s.data)||"F"===a?s:null}if(s){ss=yh(s.nextSibling),r="F!"===s.data;break e}}us(r)}r=!1}r&&(t=n[0])}}return(n=Pa()).memoizedState=n.baseState=t,r={pending:null,lanes:0,dispatch:null,lastRenderedReducer:oi,lastRenderedState:t},n.queue=r,n=Pi.bind(null,va,r),r.dispatch=n,r=Ja(!1),a=Bi.bind(null,va,!1,r.queue),s={state:t,dispatch:null,action:e,pending:null},(r=Pa()).queue=s,n=ti.bind(null,va,s,a,n),s.dispatch=n,r.memoizedState=e,[t,n,!1]}function ui(e){return ci(za(),xa,e)}function ci(e,t,n){if(t=Ga(e,t,oi)[0],e=ja(Ua)[0],"object"===typeof t&&null!==t&&"function"===typeof t.then)try{var r=Ba(t)}catch(i){if(i===Gs)throw qs;throw i}else r=t;var s=(t=za()).queue,a=s.dispatch;return n!==t.memoizedState&&(va.flags|=2048,pi(9,{destroy:void 0,resource:void 0},hi.bind(null,s,n),null)),[r,a,e]}function hi(e,t){e.action=t}function di(e){var t=za(),n=xa;if(null!==n)return ci(t,n,e);za(),t=t.memoizedState;var r=(n=za()).queue.dispatch;return n.memoizedState=e,[t,r,!1]}function pi(e,t,n,r){return e={tag:e,create:n,deps:r,inst:t,next:null},null===(t=va.updateQueue)&&(t={lastEffect:null,events:null,stores:null,memoCache:null},va.updateQueue=t),null===(n=t.lastEffect)?t.lastEffect=e.next=e:(r=n.next,n.next=e,e.next=r,t.lastEffect=e),e}function fi(){return za().memoizedState}function mi(e,t,n,r){var s=Pa();r=void 0===r?null:r,va.flags|=e,s.memoizedState=pi(1|t,{destroy:void 0,resource:void 0},n,r)}function gi(e,t,n,r){var s=za();r=void 0===r?null:r;var a=s.memoizedState.inst;null!==xa&&null!==r&&$a(r,xa.memoizedState.deps)?s.memoizedState=pi(t,a,n,r):(va.flags|=e,s.memoizedState=pi(1|t,a,n,r))}function yi(e,t){mi(8390656,8,e,t)}function bi(e,t){gi(2048,8,e,t)}function vi(e,t){return gi(4,2,e,t)}function xi(e,t){return gi(4,4,e,t)}function wi(e,t){if("function"===typeof t){e=e();var n=t(e);return function(){"function"===typeof n?n():t(null)}}if(null!==t&&void 0!==t)return e=e(),t.current=e,function(){t.current=null}}function ki(e,t,n){n=null!==n&&void 0!==n?n.concat([e]):null,gi(4,4,wi.bind(null,t,e),n)}function Si(){}function Ni(e,t){var n=za();t=void 0===t?null:t;var r=n.memoizedState;return null!==t&&$a(t,r[1])?r[0]:(n.memoizedState=[e,t],e)}function Ii(e,t){var n=za();t=void 0===t?null:t;var r=n.memoizedState;if(null!==t&&$a(t,r[1]))return r[0];if(r=e(),Na){de(!0);try{e()}finally{de(!1)}}return n.memoizedState=[r,t],r}function Ci(e,t,n){return void 0===n||0!==(1073741824&ba)?e.memoizedState=t:(e.memoizedState=n,e=Fu(),va.lanes|=e,pu|=e,n)}function Ti(e,t,n,r){return Xn(n,t)?n:null!==pa.current?(e=Ci(e,n,r),Xn(e,t)||(To=!0),e):0===(42&ba)?(To=!0,e.memoizedState=n):(e=Fu(),va.lanes|=e,pu|=e,t)}function Ai(e,t,n,r,s){var a=F.p;F.p=0!==a&&8>a?a:8;var i=_.T,o={};_.T=o,Bi(e,!1,t,n);try{var l=s(),u=_.S;if(null!==u&&u(o,l),null!==l&&"object"===typeof l&&"function"===typeof l.then)zi(e,t,function(e,t){var n=[],r={status:"pending",value:null,reason:null,then:function(e){n.push(e)}};return e.then((function(){r.status="fulfilled",r.value=t;for(var e=0;e<n.length;e++)(0,n[e])(t)}),(function(e){for(r.status="rejected",r.reason=e,e=0;e<n.length;e++)(0,n[e])(void 0)})),r}(l,r),_u());else zi(e,t,r,_u())}catch(c){zi(e,t,{then:function(){},status:"rejected",reason:c},_u())}finally{F.p=a,_.T=i}}function Ei(){}function $i(e,t,n,r){if(5!==e.tag)throw Error(i(476));var s=Ri(e).queue;Ai(e,s,t,M,null===n?Ei:function(){return Di(e),n(r)})}function Ri(e){var t=e.memoizedState;if(null!==t)return t;var n={};return(t={memoizedState:M,baseState:M,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Ua,lastRenderedState:M},next:null}).next={memoizedState:n,baseState:n,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Ua,lastRenderedState:n},next:null},e.memoizedState=t,null!==(e=e.alternate)&&(e.memoizedState=t),t}function Di(e){zi(e,Ri(e).next.queue,{},_u())}function Oi(){return Cs(Kh)}function _i(){return za().memoizedState}function Fi(){return za().memoizedState}function Mi(e){for(var t=e.return;null!==t;){switch(t.tag){case 24:case 3:var n=_u(),r=aa(t,e=sa(n),n);return null!==r&&(Mu(r,t,n),ia(r,t,n)),t={cache:Os()},void(e.payload=t)}t=t.return}}function Li(e,t,n){var r=_u();n={lane:r,revertLane:0,action:n,hasEagerState:!1,eagerState:null,next:null},Vi(e)?Wi(t,n):null!==(n=$r(e,t,n,r))&&(Mu(n,e,r),Ui(n,t,r))}function Pi(e,t,n){zi(e,t,n,_u())}function zi(e,t,n,r){var s={lane:r,revertLane:0,action:n,hasEagerState:!1,eagerState:null,next:null};if(Vi(e))Wi(t,s);else{var a=e.alternate;if(0===e.lanes&&(null===a||0===a.lanes)&&null!==(a=t.lastRenderedReducer))try{var i=t.lastRenderedState,o=a(i,n);if(s.hasEagerState=!0,s.eagerState=o,Xn(o,i))return Er(e,t,s,0),null===ru&&Ar(),!1}catch(l){}if(null!==(n=$r(e,t,s,r)))return Mu(n,e,r),Ui(n,t,r),!0}return!1}function Bi(e,t,n,r){if(r={lane:2,revertLane:Ec(),action:r,hasEagerState:!1,eagerState:null,next:null},Vi(e)){if(t)throw Error(i(479))}else null!==(t=$r(e,n,r,2))&&Mu(t,e,2)}function Vi(e){var t=e.alternate;return e===va||null!==t&&t===va}function Wi(e,t){Sa=ka=!0;var n=e.pending;null===n?t.next=t:(t.next=n.next,n.next=t),e.pending=t}function Ui(e,t,n){if(0!==(4194048&n)){var r=t.lanes;n|=r&=e.pendingLanes,t.lanes=n,Te(e,n)}}var ji={readContext:Cs,use:Va,useCallback:Ea,useContext:Ea,useEffect:Ea,useImperativeHandle:Ea,useLayoutEffect:Ea,useInsertionEffect:Ea,useMemo:Ea,useReducer:Ea,useRef:Ea,useState:Ea,useDebugValue:Ea,useDeferredValue:Ea,useTransition:Ea,useSyncExternalStore:Ea,useId:Ea,useHostTransitionStatus:Ea,useFormState:Ea,useActionState:Ea,useOptimistic:Ea,useMemoCache:Ea,useCacheRefresh:Ea},Gi={readContext:Cs,use:Va,useCallback:function(e,t){return Pa().memoizedState=[e,void 0===t?null:t],e},useContext:Cs,useEffect:yi,useImperativeHandle:function(e,t,n){n=null!==n&&void 0!==n?n.concat([e]):null,mi(4194308,4,wi.bind(null,t,e),n)},useLayoutEffect:function(e,t){return mi(4194308,4,e,t)},useInsertionEffect:function(e,t){mi(4,2,e,t)},useMemo:function(e,t){var n=Pa();t=void 0===t?null:t;var r=e();if(Na){de(!0);try{e()}finally{de(!1)}}return n.memoizedState=[r,t],r},useReducer:function(e,t,n){var r=Pa();if(void 0!==n){var s=n(t);if(Na){de(!0);try{n(t)}finally{de(!1)}}}else s=t;return r.memoizedState=r.baseState=s,e={pending:null,lanes:0,dispatch:null,lastRenderedReducer:e,lastRenderedState:s},r.queue=e,e=e.dispatch=Li.bind(null,va,e),[r.memoizedState,e]},useRef:function(e){return e={current:e},Pa().memoizedState=e},useState:function(e){var t=(e=Ja(e)).queue,n=Pi.bind(null,va,t);return t.dispatch=n,[e.memoizedState,n]},useDebugValue:Si,useDeferredValue:function(e,t){return Ci(Pa(),e,t)},useTransition:function(){var e=Ja(!1);return e=Ai.bind(null,va,e.queue,!0,!1),Pa().memoizedState=e,[!1,e]},useSyncExternalStore:function(e,t,n){var r=va,s=Pa();if(as){if(void 0===n)throw Error(i(407));n=n()}else{if(n=t(),null===ru)throw Error(i(349));0!==(124&au)||Ka(r,t,n)}s.memoizedState=n;var a={value:n,getSnapshot:t};return s.queue=a,yi(Qa.bind(null,r,a,e),[e]),r.flags|=2048,pi(9,{destroy:void 0,resource:void 0},Xa.bind(null,r,a,n,t),null),n},useId:function(){var e=Pa(),t=ru.identifierPrefix;if(as){var n=Zr;t="\xab"+t+"R"+(n=(Yr&~(1<<32-pe(Yr)-1)).toString(32)+n),0<(n=Ia++)&&(t+="H"+n.toString(32)),t+="\xbb"}else t="\xab"+t+"r"+(n=Aa++).toString(32)+"\xbb";return e.memoizedState=t},useHostTransitionStatus:Oi,useFormState:li,useActionState:li,useOptimistic:function(e){var t=Pa();t.memoizedState=t.baseState=e;var n={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return t.queue=n,t=Bi.bind(null,va,!0,n),n.dispatch=t,[e,t]},useMemoCache:Wa,useCacheRefresh:function(){return Pa().memoizedState=Mi.bind(null,va)}},Hi={readContext:Cs,use:Va,useCallback:Ni,useContext:Cs,useEffect:bi,useImperativeHandle:ki,useInsertionEffect:vi,useLayoutEffect:xi,useMemo:Ii,useReducer:ja,useRef:fi,useState:function(){return ja(Ua)},useDebugValue:Si,useDeferredValue:function(e,t){return Ti(za(),xa.memoizedState,e,t)},useTransition:function(){var e=ja(Ua)[0],t=za().memoizedState;return["boolean"===typeof e?e:Ba(e),t]},useSyncExternalStore:qa,useId:_i,useHostTransitionStatus:Oi,useFormState:ui,useActionState:ui,useOptimistic:function(e,t){return ei(za(),0,e,t)},useMemoCache:Wa,useCacheRefresh:Fi},qi={readContext:Cs,use:Va,useCallback:Ni,useContext:Cs,useEffect:bi,useImperativeHandle:ki,useInsertionEffect:vi,useLayoutEffect:xi,useMemo:Ii,useReducer:Ha,useRef:fi,useState:function(){return Ha(Ua)},useDebugValue:Si,useDeferredValue:function(e,t){var n=za();return null===xa?Ci(n,e,t):Ti(n,xa.memoizedState,e,t)},useTransition:function(){var e=Ha(Ua)[0],t=za().memoizedState;return["boolean"===typeof e?e:Ba(e),t]},useSyncExternalStore:qa,useId:_i,useHostTransitionStatus:Oi,useFormState:di,useActionState:di,useOptimistic:function(e,t){var n=za();return null!==xa?ei(n,0,e,t):(n.baseState=e,[e,n.queue.dispatch])},useMemoCache:Wa,useCacheRefresh:Fi},Ki=null,Xi=0;function Qi(e){var t=Xi;return Xi+=1,null===Ki&&(Ki=[]),Ys(Ki,e,t)}function Yi(e,t){t=t.props.ref,e.ref=void 0!==t?t:null}function Zi(e,t){if(t.$$typeof===p)throw Error(i(525));throw e=Object.prototype.toString.call(t),Error(i(31,"[object Object]"===e?"object with keys {"+Object.keys(t).join(", ")+"}":e))}function Ji(e){return(0,e._init)(e._payload)}function eo(e){function t(t,n){if(e){var r=t.deletions;null===r?(t.deletions=[n],t.flags|=16):r.push(n)}}function n(n,r){if(!e)return null;for(;null!==r;)t(n,r),r=r.sibling;return null}function r(e){for(var t=new Map;null!==e;)null!==e.key?t.set(e.key,e):t.set(e.index,e),e=e.sibling;return t}function s(e,t){return(e=Pr(e,t)).index=0,e.sibling=null,e}function a(t,n,r){return t.index=r,e?null!==(r=t.alternate)?(r=r.index)<n?(t.flags|=67108866,n):r:(t.flags|=67108866,n):(t.flags|=1048576,n)}function o(t){return e&&null===t.alternate&&(t.flags|=67108866),t}function l(e,t,n,r){return null===t||6!==t.tag?((t=Wr(n,e.mode,r)).return=e,t):((t=s(t,n)).return=e,t)}function u(e,t,n,r){var a=n.type;return a===g?h(e,t,n.props.children,r,n.key):null!==t&&(t.elementType===a||"object"===typeof a&&null!==a&&a.$$typeof===C&&Ji(a)===t.type)?(Yi(t=s(t,n.props),n),t.return=e,t):(Yi(t=Br(n.type,n.key,n.props,null,e.mode,r),n),t.return=e,t)}function c(e,t,n,r){return null===t||4!==t.tag||t.stateNode.containerInfo!==n.containerInfo||t.stateNode.implementation!==n.implementation?((t=Ur(n,e.mode,r)).return=e,t):((t=s(t,n.children||[])).return=e,t)}function h(e,t,n,r,a){return null===t||7!==t.tag?((t=Vr(n,e.mode,r,a)).return=e,t):((t=s(t,n)).return=e,t)}function d(e,t,n){if("string"===typeof t&&""!==t||"number"===typeof t||"bigint"===typeof t)return(t=Wr(""+t,e.mode,n)).return=e,t;if("object"===typeof t&&null!==t){switch(t.$$typeof){case f:return Yi(n=Br(t.type,t.key,t.props,null,e.mode,n),t),n.return=e,n;case m:return(t=Ur(t,e.mode,n)).return=e,t;case C:return d(e,t=(0,t._init)(t._payload),n)}if(O(t)||$(t))return(t=Vr(t,e.mode,n,null)).return=e,t;if("function"===typeof t.then)return d(e,Qi(t),n);if(t.$$typeof===w)return d(e,Ts(e,t),n);Zi(e,t)}return null}function p(e,t,n,r){var s=null!==t?t.key:null;if("string"===typeof n&&""!==n||"number"===typeof n||"bigint"===typeof n)return null!==s?null:l(e,t,""+n,r);if("object"===typeof n&&null!==n){switch(n.$$typeof){case f:return n.key===s?u(e,t,n,r):null;case m:return n.key===s?c(e,t,n,r):null;case C:return p(e,t,n=(s=n._init)(n._payload),r)}if(O(n)||$(n))return null!==s?null:h(e,t,n,r,null);if("function"===typeof n.then)return p(e,t,Qi(n),r);if(n.$$typeof===w)return p(e,t,Ts(e,n),r);Zi(e,n)}return null}function y(e,t,n,r,s){if("string"===typeof r&&""!==r||"number"===typeof r||"bigint"===typeof r)return l(t,e=e.get(n)||null,""+r,s);if("object"===typeof r&&null!==r){switch(r.$$typeof){case f:return u(t,e=e.get(null===r.key?n:r.key)||null,r,s);case m:return c(t,e=e.get(null===r.key?n:r.key)||null,r,s);case C:return y(e,t,n,r=(0,r._init)(r._payload),s)}if(O(r)||$(r))return h(t,e=e.get(n)||null,r,s,null);if("function"===typeof r.then)return y(e,t,n,Qi(r),s);if(r.$$typeof===w)return y(e,t,n,Ts(t,r),s);Zi(t,r)}return null}function b(l,u,c,h){if("object"===typeof c&&null!==c&&c.type===g&&null===c.key&&(c=c.props.children),"object"===typeof c&&null!==c){switch(c.$$typeof){case f:e:{for(var v=c.key;null!==u;){if(u.key===v){if((v=c.type)===g){if(7===u.tag){n(l,u.sibling),(h=s(u,c.props.children)).return=l,l=h;break e}}else if(u.elementType===v||"object"===typeof v&&null!==v&&v.$$typeof===C&&Ji(v)===u.type){n(l,u.sibling),Yi(h=s(u,c.props),c),h.return=l,l=h;break e}n(l,u);break}t(l,u),u=u.sibling}c.type===g?((h=Vr(c.props.children,l.mode,h,c.key)).return=l,l=h):(Yi(h=Br(c.type,c.key,c.props,null,l.mode,h),c),h.return=l,l=h)}return o(l);case m:e:{for(v=c.key;null!==u;){if(u.key===v){if(4===u.tag&&u.stateNode.containerInfo===c.containerInfo&&u.stateNode.implementation===c.implementation){n(l,u.sibling),(h=s(u,c.children||[])).return=l,l=h;break e}n(l,u);break}t(l,u),u=u.sibling}(h=Ur(c,l.mode,h)).return=l,l=h}return o(l);case C:return b(l,u,c=(v=c._init)(c._payload),h)}if(O(c))return function(s,i,o,l){for(var u=null,c=null,h=i,f=i=0,m=null;null!==h&&f<o.length;f++){h.index>f?(m=h,h=null):m=h.sibling;var g=p(s,h,o[f],l);if(null===g){null===h&&(h=m);break}e&&h&&null===g.alternate&&t(s,h),i=a(g,i,f),null===c?u=g:c.sibling=g,c=g,h=m}if(f===o.length)return n(s,h),as&&Jr(s,f),u;if(null===h){for(;f<o.length;f++)null!==(h=d(s,o[f],l))&&(i=a(h,i,f),null===c?u=h:c.sibling=h,c=h);return as&&Jr(s,f),u}for(h=r(h);f<o.length;f++)null!==(m=y(h,s,f,o[f],l))&&(e&&null!==m.alternate&&h.delete(null===m.key?f:m.key),i=a(m,i,f),null===c?u=m:c.sibling=m,c=m);return e&&h.forEach((function(e){return t(s,e)})),as&&Jr(s,f),u}(l,u,c,h);if($(c)){if("function"!==typeof(v=$(c)))throw Error(i(150));return function(s,o,l,u){if(null==l)throw Error(i(151));for(var c=null,h=null,f=o,m=o=0,g=null,b=l.next();null!==f&&!b.done;m++,b=l.next()){f.index>m?(g=f,f=null):g=f.sibling;var v=p(s,f,b.value,u);if(null===v){null===f&&(f=g);break}e&&f&&null===v.alternate&&t(s,f),o=a(v,o,m),null===h?c=v:h.sibling=v,h=v,f=g}if(b.done)return n(s,f),as&&Jr(s,m),c;if(null===f){for(;!b.done;m++,b=l.next())null!==(b=d(s,b.value,u))&&(o=a(b,o,m),null===h?c=b:h.sibling=b,h=b);return as&&Jr(s,m),c}for(f=r(f);!b.done;m++,b=l.next())null!==(b=y(f,s,m,b.value,u))&&(e&&null!==b.alternate&&f.delete(null===b.key?m:b.key),o=a(b,o,m),null===h?c=b:h.sibling=b,h=b);return e&&f.forEach((function(e){return t(s,e)})),as&&Jr(s,m),c}(l,u,c=v.call(c),h)}if("function"===typeof c.then)return b(l,u,Qi(c),h);if(c.$$typeof===w)return b(l,u,Ts(l,c),h);Zi(l,c)}return"string"===typeof c&&""!==c||"number"===typeof c||"bigint"===typeof c?(c=""+c,null!==u&&6===u.tag?(n(l,u.sibling),(h=s(u,c)).return=l,l=h):(n(l,u),(h=Wr(c,l.mode,h)).return=l,l=h),o(l)):n(l,u)}return function(e,t,n,r){try{Xi=0;var s=b(e,t,n,r);return Ki=null,s}catch(i){if(i===Gs||i===qs)throw i;var a=Mr(29,i,null,e.mode);return a.lanes=r,a.return=e,a}}}var to=eo(!0),no=eo(!1),ro=z(null),so=null;function ao(e){var t=e.alternate;V(uo,1&uo.current),V(ro,e),null===so&&(null===t||null!==pa.current||null!==t.memoizedState)&&(so=e)}function io(e){if(22===e.tag){if(V(uo,uo.current),V(ro,e),null===so){var t=e.alternate;null!==t&&null!==t.memoizedState&&(so=e)}}else oo()}function oo(){V(uo,uo.current),V(ro,ro.current)}function lo(e){B(ro),so===e&&(so=null),B(uo)}var uo=z(0);function co(e){for(var t=e;null!==t;){if(13===t.tag){var n=t.memoizedState;if(null!==n&&(null===(n=n.dehydrated)||"$?"===n.data||gh(n)))return t}else if(19===t.tag&&void 0!==t.memoizedProps.revealOrder){if(0!==(128&t.flags))return t}else if(null!==t.child){t.child.return=t,t=t.child;continue}if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}return null}function ho(e,t,n,r){n=null===(n=n(r,t=e.memoizedState))||void 0===n?t:d({},t,n),e.memoizedState=n,0===e.lanes&&(e.updateQueue.baseState=n)}var po={enqueueSetState:function(e,t,n){e=e._reactInternals;var r=_u(),s=sa(r);s.payload=t,void 0!==n&&null!==n&&(s.callback=n),null!==(t=aa(e,s,r))&&(Mu(t,e,r),ia(t,e,r))},enqueueReplaceState:function(e,t,n){e=e._reactInternals;var r=_u(),s=sa(r);s.tag=1,s.payload=t,void 0!==n&&null!==n&&(s.callback=n),null!==(t=aa(e,s,r))&&(Mu(t,e,r),ia(t,e,r))},enqueueForceUpdate:function(e,t){e=e._reactInternals;var n=_u(),r=sa(n);r.tag=2,void 0!==t&&null!==t&&(r.callback=t),null!==(t=aa(e,r,n))&&(Mu(t,e,n),ia(t,e,n))}};function fo(e,t,n,r,s,a,i){return"function"===typeof(e=e.stateNode).shouldComponentUpdate?e.shouldComponentUpdate(r,a,i):!t.prototype||!t.prototype.isPureReactComponent||(!Qn(n,r)||!Qn(s,a))}function mo(e,t,n,r){e=t.state,"function"===typeof t.componentWillReceiveProps&&t.componentWillReceiveProps(n,r),"function"===typeof t.UNSAFE_componentWillReceiveProps&&t.UNSAFE_componentWillReceiveProps(n,r),t.state!==e&&po.enqueueReplaceState(t,t.state,null)}function go(e,t){var n=t;if("ref"in t)for(var r in n={},t)"ref"!==r&&(n[r]=t[r]);if(e=e.defaultProps)for(var s in n===t&&(n=d({},n)),e)void 0===n[s]&&(n[s]=e[s]);return n}var yo="function"===typeof reportError?reportError:function(e){if("object"===typeof window&&"function"===typeof window.ErrorEvent){var t=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:"object"===typeof e&&null!==e&&"string"===typeof e.message?String(e.message):String(e),error:e});if(!window.dispatchEvent(t))return}else if("object"===typeof process&&"function"===typeof process.emit)return void process.emit("uncaughtException",e);console.error(e)};function bo(e){yo(e)}function vo(e){console.error(e)}function xo(e){yo(e)}function wo(e,t){try{(0,e.onUncaughtError)(t.value,{componentStack:t.stack})}catch(n){setTimeout((function(){throw n}))}}function ko(e,t,n){try{(0,e.onCaughtError)(n.value,{componentStack:n.stack,errorBoundary:1===t.tag?t.stateNode:null})}catch(r){setTimeout((function(){throw r}))}}function So(e,t,n){return(n=sa(n)).tag=3,n.payload={element:null},n.callback=function(){wo(e,t)},n}function No(e){return(e=sa(e)).tag=3,e}function Io(e,t,n,r){var s=n.type.getDerivedStateFromError;if("function"===typeof s){var a=r.value;e.payload=function(){return s(a)},e.callback=function(){ko(t,n,r)}}var i=n.stateNode;null!==i&&"function"===typeof i.componentDidCatch&&(e.callback=function(){ko(t,n,r),"function"!==typeof s&&(null===Nu?Nu=new Set([this]):Nu.add(this));var e=r.stack;this.componentDidCatch(r.value,{componentStack:null!==e?e:""})})}var Co=Error(i(461)),To=!1;function Ao(e,t,n,r){t.child=null===e?no(t,null,n,r):to(t,e.child,n,r)}function Eo(e,t,n,r,s){n=n.render;var a=t.ref;if("ref"in r){var i={};for(var o in r)"ref"!==o&&(i[o]=r[o])}else i=r;return Is(t),r=Ra(e,t,n,i,a,s),o=Fa(),null===e||To?(as&&o&&ts(t),t.flags|=1,Ao(e,t,r,s),t.child):(Ma(e,t,s),Xo(e,t,s))}function $o(e,t,n,r,s){if(null===e){var a=n.type;return"function"!==typeof a||Lr(a)||void 0!==a.defaultProps||null!==n.compare?((e=Br(n.type,null,r,t,t.mode,s)).ref=t.ref,e.return=t,t.child=e):(t.tag=15,t.type=a,Ro(e,t,a,r,s))}if(a=e.child,!Qo(e,s)){var i=a.memoizedProps;if((n=null!==(n=n.compare)?n:Qn)(i,r)&&e.ref===t.ref)return Xo(e,t,s)}return t.flags|=1,(e=Pr(a,r)).ref=t.ref,e.return=t,t.child=e}function Ro(e,t,n,r,s){if(null!==e){var a=e.memoizedProps;if(Qn(a,r)&&e.ref===t.ref){if(To=!1,t.pendingProps=r=a,!Qo(e,s))return t.lanes=e.lanes,Xo(e,t,s);0!==(131072&e.flags)&&(To=!0)}}return Fo(e,t,n,r,s)}function Do(e,t,n){var r=t.pendingProps,s=r.children,a=null!==e?e.memoizedState:null;if("hidden"===r.mode){if(0!==(128&t.flags)){if(r=null!==a?a.baseLanes|n:n,null!==e){for(s=t.child=e.child,a=0;null!==s;)a=a|s.lanes|s.childLanes,s=s.sibling;t.childLanes=a&~r}else t.childLanes=0,t.child=null;return Oo(e,t,r,n)}if(0===(536870912&n))return t.lanes=t.childLanes=536870912,Oo(e,t,null!==a?a.baseLanes|n:n,n);t.memoizedState={baseLanes:0,cachePool:null},null!==e&&Us(0,null!==a?a.cachePool:null),null!==a?ma(t,a):ga(),io(t)}else null!==a?(Us(0,a.cachePool),ma(t,a),oo(),t.memoizedState=null):(null!==e&&Us(0,null),ga(),oo());return Ao(e,t,s,n),t.child}function Oo(e,t,n,r){var s=Ws();return s=null===s?null:{parent:Ds._currentValue,pool:s},t.memoizedState={baseLanes:n,cachePool:s},null!==e&&Us(0,null),ga(),io(t),null!==e&&Ss(e,t,r,!0),null}function _o(e,t){var n=t.ref;if(null===n)null!==e&&null!==e.ref&&(t.flags|=4194816);else{if("function"!==typeof n&&"object"!==typeof n)throw Error(i(284));null!==e&&e.ref===n||(t.flags|=4194816)}}function Fo(e,t,n,r,s){return Is(t),n=Ra(e,t,n,r,void 0,s),r=Fa(),null===e||To?(as&&r&&ts(t),t.flags|=1,Ao(e,t,n,s),t.child):(Ma(e,t,s),Xo(e,t,s))}function Mo(e,t,n,r,s,a){return Is(t),t.updateQueue=null,n=Oa(t,r,n,s),Da(e),r=Fa(),null===e||To?(as&&r&&ts(t),t.flags|=1,Ao(e,t,n,a),t.child):(Ma(e,t,a),Xo(e,t,a))}function Lo(e,t,n,r,s){if(Is(t),null===t.stateNode){var a=_r,i=n.contextType;"object"===typeof i&&null!==i&&(a=Cs(i)),a=new n(r,a),t.memoizedState=null!==a.state&&void 0!==a.state?a.state:null,a.updater=po,t.stateNode=a,a._reactInternals=t,(a=t.stateNode).props=r,a.state=t.memoizedState,a.refs={},na(t),i=n.contextType,a.context="object"===typeof i&&null!==i?Cs(i):_r,a.state=t.memoizedState,"function"===typeof(i=n.getDerivedStateFromProps)&&(ho(t,n,i,r),a.state=t.memoizedState),"function"===typeof n.getDerivedStateFromProps||"function"===typeof a.getSnapshotBeforeUpdate||"function"!==typeof a.UNSAFE_componentWillMount&&"function"!==typeof a.componentWillMount||(i=a.state,"function"===typeof a.componentWillMount&&a.componentWillMount(),"function"===typeof a.UNSAFE_componentWillMount&&a.UNSAFE_componentWillMount(),i!==a.state&&po.enqueueReplaceState(a,a.state,null),ca(t,r,a,s),ua(),a.state=t.memoizedState),"function"===typeof a.componentDidMount&&(t.flags|=4194308),r=!0}else if(null===e){a=t.stateNode;var o=t.memoizedProps,l=go(n,o);a.props=l;var u=a.context,c=n.contextType;i=_r,"object"===typeof c&&null!==c&&(i=Cs(c));var h=n.getDerivedStateFromProps;c="function"===typeof h||"function"===typeof a.getSnapshotBeforeUpdate,o=t.pendingProps!==o,c||"function"!==typeof a.UNSAFE_componentWillReceiveProps&&"function"!==typeof a.componentWillReceiveProps||(o||u!==i)&&mo(t,a,r,i),ta=!1;var d=t.memoizedState;a.state=d,ca(t,r,a,s),ua(),u=t.memoizedState,o||d!==u||ta?("function"===typeof h&&(ho(t,n,h,r),u=t.memoizedState),(l=ta||fo(t,n,l,r,d,u,i))?(c||"function"!==typeof a.UNSAFE_componentWillMount&&"function"!==typeof a.componentWillMount||("function"===typeof a.componentWillMount&&a.componentWillMount(),"function"===typeof a.UNSAFE_componentWillMount&&a.UNSAFE_componentWillMount()),"function"===typeof a.componentDidMount&&(t.flags|=4194308)):("function"===typeof a.componentDidMount&&(t.flags|=4194308),t.memoizedProps=r,t.memoizedState=u),a.props=r,a.state=u,a.context=i,r=l):("function"===typeof a.componentDidMount&&(t.flags|=4194308),r=!1)}else{a=t.stateNode,ra(e,t),c=go(n,i=t.memoizedProps),a.props=c,h=t.pendingProps,d=a.context,u=n.contextType,l=_r,"object"===typeof u&&null!==u&&(l=Cs(u)),(u="function"===typeof(o=n.getDerivedStateFromProps)||"function"===typeof a.getSnapshotBeforeUpdate)||"function"!==typeof a.UNSAFE_componentWillReceiveProps&&"function"!==typeof a.componentWillReceiveProps||(i!==h||d!==l)&&mo(t,a,r,l),ta=!1,d=t.memoizedState,a.state=d,ca(t,r,a,s),ua();var p=t.memoizedState;i!==h||d!==p||ta||null!==e&&null!==e.dependencies&&Ns(e.dependencies)?("function"===typeof o&&(ho(t,n,o,r),p=t.memoizedState),(c=ta||fo(t,n,c,r,d,p,l)||null!==e&&null!==e.dependencies&&Ns(e.dependencies))?(u||"function"!==typeof a.UNSAFE_componentWillUpdate&&"function"!==typeof a.componentWillUpdate||("function"===typeof a.componentWillUpdate&&a.componentWillUpdate(r,p,l),"function"===typeof a.UNSAFE_componentWillUpdate&&a.UNSAFE_componentWillUpdate(r,p,l)),"function"===typeof a.componentDidUpdate&&(t.flags|=4),"function"===typeof a.getSnapshotBeforeUpdate&&(t.flags|=1024)):("function"!==typeof a.componentDidUpdate||i===e.memoizedProps&&d===e.memoizedState||(t.flags|=4),"function"!==typeof a.getSnapshotBeforeUpdate||i===e.memoizedProps&&d===e.memoizedState||(t.flags|=1024),t.memoizedProps=r,t.memoizedState=p),a.props=r,a.state=p,a.context=l,r=c):("function"!==typeof a.componentDidUpdate||i===e.memoizedProps&&d===e.memoizedState||(t.flags|=4),"function"!==typeof a.getSnapshotBeforeUpdate||i===e.memoizedProps&&d===e.memoizedState||(t.flags|=1024),r=!1)}return a=r,_o(e,t),r=0!==(128&t.flags),a||r?(a=t.stateNode,n=r&&"function"!==typeof n.getDerivedStateFromError?null:a.render(),t.flags|=1,null!==e&&r?(t.child=to(t,e.child,null,s),t.child=to(t,null,n,s)):Ao(e,t,n,s),t.memoizedState=a.state,e=t.child):e=Xo(e,t,s),e}function Po(e,t,n,r){return ps(),t.flags|=256,Ao(e,t,n,r),t.child}var zo={dehydrated:null,treeContext:null,retryLane:0,hydrationErrors:null};function Bo(e){return{baseLanes:e,cachePool:js()}}function Vo(e,t,n){return e=null!==e?e.childLanes&~n:0,t&&(e|=gu),e}function Wo(e,t,n){var r,s=t.pendingProps,a=!1,o=0!==(128&t.flags);if((r=o)||(r=(null===e||null!==e.memoizedState)&&0!==(2&uo.current)),r&&(a=!0,t.flags&=-129),r=0!==(32&t.flags),t.flags&=-33,null===e){if(as){if(a?ao(t):oo(),as){var l,u=ss;if(l=u){e:{for(l=u,u=os;8!==l.nodeType;){if(!u){u=null;break e}if(null===(l=yh(l.nextSibling))){u=null;break e}}u=l}null!==u?(t.memoizedState={dehydrated:u,treeContext:null!==Qr?{id:Yr,overflow:Zr}:null,retryLane:536870912,hydrationErrors:null},(l=Mr(18,null,null,0)).stateNode=u,l.return=t,t.child=l,rs=t,ss=null,l=!0):l=!1}l||us(t)}if(null!==(u=t.memoizedState)&&null!==(u=u.dehydrated))return gh(u)?t.lanes=32:t.lanes=536870912,null;lo(t)}return u=s.children,s=s.fallback,a?(oo(),u=jo({mode:"hidden",children:u},a=t.mode),s=Vr(s,a,n,null),u.return=t,s.return=t,u.sibling=s,t.child=u,(a=t.child).memoizedState=Bo(n),a.childLanes=Vo(e,r,n),t.memoizedState=zo,s):(ao(t),Uo(t,u))}if(null!==(l=e.memoizedState)&&null!==(u=l.dehydrated)){if(o)256&t.flags?(ao(t),t.flags&=-257,t=Go(e,t,n)):null!==t.memoizedState?(oo(),t.child=e.child,t.flags|=128,t=null):(oo(),a=s.fallback,u=t.mode,s=jo({mode:"visible",children:s.children},u),(a=Vr(a,u,n,null)).flags|=2,s.return=t,a.return=t,s.sibling=a,t.child=s,to(t,e.child,null,n),(s=t.child).memoizedState=Bo(n),s.childLanes=Vo(e,r,n),t.memoizedState=zo,t=a);else if(ao(t),gh(u)){if(r=u.nextSibling&&u.nextSibling.dataset)var c=r.dgst;r=c,(s=Error(i(419))).stack="",s.digest=r,ms({value:s,source:null,stack:null}),t=Go(e,t,n)}else if(To||Ss(e,t,n,!1),r=0!==(n&e.childLanes),To||r){if(null!==(r=ru)&&(0!==(s=0!==((s=0!==(42&(s=n&-n))?1:Ae(s))&(r.suspendedLanes|n))?0:s)&&s!==l.retryLane))throw l.retryLane=s,Rr(e,s),Mu(r,e,s),Co;"$?"===u.data||qu(),t=Go(e,t,n)}else"$?"===u.data?(t.flags|=192,t.child=e.child,t=null):(e=l.treeContext,ss=yh(u.nextSibling),rs=t,as=!0,is=null,os=!1,null!==e&&(Kr[Xr++]=Yr,Kr[Xr++]=Zr,Kr[Xr++]=Qr,Yr=e.id,Zr=e.overflow,Qr=t),(t=Uo(t,s.children)).flags|=4096);return t}return a?(oo(),a=s.fallback,u=t.mode,c=(l=e.child).sibling,(s=Pr(l,{mode:"hidden",children:s.children})).subtreeFlags=65011712&l.subtreeFlags,null!==c?a=Pr(c,a):(a=Vr(a,u,n,null)).flags|=2,a.return=t,s.return=t,s.sibling=a,t.child=s,s=a,a=t.child,null===(u=e.child.memoizedState)?u=Bo(n):(null!==(l=u.cachePool)?(c=Ds._currentValue,l=l.parent!==c?{parent:c,pool:c}:l):l=js(),u={baseLanes:u.baseLanes|n,cachePool:l}),a.memoizedState=u,a.childLanes=Vo(e,r,n),t.memoizedState=zo,s):(ao(t),e=(n=e.child).sibling,(n=Pr(n,{mode:"visible",children:s.children})).return=t,n.sibling=null,null!==e&&(null===(r=t.deletions)?(t.deletions=[e],t.flags|=16):r.push(e)),t.child=n,t.memoizedState=null,n)}function Uo(e,t){return(t=jo({mode:"visible",children:t},e.mode)).return=e,e.child=t}function jo(e,t){return(e=Mr(22,e,null,t)).lanes=0,e.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null},e}function Go(e,t,n){return to(t,e.child,null,n),(e=Uo(t,t.pendingProps.children)).flags|=2,t.memoizedState=null,e}function Ho(e,t,n){e.lanes|=t;var r=e.alternate;null!==r&&(r.lanes|=t),ws(e.return,t,n)}function qo(e,t,n,r,s){var a=e.memoizedState;null===a?e.memoizedState={isBackwards:t,rendering:null,renderingStartTime:0,last:r,tail:n,tailMode:s}:(a.isBackwards=t,a.rendering=null,a.renderingStartTime=0,a.last=r,a.tail=n,a.tailMode=s)}function Ko(e,t,n){var r=t.pendingProps,s=r.revealOrder,a=r.tail;if(Ao(e,t,r.children,n),0!==(2&(r=uo.current)))r=1&r|2,t.flags|=128;else{if(null!==e&&0!==(128&e.flags))e:for(e=t.child;null!==e;){if(13===e.tag)null!==e.memoizedState&&Ho(e,n,t);else if(19===e.tag)Ho(e,n,t);else if(null!==e.child){e.child.return=e,e=e.child;continue}if(e===t)break e;for(;null===e.sibling;){if(null===e.return||e.return===t)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}r&=1}switch(V(uo,r),s){case"forwards":for(n=t.child,s=null;null!==n;)null!==(e=n.alternate)&&null===co(e)&&(s=n),n=n.sibling;null===(n=s)?(s=t.child,t.child=null):(s=n.sibling,n.sibling=null),qo(t,!1,s,n,a);break;case"backwards":for(n=null,s=t.child,t.child=null;null!==s;){if(null!==(e=s.alternate)&&null===co(e)){t.child=s;break}e=s.sibling,s.sibling=n,n=s,s=e}qo(t,!0,n,null,a);break;case"together":qo(t,!1,null,null,void 0);break;default:t.memoizedState=null}return t.child}function Xo(e,t,n){if(null!==e&&(t.dependencies=e.dependencies),pu|=t.lanes,0===(n&t.childLanes)){if(null===e)return null;if(Ss(e,t,n,!1),0===(n&t.childLanes))return null}if(null!==e&&t.child!==e.child)throw Error(i(153));if(null!==t.child){for(n=Pr(e=t.child,e.pendingProps),t.child=n,n.return=t;null!==e.sibling;)e=e.sibling,(n=n.sibling=Pr(e,e.pendingProps)).return=t;n.sibling=null}return t.child}function Qo(e,t){return 0!==(e.lanes&t)||!(null===(e=e.dependencies)||!Ns(e))}function Yo(e,t,n){if(null!==e)if(e.memoizedProps!==t.pendingProps)To=!0;else{if(!Qo(e,n)&&0===(128&t.flags))return To=!1,function(e,t,n){switch(t.tag){case 3:H(t,t.stateNode.containerInfo),vs(0,Ds,e.memoizedState.cache),ps();break;case 27:case 5:K(t);break;case 4:H(t,t.stateNode.containerInfo);break;case 10:vs(0,t.type,t.memoizedProps.value);break;case 13:var r=t.memoizedState;if(null!==r)return null!==r.dehydrated?(ao(t),t.flags|=128,null):0!==(n&t.child.childLanes)?Wo(e,t,n):(ao(t),null!==(e=Xo(e,t,n))?e.sibling:null);ao(t);break;case 19:var s=0!==(128&e.flags);if((r=0!==(n&t.childLanes))||(Ss(e,t,n,!1),r=0!==(n&t.childLanes)),s){if(r)return Ko(e,t,n);t.flags|=128}if(null!==(s=t.memoizedState)&&(s.rendering=null,s.tail=null,s.lastEffect=null),V(uo,uo.current),r)break;return null;case 22:case 23:return t.lanes=0,Do(e,t,n);case 24:vs(0,Ds,e.memoizedState.cache)}return Xo(e,t,n)}(e,t,n);To=0!==(131072&e.flags)}else To=!1,as&&0!==(1048576&t.flags)&&es(t,qr,t.index);switch(t.lanes=0,t.tag){case 16:e:{e=t.pendingProps;var r=t.elementType,s=r._init;if(r=s(r._payload),t.type=r,"function"!==typeof r){if(void 0!==r&&null!==r){if((s=r.$$typeof)===k){t.tag=11,t=Eo(null,t,r,e,n);break e}if(s===I){t.tag=14,t=$o(null,t,r,e,n);break e}}throw t=D(r)||r,Error(i(306,t,""))}Lr(r)?(e=go(r,e),t.tag=1,t=Lo(null,t,r,e,n)):(t.tag=0,t=Fo(null,t,r,e,n))}return t;case 0:return Fo(e,t,t.type,t.pendingProps,n);case 1:return Lo(e,t,r=t.type,s=go(r,t.pendingProps),n);case 3:e:{if(H(t,t.stateNode.containerInfo),null===e)throw Error(i(387));r=t.pendingProps;var a=t.memoizedState;s=a.element,ra(e,t),ca(t,r,null,n);var o=t.memoizedState;if(r=o.cache,vs(0,Ds,r),r!==a.cache&&ks(t,[Ds],n,!0),ua(),r=o.element,a.isDehydrated){if(a={element:r,isDehydrated:!1,cache:o.cache},t.updateQueue.baseState=a,t.memoizedState=a,256&t.flags){t=Po(e,t,r,n);break e}if(r!==s){ms(s=Nr(Error(i(424)),t)),t=Po(e,t,r,n);break e}if(9===(e=t.stateNode.containerInfo).nodeType)e=e.body;else e="HTML"===e.nodeName?e.ownerDocument.body:e;for(ss=yh(e.firstChild),rs=t,as=!0,is=null,os=!0,n=no(t,null,r,n),t.child=n;n;)n.flags=-3&n.flags|4096,n=n.sibling}else{if(ps(),r===s){t=Xo(e,t,n);break e}Ao(e,t,r,n)}t=t.child}return t;case 26:return _o(e,t),null===e?(n=Ah(t.type,null,t.pendingProps,null))?t.memoizedState=n:as||(n=t.type,e=t.pendingProps,(r=rh(j.current).createElement(n))[De]=t,r[Oe]=e,eh(r,n,e),Ge(r),t.stateNode=r):t.memoizedState=Ah(t.type,e.memoizedProps,t.pendingProps,e.memoizedState),null;case 27:return K(t),null===e&&as&&(r=t.stateNode=xh(t.type,t.pendingProps,j.current),rs=t,os=!0,s=ss,ph(t.type)?(bh=s,ss=yh(r.firstChild)):ss=s),Ao(e,t,t.pendingProps.children,n),_o(e,t),null===e&&(t.flags|=4194304),t.child;case 5:return null===e&&as&&((s=r=ss)&&(null!==(r=function(e,t,n,r){for(;1===e.nodeType;){var s=n;if(e.nodeName.toLowerCase()!==t.toLowerCase()){if(!r&&("INPUT"!==e.nodeName||"hidden"!==e.type))break}else if(r){if(!e[ze])switch(t){case"meta":if(!e.hasAttribute("itemprop"))break;return e;case"link":if("stylesheet"===(a=e.getAttribute("rel"))&&e.hasAttribute("data-precedence"))break;if(a!==s.rel||e.getAttribute("href")!==(null==s.href||""===s.href?null:s.href)||e.getAttribute("crossorigin")!==(null==s.crossOrigin?null:s.crossOrigin)||e.getAttribute("title")!==(null==s.title?null:s.title))break;return e;case"style":if(e.hasAttribute("data-precedence"))break;return e;case"script":if(((a=e.getAttribute("src"))!==(null==s.src?null:s.src)||e.getAttribute("type")!==(null==s.type?null:s.type)||e.getAttribute("crossorigin")!==(null==s.crossOrigin?null:s.crossOrigin))&&a&&e.hasAttribute("async")&&!e.hasAttribute("itemprop"))break;return e;default:return e}}else{if("input"!==t||"hidden"!==e.type)return e;var a=null==s.name?null:""+s.name;if("hidden"===s.type&&e.getAttribute("name")===a)return e}if(null===(e=yh(e.nextSibling)))break}return null}(r,t.type,t.pendingProps,os))?(t.stateNode=r,rs=t,ss=yh(r.firstChild),os=!1,s=!0):s=!1),s||us(t)),K(t),s=t.type,a=t.pendingProps,o=null!==e?e.memoizedProps:null,r=a.children,ih(s,a)?r=null:null!==o&&ih(s,o)&&(t.flags|=32),null!==t.memoizedState&&(s=Ra(e,t,_a,null,null,n),Kh._currentValue=s),_o(e,t),Ao(e,t,r,n),t.child;case 6:return null===e&&as&&((e=n=ss)&&(null!==(n=function(e,t,n){if(""===t)return null;for(;3!==e.nodeType;){if((1!==e.nodeType||"INPUT"!==e.nodeName||"hidden"!==e.type)&&!n)return null;if(null===(e=yh(e.nextSibling)))return null}return e}(n,t.pendingProps,os))?(t.stateNode=n,rs=t,ss=null,e=!0):e=!1),e||us(t)),null;case 13:return Wo(e,t,n);case 4:return H(t,t.stateNode.containerInfo),r=t.pendingProps,null===e?t.child=to(t,null,r,n):Ao(e,t,r,n),t.child;case 11:return Eo(e,t,t.type,t.pendingProps,n);case 7:return Ao(e,t,t.pendingProps,n),t.child;case 8:case 12:return Ao(e,t,t.pendingProps.children,n),t.child;case 10:return r=t.pendingProps,vs(0,t.type,r.value),Ao(e,t,r.children,n),t.child;case 9:return s=t.type._context,r=t.pendingProps.children,Is(t),r=r(s=Cs(s)),t.flags|=1,Ao(e,t,r,n),t.child;case 14:return $o(e,t,t.type,t.pendingProps,n);case 15:return Ro(e,t,t.type,t.pendingProps,n);case 19:return Ko(e,t,n);case 31:return r=t.pendingProps,n=t.mode,r={mode:r.mode,children:r.children},null===e?((n=jo(r,n)).ref=t.ref,t.child=n,n.return=t,t=n):((n=Pr(e.child,r)).ref=t.ref,t.child=n,n.return=t,t=n),t;case 22:return Do(e,t,n);case 24:return Is(t),r=Cs(Ds),null===e?(null===(s=Ws())&&(s=ru,a=Os(),s.pooledCache=a,a.refCount++,null!==a&&(s.pooledCacheLanes|=n),s=a),t.memoizedState={parent:r,cache:s},na(t),vs(0,Ds,s)):(0!==(e.lanes&n)&&(ra(e,t),ca(t,null,null,n),ua()),s=e.memoizedState,a=t.memoizedState,s.parent!==r?(s={parent:r,cache:r},t.memoizedState=s,0===t.lanes&&(t.memoizedState=t.updateQueue.baseState=s),vs(0,Ds,r)):(r=a.cache,vs(0,Ds,r),r!==s.cache&&ks(t,[Ds],n,!0))),Ao(e,t,t.pendingProps.children,n),t.child;case 29:throw t.pendingProps}throw Error(i(156,t.tag))}function Zo(e){e.flags|=4}function Jo(e,t){if("stylesheet"!==t.type||0!==(4&t.state.loading))e.flags&=-16777217;else if(e.flags|=16777216,!Vh(t)){if(null!==(t=ro.current)&&((4194048&au)===au?null!==so:(62914560&au)!==au&&0===(536870912&au)||t!==so))throw Zs=Ks,Hs;e.flags|=8192}}function el(e,t){null!==t&&(e.flags|=4),16384&e.flags&&(t=22!==e.tag?Se():536870912,e.lanes|=t,yu|=t)}function tl(e,t){if(!as)switch(e.tailMode){case"hidden":t=e.tail;for(var n=null;null!==t;)null!==t.alternate&&(n=t),t=t.sibling;null===n?e.tail=null:n.sibling=null;break;case"collapsed":n=e.tail;for(var r=null;null!==n;)null!==n.alternate&&(r=n),n=n.sibling;null===r?t||null===e.tail?e.tail=null:e.tail.sibling=null:r.sibling=null}}function nl(e){var t=null!==e.alternate&&e.alternate.child===e.child,n=0,r=0;if(t)for(var s=e.child;null!==s;)n|=s.lanes|s.childLanes,r|=65011712&s.subtreeFlags,r|=65011712&s.flags,s.return=e,s=s.sibling;else for(s=e.child;null!==s;)n|=s.lanes|s.childLanes,r|=s.subtreeFlags,r|=s.flags,s.return=e,s=s.sibling;return e.subtreeFlags|=r,e.childLanes=n,t}function rl(e,t,n){var r=t.pendingProps;switch(ns(t),t.tag){case 31:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:case 1:return nl(t),null;case 3:return n=t.stateNode,r=null,null!==e&&(r=e.memoizedState.cache),t.memoizedState.cache!==r&&(t.flags|=2048),xs(Ds),q(),n.pendingContext&&(n.context=n.pendingContext,n.pendingContext=null),null!==e&&null!==e.child||(ds(t)?Zo(t):null===e||e.memoizedState.isDehydrated&&0===(256&t.flags)||(t.flags|=1024,fs())),nl(t),null;case 26:return n=t.memoizedState,null===e?(Zo(t),null!==n?(nl(t),Jo(t,n)):(nl(t),t.flags&=-16777217)):n?n!==e.memoizedState?(Zo(t),nl(t),Jo(t,n)):(nl(t),t.flags&=-16777217):(e.memoizedProps!==r&&Zo(t),nl(t),t.flags&=-16777217),null;case 27:X(t),n=j.current;var s=t.type;if(null!==e&&null!=t.stateNode)e.memoizedProps!==r&&Zo(t);else{if(!r){if(null===t.stateNode)throw Error(i(166));return nl(t),null}e=W.current,ds(t)?cs(t):(e=xh(s,r,n),t.stateNode=e,Zo(t))}return nl(t),null;case 5:if(X(t),n=t.type,null!==e&&null!=t.stateNode)e.memoizedProps!==r&&Zo(t);else{if(!r){if(null===t.stateNode)throw Error(i(166));return nl(t),null}if(e=W.current,ds(t))cs(t);else{switch(s=rh(j.current),e){case 1:e=s.createElementNS("http://www.w3.org/2000/svg",n);break;case 2:e=s.createElementNS("http://www.w3.org/1998/Math/MathML",n);break;default:switch(n){case"svg":e=s.createElementNS("http://www.w3.org/2000/svg",n);break;case"math":e=s.createElementNS("http://www.w3.org/1998/Math/MathML",n);break;case"script":(e=s.createElement("div")).innerHTML="<script><\/script>",e=e.removeChild(e.firstChild);break;case"select":e="string"===typeof r.is?s.createElement("select",{is:r.is}):s.createElement("select"),r.multiple?e.multiple=!0:r.size&&(e.size=r.size);break;default:e="string"===typeof r.is?s.createElement(n,{is:r.is}):s.createElement(n)}}e[De]=t,e[Oe]=r;e:for(s=t.child;null!==s;){if(5===s.tag||6===s.tag)e.appendChild(s.stateNode);else if(4!==s.tag&&27!==s.tag&&null!==s.child){s.child.return=s,s=s.child;continue}if(s===t)break e;for(;null===s.sibling;){if(null===s.return||s.return===t)break e;s=s.return}s.sibling.return=s.return,s=s.sibling}t.stateNode=e;e:switch(eh(e,n,r),n){case"button":case"input":case"select":case"textarea":e=!!r.autoFocus;break e;case"img":e=!0;break e;default:e=!1}e&&Zo(t)}}return nl(t),t.flags&=-16777217,null;case 6:if(e&&null!=t.stateNode)e.memoizedProps!==r&&Zo(t);else{if("string"!==typeof r&&null===t.stateNode)throw Error(i(166));if(e=j.current,ds(t)){if(e=t.stateNode,n=t.memoizedProps,r=null,null!==(s=rs))switch(s.tag){case 27:case 5:r=s.memoizedProps}e[De]=t,(e=!!(e.nodeValue===n||null!==r&&!0===r.suppressHydrationWarning||Qc(e.nodeValue,n)))||us(t)}else(e=rh(e).createTextNode(r))[De]=t,t.stateNode=e}return nl(t),null;case 13:if(r=t.memoizedState,null===e||null!==e.memoizedState&&null!==e.memoizedState.dehydrated){if(s=ds(t),null!==r&&null!==r.dehydrated){if(null===e){if(!s)throw Error(i(318));if(!(s=null!==(s=t.memoizedState)?s.dehydrated:null))throw Error(i(317));s[De]=t}else ps(),0===(128&t.flags)&&(t.memoizedState=null),t.flags|=4;nl(t),s=!1}else s=fs(),null!==e&&null!==e.memoizedState&&(e.memoizedState.hydrationErrors=s),s=!0;if(!s)return 256&t.flags?(lo(t),t):(lo(t),null)}if(lo(t),0!==(128&t.flags))return t.lanes=n,t;if(n=null!==r,e=null!==e&&null!==e.memoizedState,n){s=null,null!==(r=t.child).alternate&&null!==r.alternate.memoizedState&&null!==r.alternate.memoizedState.cachePool&&(s=r.alternate.memoizedState.cachePool.pool);var a=null;null!==r.memoizedState&&null!==r.memoizedState.cachePool&&(a=r.memoizedState.cachePool.pool),a!==s&&(r.flags|=2048)}return n!==e&&n&&(t.child.flags|=8192),el(t,t.updateQueue),nl(t),null;case 4:return q(),null===e&&Bc(t.stateNode.containerInfo),nl(t),null;case 10:return xs(t.type),nl(t),null;case 19:if(B(uo),null===(s=t.memoizedState))return nl(t),null;if(r=0!==(128&t.flags),null===(a=s.rendering))if(r)tl(s,!1);else{if(0!==du||null!==e&&0!==(128&e.flags))for(e=t.child;null!==e;){if(null!==(a=co(e))){for(t.flags|=128,tl(s,!1),e=a.updateQueue,t.updateQueue=e,el(t,e),t.subtreeFlags=0,e=n,n=t.child;null!==n;)zr(n,e),n=n.sibling;return V(uo,1&uo.current|2),t.child}e=e.sibling}null!==s.tail&&te()>ku&&(t.flags|=128,r=!0,tl(s,!1),t.lanes=4194304)}else{if(!r)if(null!==(e=co(a))){if(t.flags|=128,r=!0,e=e.updateQueue,t.updateQueue=e,el(t,e),tl(s,!0),null===s.tail&&"hidden"===s.tailMode&&!a.alternate&&!as)return nl(t),null}else 2*te()-s.renderingStartTime>ku&&536870912!==n&&(t.flags|=128,r=!0,tl(s,!1),t.lanes=4194304);s.isBackwards?(a.sibling=t.child,t.child=a):(null!==(e=s.last)?e.sibling=a:t.child=a,s.last=a)}return null!==s.tail?(t=s.tail,s.rendering=t,s.tail=t.sibling,s.renderingStartTime=te(),t.sibling=null,e=uo.current,V(uo,r?1&e|2:1&e),t):(nl(t),null);case 22:case 23:return lo(t),ya(),r=null!==t.memoizedState,null!==e?null!==e.memoizedState!==r&&(t.flags|=8192):r&&(t.flags|=8192),r?0!==(536870912&n)&&0===(128&t.flags)&&(nl(t),6&t.subtreeFlags&&(t.flags|=8192)):nl(t),null!==(n=t.updateQueue)&&el(t,n.retryQueue),n=null,null!==e&&null!==e.memoizedState&&null!==e.memoizedState.cachePool&&(n=e.memoizedState.cachePool.pool),r=null,null!==t.memoizedState&&null!==t.memoizedState.cachePool&&(r=t.memoizedState.cachePool.pool),r!==n&&(t.flags|=2048),null!==e&&B(Vs),null;case 24:return n=null,null!==e&&(n=e.memoizedState.cache),t.memoizedState.cache!==n&&(t.flags|=2048),xs(Ds),nl(t),null;case 25:case 30:return null}throw Error(i(156,t.tag))}function sl(e,t){switch(ns(t),t.tag){case 1:return 65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 3:return xs(Ds),q(),0!==(65536&(e=t.flags))&&0===(128&e)?(t.flags=-65537&e|128,t):null;case 26:case 27:case 5:return X(t),null;case 13:if(lo(t),null!==(e=t.memoizedState)&&null!==e.dehydrated){if(null===t.alternate)throw Error(i(340));ps()}return 65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 19:return B(uo),null;case 4:return q(),null;case 10:return xs(t.type),null;case 22:case 23:return lo(t),ya(),null!==e&&B(Vs),65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 24:return xs(Ds),null;default:return null}}function al(e,t){switch(ns(t),t.tag){case 3:xs(Ds),q();break;case 26:case 27:case 5:X(t);break;case 4:q();break;case 13:lo(t);break;case 19:B(uo);break;case 10:xs(t.type);break;case 22:case 23:lo(t),ya(),null!==e&&B(Vs);break;case 24:xs(Ds)}}function il(e,t){try{var n=t.updateQueue,r=null!==n?n.lastEffect:null;if(null!==r){var s=r.next;n=s;do{if((n.tag&e)===e){r=void 0;var a=n.create,i=n.inst;r=a(),i.destroy=r}n=n.next}while(n!==s)}}catch(o){cc(t,t.return,o)}}function ol(e,t,n){try{var r=t.updateQueue,s=null!==r?r.lastEffect:null;if(null!==s){var a=s.next;r=a;do{if((r.tag&e)===e){var i=r.inst,o=i.destroy;if(void 0!==o){i.destroy=void 0,s=t;var l=n,u=o;try{u()}catch(c){cc(s,l,c)}}}r=r.next}while(r!==a)}}catch(c){cc(t,t.return,c)}}function ll(e){var t=e.updateQueue;if(null!==t){var n=e.stateNode;try{da(t,n)}catch(r){cc(e,e.return,r)}}}function ul(e,t,n){n.props=go(e.type,e.memoizedProps),n.state=e.memoizedState;try{n.componentWillUnmount()}catch(r){cc(e,t,r)}}function cl(e,t){try{var n=e.ref;if(null!==n){switch(e.tag){case 26:case 27:case 5:var r=e.stateNode;break;default:r=e.stateNode}"function"===typeof n?e.refCleanup=n(r):n.current=r}}catch(s){cc(e,t,s)}}function hl(e,t){var n=e.ref,r=e.refCleanup;if(null!==n)if("function"===typeof r)try{r()}catch(s){cc(e,t,s)}finally{e.refCleanup=null,null!=(e=e.alternate)&&(e.refCleanup=null)}else if("function"===typeof n)try{n(null)}catch(a){cc(e,t,a)}else n.current=null}function dl(e){var t=e.type,n=e.memoizedProps,r=e.stateNode;try{e:switch(t){case"button":case"input":case"select":case"textarea":n.autoFocus&&r.focus();break e;case"img":n.src?r.src=n.src:n.srcSet&&(r.srcset=n.srcSet)}}catch(s){cc(e,e.return,s)}}function pl(e,t,n){try{var r=e.stateNode;!function(e,t,n,r){switch(t){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"input":var s=null,a=null,o=null,l=null,u=null,c=null,h=null;for(f in n){var d=n[f];if(n.hasOwnProperty(f)&&null!=d)switch(f){case"checked":case"value":break;case"defaultValue":u=d;default:r.hasOwnProperty(f)||Zc(e,t,f,null,r,d)}}for(var p in r){var f=r[p];if(d=n[p],r.hasOwnProperty(p)&&(null!=f||null!=d))switch(p){case"type":a=f;break;case"name":s=f;break;case"checked":c=f;break;case"defaultChecked":h=f;break;case"value":o=f;break;case"defaultValue":l=f;break;case"children":case"dangerouslySetInnerHTML":if(null!=f)throw Error(i(137,t));break;default:f!==d&&Zc(e,t,p,f,r,d)}}return void gt(e,o,l,u,c,h,a,s);case"select":for(a in f=o=l=p=null,n)if(u=n[a],n.hasOwnProperty(a)&&null!=u)switch(a){case"value":break;case"multiple":f=u;default:r.hasOwnProperty(a)||Zc(e,t,a,null,r,u)}for(s in r)if(a=r[s],u=n[s],r.hasOwnProperty(s)&&(null!=a||null!=u))switch(s){case"value":p=a;break;case"defaultValue":l=a;break;case"multiple":o=a;default:a!==u&&Zc(e,t,s,a,r,u)}return t=l,n=o,r=f,void(null!=p?vt(e,!!n,p,!1):!!r!==!!n&&(null!=t?vt(e,!!n,t,!0):vt(e,!!n,n?[]:"",!1)));case"textarea":for(l in f=p=null,n)if(s=n[l],n.hasOwnProperty(l)&&null!=s&&!r.hasOwnProperty(l))switch(l){case"value":case"children":break;default:Zc(e,t,l,null,r,s)}for(o in r)if(s=r[o],a=n[o],r.hasOwnProperty(o)&&(null!=s||null!=a))switch(o){case"value":p=s;break;case"defaultValue":f=s;break;case"children":break;case"dangerouslySetInnerHTML":if(null!=s)throw Error(i(91));break;default:s!==a&&Zc(e,t,o,s,r,a)}return void xt(e,p,f);case"option":for(var m in n)if(p=n[m],n.hasOwnProperty(m)&&null!=p&&!r.hasOwnProperty(m))if("selected"===m)e.selected=!1;else Zc(e,t,m,null,r,p);for(u in r)if(p=r[u],f=n[u],r.hasOwnProperty(u)&&p!==f&&(null!=p||null!=f))if("selected"===u)e.selected=p&&"function"!==typeof p&&"symbol"!==typeof p;else Zc(e,t,u,p,r,f);return;case"img":case"link":case"area":case"base":case"br":case"col":case"embed":case"hr":case"keygen":case"meta":case"param":case"source":case"track":case"wbr":case"menuitem":for(var g in n)p=n[g],n.hasOwnProperty(g)&&null!=p&&!r.hasOwnProperty(g)&&Zc(e,t,g,null,r,p);for(c in r)if(p=r[c],f=n[c],r.hasOwnProperty(c)&&p!==f&&(null!=p||null!=f))switch(c){case"children":case"dangerouslySetInnerHTML":if(null!=p)throw Error(i(137,t));break;default:Zc(e,t,c,p,r,f)}return;default:if(Ct(t)){for(var y in n)p=n[y],n.hasOwnProperty(y)&&void 0!==p&&!r.hasOwnProperty(y)&&Jc(e,t,y,void 0,r,p);for(h in r)p=r[h],f=n[h],!r.hasOwnProperty(h)||p===f||void 0===p&&void 0===f||Jc(e,t,h,p,r,f);return}}for(var b in n)p=n[b],n.hasOwnProperty(b)&&null!=p&&!r.hasOwnProperty(b)&&Zc(e,t,b,null,r,p);for(d in r)p=r[d],f=n[d],!r.hasOwnProperty(d)||p===f||null==p&&null==f||Zc(e,t,d,p,r,f)}(r,e.type,n,t),r[Oe]=t}catch(s){cc(e,e.return,s)}}function fl(e){return 5===e.tag||3===e.tag||26===e.tag||27===e.tag&&ph(e.type)||4===e.tag}function ml(e){e:for(;;){for(;null===e.sibling;){if(null===e.return||fl(e.return))return null;e=e.return}for(e.sibling.return=e.return,e=e.sibling;5!==e.tag&&6!==e.tag&&18!==e.tag;){if(27===e.tag&&ph(e.type))continue e;if(2&e.flags)continue e;if(null===e.child||4===e.tag)continue e;e.child.return=e,e=e.child}if(!(2&e.flags))return e.stateNode}}function gl(e,t,n){var r=e.tag;if(5===r||6===r)e=e.stateNode,t?(9===n.nodeType?n.body:"HTML"===n.nodeName?n.ownerDocument.body:n).insertBefore(e,t):((t=9===n.nodeType?n.body:"HTML"===n.nodeName?n.ownerDocument.body:n).appendChild(e),null!==(n=n._reactRootContainer)&&void 0!==n||null!==t.onclick||(t.onclick=Yc));else if(4!==r&&(27===r&&ph(e.type)&&(n=e.stateNode,t=null),null!==(e=e.child)))for(gl(e,t,n),e=e.sibling;null!==e;)gl(e,t,n),e=e.sibling}function yl(e,t,n){var r=e.tag;if(5===r||6===r)e=e.stateNode,t?n.insertBefore(e,t):n.appendChild(e);else if(4!==r&&(27===r&&ph(e.type)&&(n=e.stateNode),null!==(e=e.child)))for(yl(e,t,n),e=e.sibling;null!==e;)yl(e,t,n),e=e.sibling}function bl(e){var t=e.stateNode,n=e.memoizedProps;try{for(var r=e.type,s=t.attributes;s.length;)t.removeAttributeNode(s[0]);eh(t,r,n),t[De]=e,t[Oe]=n}catch(a){cc(e,e.return,a)}}var vl=!1,xl=!1,wl=!1,kl="function"===typeof WeakSet?WeakSet:Set,Sl=null;function Nl(e,t,n){var r=n.flags;switch(n.tag){case 0:case 11:case 15:Ll(e,n),4&r&&il(5,n);break;case 1:if(Ll(e,n),4&r)if(e=n.stateNode,null===t)try{e.componentDidMount()}catch(i){cc(n,n.return,i)}else{var s=go(n.type,t.memoizedProps);t=t.memoizedState;try{e.componentDidUpdate(s,t,e.__reactInternalSnapshotBeforeUpdate)}catch(o){cc(n,n.return,o)}}64&r&&ll(n),512&r&&cl(n,n.return);break;case 3:if(Ll(e,n),64&r&&null!==(e=n.updateQueue)){if(t=null,null!==n.child)switch(n.child.tag){case 27:case 5:case 1:t=n.child.stateNode}try{da(e,t)}catch(i){cc(n,n.return,i)}}break;case 27:null===t&&4&r&&bl(n);case 26:case 5:Ll(e,n),null===t&&4&r&&dl(n),512&r&&cl(n,n.return);break;case 12:Ll(e,n);break;case 13:Ll(e,n),4&r&&$l(e,n),64&r&&(null!==(e=n.memoizedState)&&(null!==(e=e.dehydrated)&&function(e,t){var n=e.ownerDocument;if("$?"!==e.data||"complete"===n.readyState)t();else{var r=function(){t(),n.removeEventListener("DOMContentLoaded",r)};n.addEventListener("DOMContentLoaded",r),e._reactRetry=r}}(e,n=fc.bind(null,n))));break;case 22:if(!(r=null!==n.memoizedState||vl)){t=null!==t&&null!==t.memoizedState||xl,s=vl;var a=xl;vl=r,(xl=t)&&!a?zl(e,n,0!==(8772&n.subtreeFlags)):Ll(e,n),vl=s,xl=a}break;case 30:break;default:Ll(e,n)}}function Il(e){var t=e.alternate;null!==t&&(e.alternate=null,Il(t)),e.child=null,e.deletions=null,e.sibling=null,5===e.tag&&(null!==(t=e.stateNode)&&Be(t)),e.stateNode=null,e.return=null,e.dependencies=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.stateNode=null,e.updateQueue=null}var Cl=null,Tl=!1;function Al(e,t,n){for(n=n.child;null!==n;)El(e,t,n),n=n.sibling}function El(e,t,n){if(he&&"function"===typeof he.onCommitFiberUnmount)try{he.onCommitFiberUnmount(ce,n)}catch(a){}switch(n.tag){case 26:xl||hl(n,t),Al(e,t,n),n.memoizedState?n.memoizedState.count--:n.stateNode&&(n=n.stateNode).parentNode.removeChild(n);break;case 27:xl||hl(n,t);var r=Cl,s=Tl;ph(n.type)&&(Cl=n.stateNode,Tl=!1),Al(e,t,n),wh(n.stateNode),Cl=r,Tl=s;break;case 5:xl||hl(n,t);case 6:if(r=Cl,s=Tl,Cl=null,Al(e,t,n),Tl=s,null!==(Cl=r))if(Tl)try{(9===Cl.nodeType?Cl.body:"HTML"===Cl.nodeName?Cl.ownerDocument.body:Cl).removeChild(n.stateNode)}catch(i){cc(n,t,i)}else try{Cl.removeChild(n.stateNode)}catch(i){cc(n,t,i)}break;case 18:null!==Cl&&(Tl?(fh(9===(e=Cl).nodeType?e.body:"HTML"===e.nodeName?e.ownerDocument.body:e,n.stateNode),Td(e)):fh(Cl,n.stateNode));break;case 4:r=Cl,s=Tl,Cl=n.stateNode.containerInfo,Tl=!0,Al(e,t,n),Cl=r,Tl=s;break;case 0:case 11:case 14:case 15:xl||ol(2,n,t),xl||ol(4,n,t),Al(e,t,n);break;case 1:xl||(hl(n,t),"function"===typeof(r=n.stateNode).componentWillUnmount&&ul(n,t,r)),Al(e,t,n);break;case 21:Al(e,t,n);break;case 22:xl=(r=xl)||null!==n.memoizedState,Al(e,t,n),xl=r;break;default:Al(e,t,n)}}function $l(e,t){if(null===t.memoizedState&&(null!==(e=t.alternate)&&(null!==(e=e.memoizedState)&&null!==(e=e.dehydrated))))try{Td(e)}catch(n){cc(t,t.return,n)}}function Rl(e,t){var n=function(e){switch(e.tag){case 13:case 19:var t=e.stateNode;return null===t&&(t=e.stateNode=new kl),t;case 22:return null===(t=(e=e.stateNode)._retryCache)&&(t=e._retryCache=new kl),t;default:throw Error(i(435,e.tag))}}(e);t.forEach((function(t){var r=mc.bind(null,e,t);n.has(t)||(n.add(t),t.then(r,r))}))}function Dl(e,t){var n=t.deletions;if(null!==n)for(var r=0;r<n.length;r++){var s=n[r],a=e,o=t,l=o;e:for(;null!==l;){switch(l.tag){case 27:if(ph(l.type)){Cl=l.stateNode,Tl=!1;break e}break;case 5:Cl=l.stateNode,Tl=!1;break e;case 3:case 4:Cl=l.stateNode.containerInfo,Tl=!0;break e}l=l.return}if(null===Cl)throw Error(i(160));El(a,o,s),Cl=null,Tl=!1,null!==(a=s.alternate)&&(a.return=null),s.return=null}if(13878&t.subtreeFlags)for(t=t.child;null!==t;)_l(t,e),t=t.sibling}var Ol=null;function _l(e,t){var n=e.alternate,r=e.flags;switch(e.tag){case 0:case 11:case 14:case 15:Dl(t,e),Fl(e),4&r&&(ol(3,e,e.return),il(3,e),ol(5,e,e.return));break;case 1:Dl(t,e),Fl(e),512&r&&(xl||null===n||hl(n,n.return)),64&r&&vl&&(null!==(e=e.updateQueue)&&(null!==(r=e.callbacks)&&(n=e.shared.hiddenCallbacks,e.shared.hiddenCallbacks=null===n?r:n.concat(r))));break;case 26:var s=Ol;if(Dl(t,e),Fl(e),512&r&&(xl||null===n||hl(n,n.return)),4&r){var a=null!==n?n.memoizedState:null;if(r=e.memoizedState,null===n)if(null===r)if(null===e.stateNode){e:{r=e.type,n=e.memoizedProps,s=s.ownerDocument||s;t:switch(r){case"title":(!(a=s.getElementsByTagName("title")[0])||a[ze]||a[De]||"http://www.w3.org/2000/svg"===a.namespaceURI||a.hasAttribute("itemprop"))&&(a=s.createElement(r),s.head.insertBefore(a,s.querySelector("head > title"))),eh(a,r,n),a[De]=e,Ge(a),r=a;break e;case"link":var o=zh("link","href",s).get(r+(n.href||""));if(o)for(var l=0;l<o.length;l++)if((a=o[l]).getAttribute("href")===(null==n.href||""===n.href?null:n.href)&&a.getAttribute("rel")===(null==n.rel?null:n.rel)&&a.getAttribute("title")===(null==n.title?null:n.title)&&a.getAttribute("crossorigin")===(null==n.crossOrigin?null:n.crossOrigin)){o.splice(l,1);break t}eh(a=s.createElement(r),r,n),s.head.appendChild(a);break;case"meta":if(o=zh("meta","content",s).get(r+(n.content||"")))for(l=0;l<o.length;l++)if((a=o[l]).getAttribute("content")===(null==n.content?null:""+n.content)&&a.getAttribute("name")===(null==n.name?null:n.name)&&a.getAttribute("property")===(null==n.property?null:n.property)&&a.getAttribute("http-equiv")===(null==n.httpEquiv?null:n.httpEquiv)&&a.getAttribute("charset")===(null==n.charSet?null:n.charSet)){o.splice(l,1);break t}eh(a=s.createElement(r),r,n),s.head.appendChild(a);break;default:throw Error(i(468,r))}a[De]=e,Ge(a),r=a}e.stateNode=r}else Bh(s,e.type,e.stateNode);else e.stateNode=_h(s,r,e.memoizedProps);else a!==r?(null===a?null!==n.stateNode&&(n=n.stateNode).parentNode.removeChild(n):a.count--,null===r?Bh(s,e.type,e.stateNode):_h(s,r,e.memoizedProps)):null===r&&null!==e.stateNode&&pl(e,e.memoizedProps,n.memoizedProps)}break;case 27:Dl(t,e),Fl(e),512&r&&(xl||null===n||hl(n,n.return)),null!==n&&4&r&&pl(e,e.memoizedProps,n.memoizedProps);break;case 5:if(Dl(t,e),Fl(e),512&r&&(xl||null===n||hl(n,n.return)),32&e.flags){s=e.stateNode;try{kt(s,"")}catch(f){cc(e,e.return,f)}}4&r&&null!=e.stateNode&&pl(e,s=e.memoizedProps,null!==n?n.memoizedProps:s),1024&r&&(wl=!0);break;case 6:if(Dl(t,e),Fl(e),4&r){if(null===e.stateNode)throw Error(i(162));r=e.memoizedProps,n=e.stateNode;try{n.nodeValue=r}catch(f){cc(e,e.return,f)}}break;case 3:if(Ph=null,s=Ol,Ol=Nh(t.containerInfo),Dl(t,e),Ol=s,Fl(e),4&r&&null!==n&&n.memoizedState.isDehydrated)try{Td(t.containerInfo)}catch(f){cc(e,e.return,f)}wl&&(wl=!1,Ml(e));break;case 4:r=Ol,Ol=Nh(e.stateNode.containerInfo),Dl(t,e),Fl(e),Ol=r;break;case 12:default:Dl(t,e),Fl(e);break;case 13:Dl(t,e),Fl(e),8192&e.child.flags&&null!==e.memoizedState!==(null!==n&&null!==n.memoizedState)&&(wu=te()),4&r&&(null!==(r=e.updateQueue)&&(e.updateQueue=null,Rl(e,r)));break;case 22:s=null!==e.memoizedState;var u=null!==n&&null!==n.memoizedState,c=vl,h=xl;if(vl=c||s,xl=h||u,Dl(t,e),xl=h,vl=c,Fl(e),8192&r)e:for(t=e.stateNode,t._visibility=s?-2&t._visibility:1|t._visibility,s&&(null===n||u||vl||xl||Pl(e)),n=null,t=e;;){if(5===t.tag||26===t.tag){if(null===n){u=n=t;try{if(a=u.stateNode,s)"function"===typeof(o=a.style).setProperty?o.setProperty("display","none","important"):o.display="none";else{l=u.stateNode;var d=u.memoizedProps.style,p=void 0!==d&&null!==d&&d.hasOwnProperty("display")?d.display:null;l.style.display=null==p||"boolean"===typeof p?"":(""+p).trim()}}catch(f){cc(u,u.return,f)}}}else if(6===t.tag){if(null===n){u=t;try{u.stateNode.nodeValue=s?"":u.memoizedProps}catch(f){cc(u,u.return,f)}}}else if((22!==t.tag&&23!==t.tag||null===t.memoizedState||t===e)&&null!==t.child){t.child.return=t,t=t.child;continue}if(t===e)break e;for(;null===t.sibling;){if(null===t.return||t.return===e)break e;n===t&&(n=null),t=t.return}n===t&&(n=null),t.sibling.return=t.return,t=t.sibling}4&r&&(null!==(r=e.updateQueue)&&(null!==(n=r.retryQueue)&&(r.retryQueue=null,Rl(e,n))));break;case 19:Dl(t,e),Fl(e),4&r&&(null!==(r=e.updateQueue)&&(e.updateQueue=null,Rl(e,r)));case 30:case 21:}}function Fl(e){var t=e.flags;if(2&t){try{for(var n,r=e.return;null!==r;){if(fl(r)){n=r;break}r=r.return}if(null==n)throw Error(i(160));switch(n.tag){case 27:var s=n.stateNode;yl(e,ml(e),s);break;case 5:var a=n.stateNode;32&n.flags&&(kt(a,""),n.flags&=-33),yl(e,ml(e),a);break;case 3:case 4:var o=n.stateNode.containerInfo;gl(e,ml(e),o);break;default:throw Error(i(161))}}catch(l){cc(e,e.return,l)}e.flags&=-3}4096&t&&(e.flags&=-4097)}function Ml(e){if(1024&e.subtreeFlags)for(e=e.child;null!==e;){var t=e;Ml(t),5===t.tag&&1024&t.flags&&t.stateNode.reset(),e=e.sibling}}function Ll(e,t){if(8772&t.subtreeFlags)for(t=t.child;null!==t;)Nl(e,t.alternate,t),t=t.sibling}function Pl(e){for(e=e.child;null!==e;){var t=e;switch(t.tag){case 0:case 11:case 14:case 15:ol(4,t,t.return),Pl(t);break;case 1:hl(t,t.return);var n=t.stateNode;"function"===typeof n.componentWillUnmount&&ul(t,t.return,n),Pl(t);break;case 27:wh(t.stateNode);case 26:case 5:hl(t,t.return),Pl(t);break;case 22:null===t.memoizedState&&Pl(t);break;default:Pl(t)}e=e.sibling}}function zl(e,t,n){for(n=n&&0!==(8772&t.subtreeFlags),t=t.child;null!==t;){var r=t.alternate,s=e,a=t,i=a.flags;switch(a.tag){case 0:case 11:case 15:zl(s,a,n),il(4,a);break;case 1:if(zl(s,a,n),"function"===typeof(s=(r=a).stateNode).componentDidMount)try{s.componentDidMount()}catch(u){cc(r,r.return,u)}if(null!==(s=(r=a).updateQueue)){var o=r.stateNode;try{var l=s.shared.hiddenCallbacks;if(null!==l)for(s.shared.hiddenCallbacks=null,s=0;s<l.length;s++)ha(l[s],o)}catch(u){cc(r,r.return,u)}}n&&64&i&&ll(a),cl(a,a.return);break;case 27:bl(a);case 26:case 5:zl(s,a,n),n&&null===r&&4&i&&dl(a),cl(a,a.return);break;case 12:zl(s,a,n);break;case 13:zl(s,a,n),n&&4&i&&$l(s,a);break;case 22:null===a.memoizedState&&zl(s,a,n),cl(a,a.return);break;case 30:break;default:zl(s,a,n)}t=t.sibling}}function Bl(e,t){var n=null;null!==e&&null!==e.memoizedState&&null!==e.memoizedState.cachePool&&(n=e.memoizedState.cachePool.pool),e=null,null!==t.memoizedState&&null!==t.memoizedState.cachePool&&(e=t.memoizedState.cachePool.pool),e!==n&&(null!=e&&e.refCount++,null!=n&&_s(n))}function Vl(e,t){e=null,null!==t.alternate&&(e=t.alternate.memoizedState.cache),(t=t.memoizedState.cache)!==e&&(t.refCount++,null!=e&&_s(e))}function Wl(e,t,n,r){if(10256&t.subtreeFlags)for(t=t.child;null!==t;)Ul(e,t,n,r),t=t.sibling}function Ul(e,t,n,r){var s=t.flags;switch(t.tag){case 0:case 11:case 15:Wl(e,t,n,r),2048&s&&il(9,t);break;case 1:case 13:default:Wl(e,t,n,r);break;case 3:Wl(e,t,n,r),2048&s&&(e=null,null!==t.alternate&&(e=t.alternate.memoizedState.cache),(t=t.memoizedState.cache)!==e&&(t.refCount++,null!=e&&_s(e)));break;case 12:if(2048&s){Wl(e,t,n,r),e=t.stateNode;try{var a=t.memoizedProps,i=a.id,o=a.onPostCommit;"function"===typeof o&&o(i,null===t.alternate?"mount":"update",e.passiveEffectDuration,-0)}catch(l){cc(t,t.return,l)}}else Wl(e,t,n,r);break;case 23:break;case 22:a=t.stateNode,i=t.alternate,null!==t.memoizedState?2&a._visibility?Wl(e,t,n,r):Gl(e,t):2&a._visibility?Wl(e,t,n,r):(a._visibility|=2,jl(e,t,n,r,0!==(10256&t.subtreeFlags))),2048&s&&Bl(i,t);break;case 24:Wl(e,t,n,r),2048&s&&Vl(t.alternate,t)}}function jl(e,t,n,r,s){for(s=s&&0!==(10256&t.subtreeFlags),t=t.child;null!==t;){var a=e,i=t,o=n,l=r,u=i.flags;switch(i.tag){case 0:case 11:case 15:jl(a,i,o,l,s),il(8,i);break;case 23:break;case 22:var c=i.stateNode;null!==i.memoizedState?2&c._visibility?jl(a,i,o,l,s):Gl(a,i):(c._visibility|=2,jl(a,i,o,l,s)),s&&2048&u&&Bl(i.alternate,i);break;case 24:jl(a,i,o,l,s),s&&2048&u&&Vl(i.alternate,i);break;default:jl(a,i,o,l,s)}t=t.sibling}}function Gl(e,t){if(10256&t.subtreeFlags)for(t=t.child;null!==t;){var n=e,r=t,s=r.flags;switch(r.tag){case 22:Gl(n,r),2048&s&&Bl(r.alternate,r);break;case 24:Gl(n,r),2048&s&&Vl(r.alternate,r);break;default:Gl(n,r)}t=t.sibling}}var Hl=8192;function ql(e){if(e.subtreeFlags&Hl)for(e=e.child;null!==e;)Kl(e),e=e.sibling}function Kl(e){switch(e.tag){case 26:ql(e),e.flags&Hl&&null!==e.memoizedState&&function(e,t,n){if(null===Wh)throw Error(i(475));var r=Wh;if("stylesheet"===t.type&&("string"!==typeof n.media||!1!==matchMedia(n.media).matches)&&0===(4&t.state.loading)){if(null===t.instance){var s=Eh(n.href),a=e.querySelector($h(s));if(a)return null!==(e=a._p)&&"object"===typeof e&&"function"===typeof e.then&&(r.count++,r=jh.bind(r),e.then(r,r)),t.state.loading|=4,t.instance=a,void Ge(a);a=e.ownerDocument||e,n=Rh(n),(s=kh.get(s))&&Mh(n,s),Ge(a=a.createElement("link"));var o=a;o._p=new Promise((function(e,t){o.onload=e,o.onerror=t})),eh(a,"link",n),t.instance=a}null===r.stylesheets&&(r.stylesheets=new Map),r.stylesheets.set(t,e),(e=t.state.preload)&&0===(3&t.state.loading)&&(r.count++,t=jh.bind(r),e.addEventListener("load",t),e.addEventListener("error",t))}}(Ol,e.memoizedState,e.memoizedProps);break;case 5:default:ql(e);break;case 3:case 4:var t=Ol;Ol=Nh(e.stateNode.containerInfo),ql(e),Ol=t;break;case 22:null===e.memoizedState&&(null!==(t=e.alternate)&&null!==t.memoizedState?(t=Hl,Hl=16777216,ql(e),Hl=t):ql(e))}}function Xl(e){var t=e.alternate;if(null!==t&&null!==(e=t.child)){t.child=null;do{t=e.sibling,e.sibling=null,e=t}while(null!==e)}}function Ql(e){var t=e.deletions;if(0!==(16&e.flags)){if(null!==t)for(var n=0;n<t.length;n++){var r=t[n];Sl=r,Jl(r,e)}Xl(e)}if(10256&e.subtreeFlags)for(e=e.child;null!==e;)Yl(e),e=e.sibling}function Yl(e){switch(e.tag){case 0:case 11:case 15:Ql(e),2048&e.flags&&ol(9,e,e.return);break;case 3:case 12:default:Ql(e);break;case 22:var t=e.stateNode;null!==e.memoizedState&&2&t._visibility&&(null===e.return||13!==e.return.tag)?(t._visibility&=-3,Zl(e)):Ql(e)}}function Zl(e){var t=e.deletions;if(0!==(16&e.flags)){if(null!==t)for(var n=0;n<t.length;n++){var r=t[n];Sl=r,Jl(r,e)}Xl(e)}for(e=e.child;null!==e;){switch((t=e).tag){case 0:case 11:case 15:ol(8,t,t.return),Zl(t);break;case 22:2&(n=t.stateNode)._visibility&&(n._visibility&=-3,Zl(t));break;default:Zl(t)}e=e.sibling}}function Jl(e,t){for(;null!==Sl;){var n=Sl;switch(n.tag){case 0:case 11:case 15:ol(8,n,t);break;case 23:case 22:if(null!==n.memoizedState&&null!==n.memoizedState.cachePool){var r=n.memoizedState.cachePool.pool;null!=r&&r.refCount++}break;case 24:_s(n.memoizedState.cache)}if(null!==(r=n.child))r.return=n,Sl=r;else e:for(n=e;null!==Sl;){var s=(r=Sl).sibling,a=r.return;if(Il(r),r===n){Sl=null;break e}if(null!==s){s.return=a,Sl=s;break e}Sl=a}}}var eu={getCacheForType:function(e){var t=Cs(Ds),n=t.data.get(e);return void 0===n&&(n=e(),t.data.set(e,n)),n}},tu="function"===typeof WeakMap?WeakMap:Map,nu=0,ru=null,su=null,au=0,iu=0,ou=null,lu=!1,uu=!1,cu=!1,hu=0,du=0,pu=0,fu=0,mu=0,gu=0,yu=0,bu=null,vu=null,xu=!1,wu=0,ku=1/0,Su=null,Nu=null,Iu=0,Cu=null,Tu=null,Au=0,Eu=0,$u=null,Ru=null,Du=0,Ou=null;function _u(){if(0!==(2&nu)&&0!==au)return au&-au;if(null!==_.T){return 0!==Ls?Ls:Ec()}return $e()}function Fu(){0===gu&&(gu=0===(536870912&au)||as?ke():536870912);var e=ro.current;return null!==e&&(e.flags|=32),gu}function Mu(e,t,n){(e!==ru||2!==iu&&9!==iu)&&null===e.cancelPendingCommit||(Uu(e,0),Bu(e,au,gu,!1)),Ie(e,n),0!==(2&nu)&&e===ru||(e===ru&&(0===(2&nu)&&(fu|=n),4===du&&Bu(e,au,gu,!1)),kc(e))}function Lu(e,t,n){if(0!==(6&nu))throw Error(i(327));for(var r=!n&&0===(124&t)&&0===(t&e.expiredLanes)||xe(e,t),s=r?function(e,t){var n=nu;nu|=2;var r=Gu(),s=Hu();ru!==e||au!==t?(Su=null,ku=te()+500,Uu(e,t)):uu=xe(e,t);e:for(;;)try{if(0!==iu&&null!==su){t=su;var a=ou;t:switch(iu){case 1:iu=0,ou=null,Ju(e,t,a,1);break;case 2:case 9:if(Xs(a)){iu=0,ou=null,Zu(t);break}t=function(){2!==iu&&9!==iu||ru!==e||(iu=7),kc(e)},a.then(t,t);break e;case 3:iu=7;break e;case 4:iu=5;break e;case 7:Xs(a)?(iu=0,ou=null,Zu(t)):(iu=0,ou=null,Ju(e,t,a,7));break;case 5:var o=null;switch(su.tag){case 26:o=su.memoizedState;case 5:case 27:var l=su;if(!o||Vh(o)){iu=0,ou=null;var u=l.sibling;if(null!==u)su=u;else{var c=l.return;null!==c?(su=c,ec(c)):su=null}break t}}iu=0,ou=null,Ju(e,t,a,5);break;case 6:iu=0,ou=null,Ju(e,t,a,6);break;case 8:Wu(),du=6;break e;default:throw Error(i(462))}}Qu();break}catch(h){ju(e,h)}return bs=ys=null,_.H=r,_.A=s,nu=n,null!==su?0:(ru=null,au=0,Ar(),du)}(e,t):Ku(e,t,!0),a=r;;){if(0===s){uu&&!r&&Bu(e,t,0,!1);break}if(n=e.current.alternate,!a||zu(n)){if(2===s){if(a=t,e.errorRecoveryDisabledLanes&a)var o=0;else o=0!==(o=-536870913&e.pendingLanes)?o:536870912&o?536870912:0;if(0!==o){t=o;e:{var l=e;s=bu;var u=l.current.memoizedState.isDehydrated;if(u&&(Uu(l,o).flags|=256),2!==(o=Ku(l,o,!1))){if(cu&&!u){l.errorRecoveryDisabledLanes|=a,fu|=a,s=4;break e}a=vu,vu=s,null!==a&&(null===vu?vu=a:vu.push.apply(vu,a))}s=o}if(a=!1,2!==s)continue}}if(1===s){Uu(e,0),Bu(e,t,0,!0);break}e:{switch(r=e,a=s){case 0:case 1:throw Error(i(345));case 4:if((4194048&t)!==t)break;case 6:Bu(r,t,gu,!lu);break e;case 2:vu=null;break;case 3:case 5:break;default:throw Error(i(329))}if((62914560&t)===t&&10<(s=wu+300-te())){if(Bu(r,t,gu,!lu),0!==ve(r,0,!0))break e;r.timeoutHandle=lh(Pu.bind(null,r,n,vu,Su,xu,t,gu,fu,yu,lu,a,2,-0,0),s)}else Pu(r,n,vu,Su,xu,t,gu,fu,yu,lu,a,0,-0,0)}break}s=Ku(e,t,!1),a=!1}kc(e)}function Pu(e,t,n,r,s,a,o,l,u,c,h,d,p,f){if(e.timeoutHandle=-1,(8192&(d=t.subtreeFlags)||16785408===(16785408&d))&&(Wh={stylesheets:null,count:0,unsuspend:Uh},Kl(t),null!==(d=function(){if(null===Wh)throw Error(i(475));var e=Wh;return e.stylesheets&&0===e.count&&Hh(e,e.stylesheets),0<e.count?function(t){var n=setTimeout((function(){if(e.stylesheets&&Hh(e,e.stylesheets),e.unsuspend){var t=e.unsuspend;e.unsuspend=null,t()}}),6e4);return e.unsuspend=t,function(){e.unsuspend=null,clearTimeout(n)}}:null}())))return e.cancelPendingCommit=d(nc.bind(null,e,t,a,n,r,s,o,l,u,h,1,p,f)),void Bu(e,a,o,!c);nc(e,t,a,n,r,s,o,l,u)}function zu(e){for(var t=e;;){var n=t.tag;if((0===n||11===n||15===n)&&16384&t.flags&&(null!==(n=t.updateQueue)&&null!==(n=n.stores)))for(var r=0;r<n.length;r++){var s=n[r],a=s.getSnapshot;s=s.value;try{if(!Xn(a(),s))return!1}catch(i){return!1}}if(n=t.child,16384&t.subtreeFlags&&null!==n)n.return=t,t=n;else{if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return!0;t=t.return}t.sibling.return=t.return,t=t.sibling}}return!0}function Bu(e,t,n,r){t&=~mu,t&=~fu,e.suspendedLanes|=t,e.pingedLanes&=~t,r&&(e.warmLanes|=t),r=e.expirationTimes;for(var s=t;0<s;){var a=31-pe(s),i=1<<a;r[a]=-1,s&=~i}0!==n&&Ce(e,n,t)}function Vu(){return 0!==(6&nu)||(Sc(0,!1),!1)}function Wu(){if(null!==su){if(0===iu)var e=su.return;else bs=ys=null,La(e=su),Ki=null,Xi=0,e=su;for(;null!==e;)al(e.alternate,e),e=e.return;su=null}}function Uu(e,t){var n=e.timeoutHandle;-1!==n&&(e.timeoutHandle=-1,uh(n)),null!==(n=e.cancelPendingCommit)&&(e.cancelPendingCommit=null,n()),Wu(),ru=e,su=n=Pr(e.current,null),au=t,iu=0,ou=null,lu=!1,uu=xe(e,t),cu=!1,yu=gu=mu=fu=pu=du=0,vu=bu=null,xu=!1,0!==(8&t)&&(t|=32&t);var r=e.entangledLanes;if(0!==r)for(e=e.entanglements,r&=t;0<r;){var s=31-pe(r),a=1<<s;t|=e[s],r&=~a}return hu=t,Ar(),n}function ju(e,t){va=null,_.H=ji,t===Gs||t===qs?(t=Js(),iu=3):t===Hs?(t=Js(),iu=4):iu=t===Co?8:null!==t&&"object"===typeof t&&"function"===typeof t.then?6:1,ou=t,null===su&&(du=1,wo(e,Nr(t,e.current)))}function Gu(){var e=_.H;return _.H=ji,null===e?ji:e}function Hu(){var e=_.A;return _.A=eu,e}function qu(){du=4,lu||(4194048&au)!==au&&null!==ro.current||(uu=!0),0===(134217727&pu)&&0===(134217727&fu)||null===ru||Bu(ru,au,gu,!1)}function Ku(e,t,n){var r=nu;nu|=2;var s=Gu(),a=Hu();ru===e&&au===t||(Su=null,Uu(e,t)),t=!1;var i=du;e:for(;;)try{if(0!==iu&&null!==su){var o=su,l=ou;switch(iu){case 8:Wu(),i=6;break e;case 3:case 2:case 9:case 6:null===ro.current&&(t=!0);var u=iu;if(iu=0,ou=null,Ju(e,o,l,u),n&&uu){i=0;break e}break;default:u=iu,iu=0,ou=null,Ju(e,o,l,u)}}Xu(),i=du;break}catch(c){ju(e,c)}return t&&e.shellSuspendCounter++,bs=ys=null,nu=r,_.H=s,_.A=a,null===su&&(ru=null,au=0,Ar()),i}function Xu(){for(;null!==su;)Yu(su)}function Qu(){for(;null!==su&&!J();)Yu(su)}function Yu(e){var t=Yo(e.alternate,e,hu);e.memoizedProps=e.pendingProps,null===t?ec(e):su=t}function Zu(e){var t=e,n=t.alternate;switch(t.tag){case 15:case 0:t=Mo(n,t,t.pendingProps,t.type,void 0,au);break;case 11:t=Mo(n,t,t.pendingProps,t.type.render,t.ref,au);break;case 5:La(t);default:al(n,t),t=Yo(n,t=su=zr(t,hu),hu)}e.memoizedProps=e.pendingProps,null===t?ec(e):su=t}function Ju(e,t,n,r){bs=ys=null,La(t),Ki=null,Xi=0;var s=t.return;try{if(function(e,t,n,r,s){if(n.flags|=32768,null!==r&&"object"===typeof r&&"function"===typeof r.then){if(null!==(t=n.alternate)&&Ss(t,n,s,!0),null!==(n=ro.current)){switch(n.tag){case 13:return null===so?qu():null===n.alternate&&0===du&&(du=3),n.flags&=-257,n.flags|=65536,n.lanes=s,r===Ks?n.flags|=16384:(null===(t=n.updateQueue)?n.updateQueue=new Set([r]):t.add(r),hc(e,r,s)),!1;case 22:return n.flags|=65536,r===Ks?n.flags|=16384:(null===(t=n.updateQueue)?(t={transitions:null,markerInstances:null,retryQueue:new Set([r])},n.updateQueue=t):null===(n=t.retryQueue)?t.retryQueue=new Set([r]):n.add(r),hc(e,r,s)),!1}throw Error(i(435,n.tag))}return hc(e,r,s),qu(),!1}if(as)return null!==(t=ro.current)?(0===(65536&t.flags)&&(t.flags|=256),t.flags|=65536,t.lanes=s,r!==ls&&ms(Nr(e=Error(i(422),{cause:r}),n))):(r!==ls&&ms(Nr(t=Error(i(423),{cause:r}),n)),(e=e.current.alternate).flags|=65536,s&=-s,e.lanes|=s,r=Nr(r,n),oa(e,s=So(e.stateNode,r,s)),4!==du&&(du=2)),!1;var a=Error(i(520),{cause:r});if(a=Nr(a,n),null===bu?bu=[a]:bu.push(a),4!==du&&(du=2),null===t)return!0;r=Nr(r,n),n=t;do{switch(n.tag){case 3:return n.flags|=65536,e=s&-s,n.lanes|=e,oa(n,e=So(n.stateNode,r,e)),!1;case 1:if(t=n.type,a=n.stateNode,0===(128&n.flags)&&("function"===typeof t.getDerivedStateFromError||null!==a&&"function"===typeof a.componentDidCatch&&(null===Nu||!Nu.has(a))))return n.flags|=65536,s&=-s,n.lanes|=s,Io(s=No(s),e,n,r),oa(n,s),!1}n=n.return}while(null!==n);return!1}(e,s,t,n,au))return du=1,wo(e,Nr(n,e.current)),void(su=null)}catch(a){if(null!==s)throw su=s,a;return du=1,wo(e,Nr(n,e.current)),void(su=null)}32768&t.flags?(as||1===r?e=!0:uu||0!==(536870912&au)?e=!1:(lu=e=!0,(2===r||9===r||3===r||6===r)&&(null!==(r=ro.current)&&13===r.tag&&(r.flags|=16384))),tc(t,e)):ec(t)}function ec(e){var t=e;do{if(0!==(32768&t.flags))return void tc(t,lu);e=t.return;var n=rl(t.alternate,t,hu);if(null!==n)return void(su=n);if(null!==(t=t.sibling))return void(su=t);su=t=e}while(null!==t);0===du&&(du=5)}function tc(e,t){do{var n=sl(e.alternate,e);if(null!==n)return n.flags&=32767,void(su=n);if(null!==(n=e.return)&&(n.flags|=32768,n.subtreeFlags=0,n.deletions=null),!t&&null!==(e=e.sibling))return void(su=e);su=e=n}while(null!==e);du=6,su=null}function nc(e,t,n,r,s,a,o,l,u){e.cancelPendingCommit=null;do{oc()}while(0!==Iu);if(0!==(6&nu))throw Error(i(327));if(null!==t){if(t===e.current)throw Error(i(177));if(a=t.lanes|t.childLanes,function(e,t,n,r,s,a){var i=e.pendingLanes;e.pendingLanes=n,e.suspendedLanes=0,e.pingedLanes=0,e.warmLanes=0,e.expiredLanes&=n,e.entangledLanes&=n,e.errorRecoveryDisabledLanes&=n,e.shellSuspendCounter=0;var o=e.entanglements,l=e.expirationTimes,u=e.hiddenUpdates;for(n=i&~n;0<n;){var c=31-pe(n),h=1<<c;o[c]=0,l[c]=-1;var d=u[c];if(null!==d)for(u[c]=null,c=0;c<d.length;c++){var p=d[c];null!==p&&(p.lane&=-536870913)}n&=~h}0!==r&&Ce(e,r,0),0!==a&&0===s&&0!==e.tag&&(e.suspendedLanes|=a&~(i&~t))}(e,n,a|=Tr,o,l,u),e===ru&&(su=ru=null,au=0),Tu=t,Cu=e,Au=n,Eu=a,$u=s,Ru=r,0!==(10256&t.subtreeFlags)||0!==(10256&t.flags)?(e.callbackNode=null,e.callbackPriority=0,Y(ae,(function(){return lc(),null}))):(e.callbackNode=null,e.callbackPriority=0),r=0!==(13878&t.flags),0!==(13878&t.subtreeFlags)||r){r=_.T,_.T=null,s=F.p,F.p=2,o=nu,nu|=4;try{!function(e,t){if(e=e.containerInfo,th=nd,tr(e=er(e))){if("selectionStart"in e)var n={start:e.selectionStart,end:e.selectionEnd};else e:{var r=(n=(n=e.ownerDocument)&&n.defaultView||window).getSelection&&n.getSelection();if(r&&0!==r.rangeCount){n=r.anchorNode;var s=r.anchorOffset,a=r.focusNode;r=r.focusOffset;try{n.nodeType,a.nodeType}catch(g){n=null;break e}var o=0,l=-1,u=-1,c=0,h=0,d=e,p=null;t:for(;;){for(var f;d!==n||0!==s&&3!==d.nodeType||(l=o+s),d!==a||0!==r&&3!==d.nodeType||(u=o+r),3===d.nodeType&&(o+=d.nodeValue.length),null!==(f=d.firstChild);)p=d,d=f;for(;;){if(d===e)break t;if(p===n&&++c===s&&(l=o),p===a&&++h===r&&(u=o),null!==(f=d.nextSibling))break;p=(d=p).parentNode}d=f}n=-1===l||-1===u?null:{start:l,end:u}}else n=null}n=n||{start:0,end:0}}else n=null;for(nh={focusedElem:e,selectionRange:n},nd=!1,Sl=t;null!==Sl;)if(e=(t=Sl).child,0!==(1024&t.subtreeFlags)&&null!==e)e.return=t,Sl=e;else for(;null!==Sl;){switch(a=(t=Sl).alternate,e=t.flags,t.tag){case 0:case 11:case 15:case 5:case 26:case 27:case 6:case 4:case 17:break;case 1:if(0!==(1024&e)&&null!==a){e=void 0,n=t,s=a.memoizedProps,a=a.memoizedState,r=n.stateNode;try{var m=go(n.type,s,(n.elementType,n.type));e=r.getSnapshotBeforeUpdate(m,a),r.__reactInternalSnapshotBeforeUpdate=e}catch(y){cc(n,n.return,y)}}break;case 3:if(0!==(1024&e))if(9===(n=(e=t.stateNode.containerInfo).nodeType))mh(e);else if(1===n)switch(e.nodeName){case"HEAD":case"HTML":case"BODY":mh(e);break;default:e.textContent=""}break;default:if(0!==(1024&e))throw Error(i(163))}if(null!==(e=t.sibling)){e.return=t.return,Sl=e;break}Sl=t.return}}(e,t)}finally{nu=o,F.p=s,_.T=r}}Iu=1,rc(),sc(),ac()}}function rc(){if(1===Iu){Iu=0;var e=Cu,t=Tu,n=0!==(13878&t.flags);if(0!==(13878&t.subtreeFlags)||n){n=_.T,_.T=null;var r=F.p;F.p=2;var s=nu;nu|=4;try{_l(t,e);var a=nh,i=er(e.containerInfo),o=a.focusedElem,l=a.selectionRange;if(i!==o&&o&&o.ownerDocument&&Jn(o.ownerDocument.documentElement,o)){if(null!==l&&tr(o)){var u=l.start,c=l.end;if(void 0===c&&(c=u),"selectionStart"in o)o.selectionStart=u,o.selectionEnd=Math.min(c,o.value.length);else{var h=o.ownerDocument||document,d=h&&h.defaultView||window;if(d.getSelection){var p=d.getSelection(),f=o.textContent.length,m=Math.min(l.start,f),g=void 0===l.end?m:Math.min(l.end,f);!p.extend&&m>g&&(i=g,g=m,m=i);var y=Zn(o,m),b=Zn(o,g);if(y&&b&&(1!==p.rangeCount||p.anchorNode!==y.node||p.anchorOffset!==y.offset||p.focusNode!==b.node||p.focusOffset!==b.offset)){var v=h.createRange();v.setStart(y.node,y.offset),p.removeAllRanges(),m>g?(p.addRange(v),p.extend(b.node,b.offset)):(v.setEnd(b.node,b.offset),p.addRange(v))}}}}for(h=[],p=o;p=p.parentNode;)1===p.nodeType&&h.push({element:p,left:p.scrollLeft,top:p.scrollTop});for("function"===typeof o.focus&&o.focus(),o=0;o<h.length;o++){var x=h[o];x.element.scrollLeft=x.left,x.element.scrollTop=x.top}}nd=!!th,nh=th=null}finally{nu=s,F.p=r,_.T=n}}e.current=t,Iu=2}}function sc(){if(2===Iu){Iu=0;var e=Cu,t=Tu,n=0!==(8772&t.flags);if(0!==(8772&t.subtreeFlags)||n){n=_.T,_.T=null;var r=F.p;F.p=2;var s=nu;nu|=4;try{Nl(e,t.alternate,t)}finally{nu=s,F.p=r,_.T=n}}Iu=3}}function ac(){if(4===Iu||3===Iu){Iu=0,ee();var e=Cu,t=Tu,n=Au,r=Ru;0!==(10256&t.subtreeFlags)||0!==(10256&t.flags)?Iu=5:(Iu=0,Tu=Cu=null,ic(e,e.pendingLanes));var s=e.pendingLanes;if(0===s&&(Nu=null),Ee(n),t=t.stateNode,he&&"function"===typeof he.onCommitFiberRoot)try{he.onCommitFiberRoot(ce,t,void 0,128===(128&t.current.flags))}catch(l){}if(null!==r){t=_.T,s=F.p,F.p=2,_.T=null;try{for(var a=e.onRecoverableError,i=0;i<r.length;i++){var o=r[i];a(o.value,{componentStack:o.stack})}}finally{_.T=t,F.p=s}}0!==(3&Au)&&oc(),kc(e),s=e.pendingLanes,0!==(4194090&n)&&0!==(42&s)?e===Ou?Du++:(Du=0,Ou=e):Du=0,Sc(0,!1)}}function ic(e,t){0===(e.pooledCacheLanes&=t)&&(null!=(t=e.pooledCache)&&(e.pooledCache=null,_s(t)))}function oc(e){return rc(),sc(),ac(),lc()}function lc(){if(5!==Iu)return!1;var e=Cu,t=Eu;Eu=0;var n=Ee(Au),r=_.T,s=F.p;try{F.p=32>n?32:n,_.T=null,n=$u,$u=null;var a=Cu,o=Au;if(Iu=0,Tu=Cu=null,Au=0,0!==(6&nu))throw Error(i(331));var l=nu;if(nu|=4,Yl(a.current),Ul(a,a.current,o,n),nu=l,Sc(0,!1),he&&"function"===typeof he.onPostCommitFiberRoot)try{he.onPostCommitFiberRoot(ce,a)}catch(u){}return!0}finally{F.p=s,_.T=r,ic(e,t)}}function uc(e,t,n){t=Nr(n,t),null!==(e=aa(e,t=So(e.stateNode,t,2),2))&&(Ie(e,2),kc(e))}function cc(e,t,n){if(3===e.tag)uc(e,e,n);else for(;null!==t;){if(3===t.tag){uc(t,e,n);break}if(1===t.tag){var r=t.stateNode;if("function"===typeof t.type.getDerivedStateFromError||"function"===typeof r.componentDidCatch&&(null===Nu||!Nu.has(r))){e=Nr(n,e),null!==(r=aa(t,n=No(2),2))&&(Io(n,r,t,e),Ie(r,2),kc(r));break}}t=t.return}}function hc(e,t,n){var r=e.pingCache;if(null===r){r=e.pingCache=new tu;var s=new Set;r.set(t,s)}else void 0===(s=r.get(t))&&(s=new Set,r.set(t,s));s.has(n)||(cu=!0,s.add(n),e=dc.bind(null,e,t,n),t.then(e,e))}function dc(e,t,n){var r=e.pingCache;null!==r&&r.delete(t),e.pingedLanes|=e.suspendedLanes&n,e.warmLanes&=~n,ru===e&&(au&n)===n&&(4===du||3===du&&(62914560&au)===au&&300>te()-wu?0===(2&nu)&&Uu(e,0):mu|=n,yu===au&&(yu=0)),kc(e)}function pc(e,t){0===t&&(t=Se()),null!==(e=Rr(e,t))&&(Ie(e,t),kc(e))}function fc(e){var t=e.memoizedState,n=0;null!==t&&(n=t.retryLane),pc(e,n)}function mc(e,t){var n=0;switch(e.tag){case 13:var r=e.stateNode,s=e.memoizedState;null!==s&&(n=s.retryLane);break;case 19:r=e.stateNode;break;case 22:r=e.stateNode._retryCache;break;default:throw Error(i(314))}null!==r&&r.delete(t),pc(e,n)}var gc=null,yc=null,bc=!1,vc=!1,xc=!1,wc=0;function kc(e){e!==yc&&null===e.next&&(null===yc?gc=yc=e:yc=yc.next=e),vc=!0,bc||(bc=!0,hh((function(){0!==(6&nu)?Y(re,Nc):Ic()})))}function Sc(e,t){if(!xc&&vc){xc=!0;do{for(var n=!1,r=gc;null!==r;){if(!t)if(0!==e){var s=r.pendingLanes;if(0===s)var a=0;else{var i=r.suspendedLanes,o=r.pingedLanes;a=(1<<31-pe(42|e)+1)-1,a=201326741&(a&=s&~(i&~o))?201326741&a|1:a?2|a:0}0!==a&&(n=!0,Ac(r,a))}else a=au,0===(3&(a=ve(r,r===ru?a:0,null!==r.cancelPendingCommit||-1!==r.timeoutHandle)))||xe(r,a)||(n=!0,Ac(r,a));r=r.next}}while(n);xc=!1}}function Nc(){Ic()}function Ic(){vc=bc=!1;var e=0;0!==wc&&(function(){var e=window.event;if(e&&"popstate"===e.type)return e!==oh&&(oh=e,!0);return oh=null,!1}()&&(e=wc),wc=0);for(var t=te(),n=null,r=gc;null!==r;){var s=r.next,a=Cc(r,t);0===a?(r.next=null,null===n?gc=s:n.next=s,null===s&&(yc=n)):(n=r,(0!==e||0!==(3&a))&&(vc=!0)),r=s}Sc(e,!1)}function Cc(e,t){for(var n=e.suspendedLanes,r=e.pingedLanes,s=e.expirationTimes,a=-62914561&e.pendingLanes;0<a;){var i=31-pe(a),o=1<<i,l=s[i];-1===l?0!==(o&n)&&0===(o&r)||(s[i]=we(o,t)):l<=t&&(e.expiredLanes|=o),a&=~o}if(n=au,n=ve(e,e===(t=ru)?n:0,null!==e.cancelPendingCommit||-1!==e.timeoutHandle),r=e.callbackNode,0===n||e===t&&(2===iu||9===iu)||null!==e.cancelPendingCommit)return null!==r&&null!==r&&Z(r),e.callbackNode=null,e.callbackPriority=0;if(0===(3&n)||xe(e,n)){if((t=n&-n)===e.callbackPriority)return t;switch(null!==r&&Z(r),Ee(n)){case 2:case 8:n=se;break;case 32:default:n=ae;break;case 268435456:n=oe}return r=Tc.bind(null,e),n=Y(n,r),e.callbackPriority=t,e.callbackNode=n,t}return null!==r&&null!==r&&Z(r),e.callbackPriority=2,e.callbackNode=null,2}function Tc(e,t){if(0!==Iu&&5!==Iu)return e.callbackNode=null,e.callbackPriority=0,null;var n=e.callbackNode;if(oc()&&e.callbackNode!==n)return null;var r=au;return 0===(r=ve(e,e===ru?r:0,null!==e.cancelPendingCommit||-1!==e.timeoutHandle))?null:(Lu(e,r,t),Cc(e,te()),null!=e.callbackNode&&e.callbackNode===n?Tc.bind(null,e):null)}function Ac(e,t){if(oc())return null;Lu(e,t,!0)}function Ec(){return 0===wc&&(wc=ke()),wc}function $c(e){return null==e||"symbol"===typeof e||"boolean"===typeof e?null:"function"===typeof e?e:Et(""+e)}function Rc(e,t){var n=t.ownerDocument.createElement("input");return n.name=t.name,n.value=t.value,e.id&&n.setAttribute("form",e.id),t.parentNode.insertBefore(n,t),e=new FormData(e),n.parentNode.removeChild(n),e}for(var Dc=0;Dc<wr.length;Dc++){var Oc=wr[Dc];kr(Oc.toLowerCase(),"on"+(Oc[0].toUpperCase()+Oc.slice(1)))}kr(pr,"onAnimationEnd"),kr(fr,"onAnimationIteration"),kr(mr,"onAnimationStart"),kr("dblclick","onDoubleClick"),kr("focusin","onFocus"),kr("focusout","onBlur"),kr(gr,"onTransitionRun"),kr(yr,"onTransitionStart"),kr(br,"onTransitionCancel"),kr(vr,"onTransitionEnd"),Xe("onMouseEnter",["mouseout","mouseover"]),Xe("onMouseLeave",["mouseout","mouseover"]),Xe("onPointerEnter",["pointerout","pointerover"]),Xe("onPointerLeave",["pointerout","pointerover"]),Ke("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),Ke("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),Ke("onBeforeInput",["compositionend","keypress","textInput","paste"]),Ke("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),Ke("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),Ke("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var _c="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Fc=new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(_c));function Mc(e,t){t=0!==(4&t);for(var n=0;n<e.length;n++){var r=e[n],s=r.event;r=r.listeners;e:{var a=void 0;if(t)for(var i=r.length-1;0<=i;i--){var o=r[i],l=o.instance,u=o.currentTarget;if(o=o.listener,l!==a&&s.isPropagationStopped())break e;a=o,s.currentTarget=u;try{a(s)}catch(c){yo(c)}s.currentTarget=null,a=l}else for(i=0;i<r.length;i++){if(l=(o=r[i]).instance,u=o.currentTarget,o=o.listener,l!==a&&s.isPropagationStopped())break e;a=o,s.currentTarget=u;try{a(s)}catch(c){yo(c)}s.currentTarget=null,a=l}}}}function Lc(e,t){var n=t[Fe];void 0===n&&(n=t[Fe]=new Set);var r=e+"__bubble";n.has(r)||(Vc(t,e,2,!1),n.add(r))}function Pc(e,t,n){var r=0;t&&(r|=4),Vc(n,e,r,t)}var zc="_reactListening"+Math.random().toString(36).slice(2);function Bc(e){if(!e[zc]){e[zc]=!0,He.forEach((function(t){"selectionchange"!==t&&(Fc.has(t)||Pc(t,!1,e),Pc(t,!0,e))}));var t=9===e.nodeType?e:e.ownerDocument;null===t||t[zc]||(t[zc]=!0,Pc("selectionchange",!1,t))}}function Vc(e,t,n,r){switch(ud(t)){case 2:var s=rd;break;case 8:s=sd;break;default:s=ad}n=s.bind(null,t,n,e),s=void 0,!zt||"touchstart"!==t&&"touchmove"!==t&&"wheel"!==t||(s=!0),r?void 0!==s?e.addEventListener(t,n,{capture:!0,passive:s}):e.addEventListener(t,n,!0):void 0!==s?e.addEventListener(t,n,{passive:s}):e.addEventListener(t,n,!1)}function Wc(e,t,n,r,s){var a=r;if(0===(1&t)&&0===(2&t)&&null!==r)e:for(;;){if(null===r)return;var i=r.tag;if(3===i||4===i){var o=r.stateNode.containerInfo;if(o===s)break;if(4===i)for(i=r.return;null!==i;){var u=i.tag;if((3===u||4===u)&&i.stateNode.containerInfo===s)return;i=i.return}for(;null!==o;){if(null===(i=Ve(o)))return;if(5===(u=i.tag)||6===u||26===u||27===u){r=a=i;continue e}o=o.parentNode}}r=r.return}Mt((function(){var r=a,s=Rt(n),i=[];e:{var o=xr.get(e);if(void 0!==o){var u=Jt,c=e;switch(e){case"keypress":if(0===Gt(n))break e;case"keydown":case"keyup":u=mn;break;case"focusin":c="focus",u=an;break;case"focusout":c="blur",u=an;break;case"beforeblur":case"afterblur":u=an;break;case"click":if(2===n.button)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":u=rn;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":u=sn;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":u=yn;break;case pr:case fr:case mr:u=on;break;case vr:u=bn;break;case"scroll":case"scrollend":u=tn;break;case"wheel":u=vn;break;case"copy":case"cut":case"paste":u=ln;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":u=gn;break;case"toggle":case"beforetoggle":u=xn}var h=0!==(4&t),d=!h&&("scroll"===e||"scrollend"===e),p=h?null!==o?o+"Capture":null:o;h=[];for(var f,m=r;null!==m;){var g=m;if(f=g.stateNode,5!==(g=g.tag)&&26!==g&&27!==g||null===f||null===p||null!=(g=Lt(m,p))&&h.push(Uc(m,g,f)),d)break;m=m.return}0<h.length&&(o=new u(o,c,null,n,s),i.push({event:o,listeners:h}))}}if(0===(7&t)){if(u="mouseout"===e||"pointerout"===e,(!(o="mouseover"===e||"pointerover"===e)||n===$t||!(c=n.relatedTarget||n.fromElement)||!Ve(c)&&!c[_e])&&(u||o)&&(o=s.window===s?s:(o=s.ownerDocument)?o.defaultView||o.parentWindow:window,u?(u=r,null!==(c=(c=n.relatedTarget||n.toElement)?Ve(c):null)&&(d=l(c),h=c.tag,c!==d||5!==h&&27!==h&&6!==h)&&(c=null)):(u=null,c=r),u!==c)){if(h=rn,g="onMouseLeave",p="onMouseEnter",m="mouse","pointerout"!==e&&"pointerover"!==e||(h=gn,g="onPointerLeave",p="onPointerEnter",m="pointer"),d=null==u?o:Ue(u),f=null==c?o:Ue(c),(o=new h(g,m+"leave",u,n,s)).target=d,o.relatedTarget=f,g=null,Ve(s)===r&&((h=new h(p,m+"enter",c,n,s)).target=f,h.relatedTarget=d,g=h),d=g,u&&c)e:{for(p=c,m=0,f=h=u;f;f=Gc(f))m++;for(f=0,g=p;g;g=Gc(g))f++;for(;0<m-f;)h=Gc(h),m--;for(;0<f-m;)p=Gc(p),f--;for(;m--;){if(h===p||null!==p&&h===p.alternate)break e;h=Gc(h),p=Gc(p)}h=null}else h=null;null!==u&&Hc(i,o,u,h,!1),null!==c&&null!==d&&Hc(i,d,c,h,!0)}if("select"===(u=(o=r?Ue(r):window).nodeName&&o.nodeName.toLowerCase())||"input"===u&&"file"===o.type)var y=Pn;else if(Dn(o))if(zn)y=Kn;else{y=Hn;var b=Gn}else!(u=o.nodeName)||"input"!==u.toLowerCase()||"checkbox"!==o.type&&"radio"!==o.type?r&&Ct(r.elementType)&&(y=Pn):y=qn;switch(y&&(y=y(e,r))?On(i,y,n,s):(b&&b(e,o,r),"focusout"===e&&r&&"number"===o.type&&null!=r.memoizedProps.value&&bt(o,"number",o.value)),b=r?Ue(r):window,e){case"focusin":(Dn(b)||"true"===b.contentEditable)&&(rr=b,sr=r,ar=null);break;case"focusout":ar=sr=rr=null;break;case"mousedown":ir=!0;break;case"contextmenu":case"mouseup":case"dragend":ir=!1,or(i,n,s);break;case"selectionchange":if(nr)break;case"keydown":case"keyup":or(i,n,s)}var v;if(kn)e:{switch(e){case"compositionstart":var x="onCompositionStart";break e;case"compositionend":x="onCompositionEnd";break e;case"compositionupdate":x="onCompositionUpdate";break e}x=void 0}else $n?An(e,n)&&(x="onCompositionEnd"):"keydown"===e&&229===n.keyCode&&(x="onCompositionStart");x&&(In&&"ko"!==n.locale&&($n||"onCompositionStart"!==x?"onCompositionEnd"===x&&$n&&(v=jt()):(Wt="value"in(Vt=s)?Vt.value:Vt.textContent,$n=!0)),0<(b=jc(r,x)).length&&(x=new un(x,e,null,n,s),i.push({event:x,listeners:b}),v?x.data=v:null!==(v=En(n))&&(x.data=v))),(v=Nn?function(e,t){switch(e){case"compositionend":return En(t);case"keypress":return 32!==t.which?null:(Tn=!0,Cn);case"textInput":return(e=t.data)===Cn&&Tn?null:e;default:return null}}(e,n):function(e,t){if($n)return"compositionend"===e||!kn&&An(e,t)?(e=jt(),Ut=Wt=Vt=null,$n=!1,e):null;switch(e){case"paste":default:return null;case"keypress":if(!(t.ctrlKey||t.altKey||t.metaKey)||t.ctrlKey&&t.altKey){if(t.char&&1<t.char.length)return t.char;if(t.which)return String.fromCharCode(t.which)}return null;case"compositionend":return In&&"ko"!==t.locale?null:t.data}}(e,n))&&(0<(x=jc(r,"onBeforeInput")).length&&(b=new un("onBeforeInput","beforeinput",null,n,s),i.push({event:b,listeners:x}),b.data=v)),function(e,t,n,r,s){if("submit"===t&&n&&n.stateNode===s){var a=$c((s[Oe]||null).action),i=r.submitter;i&&null!==(t=(t=i[Oe]||null)?$c(t.formAction):i.getAttribute("formAction"))&&(a=t,i=null);var o=new Jt("action","action",null,r,s);e.push({event:o,listeners:[{instance:null,listener:function(){if(r.defaultPrevented){if(0!==wc){var e=i?Rc(s,i):new FormData(s);$i(n,{pending:!0,data:e,method:s.method,action:a},null,e)}}else"function"===typeof a&&(o.preventDefault(),e=i?Rc(s,i):new FormData(s),$i(n,{pending:!0,data:e,method:s.method,action:a},a,e))},currentTarget:s}]})}}(i,e,r,n,s)}Mc(i,t)}))}function Uc(e,t,n){return{instance:e,listener:t,currentTarget:n}}function jc(e,t){for(var n=t+"Capture",r=[];null!==e;){var s=e,a=s.stateNode;if(5!==(s=s.tag)&&26!==s&&27!==s||null===a||(null!=(s=Lt(e,n))&&r.unshift(Uc(e,s,a)),null!=(s=Lt(e,t))&&r.push(Uc(e,s,a))),3===e.tag)return r;e=e.return}return[]}function Gc(e){if(null===e)return null;do{e=e.return}while(e&&5!==e.tag&&27!==e.tag);return e||null}function Hc(e,t,n,r,s){for(var a=t._reactName,i=[];null!==n&&n!==r;){var o=n,l=o.alternate,u=o.stateNode;if(o=o.tag,null!==l&&l===r)break;5!==o&&26!==o&&27!==o||null===u||(l=u,s?null!=(u=Lt(n,a))&&i.unshift(Uc(n,u,l)):s||null!=(u=Lt(n,a))&&i.push(Uc(n,u,l))),n=n.return}0!==i.length&&e.push({event:t,listeners:i})}var qc=/\r\n?/g,Kc=/\u0000|\uFFFD/g;function Xc(e){return("string"===typeof e?e:""+e).replace(qc,"\n").replace(Kc,"")}function Qc(e,t){return t=Xc(t),Xc(e)===t}function Yc(){}function Zc(e,t,n,r,s,a){switch(n){case"children":"string"===typeof r?"body"===t||"textarea"===t&&""===r||kt(e,r):("number"===typeof r||"bigint"===typeof r)&&"body"!==t&&kt(e,""+r);break;case"className":nt(e,"class",r);break;case"tabIndex":nt(e,"tabindex",r);break;case"dir":case"role":case"viewBox":case"width":case"height":nt(e,n,r);break;case"style":It(e,r,a);break;case"data":if("object"!==t){nt(e,"data",r);break}case"src":case"href":if(""===r&&("a"!==t||"href"!==n)){e.removeAttribute(n);break}if(null==r||"function"===typeof r||"symbol"===typeof r||"boolean"===typeof r){e.removeAttribute(n);break}r=Et(""+r),e.setAttribute(n,r);break;case"action":case"formAction":if("function"===typeof r){e.setAttribute(n,"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");break}if("function"===typeof a&&("formAction"===n?("input"!==t&&Zc(e,t,"name",s.name,s,null),Zc(e,t,"formEncType",s.formEncType,s,null),Zc(e,t,"formMethod",s.formMethod,s,null),Zc(e,t,"formTarget",s.formTarget,s,null)):(Zc(e,t,"encType",s.encType,s,null),Zc(e,t,"method",s.method,s,null),Zc(e,t,"target",s.target,s,null))),null==r||"symbol"===typeof r||"boolean"===typeof r){e.removeAttribute(n);break}r=Et(""+r),e.setAttribute(n,r);break;case"onClick":null!=r&&(e.onclick=Yc);break;case"onScroll":null!=r&&Lc("scroll",e);break;case"onScrollEnd":null!=r&&Lc("scrollend",e);break;case"dangerouslySetInnerHTML":if(null!=r){if("object"!==typeof r||!("__html"in r))throw Error(i(61));if(null!=(n=r.__html)){if(null!=s.children)throw Error(i(60));e.innerHTML=n}}break;case"multiple":e.multiple=r&&"function"!==typeof r&&"symbol"!==typeof r;break;case"muted":e.muted=r&&"function"!==typeof r&&"symbol"!==typeof r;break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":case"autoFocus":break;case"xlinkHref":if(null==r||"function"===typeof r||"boolean"===typeof r||"symbol"===typeof r){e.removeAttribute("xlink:href");break}n=Et(""+r),e.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",n);break;case"contentEditable":case"spellCheck":case"draggable":case"value":case"autoReverse":case"externalResourcesRequired":case"focusable":case"preserveAlpha":null!=r&&"function"!==typeof r&&"symbol"!==typeof r?e.setAttribute(n,""+r):e.removeAttribute(n);break;case"inert":case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":r&&"function"!==typeof r&&"symbol"!==typeof r?e.setAttribute(n,""):e.removeAttribute(n);break;case"capture":case"download":!0===r?e.setAttribute(n,""):!1!==r&&null!=r&&"function"!==typeof r&&"symbol"!==typeof r?e.setAttribute(n,r):e.removeAttribute(n);break;case"cols":case"rows":case"size":case"span":null!=r&&"function"!==typeof r&&"symbol"!==typeof r&&!isNaN(r)&&1<=r?e.setAttribute(n,r):e.removeAttribute(n);break;case"rowSpan":case"start":null==r||"function"===typeof r||"symbol"===typeof r||isNaN(r)?e.removeAttribute(n):e.setAttribute(n,r);break;case"popover":Lc("beforetoggle",e),Lc("toggle",e),tt(e,"popover",r);break;case"xlinkActuate":rt(e,"http://www.w3.org/1999/xlink","xlink:actuate",r);break;case"xlinkArcrole":rt(e,"http://www.w3.org/1999/xlink","xlink:arcrole",r);break;case"xlinkRole":rt(e,"http://www.w3.org/1999/xlink","xlink:role",r);break;case"xlinkShow":rt(e,"http://www.w3.org/1999/xlink","xlink:show",r);break;case"xlinkTitle":rt(e,"http://www.w3.org/1999/xlink","xlink:title",r);break;case"xlinkType":rt(e,"http://www.w3.org/1999/xlink","xlink:type",r);break;case"xmlBase":rt(e,"http://www.w3.org/XML/1998/namespace","xml:base",r);break;case"xmlLang":rt(e,"http://www.w3.org/XML/1998/namespace","xml:lang",r);break;case"xmlSpace":rt(e,"http://www.w3.org/XML/1998/namespace","xml:space",r);break;case"is":tt(e,"is",r);break;case"innerText":case"textContent":break;default:(!(2<n.length)||"o"!==n[0]&&"O"!==n[0]||"n"!==n[1]&&"N"!==n[1])&&tt(e,n=Tt.get(n)||n,r)}}function Jc(e,t,n,r,s,a){switch(n){case"style":It(e,r,a);break;case"dangerouslySetInnerHTML":if(null!=r){if("object"!==typeof r||!("__html"in r))throw Error(i(61));if(null!=(n=r.__html)){if(null!=s.children)throw Error(i(60));e.innerHTML=n}}break;case"children":"string"===typeof r?kt(e,r):("number"===typeof r||"bigint"===typeof r)&&kt(e,""+r);break;case"onScroll":null!=r&&Lc("scroll",e);break;case"onScrollEnd":null!=r&&Lc("scrollend",e);break;case"onClick":null!=r&&(e.onclick=Yc);break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"innerHTML":case"ref":case"innerText":case"textContent":break;default:qe.hasOwnProperty(n)||("o"!==n[0]||"n"!==n[1]||(s=n.endsWith("Capture"),t=n.slice(2,s?n.length-7:void 0),"function"===typeof(a=null!=(a=e[Oe]||null)?a[n]:null)&&e.removeEventListener(t,a,s),"function"!==typeof r)?n in e?e[n]=r:!0===r?e.setAttribute(n,""):tt(e,n,r):("function"!==typeof a&&null!==a&&(n in e?e[n]=null:e.hasAttribute(n)&&e.removeAttribute(n)),e.addEventListener(t,r,s)))}}function eh(e,t,n){switch(t){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"img":Lc("error",e),Lc("load",e);var r,s=!1,a=!1;for(r in n)if(n.hasOwnProperty(r)){var o=n[r];if(null!=o)switch(r){case"src":s=!0;break;case"srcSet":a=!0;break;case"children":case"dangerouslySetInnerHTML":throw Error(i(137,t));default:Zc(e,t,r,o,n,null)}}return a&&Zc(e,t,"srcSet",n.srcSet,n,null),void(s&&Zc(e,t,"src",n.src,n,null));case"input":Lc("invalid",e);var l=r=o=a=null,u=null,c=null;for(s in n)if(n.hasOwnProperty(s)){var h=n[s];if(null!=h)switch(s){case"name":a=h;break;case"type":o=h;break;case"checked":u=h;break;case"defaultChecked":c=h;break;case"value":r=h;break;case"defaultValue":l=h;break;case"children":case"dangerouslySetInnerHTML":if(null!=h)throw Error(i(137,t));break;default:Zc(e,t,s,h,n,null)}}return yt(e,r,l,u,c,o,a,!1),void ht(e);case"select":for(a in Lc("invalid",e),s=o=r=null,n)if(n.hasOwnProperty(a)&&null!=(l=n[a]))switch(a){case"value":r=l;break;case"defaultValue":o=l;break;case"multiple":s=l;default:Zc(e,t,a,l,n,null)}return t=r,n=o,e.multiple=!!s,void(null!=t?vt(e,!!s,t,!1):null!=n&&vt(e,!!s,n,!0));case"textarea":for(o in Lc("invalid",e),r=a=s=null,n)if(n.hasOwnProperty(o)&&null!=(l=n[o]))switch(o){case"value":s=l;break;case"defaultValue":a=l;break;case"children":r=l;break;case"dangerouslySetInnerHTML":if(null!=l)throw Error(i(91));break;default:Zc(e,t,o,l,n,null)}return wt(e,s,a,r),void ht(e);case"option":for(u in n)if(n.hasOwnProperty(u)&&null!=(s=n[u]))if("selected"===u)e.selected=s&&"function"!==typeof s&&"symbol"!==typeof s;else Zc(e,t,u,s,n,null);return;case"dialog":Lc("beforetoggle",e),Lc("toggle",e),Lc("cancel",e),Lc("close",e);break;case"iframe":case"object":Lc("load",e);break;case"video":case"audio":for(s=0;s<_c.length;s++)Lc(_c[s],e);break;case"image":Lc("error",e),Lc("load",e);break;case"details":Lc("toggle",e);break;case"embed":case"source":case"link":Lc("error",e),Lc("load",e);case"area":case"base":case"br":case"col":case"hr":case"keygen":case"meta":case"param":case"track":case"wbr":case"menuitem":for(c in n)if(n.hasOwnProperty(c)&&null!=(s=n[c]))switch(c){case"children":case"dangerouslySetInnerHTML":throw Error(i(137,t));default:Zc(e,t,c,s,n,null)}return;default:if(Ct(t)){for(h in n)n.hasOwnProperty(h)&&(void 0!==(s=n[h])&&Jc(e,t,h,s,n,void 0));return}}for(l in n)n.hasOwnProperty(l)&&(null!=(s=n[l])&&Zc(e,t,l,s,n,null))}var th=null,nh=null;function rh(e){return 9===e.nodeType?e:e.ownerDocument}function sh(e){switch(e){case"http://www.w3.org/2000/svg":return 1;case"http://www.w3.org/1998/Math/MathML":return 2;default:return 0}}function ah(e,t){if(0===e)switch(t){case"svg":return 1;case"math":return 2;default:return 0}return 1===e&&"foreignObject"===t?0:e}function ih(e,t){return"textarea"===e||"noscript"===e||"string"===typeof t.children||"number"===typeof t.children||"bigint"===typeof t.children||"object"===typeof t.dangerouslySetInnerHTML&&null!==t.dangerouslySetInnerHTML&&null!=t.dangerouslySetInnerHTML.__html}var oh=null;var lh="function"===typeof setTimeout?setTimeout:void 0,uh="function"===typeof clearTimeout?clearTimeout:void 0,ch="function"===typeof Promise?Promise:void 0,hh="function"===typeof queueMicrotask?queueMicrotask:"undefined"!==typeof ch?function(e){return ch.resolve(null).then(e).catch(dh)}:lh;function dh(e){setTimeout((function(){throw e}))}function ph(e){return"head"===e}function fh(e,t){var n=t,r=0,s=0;do{var a=n.nextSibling;if(e.removeChild(n),a&&8===a.nodeType)if("/$"===(n=a.data)){if(0<r&&8>r){n=r;var i=e.ownerDocument;if(1&n&&wh(i.documentElement),2&n&&wh(i.body),4&n)for(wh(n=i.head),i=n.firstChild;i;){var o=i.nextSibling,l=i.nodeName;i[ze]||"SCRIPT"===l||"STYLE"===l||"LINK"===l&&"stylesheet"===i.rel.toLowerCase()||n.removeChild(i),i=o}}if(0===s)return e.removeChild(a),void Td(t);s--}else"$"===n||"$?"===n||"$!"===n?s++:r=n.charCodeAt(0)-48;else r=0;n=a}while(n);Td(t)}function mh(e){var t=e.firstChild;for(t&&10===t.nodeType&&(t=t.nextSibling);t;){var n=t;switch(t=t.nextSibling,n.nodeName){case"HTML":case"HEAD":case"BODY":mh(n),Be(n);continue;case"SCRIPT":case"STYLE":continue;case"LINK":if("stylesheet"===n.rel.toLowerCase())continue}e.removeChild(n)}}function gh(e){return"$!"===e.data||"$?"===e.data&&"complete"===e.ownerDocument.readyState}function yh(e){for(;null!=e;e=e.nextSibling){var t=e.nodeType;if(1===t||3===t)break;if(8===t){if("$"===(t=e.data)||"$!"===t||"$?"===t||"F!"===t||"F"===t)break;if("/$"===t)return null}}return e}var bh=null;function vh(e){e=e.previousSibling;for(var t=0;e;){if(8===e.nodeType){var n=e.data;if("$"===n||"$!"===n||"$?"===n){if(0===t)return e;t--}else"/$"===n&&t++}e=e.previousSibling}return null}function xh(e,t,n){switch(t=rh(n),e){case"html":if(!(e=t.documentElement))throw Error(i(452));return e;case"head":if(!(e=t.head))throw Error(i(453));return e;case"body":if(!(e=t.body))throw Error(i(454));return e;default:throw Error(i(451))}}function wh(e){for(var t=e.attributes;t.length;)e.removeAttributeNode(t[0]);Be(e)}var kh=new Map,Sh=new Set;function Nh(e){return"function"===typeof e.getRootNode?e.getRootNode():9===e.nodeType?e:e.ownerDocument}var Ih=F.d;F.d={f:function(){var e=Ih.f(),t=Vu();return e||t},r:function(e){var t=We(e);null!==t&&5===t.tag&&"form"===t.type?Di(t):Ih.r(e)},D:function(e){Ih.D(e),Th("dns-prefetch",e,null)},C:function(e,t){Ih.C(e,t),Th("preconnect",e,t)},L:function(e,t,n){Ih.L(e,t,n);var r=Ch;if(r&&e&&t){var s='link[rel="preload"][as="'+mt(t)+'"]';"image"===t&&n&&n.imageSrcSet?(s+='[imagesrcset="'+mt(n.imageSrcSet)+'"]',"string"===typeof n.imageSizes&&(s+='[imagesizes="'+mt(n.imageSizes)+'"]')):s+='[href="'+mt(e)+'"]';var a=s;switch(t){case"style":a=Eh(e);break;case"script":a=Dh(e)}kh.has(a)||(e=d({rel:"preload",href:"image"===t&&n&&n.imageSrcSet?void 0:e,as:t},n),kh.set(a,e),null!==r.querySelector(s)||"style"===t&&r.querySelector($h(a))||"script"===t&&r.querySelector(Oh(a))||(eh(t=r.createElement("link"),"link",e),Ge(t),r.head.appendChild(t)))}},m:function(e,t){Ih.m(e,t);var n=Ch;if(n&&e){var r=t&&"string"===typeof t.as?t.as:"script",s='link[rel="modulepreload"][as="'+mt(r)+'"][href="'+mt(e)+'"]',a=s;switch(r){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":a=Dh(e)}if(!kh.has(a)&&(e=d({rel:"modulepreload",href:e},t),kh.set(a,e),null===n.querySelector(s))){switch(r){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":if(n.querySelector(Oh(a)))return}eh(r=n.createElement("link"),"link",e),Ge(r),n.head.appendChild(r)}}},X:function(e,t){Ih.X(e,t);var n=Ch;if(n&&e){var r=je(n).hoistableScripts,s=Dh(e),a=r.get(s);a||((a=n.querySelector(Oh(s)))||(e=d({src:e,async:!0},t),(t=kh.get(s))&&Lh(e,t),Ge(a=n.createElement("script")),eh(a,"link",e),n.head.appendChild(a)),a={type:"script",instance:a,count:1,state:null},r.set(s,a))}},S:function(e,t,n){Ih.S(e,t,n);var r=Ch;if(r&&e){var s=je(r).hoistableStyles,a=Eh(e);t=t||"default";var i=s.get(a);if(!i){var o={loading:0,preload:null};if(i=r.querySelector($h(a)))o.loading=5;else{e=d({rel:"stylesheet",href:e,"data-precedence":t},n),(n=kh.get(a))&&Mh(e,n);var l=i=r.createElement("link");Ge(l),eh(l,"link",e),l._p=new Promise((function(e,t){l.onload=e,l.onerror=t})),l.addEventListener("load",(function(){o.loading|=1})),l.addEventListener("error",(function(){o.loading|=2})),o.loading|=4,Fh(i,t,r)}i={type:"stylesheet",instance:i,count:1,state:o},s.set(a,i)}}},M:function(e,t){Ih.M(e,t);var n=Ch;if(n&&e){var r=je(n).hoistableScripts,s=Dh(e),a=r.get(s);a||((a=n.querySelector(Oh(s)))||(e=d({src:e,async:!0,type:"module"},t),(t=kh.get(s))&&Lh(e,t),Ge(a=n.createElement("script")),eh(a,"link",e),n.head.appendChild(a)),a={type:"script",instance:a,count:1,state:null},r.set(s,a))}}};var Ch="undefined"===typeof document?null:document;function Th(e,t,n){var r=Ch;if(r&&"string"===typeof t&&t){var s=mt(t);s='link[rel="'+e+'"][href="'+s+'"]',"string"===typeof n&&(s+='[crossorigin="'+n+'"]'),Sh.has(s)||(Sh.add(s),e={rel:e,crossOrigin:n,href:t},null===r.querySelector(s)&&(eh(t=r.createElement("link"),"link",e),Ge(t),r.head.appendChild(t)))}}function Ah(e,t,n,r){var s,a,o,l,u=(u=j.current)?Nh(u):null;if(!u)throw Error(i(446));switch(e){case"meta":case"title":return null;case"style":return"string"===typeof n.precedence&&"string"===typeof n.href?(t=Eh(n.href),(r=(n=je(u).hoistableStyles).get(t))||(r={type:"style",instance:null,count:0,state:null},n.set(t,r)),r):{type:"void",instance:null,count:0,state:null};case"link":if("stylesheet"===n.rel&&"string"===typeof n.href&&"string"===typeof n.precedence){e=Eh(n.href);var c=je(u).hoistableStyles,h=c.get(e);if(h||(u=u.ownerDocument||u,h={type:"stylesheet",instance:null,count:0,state:{loading:0,preload:null}},c.set(e,h),(c=u.querySelector($h(e)))&&!c._p&&(h.instance=c,h.state.loading=5),kh.has(e)||(n={rel:"preload",as:"style",href:n.href,crossOrigin:n.crossOrigin,integrity:n.integrity,media:n.media,hrefLang:n.hrefLang,referrerPolicy:n.referrerPolicy},kh.set(e,n),c||(s=u,a=e,o=n,l=h.state,s.querySelector('link[rel="preload"][as="style"]['+a+"]")?l.loading=1:(a=s.createElement("link"),l.preload=a,a.addEventListener("load",(function(){return l.loading|=1})),a.addEventListener("error",(function(){return l.loading|=2})),eh(a,"link",o),Ge(a),s.head.appendChild(a))))),t&&null===r)throw Error(i(528,""));return h}if(t&&null!==r)throw Error(i(529,""));return null;case"script":return t=n.async,"string"===typeof(n=n.src)&&t&&"function"!==typeof t&&"symbol"!==typeof t?(t=Dh(n),(r=(n=je(u).hoistableScripts).get(t))||(r={type:"script",instance:null,count:0,state:null},n.set(t,r)),r):{type:"void",instance:null,count:0,state:null};default:throw Error(i(444,e))}}function Eh(e){return'href="'+mt(e)+'"'}function $h(e){return'link[rel="stylesheet"]['+e+"]"}function Rh(e){return d({},e,{"data-precedence":e.precedence,precedence:null})}function Dh(e){return'[src="'+mt(e)+'"]'}function Oh(e){return"script[async]"+e}function _h(e,t,n){if(t.count++,null===t.instance)switch(t.type){case"style":var r=e.querySelector('style[data-href~="'+mt(n.href)+'"]');if(r)return t.instance=r,Ge(r),r;var s=d({},n,{"data-href":n.href,"data-precedence":n.precedence,href:null,precedence:null});return Ge(r=(e.ownerDocument||e).createElement("style")),eh(r,"style",s),Fh(r,n.precedence,e),t.instance=r;case"stylesheet":s=Eh(n.href);var a=e.querySelector($h(s));if(a)return t.state.loading|=4,t.instance=a,Ge(a),a;r=Rh(n),(s=kh.get(s))&&Mh(r,s),Ge(a=(e.ownerDocument||e).createElement("link"));var o=a;return o._p=new Promise((function(e,t){o.onload=e,o.onerror=t})),eh(a,"link",r),t.state.loading|=4,Fh(a,n.precedence,e),t.instance=a;case"script":return a=Dh(n.src),(s=e.querySelector(Oh(a)))?(t.instance=s,Ge(s),s):(r=n,(s=kh.get(a))&&Lh(r=d({},n),s),Ge(s=(e=e.ownerDocument||e).createElement("script")),eh(s,"link",r),e.head.appendChild(s),t.instance=s);case"void":return null;default:throw Error(i(443,t.type))}else"stylesheet"===t.type&&0===(4&t.state.loading)&&(r=t.instance,t.state.loading|=4,Fh(r,n.precedence,e));return t.instance}function Fh(e,t,n){for(var r=n.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),s=r.length?r[r.length-1]:null,a=s,i=0;i<r.length;i++){var o=r[i];if(o.dataset.precedence===t)a=o;else if(a!==s)break}a?a.parentNode.insertBefore(e,a.nextSibling):(t=9===n.nodeType?n.head:n).insertBefore(e,t.firstChild)}function Mh(e,t){null==e.crossOrigin&&(e.crossOrigin=t.crossOrigin),null==e.referrerPolicy&&(e.referrerPolicy=t.referrerPolicy),null==e.title&&(e.title=t.title)}function Lh(e,t){null==e.crossOrigin&&(e.crossOrigin=t.crossOrigin),null==e.referrerPolicy&&(e.referrerPolicy=t.referrerPolicy),null==e.integrity&&(e.integrity=t.integrity)}var Ph=null;function zh(e,t,n){if(null===Ph){var r=new Map,s=Ph=new Map;s.set(n,r)}else(r=(s=Ph).get(n))||(r=new Map,s.set(n,r));if(r.has(e))return r;for(r.set(e,null),n=n.getElementsByTagName(e),s=0;s<n.length;s++){var a=n[s];if(!(a[ze]||a[De]||"link"===e&&"stylesheet"===a.getAttribute("rel"))&&"http://www.w3.org/2000/svg"!==a.namespaceURI){var i=a.getAttribute(t)||"";i=e+i;var o=r.get(i);o?o.push(a):r.set(i,[a])}}return r}function Bh(e,t,n){(e=e.ownerDocument||e).head.insertBefore(n,"title"===t?e.querySelector("head > title"):null)}function Vh(e){return"stylesheet"!==e.type||0!==(3&e.state.loading)}var Wh=null;function Uh(){}function jh(){if(this.count--,0===this.count)if(this.stylesheets)Hh(this,this.stylesheets);else if(this.unsuspend){var e=this.unsuspend;this.unsuspend=null,e()}}var Gh=null;function Hh(e,t){e.stylesheets=null,null!==e.unsuspend&&(e.count++,Gh=new Map,t.forEach(qh,e),Gh=null,jh.call(e))}function qh(e,t){if(!(4&t.state.loading)){var n=Gh.get(e);if(n)var r=n.get(null);else{n=new Map,Gh.set(e,n);for(var s=e.querySelectorAll("link[data-precedence],style[data-precedence]"),a=0;a<s.length;a++){var i=s[a];"LINK"!==i.nodeName&&"not all"===i.getAttribute("media")||(n.set(i.dataset.precedence,i),r=i)}r&&n.set(null,r)}i=(s=t.instance).getAttribute("data-precedence"),(a=n.get(i)||r)===r&&n.set(null,s),n.set(i,s),this.count++,r=jh.bind(this),s.addEventListener("load",r),s.addEventListener("error",r),a?a.parentNode.insertBefore(s,a.nextSibling):(e=9===e.nodeType?e.head:e).insertBefore(s,e.firstChild),t.state.loading|=4}}var Kh={$$typeof:w,Provider:null,Consumer:null,_currentValue:M,_currentValue2:M,_threadCount:0};function Xh(e,t,n,r,s,a,i,o){this.tag=1,this.containerInfo=e,this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=Ne(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Ne(0),this.hiddenUpdates=Ne(null),this.identifierPrefix=r,this.onUncaughtError=s,this.onCaughtError=a,this.onRecoverableError=i,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=o,this.incompleteTransitions=new Map}function Qh(e,t,n,r,s,a,i,o,l,u,c,h){return e=new Xh(e,t,n,i,o,l,u,h),t=1,!0===a&&(t|=24),a=Mr(3,null,null,t),e.current=a,a.stateNode=e,(t=Os()).refCount++,e.pooledCache=t,t.refCount++,a.memoizedState={element:r,isDehydrated:n,cache:t},na(a),e}function Yh(e){return e?e=_r:_r}function Zh(e,t,n,r,s,a){s=Yh(s),null===r.context?r.context=s:r.pendingContext=s,(r=sa(t)).payload={element:n},null!==(a=void 0===a?null:a)&&(r.callback=a),null!==(n=aa(e,r,t))&&(Mu(n,0,t),ia(n,e,t))}function Jh(e,t){if(null!==(e=e.memoizedState)&&null!==e.dehydrated){var n=e.retryLane;e.retryLane=0!==n&&n<t?n:t}}function ed(e,t){Jh(e,t),(e=e.alternate)&&Jh(e,t)}function td(e){if(13===e.tag){var t=Rr(e,67108864);null!==t&&Mu(t,0,67108864),ed(e,67108864)}}var nd=!0;function rd(e,t,n,r){var s=_.T;_.T=null;var a=F.p;try{F.p=2,ad(e,t,n,r)}finally{F.p=a,_.T=s}}function sd(e,t,n,r){var s=_.T;_.T=null;var a=F.p;try{F.p=8,ad(e,t,n,r)}finally{F.p=a,_.T=s}}function ad(e,t,n,r){if(nd){var s=id(r);if(null===s)Wc(e,t,r,od,n),bd(e,r);else if(function(e,t,n,r,s){switch(t){case"focusin":return hd=vd(hd,e,t,n,r,s),!0;case"dragenter":return dd=vd(dd,e,t,n,r,s),!0;case"mouseover":return pd=vd(pd,e,t,n,r,s),!0;case"pointerover":var a=s.pointerId;return fd.set(a,vd(fd.get(a)||null,e,t,n,r,s)),!0;case"gotpointercapture":return a=s.pointerId,md.set(a,vd(md.get(a)||null,e,t,n,r,s)),!0}return!1}(s,e,t,n,r))r.stopPropagation();else if(bd(e,r),4&t&&-1<yd.indexOf(e)){for(;null!==s;){var a=We(s);if(null!==a)switch(a.tag){case 3:if((a=a.stateNode).current.memoizedState.isDehydrated){var i=be(a.pendingLanes);if(0!==i){var o=a;for(o.pendingLanes|=2,o.entangledLanes|=2;i;){var l=1<<31-pe(i);o.entanglements[1]|=l,i&=~l}kc(a),0===(6&nu)&&(ku=te()+500,Sc(0,!1))}}break;case 13:null!==(o=Rr(a,2))&&Mu(o,0,2),Vu(),ed(a,2)}if(null===(a=id(r))&&Wc(e,t,r,od,n),a===s)break;s=a}null!==s&&r.stopPropagation()}else Wc(e,t,r,null,n)}}function id(e){return ld(e=Rt(e))}var od=null;function ld(e){if(od=null,null!==(e=Ve(e))){var t=l(e);if(null===t)e=null;else{var n=t.tag;if(13===n){if(null!==(e=u(t)))return e;e=null}else if(3===n){if(t.stateNode.current.memoizedState.isDehydrated)return 3===t.tag?t.stateNode.containerInfo:null;e=null}else t!==e&&(e=null)}}return od=e,null}function ud(e){switch(e){case"beforetoggle":case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"toggle":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 2;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 8;case"message":switch(ne()){case re:return 2;case se:return 8;case ae:case ie:return 32;case oe:return 268435456;default:return 32}default:return 32}}var cd=!1,hd=null,dd=null,pd=null,fd=new Map,md=new Map,gd=[],yd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");function bd(e,t){switch(e){case"focusin":case"focusout":hd=null;break;case"dragenter":case"dragleave":dd=null;break;case"mouseover":case"mouseout":pd=null;break;case"pointerover":case"pointerout":fd.delete(t.pointerId);break;case"gotpointercapture":case"lostpointercapture":md.delete(t.pointerId)}}function vd(e,t,n,r,s,a){return null===e||e.nativeEvent!==a?(e={blockedOn:t,domEventName:n,eventSystemFlags:r,nativeEvent:a,targetContainers:[s]},null!==t&&(null!==(t=We(t))&&td(t)),e):(e.eventSystemFlags|=r,t=e.targetContainers,null!==s&&-1===t.indexOf(s)&&t.push(s),e)}function xd(e){var t=Ve(e.target);if(null!==t){var n=l(t);if(null!==n)if(13===(t=n.tag)){if(null!==(t=u(n)))return e.blockedOn=t,void function(e,t){var n=F.p;try{return F.p=e,t()}finally{F.p=n}}(e.priority,(function(){if(13===n.tag){var e=_u();e=Ae(e);var t=Rr(n,e);null!==t&&Mu(t,0,e),ed(n,e)}}))}else if(3===t&&n.stateNode.current.memoizedState.isDehydrated)return void(e.blockedOn=3===n.tag?n.stateNode.containerInfo:null)}e.blockedOn=null}function wd(e){if(null!==e.blockedOn)return!1;for(var t=e.targetContainers;0<t.length;){var n=id(e.nativeEvent);if(null!==n)return null!==(t=We(n))&&td(t),e.blockedOn=n,!1;var r=new(n=e.nativeEvent).constructor(n.type,n);$t=r,n.target.dispatchEvent(r),$t=null,t.shift()}return!0}function kd(e,t,n){wd(e)&&n.delete(t)}function Sd(){cd=!1,null!==hd&&wd(hd)&&(hd=null),null!==dd&&wd(dd)&&(dd=null),null!==pd&&wd(pd)&&(pd=null),fd.forEach(kd),md.forEach(kd)}function Nd(e,t){e.blockedOn===t&&(e.blockedOn=null,cd||(cd=!0,r.unstable_scheduleCallback(r.unstable_NormalPriority,Sd)))}var Id=null;function Cd(e){Id!==e&&(Id=e,r.unstable_scheduleCallback(r.unstable_NormalPriority,(function(){Id===e&&(Id=null);for(var t=0;t<e.length;t+=3){var n=e[t],r=e[t+1],s=e[t+2];if("function"!==typeof r){if(null===ld(r||n))continue;break}var a=We(n);null!==a&&(e.splice(t,3),t-=3,$i(a,{pending:!0,data:s,method:n.method,action:r},r,s))}})))}function Td(e){function t(t){return Nd(t,e)}null!==hd&&Nd(hd,e),null!==dd&&Nd(dd,e),null!==pd&&Nd(pd,e),fd.forEach(t),md.forEach(t);for(var n=0;n<gd.length;n++){var r=gd[n];r.blockedOn===e&&(r.blockedOn=null)}for(;0<gd.length&&null===(n=gd[0]).blockedOn;)xd(n),null===n.blockedOn&&gd.shift();if(null!=(n=(e.ownerDocument||e).$$reactFormReplay))for(r=0;r<n.length;r+=3){var s=n[r],a=n[r+1],i=s[Oe]||null;if("function"===typeof a)i||Cd(n);else if(i){var o=null;if(a&&a.hasAttribute("formAction")){if(s=a,i=a[Oe]||null)o=i.formAction;else if(null!==ld(s))continue}else o=i.action;"function"===typeof o?n[r+1]=o:(n.splice(r,3),r-=3),Cd(n)}}}function Ad(e){this._internalRoot=e}function Ed(e){this._internalRoot=e}Ed.prototype.render=Ad.prototype.render=function(e){var t=this._internalRoot;if(null===t)throw Error(i(409));Zh(t.current,_u(),e,t,null,null)},Ed.prototype.unmount=Ad.prototype.unmount=function(){var e=this._internalRoot;if(null!==e){this._internalRoot=null;var t=e.containerInfo;Zh(e.current,2,null,e,null,null),Vu(),t[_e]=null}},Ed.prototype.unstable_scheduleHydration=function(e){if(e){var t=$e();e={blockedOn:null,target:e,priority:t};for(var n=0;n<gd.length&&0!==t&&t<gd[n].priority;n++);gd.splice(n,0,e),0===n&&xd(e)}};var $d=s.version;if("19.1.0"!==$d)throw Error(i(527,$d,"19.1.0"));F.findDOMNode=function(e){var t=e._reactInternals;if(void 0===t){if("function"===typeof e.render)throw Error(i(188));throw e=Object.keys(e).join(","),Error(i(268,e))}return e=function(e){var t=e.alternate;if(!t){if(null===(t=l(e)))throw Error(i(188));return t!==e?null:e}for(var n=e,r=t;;){var s=n.return;if(null===s)break;var a=s.alternate;if(null===a){if(null!==(r=s.return)){n=r;continue}break}if(s.child===a.child){for(a=s.child;a;){if(a===n)return c(s),e;if(a===r)return c(s),t;a=a.sibling}throw Error(i(188))}if(n.return!==r.return)n=s,r=a;else{for(var o=!1,u=s.child;u;){if(u===n){o=!0,n=s,r=a;break}if(u===r){o=!0,r=s,n=a;break}u=u.sibling}if(!o){for(u=a.child;u;){if(u===n){o=!0,n=a,r=s;break}if(u===r){o=!0,r=a,n=s;break}u=u.sibling}if(!o)throw Error(i(189))}}if(n.alternate!==r)throw Error(i(190))}if(3!==n.tag)throw Error(i(188));return n.stateNode.current===n?e:t}(t),e=null===(e=null!==e?h(e):null)?null:e.stateNode};var Rd={bundleType:0,version:"19.1.0",rendererPackageName:"react-dom",currentDispatcherRef:_,reconcilerVersion:"19.1.0"};if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var Dd=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!Dd.isDisabled&&Dd.supportsFiber)try{ce=Dd.inject(Rd),he=Dd}catch(_d){}}t.createRoot=function(e,t){if(!o(e))throw Error(i(299));var n=!1,r="",s=bo,a=vo,l=xo;return null!==t&&void 0!==t&&(!0===t.unstable_strictMode&&(n=!0),void 0!==t.identifierPrefix&&(r=t.identifierPrefix),void 0!==t.onUncaughtError&&(s=t.onUncaughtError),void 0!==t.onCaughtError&&(a=t.onCaughtError),void 0!==t.onRecoverableError&&(l=t.onRecoverableError),void 0!==t.unstable_transitionCallbacks&&t.unstable_transitionCallbacks),t=Qh(e,1,!1,null,0,n,r,s,a,l,0,null),e[_e]=t.current,Bc(e),new Ad(t)},t.hydrateRoot=function(e,t,n){if(!o(e))throw Error(i(299));var r=!1,s="",a=bo,l=vo,u=xo,c=null;return null!==n&&void 0!==n&&(!0===n.unstable_strictMode&&(r=!0),void 0!==n.identifierPrefix&&(s=n.identifierPrefix),void 0!==n.onUncaughtError&&(a=n.onUncaughtError),void 0!==n.onCaughtError&&(l=n.onCaughtError),void 0!==n.onRecoverableError&&(u=n.onRecoverableError),void 0!==n.unstable_transitionCallbacks&&n.unstable_transitionCallbacks,void 0!==n.formState&&(c=n.formState)),(t=Qh(e,1,!0,t,0,r,s,a,l,u,0,c)).context=Yh(null),n=t.current,(s=sa(r=Ae(r=_u()))).callback=null,aa(n,s,r),n=r,t.current.lanes=n,Ie(t,n),kc(t),e[_e]=t.current,Bc(e),new Ed(t)},t.version="19.1.0"},16:function(e,t,n){var r;!function(e,s){function a(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function o(e,t){var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,s))||(s.exports=r):this.xorwow=o}(0,e=n.nmd(e),n.amdD)},43:(e,t,n)=>{"use strict";e.exports=n(288)},66:function(e,t,n){var r;!function(e,s){function a(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function o(e,t){var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,s))||(s.exports=r):this.xor128=o}(0,e=n.nmd(e),n.amdD)},108:()=>{},175:(e,t)=>{"use strict";const n=/^[\u0021-\u003A\u003C\u003E-\u007E]+$/,r=/^[\u0021-\u003A\u003C-\u007E]*$/,s=/^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i,a=/^[\u0020-\u003A\u003D-\u007E]*$/,i=Object.prototype.toString,o=(()=>{const e=function(){};return e.prototype=Object.create(null),e})();function l(e,t,n){do{const n=e.charCodeAt(t);if(32!==n&&9!==n)return t}while(++t<n);return n}function u(e,t,n){for(;t>n;){const n=e.charCodeAt(--t);if(32!==n&&9!==n)return t+1}return n}function c(e){if(-1===e.indexOf("%"))return e;try{return decodeURIComponent(e)}catch(t){return e}}},234:()=>{},262:function(e,t,n){var r;!function(e,s){function a(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,s=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^s,s=s-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^s,t.a=s-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function i(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function o(e,t){var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,s))||(s.exports=r):this.tychei=o}(0,e=n.nmd(e),n.amdD)},288:(e,t)=>{"use strict";var n=Symbol.for("react.transitional.element"),r=Symbol.for("react.portal"),s=Symbol.for("react.fragment"),a=Symbol.for("react.strict_mode"),i=Symbol.for("react.profiler"),o=Symbol.for("react.consumer"),l=Symbol.for("react.context"),u=Symbol.for("react.forward_ref"),c=Symbol.for("react.suspense"),h=Symbol.for("react.memo"),d=Symbol.for("react.lazy"),p=Symbol.iterator;var f={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},m=Object.assign,g={};function y(e,t,n){this.props=e,this.context=t,this.refs=g,this.updater=n||f}function b(){}function v(e,t,n){this.props=e,this.context=t,this.refs=g,this.updater=n||f}y.prototype.isReactComponent={},y.prototype.setState=function(e,t){if("object"!==typeof e&&"function"!==typeof e&&null!=e)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,t,"setState")},y.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")},b.prototype=y.prototype;var x=v.prototype=new b;x.constructor=v,m(x,y.prototype),x.isPureReactComponent=!0;var w=Array.isArray,k={H:null,A:null,T:null,S:null,V:null},S=Object.prototype.hasOwnProperty;function N(e,t,r,s,a,i){return r=i.ref,{$$typeof:n,type:e,key:t,ref:void 0!==r?r:null,props:i}}function I(e){return"object"===typeof e&&null!==e&&e.$$typeof===n}var C=/\/+/g;function T(e,t){return"object"===typeof e&&null!==e&&null!=e.key?function(e){var t={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,(function(e){return t[e]}))}(""+e.key):t.toString(36)}function A(){}function E(e,t,s,a,i){var o=typeof e;"undefined"!==o&&"boolean"!==o||(e=null);var l,u,c=!1;if(null===e)c=!0;else switch(o){case"bigint":case"string":case"number":c=!0;break;case"object":switch(e.$$typeof){case n:case r:c=!0;break;case d:return E((c=e._init)(e._payload),t,s,a,i)}}if(c)return i=i(e),c=""===a?"."+T(e,0):a,w(i)?(s="",null!=c&&(s=c.replace(C,"$&/")+"/"),E(i,t,s,"",(function(e){return e}))):null!=i&&(I(i)&&(l=i,u=s+(null==i.key||e&&e.key===i.key?"":(""+i.key).replace(C,"$&/")+"/")+c,i=N(l.type,u,void 0,0,0,l.props)),t.push(i)),1;c=0;var h,f=""===a?".":a+":";if(w(e))for(var m=0;m<e.length;m++)c+=E(a=e[m],t,s,o=f+T(a,m),i);else if("function"===typeof(m=null===(h=e)||"object"!==typeof h?null:"function"===typeof(h=p&&h[p]||h["@@iterator"])?h:null))for(e=m.call(e),m=0;!(a=e.next()).done;)c+=E(a=a.value,t,s,o=f+T(a,m++),i);else if("object"===o){if("function"===typeof e.then)return E(function(e){switch(e.status){case"fulfilled":return e.value;case"rejected":throw e.reason;default:switch("string"===typeof e.status?e.then(A,A):(e.status="pending",e.then((function(t){"pending"===e.status&&(e.status="fulfilled",e.value=t)}),(function(t){"pending"===e.status&&(e.status="rejected",e.reason=t)}))),e.status){case"fulfilled":return e.value;case"rejected":throw e.reason}}throw e}(e),t,s,a,i);throw t=String(e),Error("Objects are not valid as a React child (found: "+("[object Object]"===t?"object with keys {"+Object.keys(e).join(", ")+"}":t)+"). If you meant to render a collection of children, use an array instead.")}return c}function $(e,t,n){if(null==e)return e;var r=[],s=0;return E(e,r,"","",(function(e){return t.call(n,e,s++)})),r}function R(e){if(-1===e._status){var t=e._result;(t=t()).then((function(t){0!==e._status&&-1!==e._status||(e._status=1,e._result=t)}),(function(t){0!==e._status&&-1!==e._status||(e._status=2,e._result=t)})),-1===e._status&&(e._status=0,e._result=t)}if(1===e._status)return e._result.default;throw e._result}var D="function"===typeof reportError?reportError:function(e){if("object"===typeof window&&"function"===typeof window.ErrorEvent){var t=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:"object"===typeof e&&null!==e&&"string"===typeof e.message?String(e.message):String(e),error:e});if(!window.dispatchEvent(t))return}else if("object"===typeof process&&"function"===typeof process.emit)return void process.emit("uncaughtException",e);console.error(e)};function O(){}t.Children={map:$,forEach:function(e,t,n){$(e,(function(){t.apply(this,arguments)}),n)},count:function(e){var t=0;return $(e,(function(){t++})),t},toArray:function(e){return $(e,(function(e){return e}))||[]},only:function(e){if(!I(e))throw Error("React.Children.only expected to receive a single React element child.");return e}},t.Component=y,t.Fragment=s,t.Profiler=i,t.PureComponent=v,t.StrictMode=a,t.Suspense=c,t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=k,t.__COMPILER_RUNTIME={__proto__:null,c:function(e){return k.H.useMemoCache(e)}},t.cache=function(e){return function(){return e.apply(null,arguments)}},t.cloneElement=function(e,t,n){if(null===e||void 0===e)throw Error("The argument must be a React element, but you passed "+e+".");var r=m({},e.props),s=e.key;if(null!=t)for(a in void 0!==t.ref&&void 0,void 0!==t.key&&(s=""+t.key),t)!S.call(t,a)||"key"===a||"__self"===a||"__source"===a||"ref"===a&&void 0===t.ref||(r[a]=t[a]);var a=arguments.length-2;if(1===a)r.children=n;else if(1<a){for(var i=Array(a),o=0;o<a;o++)i[o]=arguments[o+2];r.children=i}return N(e.type,s,void 0,0,0,r)},t.createContext=function(e){return(e={$$typeof:l,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null}).Provider=e,e.Consumer={$$typeof:o,_context:e},e},t.createElement=function(e,t,n){var r,s={},a=null;if(null!=t)for(r in void 0!==t.key&&(a=""+t.key),t)S.call(t,r)&&"key"!==r&&"__self"!==r&&"__source"!==r&&(s[r]=t[r]);var i=arguments.length-2;if(1===i)s.children=n;else if(1<i){for(var o=Array(i),l=0;l<i;l++)o[l]=arguments[l+2];s.children=o}if(e&&e.defaultProps)for(r in i=e.defaultProps)void 0===s[r]&&(s[r]=i[r]);return N(e,a,void 0,0,0,s)},t.createRef=function(){return{current:null}},t.forwardRef=function(e){return{$$typeof:u,render:e}},t.isValidElement=I,t.lazy=function(e){return{$$typeof:d,_payload:{_status:-1,_result:e},_init:R}},t.memo=function(e,t){return{$$typeof:h,type:e,compare:void 0===t?null:t}},t.startTransition=function(e){var t=k.T,n={};k.T=n;try{var r=e(),s=k.S;null!==s&&s(n,r),"object"===typeof r&&null!==r&&"function"===typeof r.then&&r.then(O,D)}catch(a){D(a)}finally{k.T=t}},t.unstable_useCacheRefresh=function(){return k.H.useCacheRefresh()},t.use=function(e){return k.H.use(e)},t.useActionState=function(e,t,n){return k.H.useActionState(e,t,n)},t.useCallback=function(e,t){return k.H.useCallback(e,t)},t.useContext=function(e){return k.H.useContext(e)},t.useDebugValue=function(){},t.useDeferredValue=function(e,t){return k.H.useDeferredValue(e,t)},t.useEffect=function(e,t,n){var r=k.H;if("function"===typeof n)throw Error("useEffect CRUD overload is not enabled in this build of React.");return r.useEffect(e,t)},t.useId=function(){return k.H.useId()},t.useImperativeHandle=function(e,t,n){return k.H.useImperativeHandle(e,t,n)},t.useInsertionEffect=function(e,t){return k.H.useInsertionEffect(e,t)},t.useLayoutEffect=function(e,t){return k.H.useLayoutEffect(e,t)},t.useMemo=function(e,t){return k.H.useMemo(e,t)},t.useOptimistic=function(e,t){return k.H.useOptimistic(e,t)},t.useReducer=function(e,t,n){return k.H.useReducer(e,t,n)},t.useRef=function(e){return k.H.useRef(e)},t.useState=function(e){return k.H.useState(e)},t.useSyncExternalStore=function(e,t,n){return k.H.useSyncExternalStore(e,t,n)},t.useTransition=function(){return k.H.useTransition()},t.version="19.1.0"},334:(e,t,n)=>{var r=n(359),s=n(66),a=n(16),i=n(538),o=n(907),l=n(262),u=n(430);u.alea=r,u.xor128=s,u.xorwow=a,u.xorshift7=i,u.xor4096=o,u.tychei=l,e.exports=u},353:e=>{e.exports=n;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(I){}function n(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function r(e){return!0===(e&&e.__isLong__)}n.prototype.__isLong__,Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=r;var s={},a={};function i(e,t){var n,r,i;return t?(i=0<=(e>>>=0)&&e<256)&&(r=a[e])?r:(n=l(e,(0|e)<0?-1:0,!0),i&&(a[e]=n),n):(i=-128<=(e|=0)&&e<128)&&(r=s[e])?r:(n=l(e,e<0?-1:0,!1),i&&(s[e]=n),n)}function o(e,t){if(isNaN(e))return t?y:g;if(t){if(e<0)return y;if(e>=p)return k}else{if(e<=-f)return S;if(e+1>=f)return w}return e<0?o(-e,t).neg():l(e%d|0,e/d|0,t)}function l(e,t,r){return new n(e,t,r)}n.fromInt=i,n.fromNumber=o,n.fromBits=l;var u=Math.pow;function c(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return g;if("number"===typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var r;if((r=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return c(e.substring(1),t,n).neg();for(var s=o(u(n,8)),a=g,i=0;i<e.length;i+=8){var l=Math.min(8,e.length-i),h=parseInt(e.substring(i,i+l),n);if(l<8){var d=o(u(n,l));a=a.mul(d).add(o(h))}else a=(a=a.mul(s)).add(o(h))}return a.unsigned=t,a}function h(e,t){return"number"===typeof e?o(e,t):"string"===typeof e?c(e,t):l(e.low,e.high,"boolean"===typeof t?t:e.unsigned)}n.fromString=c,n.fromValue=h;var d=4294967296,p=d*d,f=p/2,m=i(1<<24),g=i(0);n.ZERO=g;var y=i(0,!0);n.UZERO=y;var b=i(1);n.ONE=b;var v=i(1,!0);n.UONE=v;var x=i(-1);n.NEG_ONE=x;var w=l(-1,2147483647,!1);n.MAX_VALUE=w;var k=l(-1,-1,!0);n.MAX_UNSIGNED_VALUE=k;var S=l(0,-2147483648,!1);n.MIN_VALUE=S;var N=n.prototype;N.toInt=function(){return this.unsigned?this.low>>>0:this.low},N.toNumber=function(){return this.unsigned?(this.high>>>0)*d+(this.low>>>0):this.high*d+(this.low>>>0)},N.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(S)){var t=o(e),n=this.div(t),r=n.mul(t).sub(this);return n.toString(e)+r.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var s=o(u(e,6),this.unsigned),a=this,i="";;){var l=a.div(s),c=(a.sub(l.mul(s)).toInt()>>>0).toString(e);if((a=l).isZero())return c+i;for(;c.length<6;)c="0"+c;i=""+c+i}},N.getHighBits=function(){return this.high},N.getHighBitsUnsigned=function(){return this.high>>>0},N.getLowBits=function(){return this.low},N.getLowBitsUnsigned=function(){return this.low>>>0},N.getNumBitsAbs=function(){if(this.isNegative())return this.eq(S)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&0==(e&1<<t);t--);return 0!=this.high?t+33:t+1},N.isZero=function(){return 0===this.high&&0===this.low},N.eqz=N.isZero,N.isNegative=function(){return!this.unsigned&&this.high<0},N.isPositive=function(){return this.unsigned||this.high>=0},N.isOdd=function(){return 1===(1&this.low)},N.isEven=function(){return 0===(1&this.low)},N.equals=function(e){return r(e)||(e=h(e)),(this.unsigned===e.unsigned||this.high>>>31!==1||e.high>>>31!==1)&&(this.high===e.high&&this.low===e.low)},N.eq=N.equals,N.notEquals=function(e){return!this.eq(e)},N.neq=N.notEquals,N.ne=N.notEquals,N.lessThan=function(e){return this.comp(e)<0},N.lt=N.lessThan,N.lessThanOrEqual=function(e){return this.comp(e)<=0},N.lte=N.lessThanOrEqual,N.le=N.lessThanOrEqual,N.greaterThan=function(e){return this.comp(e)>0},N.gt=N.greaterThan,N.greaterThanOrEqual=function(e){return this.comp(e)>=0},N.gte=N.greaterThanOrEqual,N.ge=N.greaterThanOrEqual,N.compare=function(e){if(r(e)||(e=h(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},N.comp=N.compare,N.negate=function(){return!this.unsigned&&this.eq(S)?S:this.not().add(b)},N.neg=N.negate,N.add=function(e){r(e)||(e=h(e));var t=this.high>>>16,n=65535&this.high,s=this.low>>>16,a=65535&this.low,i=e.high>>>16,o=65535&e.high,u=e.low>>>16,c=0,d=0,p=0,f=0;return p+=(f+=a+(65535&e.low))>>>16,d+=(p+=s+u)>>>16,c+=(d+=n+o)>>>16,c+=t+i,l((p&=65535)<<16|(f&=65535),(c&=65535)<<16|(d&=65535),this.unsigned)},N.subtract=function(e){return r(e)||(e=h(e)),this.add(e.neg())},N.sub=N.subtract,N.multiply=function(e){if(this.isZero())return g;if(r(e)||(e=h(e)),t)return l(t.mul(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned);if(e.isZero())return g;if(this.eq(S))return e.isOdd()?S:g;if(e.eq(S))return this.isOdd()?S:g;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(m)&&e.lt(m))return o(this.toNumber()*e.toNumber(),this.unsigned);var n=this.high>>>16,s=65535&this.high,a=this.low>>>16,i=65535&this.low,u=e.high>>>16,c=65535&e.high,d=e.low>>>16,p=65535&e.low,f=0,y=0,b=0,v=0;return b+=(v+=i*p)>>>16,y+=(b+=a*p)>>>16,b&=65535,y+=(b+=i*d)>>>16,f+=(y+=s*p)>>>16,y&=65535,f+=(y+=a*d)>>>16,y&=65535,f+=(y+=i*c)>>>16,f+=n*p+s*d+a*c+i*u,l((b&=65535)<<16|(v&=65535),(f&=65535)<<16|(y&=65535),this.unsigned)},N.mul=N.multiply,N.divide=function(e){if(r(e)||(e=h(e)),e.isZero())throw Error("division by zero");var n,s,a;if(t)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?l((this.unsigned?t.div_u:t.div_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?y:g;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return y;if(e.gt(this.shru(1)))return v;a=y}else{if(this.eq(S))return e.eq(b)||e.eq(x)?S:e.eq(S)?b:(n=this.shr(1).div(e).shl(1)).eq(g)?e.isNegative()?b:x:(s=this.sub(e.mul(n)),a=n.add(s.div(e)));if(e.eq(S))return this.unsigned?y:g;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();a=g}for(s=this;s.gte(e);){n=Math.max(1,Math.floor(s.toNumber()/e.toNumber()));for(var i=Math.ceil(Math.log(n)/Math.LN2),c=i<=48?1:u(2,i-48),d=o(n),p=d.mul(e);p.isNegative()||p.gt(s);)p=(d=o(n-=c,this.unsigned)).mul(e);d.isZero()&&(d=b),a=a.add(d),s=s.sub(p)}return a},N.div=N.divide,N.modulo=function(e){return r(e)||(e=h(e)),t?l((this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},N.mod=N.modulo,N.rem=N.modulo,N.not=function(){return l(~this.low,~this.high,this.unsigned)},N.and=function(e){return r(e)||(e=h(e)),l(this.low&e.low,this.high&e.high,this.unsigned)},N.or=function(e){return r(e)||(e=h(e)),l(this.low|e.low,this.high|e.high,this.unsigned)},N.xor=function(e){return r(e)||(e=h(e)),l(this.low^e.low,this.high^e.high,this.unsigned)},N.shiftLeft=function(e){return r(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?l(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):l(0,this.low<<e-32,this.unsigned)},N.shl=N.shiftLeft,N.shiftRight=function(e){return r(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?l(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):l(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},N.shr=N.shiftRight,N.shiftRightUnsigned=function(e){if(r(e)&&(e=e.toInt()),0===(e&=63))return this;var t=this.high;return e<32?l(this.low>>>e|t<<32-e,t>>>e,this.unsigned):l(32===e?t:t>>>e-32,0,this.unsigned)},N.shru=N.shiftRightUnsigned,N.shr_u=N.shiftRightUnsigned,N.toSigned=function(){return this.unsigned?l(this.low,this.high,!1):this},N.toUnsigned=function(){return this.unsigned?this:l(this.low,this.high,!0)},N.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},N.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},N.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},n.fromBytes=function(e,t,r){return r?n.fromBytesLE(e,t):n.fromBytesBE(e,t)},n.fromBytesLE=function(e,t){return new n(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},n.fromBytesBE=function(e,t){return new n(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}},359:function(e,t,n){var r;!function(e,s){function a(e){var t=this,n=function(){var e=4022871197,t=function(t){t=String(t);for(var n=0;n<t.length;n++){var r=.02519603282416938*(e+=t.charCodeAt(n));r-=e=r>>>0,e=(r*=e)>>>0,e+=4294967296*(r-=e)}return 2.3283064365386963e-10*(e>>>0)};return t}();t.next=function(){var e=2091639*t.s0+2.3283064365386963e-10*t.c;return t.s0=t.s1,t.s1=t.s2,t.s2=e-(t.c=0|e)},t.c=1,t.s0=n(" "),t.s1=n(" "),t.s2=n(" "),t.s0-=n(e),t.s0<0&&(t.s0+=1),t.s1-=n(e),t.s1<0&&(t.s1+=1),t.s2-=n(e),t.s2<0&&(t.s2+=1),n=null}function i(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function o(e,t){var n=new a(e),r=t&&t.state,s=n.next;return s.int32=function(){return 4294967296*n.next()|0},s.double=function(){return s()+11102230246251565e-32*(2097152*s()|0)},s.quick=s,r&&("object"==typeof r&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,s))||(s.exports=r):this.alea=o}(0,e=n.nmd(e),n.amdD)},391:(e,t,n)=>{"use strict";!function e(){if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__&&"function"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(t){console.error(t)}}(),e.exports=n(4)},430:function(e,t,n){var r;!function(s,a,i){var o,l=256,u=i.pow(l,6),c=i.pow(2,52),h=2*c,d=255;function p(e,t,n){var r=[],d=y(g((t=1==t?{entropy:!0}:t||{}).entropy?[e,b(a)]:null==e?function(){try{var e;return o&&(e=o.randomBytes)?e=e(l):(e=new Uint8Array(l),(s.crypto||s.msCrypto).getRandomValues(e)),b(e)}catch(r){var t=s.navigator,n=t&&t.plugins;return[+new Date,s,n,s.screen,b(a)]}}():e,3),r),p=new f(r),v=function(){for(var e=p.g(6),t=u,n=0;e<c;)e=(e+n)*l,t*=l,n=p.g(1);for(;e>=h;)e/=2,t/=2,n>>>=1;return(e+n)/t};return v.int32=function(){return 0|p.g(4)},v.quick=function(){return p.g(4)/4294967296},v.double=v,y(b(p.S),a),(t.pass||n||function(e,t,n,r){return r&&(r.S&&m(r,p),e.state=function(){return m(p,{})}),n?(i.random=e,t):e})(v,d,"global"in t?t.global:this==i,t.state)}function f(e){var t,n=e.length,r=this,s=0,a=r.i=r.j=0,i=r.S=[];for(n||(e=[n++]);s<l;)i[s]=s++;for(s=0;s<l;s++)i[s]=i[a=d&a+e[s%n]+(t=i[s])],i[a]=t;(r.g=function(e){for(var t,n=0,s=r.i,a=r.j,i=r.S;e--;)t=i[s=d&s+1],n=n*l+i[d&(i[s]=i[a=d&a+t])+(i[a]=t)];return r.i=s,r.j=a,n})(l)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function g(e,t){var n,r=[],s=typeof e;if(t&&"object"==s)for(n in e)try{r.push(g(e[n],t-1))}catch(a){}return r.length?r:"string"==s?e:e+"\0"}function y(e,t){for(var n,r=e+"",s=0;s<r.length;)t[d&s]=d&(n^=19*t[d&s])+r.charCodeAt(s++);return b(t)}function b(e){return String.fromCharCode.apply(0,e)}if(y(i.random(),a),e.exports){e.exports=p;try{o=n(234)}catch(v){}}else void 0===(r=function(){return p}.call(t,n,t,e))||(e.exports=r)}("undefined"!==typeof self?self:this,[],Math)},530:()=>{},538:function(e,t,n){var r;!function(e,s){function a(e){var t=this;t.next=function(){var e,n,r=t.x,s=t.i;return e=r[s],n=(e^=e>>>7)^e<<24,n^=(e=r[s+1&7])^e>>>10,n^=(e=r[s+3&7])^e>>>3,n^=(e=r[s+4&7])^e<<7,e=r[s+7&7],n^=(e^=e<<13)^e<<9,r[s]=n,t.i=s+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function i(e,t){return t.x=e.x.slice(),t.i=e.i,t}function o(e,t){null==e&&(e=+new Date);var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&(r.x&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,s))||(s.exports=r):this.xorshift7=o}(0,e=n.nmd(e),n.amdD)},551:()=>{},579:(e,t,n)=>{"use strict";e.exports=n(799)},590:()=>{},672:(e,t,n)=>{"use strict";var r=n(43);function s(e){var t="https://react.dev/errors/"+e;if(1<arguments.length){t+="?args[]="+encodeURIComponent(arguments[1]);for(var n=2;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n])}return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function a(){}var i={d:{f:a,r:function(){throw Error(s(522))},D:a,C:a,L:a,m:a,X:a,S:a,M:a},p:0,findDOMNode:null},o=Symbol.for("react.portal");var l=r.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;function u(e,t){return"font"===e?"":"string"===typeof t?"use-credentials"===t?t:"":void 0}t.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=i,t.createPortal=function(e,t){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!t||1!==t.nodeType&&9!==t.nodeType&&11!==t.nodeType)throw Error(s(299));return function(e,t,n){var r=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:o,key:null==r?null:""+r,children:e,containerInfo:t,implementation:n}}(e,t,null,n)},t.flushSync=function(e){var t=l.T,n=i.p;try{if(l.T=null,i.p=2,e)return e()}finally{l.T=t,i.p=n,i.d.f()}},t.preconnect=function(e,t){"string"===typeof e&&(t?t="string"===typeof(t=t.crossOrigin)?"use-credentials"===t?t:"":void 0:t=null,i.d.C(e,t))},t.prefetchDNS=function(e){"string"===typeof e&&i.d.D(e)},t.preinit=function(e,t){if("string"===typeof e&&t&&"string"===typeof t.as){var n=t.as,r=u(n,t.crossOrigin),s="string"===typeof t.integrity?t.integrity:void 0,a="string"===typeof t.fetchPriority?t.fetchPriority:void 0;"style"===n?i.d.S(e,"string"===typeof t.precedence?t.precedence:void 0,{crossOrigin:r,integrity:s,fetchPriority:a}):"script"===n&&i.d.X(e,{crossOrigin:r,integrity:s,fetchPriority:a,nonce:"string"===typeof t.nonce?t.nonce:void 0})}},t.preinitModule=function(e,t){if("string"===typeof e)if("object"===typeof t&&null!==t){if(null==t.as||"script"===t.as){var n=u(t.as,t.crossOrigin);i.d.M(e,{crossOrigin:n,integrity:"string"===typeof t.integrity?t.integrity:void 0,nonce:"string"===typeof t.nonce?t.nonce:void 0})}}else null==t&&i.d.M(e)},t.preload=function(e,t){if("string"===typeof e&&"object"===typeof t&&null!==t&&"string"===typeof t.as){var n=t.as,r=u(n,t.crossOrigin);i.d.L(e,n,{crossOrigin:r,integrity:"string"===typeof t.integrity?t.integrity:void 0,nonce:"string"===typeof t.nonce?t.nonce:void 0,type:"string"===typeof t.type?t.type:void 0,fetchPriority:"string"===typeof t.fetchPriority?t.fetchPriority:void 0,referrerPolicy:"string"===typeof t.referrerPolicy?t.referrerPolicy:void 0,imageSrcSet:"string"===typeof t.imageSrcSet?t.imageSrcSet:void 0,imageSizes:"string"===typeof t.imageSizes?t.imageSizes:void 0,media:"string"===typeof t.media?t.media:void 0})}},t.preloadModule=function(e,t){if("string"===typeof e)if(t){var n=u(t.as,t.crossOrigin);i.d.m(e,{as:"string"===typeof t.as&&"script"!==t.as?t.as:void 0,crossOrigin:n,integrity:"string"===typeof t.integrity?t.integrity:void 0})}else i.d.m(e)},t.requestFormReset=function(e){i.d.r(e)},t.unstable_batchedUpdates=function(e,t){return e(t)},t.useFormState=function(e,t,n){return l.H.useFormState(e,t,n)},t.useFormStatus=function(){return l.H.useHostTransitionStatus()},t.version="19.1.0"},799:(e,t)=>{"use strict";var n=Symbol.for("react.transitional.element"),r=Symbol.for("react.fragment");function s(e,t,r){var s=null;if(void 0!==r&&(s=""+r),void 0!==t.key&&(s=""+t.key),"key"in t)for(var a in r={},t)"key"!==a&&(r[a]=t[a]);else r=t;return t=r.ref,{$$typeof:n,type:e,key:s,ref:void 0!==t?t:null,props:r}}t.Fragment=r,t.jsx=s,t.jsxs=s},817:()=>{},844:e=>{e.exports={area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}},853:(e,t,n)=>{"use strict";e.exports=n(896)},896:(e,t)=>{"use strict";function n(e,t){var n=e.length;e.push(t);e:for(;0<n;){var r=n-1>>>1,s=e[r];if(!(0<a(s,t)))break e;e[r]=t,e[n]=s,n=r}}function r(e){return 0===e.length?null:e[0]}function s(e){if(0===e.length)return null;var t=e[0],n=e.pop();if(n!==t){e[0]=n;e:for(var r=0,s=e.length,i=s>>>1;r<i;){var o=2*(r+1)-1,l=e[o],u=o+1,c=e[u];if(0>a(l,n))u<s&&0>a(c,l)?(e[r]=c,e[u]=n,r=u):(e[r]=l,e[o]=n,r=o);else{if(!(u<s&&0>a(c,n)))break e;e[r]=c,e[u]=n,r=u}}}return t}function a(e,t){var n=e.sortIndex-t.sortIndex;return 0!==n?n:e.id-t.id}if(t.unstable_now=void 0,"object"===typeof performance&&"function"===typeof performance.now){var i=performance;t.unstable_now=function(){return i.now()}}else{var o=Date,l=o.now();t.unstable_now=function(){return o.now()-l}}var u=[],c=[],h=1,d=null,p=3,f=!1,m=!1,g=!1,y=!1,b="function"===typeof setTimeout?setTimeout:null,v="function"===typeof clearTimeout?clearTimeout:null,x="undefined"!==typeof setImmediate?setImmediate:null;function w(e){for(var t=r(c);null!==t;){if(null===t.callback)s(c);else{if(!(t.startTime<=e))break;s(c),t.sortIndex=t.expirationTime,n(u,t)}t=r(c)}}function k(e){if(g=!1,w(e),!m)if(null!==r(u))m=!0,N||(N=!0,S());else{var t=r(c);null!==t&&D(k,t.startTime-e)}}var S,N=!1,I=-1,C=5,T=-1;function A(){return!!y||!(t.unstable_now()-T<C)}function E(){if(y=!1,N){var e=t.unstable_now();T=e;var n=!0;try{e:{m=!1,g&&(g=!1,v(I),I=-1),f=!0;var a=p;try{t:{for(w(e),d=r(u);null!==d&&!(d.expirationTime>e&&A());){var i=d.callback;if("function"===typeof i){d.callback=null,p=d.priorityLevel;var o=i(d.expirationTime<=e);if(e=t.unstable_now(),"function"===typeof o){d.callback=o,w(e),n=!0;break t}d===r(u)&&s(u),w(e)}else s(u);d=r(u)}if(null!==d)n=!0;else{var l=r(c);null!==l&&D(k,l.startTime-e),n=!1}}break e}finally{d=null,p=a,f=!1}n=void 0}}finally{n?S():N=!1}}}if("function"===typeof x)S=function(){x(E)};else if("undefined"!==typeof MessageChannel){var $=new MessageChannel,R=$.port2;$.port1.onmessage=E,S=function(){R.postMessage(null)}}else S=function(){b(E,0)};function D(e,n){I=b((function(){e(t.unstable_now())}),n)}t.unstable_IdlePriority=5,t.unstable_ImmediatePriority=1,t.unstable_LowPriority=4,t.unstable_NormalPriority=3,t.unstable_Profiling=null,t.unstable_UserBlockingPriority=2,t.unstable_cancelCallback=function(e){e.callback=null},t.unstable_forceFrameRate=function(e){0>e||125<e?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):C=0<e?Math.floor(1e3/e):5},t.unstable_getCurrentPriorityLevel=function(){return p},t.unstable_next=function(e){switch(p){case 1:case 2:case 3:var t=3;break;default:t=p}var n=p;p=t;try{return e()}finally{p=n}},t.unstable_requestPaint=function(){y=!0},t.unstable_runWithPriority=function(e,t){switch(e){case 1:case 2:case 3:case 4:case 5:break;default:e=3}var n=p;p=e;try{return t()}finally{p=n}},t.unstable_scheduleCallback=function(e,s,a){var i=t.unstable_now();switch("object"===typeof a&&null!==a?a="number"===typeof(a=a.delay)&&0<a?i+a:i:a=i,e){case 1:var o=-1;break;case 2:o=250;break;case 5:o=1073741823;break;case 4:o=1e4;break;default:o=5e3}return e={id:h++,callback:s,priorityLevel:e,startTime:a,expirationTime:o=a+o,sortIndex:-1},a>i?(e.sortIndex=a,n(c,e),null===r(u)&&e===r(c)&&(g?(v(I),I=-1):g=!0,D(k,a-i))):(e.sortIndex=o,n(u,e),m||f||(m=!0,N||(N=!0,S()))),e},t.unstable_shouldYield=A,t.unstable_wrapCallback=function(e){var t=p;return function(){var n=p;p=t;try{return e.apply(this,arguments)}finally{p=n}}}},907:function(e,t,n){var r;!function(e,s){function a(e){var t=this;t.next=function(){var e,n,r=t.w,s=t.X,a=t.i;return t.w=r=r+1640531527|0,n=s[a+34&127],e=s[a=a+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=s[a]=n^e,t.i=a,n+(r^r>>>16)|0},function(e,t){var n,r,s,a,i,o=[],l=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,l=Math.max(l,t.length)),s=0,a=-32;a<l;++a)t&&(r^=t.charCodeAt((a+32)%t.length)),0===a&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,a>=0&&(i=i+1640531527|0,s=0==(n=o[127&a]^=r+i)?s+1:0);for(s>=128&&(o[127&(t&&t.length||0)]=-1),s=127,a=512;a>0;--a)r=o[s+34&127],n=o[s=s+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,o[s]=r^n;e.w=i,e.X=o,e.i=s}(t,e)}function i(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function o(e,t){null==e&&(e=+new Date);var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&(r.X&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,s))||(s.exports=r):this.xor4096=o}(0,e=n.nmd(e),n.amdD)},950:(e,t,n)=>{"use strict";!function e(){if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__&&"function"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(t){console.error(t)}}(),e.exports=n(672)}},t={};function n(r){var s=t[r];if(void 0!==s)return s.exports;var a=t[r]={id:r,loaded:!1,exports:{}};return e[r].call(a.exports,a,a.exports,n),a.loaded=!0,a.exports}n.m=e,n.amdD=function(){throw new Error("define cannot be used indirect")},n.amdO={},n.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return n.d(t,{a:t}),t},n.d=(e,t)=>{for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.f={},n.e=e=>Promise.all(Object.keys(n.f).reduce(((t,r)=>(n.f[r](e,t),t)),[])),n.u=e=>"static/js/"+e+".16867bbb.chunk.js",n.miniCssF=e=>{},n.g=function(){if("object"===typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"===typeof window)return window}}(),n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),(()=>{var e={},t="footprint-vis:";n.l=(r,s,a,i)=>{if(e[r])e[r].push(s);else{var o,l;if(void 0!==a)for(var u=document.getElementsByTagName("script"),c=0;c<u.length;c++){var h=u[c];if(h.getAttribute("src")==r||h.getAttribute("data-webpack")==t+a){o=h;break}}o||(l=!0,(o=document.createElement("script")).charset="utf-8",o.timeout=120,n.nc&&o.setAttribute("nonce",n.nc),o.setAttribute("data-webpack",t+a),o.src=r),e[r]=[s];var d=(t,n)=>{o.onerror=o.onload=null,clearTimeout(p);var s=e[r];if(delete e[r],o.parentNode&&o.parentNode.removeChild(o),s&&s.forEach((e=>e(n))),t)return t(n)},p=setTimeout(d.bind(null,void 0,{type:"timeout",target:o}),12e4);o.onerror=d.bind(null,o.onerror),o.onload=d.bind(null,o.onload),l&&document.head.appendChild(o)}}})(),n.r=e=>{"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.nmd=e=>(e.paths=[],e.children||(e.children=[]),e),n.p="/",(()=>{var e={792:0};n.f.j=(t,r)=>{var s=n.o(e,t)?e[t]:void 0;if(0!==s)if(s)r.push(s[2]);else{var a=new Promise(((n,r)=>s=e[t]=[n,r]));r.push(s[2]=a);var i=n.p+n.u(t),o=new Error;n.l(i,(r=>{if(n.o(e,t)&&(0!==(s=e[t])&&(e[t]=void 0),s)){var a=r&&("load"===r.type?"missing":r.type),i=r&&r.target&&r.target.src;o.message="Loading chunk "+t+" failed.\n("+a+": "+i+")",o.name="ChunkLoadError",o.type=a,o.request=i,s[1](o)}}),"chunk-"+t,t)}};var t=(t,r)=>{var s,a,i=r[0],o=r[1],l=r[2],u=0;if(i.some((t=>0!==e[t]))){for(s in o)n.o(o,s)&&(n.m[s]=o[s]);if(l)l(n)}for(t&&t(r);u<i.length;u++)a=i[u],n.o(e,a)&&e[a]&&e[a][0](),e[a]=0},r=self.webpackChunkfootprint_vis=self.webpackChunkfootprint_vis||[];r.forEach(t.bind(null,0)),r.push=t.bind(null,r.push.bind(r))})(),(()=>{"use strict";var e={};n.r(e),n.d(e,{CompositeArrayBuffer:()=>Wl,browserFiles:()=>Mc,browserHTTPRequest:()=>Gc,concatenateArrayBuffers:()=>ou,copyModel:()=>Hu,decodeWeights:()=>Zl,decodeWeightsStream:()=>ru,encodeWeights:()=>Yl,fromMemory:()=>Xc,fromMemorySync:()=>Qc,getLoadHandlers:()=>bu,getModelArtifactsForJSON:()=>hu,getModelArtifactsForJSONSync:()=>cu,getModelArtifactsInfoForJSON:()=>du,getSaveHandlers:()=>yu,getWeightSpecs:()=>pu,http:()=>jc,isHTTPScheme:()=>Wc,listModels:()=>ju,loadWeights:()=>zc,moveModel:()=>qu,registerLoadRouter:()=>gu,registerSaveRouter:()=>mu,removeModel:()=>Gu,weightsLoaderFactory:()=>Bc,withSaveHandler:()=>Yc,withSaveHandlerSync:()=>Zc});var t={};n.r(t),n.d(t,{assertParamsValid:()=>nh,computeFlatOffset:()=>mh,computeOutShape:()=>sh,getNormalizedAxes:()=>lh,isSliceContinous:()=>fh,maskToAxes:()=>rh,parseSliceParams:()=>gh,sliceInfo:()=>yh,startForAxis:()=>dh,startIndicesWithElidedDims:()=>uh,stopForAxis:()=>ph,stopIndicesWithElidedDims:()=>ch,stridesForAxis:()=>hh,stridesWithElidedDims:()=>ah});var r={};n.r(r),n.d(r,{conv2d:()=>Rm,depthwiseConv2d:()=>_m,matMul:()=>Fm});var s={};n.r(s),n.d(s,{collectGatherOpShapeInfo:()=>Hy,computeOutShape:()=>Gy,segOpComputeOptimalWindowSize:()=>jy});var a={};n.r(a),n.d(a,{ERF_A1:()=>ly,ERF_A2:()=>uy,ERF_A3:()=>cy,ERF_A4:()=>hy,ERF_A5:()=>dy,ERF_P:()=>oy,PARALLELIZE_THRESHOLD:()=>Qg,RowPartitionType:()=>Gg,SELU_SCALE:()=>iy,SELU_SCALEALPHA:()=>ay,applyActivation:()=>Em,assertAndGetBroadcastShape:()=>Cc,assertAxesAreInnerMostDims:()=>jd,assertParamsConsistent:()=>Ug,assignToTypedArray:()=>by,axesAreInnerMostDims:()=>Bd,calculateShapes:()=>am,checkEinsumDimSizes:()=>Ty,checkPadOnDimRoundingMode:()=>Gh,combineLocations:()=>Vd,combineRaggedTensorToTensorShapes:()=>Hg,complexWithEvenIndex:()=>my,complexWithOddIndex:()=>gy,computeConv2DInfo:()=>_h,computeConv3DInfo:()=>Fh,computeDefaultPad:()=>Mh,computeDilation2DInfo:()=>Rh,computeOptimalWindowSize:()=>Yg,computeOutAndReduceShapes:()=>Wd,computeOutShape:()=>jg,computePool2DInfo:()=>Dh,computePool3DInfo:()=>Oh,convertConv2DDataFormat:()=>jh,decodeEinsumEquation:()=>Iy,eitherStridesOrDilationsAreOne:()=>Wh,expandShapeToKeepDim:()=>Ud,exponent:()=>xy,exponents:()=>vy,fromStringArrayToUint8:()=>Ky,fromUint8ToStringArray:()=>qy,getAxesPermutation:()=>Gd,getBroadcastDims:()=>Nc,getComplexWithIndex:()=>yy,getEinsumComputePath:()=>Ay,getEinsumPermutation:()=>Cy,getFusedBiasGradient:()=>Am,getFusedDyActivation:()=>Tm,getImageCenter:()=>Zg,getInnerMostAxes:()=>qd,getPermuted:()=>ey,getRaggedRank:()=>Kg,getReductionAxes:()=>Ic,getReshaped:()=>Jg,getReshapedPermuted:()=>ty,getRowPartitionTypesHelper:()=>qg,getSliceBeginCoords:()=>ny,getSliceSize:()=>ry,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>Dy,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>Oy,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>_y,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>Ly,getSparseReshapeInputOutputMismatchErrorMessage:()=>zy,getSparseReshapeInputOutputMultipleErrorMessage:()=>Py,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>Fy,getSparseReshapeNegativeOutputDimErrorMessage:()=>My,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>Uy,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>By,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>Vy,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>Wy,getUndoAxesPermutation:()=>Hd,isIdentityPermutation:()=>Ey,log:()=>mo,mergeRealAndImagArrays:()=>py,prepareAndValidate:()=>sy,prepareSplitSize:()=>Ry,segment_util:()=>s,shouldFuse:()=>$m,slice_util:()=>t,splitRealAndImagArrays:()=>fy,stridesOrDilationsArePositive:()=>Uh,tupleValuesAreOne:()=>Vh,upcastType:()=>pl,validateDefaultValueShape:()=>Xg,validateInput:()=>sm,validateUpdateShape:()=>rm,warn:()=>fo});var i={};n.r(i),n.d(i,{json:()=>RI});var o={};n.r(o),n.d(o,{json:()=>DI});var l={};n.r(l),n.d(l,{json:()=>OI});var u={};n.r(u),n.d(u,{json:()=>_I});var c={};n.r(c),n.d(c,{json:()=>FI});var h={};n.r(h),n.d(h,{json:()=>MI});var d={};n.r(d),n.d(d,{json:()=>LI});var p={};n.r(p),n.d(p,{json:()=>PI});var f={};n.r(f),n.d(f,{json:()=>zI});var m={};n.r(m),n.d(m,{json:()=>BI});var g={};n.r(g),n.d(g,{json:()=>VI});var y={};n.r(y),n.d(y,{json:()=>WI});var b={};n.r(b),n.d(b,{json:()=>UI});var v={};n.r(v),n.d(v,{json:()=>jI});var x={};n.r(x),n.d(x,{json:()=>GI});var w={};n.r(w),n.d(w,{json:()=>HI});var k={};n.r(k),n.d(k,{json:()=>qI});var S={};n.r(S),n.d(S,{json:()=>KI});var N={};n.r(N),n.d(N,{json:()=>XI});var I={};n.r(I),n.d(I,{OP_SCOPE_SUFFIX:()=>Ml,abs:()=>Sc,acos:()=>vh,acosh:()=>xh,add:()=>nc,addN:()=>wh,all:()=>kh,any:()=>Sh,argMax:()=>Nh,argMin:()=>Ih,asin:()=>Ch,asinh:()=>Th,atan:()=>Ah,atan2:()=>Eh,atanh:()=>$h,avgPool:()=>qh,avgPool3d:()=>Kh,basicLSTMCell:()=>ed,batchNorm:()=>nd,batchNorm2d:()=>rd,batchNorm3d:()=>sd,batchNorm4d:()=>ad,batchToSpaceND:()=>td,bincount:()=>id,bitwiseAnd:()=>od,booleanMaskAsync:()=>gm,broadcastArgs:()=>ld,broadcastTo:()=>ud,buffer:()=>Zu,cast:()=>Ju,ceil:()=>cd,clipByValue:()=>hd,clone:()=>ec,complex:()=>Pl,concat:()=>Xh,concat1d:()=>dd,concat2d:()=>pd,concat3d:()=>fd,concat4d:()=>md,conv1d:()=>yd,conv2d:()=>gd,conv2dTranspose:()=>vd,conv3d:()=>xd,conv3dTranspose:()=>kd,cos:()=>Sd,cosh:()=>Nd,cosineWindow:()=>Nm,cumprod:()=>Id,cumsum:()=>Cd,denseBincount:()=>Td,depthToSpace:()=>Ad,depthwiseConv2d:()=>Ed,diag:()=>$d,dilation2d:()=>Rd,div:()=>sc,divNoNan:()=>_d,dot:()=>Fd,dropout:()=>km,einsum:()=>Md,elu:()=>Ld,enclosingPowerOfTwo:()=>Sm,ensureShape:()=>Pd,equal:()=>Dd,erf:()=>zd,euclideanNorm:()=>Jd,exp:()=>ep,expandDims:()=>tp,expm1:()=>np,eye:()=>sp,fft:()=>Vf,fill:()=>bc,floor:()=>ap,floorDiv:()=>rc,fused:()=>r,gather:()=>ip,gatherND:()=>wm,greater:()=>op,greaterEqual:()=>lp,ifft:()=>Wf,imag:()=>up,image:()=>Fg,inTopKAsync:()=>Im,irfft:()=>Uf,isFinite:()=>cp,isInf:()=>hp,isNaN:()=>dp,leakyRelu:()=>pp,less:()=>fp,lessEqual:()=>mp,linalg:()=>Mg,linspace:()=>gp,localResponseNormalization:()=>yp,log:()=>bp,log1p:()=>vp,logSigmoid:()=>kp,logSoftmax:()=>Sp,logSumExp:()=>Np,logicalAnd:()=>Ip,logicalNot:()=>Cp,logicalOr:()=>Tp,logicalXor:()=>Ap,losses:()=>Lg,lowerBound:()=>Rp,matMul:()=>Qh,max:()=>Kd,maxPool:()=>Dp,maxPool3d:()=>Op,maxPoolWithArgmax:()=>_p,maximum:()=>Tc,mean:()=>Fp,meshgrid:()=>Pp,min:()=>Xd,minimum:()=>zp,mirrorPad:()=>Bp,mod:()=>Vp,moments:()=>Wp,movingAverage:()=>bm,mul:()=>ac,multiRNNCell:()=>Up,multinomial:()=>jp,neg:()=>xp,norm:()=>Zd,notEqual:()=>Gp,oneHot:()=>Hp,ones:()=>Lp,onesLike:()=>qp,op:()=>Ll,outerProduct:()=>Kp,pad:()=>Xp,pad1d:()=>Qp,pad2d:()=>Yp,pad3d:()=>Zp,pad4d:()=>Jp,pool:()=>tf,pow:()=>xc,prelu:()=>nf,print:()=>tc,prod:()=>rf,raggedGather:()=>sf,raggedRange:()=>af,raggedTensorToTensor:()=>of,rand:()=>lf,randomGamma:()=>pf,randomNormal:()=>ff,randomStandardNormal:()=>mf,randomUniform:()=>gf,randomUniformInt:()=>yf,range:()=>bf,real:()=>vf,reciprocal:()=>xf,relu:()=>wf,relu6:()=>kf,reshape:()=>Hh,reverse:()=>Sf,reverse1d:()=>Nf,reverse2d:()=>If,reverse3d:()=>Cf,reverse4d:()=>Tf,rfft:()=>Gf,round:()=>Af,rsqrt:()=>Ef,scalar:()=>cc,scatterND:()=>vm,searchSorted:()=>$p,selu:()=>$f,separableConv2d:()=>Rf,setdiff1dAsync:()=>Df,sigmoid:()=>Yh,sign:()=>Of,signal:()=>_g,sin:()=>_f,sinh:()=>Ff,slice:()=>Zh,slice1d:()=>Mf,slice2d:()=>Lf,slice3d:()=>Pf,slice4d:()=>zf,softmax:()=>Bf,softplus:()=>wp,spaceToBatchND:()=>ef,sparse:()=>Pg,sparseToDense:()=>xm,spectral:()=>Og,split:()=>jf,sqrt:()=>ic,square:()=>oc,squaredDifference:()=>Hf,squeeze:()=>qf,stack:()=>Kf,step:()=>Xf,stridedSlice:()=>Qf,string:()=>zg,sub:()=>wc,sum:()=>Qd,tan:()=>Yf,tanh:()=>Jh,tensor:()=>Bl,tensor1d:()=>Zf,tensor2d:()=>Jf,tensor3d:()=>Jc,tensor4d:()=>em,tensor5d:()=>tm,tensor6d:()=>nm,tensorScatterUpdate:()=>im,tile:()=>rp,topk:()=>om,transpose:()=>ym,truncatedNormal:()=>lm,unique:()=>um,unsortedSegmentSum:()=>cm,unstack:()=>hm,upperBound:()=>dm,variable:()=>pm,where:()=>Od,whereAsync:()=>mm,zeros:()=>Mp,zerosLike:()=>lc});var C={};n.r(C),n.d(C,{mx:()=>QT,XI:()=>WA,Nk:()=>UA,f6:()=>GA,ct:()=>GT,YG:()=>XA,hH:()=>tE,z3:()=>zE,sG:()=>QE,uM:()=>t$,vS:()=>b$,qB:()=>C$,GG:()=>A$,lg:()=>O$,rq:()=>$$,cu:()=>H$,WR:()=>U$,GE:()=>X$,px:()=>Y$,jC:()=>dR,He:()=>mR,hE:()=>IR,BF:()=>RE,Dk:()=>FR,cl:()=>UR,_B:()=>nD,ub:()=>oD,_f:()=>cD,Ku:()=>gD,qy:()=>bD,Zy:()=>$D,bu:()=>OD,zv:()=>MT,dH:()=>aA,HS:()=>PA,yH:()=>JD,l3:()=>tO,z9:()=>rO,x6:()=>lO,_m:()=>mO,eW:()=>xO,GK:()=>SO,SP:()=>CO,yr:()=>AO,dl:()=>o$,Dw:()=>_O,xT:()=>PO,_X:()=>dA,wz:()=>GO});var T=n(43),A=n(391),E=(n(175),"popstate");function $(){return L((function(e,t){let{pathname:n,search:r,hash:s}=e.location;return _("",{pathname:n,search:r,hash:s},t.state&&t.state.usr||null,t.state&&t.state.key||"default")}),(function(e,t){return"string"===typeof t?t:F(t)}),null,arguments.length>0&&void 0!==arguments[0]?arguments[0]:{})}function R(e,t){if(!1===e||null===e||"undefined"===typeof e)throw new Error(t)}function D(e,t){if(!e){"undefined"!==typeof console&&console.warn(t);try{throw new Error(t)}catch(n){}}}function O(e,t){return{usr:e.state,key:e.key,idx:t}}function _(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3?arguments[3]:void 0;return{pathname:"string"===typeof e?e:e.pathname,search:"",hash:"",..."string"===typeof t?M(t):t,state:n,key:t&&t.key||r||Math.random().toString(36).substring(2,10)}}function F(e){let{pathname:t="/",search:n="",hash:r=""}=e;return n&&"?"!==n&&(t+="?"===n.charAt(0)?n:"?"+n),r&&"#"!==r&&(t+="#"===r.charAt(0)?r:"#"+r),t}function M(e){let t={};if(e){let n=e.indexOf("#");n>=0&&(t.hash=e.substring(n),e=e.substring(0,n));let r=e.indexOf("?");r>=0&&(t.search=e.substring(r),e=e.substring(0,r)),e&&(t.pathname=e)}return t}function L(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},{window:s=document.defaultView,v5Compat:a=!1}=r,i=s.history,o="POP",l=null,u=c();function c(){return(i.state||{idx:null}).idx}function h(){o="POP";let e=c(),t=null==e?null:e-u;u=e,l&&l({action:o,location:p.location,delta:t})}function d(e){let t="null"!==s.location.origin?s.location.origin:s.location.href,n="string"===typeof e?e:F(e);return n=n.replace(/ $/,"%20"),R(t,`No window.location.(origin|href) available to create URL for href: ${n}`),new URL(n,t)}null==u&&(u=0,i.replaceState({...i.state,idx:u},""));let p={get action(){return o},get location(){return e(s,i)},listen(e){if(l)throw new Error("A history only accepts one active listener");return s.addEventListener(E,h),l=e,()=>{s.removeEventListener(E,h),l=null}},createHref:e=>t(s,e),createURL:d,encodeLocation(e){let t=d(e);return{pathname:t.pathname,search:t.search,hash:t.hash}},push:function(e,t){o="PUSH";let r=_(p.location,e,t);n&&n(r,e),u=c()+1;let h=O(r,u),d=p.createHref(r);try{i.pushState(h,"",d)}catch(f){if(f instanceof DOMException&&"DataCloneError"===f.name)throw f;s.location.assign(d)}a&&l&&l({action:o,location:p.location,delta:1})},replace:function(e,t){o="REPLACE";let r=_(p.location,e,t);n&&n(r,e),u=c();let s=O(r,u),h=p.createHref(r);i.replaceState(s,"",h),a&&l&&l({action:o,location:p.location,delta:0})},go:e=>i.go(e)};return p}new WeakMap;function P(e,t){return z(e,t,arguments.length>2&&void 0!==arguments[2]?arguments[2]:"/",!1)}function z(e,t,n,r){let s=J(("string"===typeof t?M(t):t).pathname||"/",n);if(null==s)return null;let a=B(e);!function(e){e.sort(((e,t)=>e.score!==t.score?t.score-e.score:function(e,t){let n=e.length===t.length&&e.slice(0,-1).every(((e,n)=>e===t[n]));return n?e[e.length-1]-t[t.length-1]:0}(e.routesMeta.map((e=>e.childrenIndex)),t.routesMeta.map((e=>e.childrenIndex)))))}(a);let i=null;for(let o=0;null==i&&o<a.length;++o){let e=Z(s);i=Q(a[o],e,r)}return i}function B(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"",s=(e,s,a)=>{let i={relativePath:void 0===a?e.path||"":a,caseSensitive:!0===e.caseSensitive,childrenIndex:s,route:e};i.relativePath.startsWith("/")&&(R(i.relativePath.startsWith(r),`Absolute route path "${i.relativePath}" nested under path "${r}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`),i.relativePath=i.relativePath.slice(r.length));let o=se([r,i.relativePath]),l=n.concat(i);e.children&&e.children.length>0&&(R(!0!==e.index,`Index routes must not have child routes. Please remove all child routes from route path "${o}".`),B(e.children,t,l,o)),(null!=e.path||e.index)&&t.push({path:o,score:X(o,e.index),routesMeta:l})};return e.forEach(((e,t)=>{if(""!==e.path&&e.path?.includes("?"))for(let n of V(e.path))s(e,t,n);else s(e,t)})),t}function V(e){let t=e.split("/");if(0===t.length)return[];let[n,...r]=t,s=n.endsWith("?"),a=n.replace(/\?$/,"");if(0===r.length)return s?[a,""]:[a];let i=V(r.join("/")),o=[];return o.push(...i.map((e=>""===e?a:[a,e].join("/")))),s&&o.push(...i),o.map((t=>e.startsWith("/")&&""===t?"/":t))}var W=/^:[\w-]+$/,U=3,j=2,G=1,H=10,q=-2,K=e=>"*"===e;function X(e,t){let n=e.split("/"),r=n.length;return n.some(K)&&(r+=q),t&&(r+=j),n.filter((e=>!K(e))).reduce(((e,t)=>e+(W.test(t)?U:""===t?G:H)),r)}function Q(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],{routesMeta:r}=e,s={},a="/",i=[];for(let o=0;o<r.length;++o){let e=r[o],l=o===r.length-1,u="/"===a?t:t.slice(a.length)||"/",c=Y({path:e.relativePath,caseSensitive:e.caseSensitive,end:l},u),h=e.route;if(!c&&l&&n&&!r[r.length-1].route.index&&(c=Y({path:e.relativePath,caseSensitive:e.caseSensitive,end:!1},u)),!c)return null;Object.assign(s,c.params),i.push({params:s,pathname:se([a,c.pathname]),pathnameBase:ae(se([a,c.pathnameBase])),route:h}),"/"!==c.pathnameBase&&(a=se([a,c.pathnameBase]))}return i}function Y(e,t){"string"===typeof e&&(e={path:e,caseSensitive:!1,end:!0});let[n,r]=function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];D("*"===e||!e.endsWith("*")||e.endsWith("/*"),`Route path "${e}" will be treated as if it were "${e.replace(/\*$/,"/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${e.replace(/\*$/,"/*")}".`);let r=[],s="^"+e.replace(/\/*\*?$/,"").replace(/^\/*/,"/").replace(/[\\.*+^${}|()[\]]/g,"\\$&").replace(/\/:([\w-]+)(\?)?/g,((e,t,n)=>(r.push({paramName:t,isOptional:null!=n}),n?"/?([^\\/]+)?":"/([^\\/]+)")));e.endsWith("*")?(r.push({paramName:"*"}),s+="*"===e||"/*"===e?"(.*)$":"(?:\\/(.+)|\\/*)$"):n?s+="\\/*$":""!==e&&"/"!==e&&(s+="(?:(?=\\/|$))");let a=new RegExp(s,t?void 0:"i");return[a,r]}(e.path,e.caseSensitive,e.end),s=t.match(n);if(!s)return null;let a=s[0],i=a.replace(/(.)\/+$/,"$1"),o=s.slice(1),l=r.reduce(((e,t,n)=>{let{paramName:r,isOptional:s}=t;if("*"===r){let e=o[n]||"";i=a.slice(0,a.length-e.length).replace(/(.)\/+$/,"$1")}const l=o[n];return e[r]=s&&!l?void 0:(l||"").replace(/%2F/g,"/"),e}),{});return{params:l,pathname:a,pathnameBase:i,pattern:e}}function Z(e){try{return e.split("/").map((e=>decodeURIComponent(e).replace(/\//g,"%2F"))).join("/")}catch(t){return D(!1,`The URL path "${e}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${t}).`),e}}function J(e,t){if("/"===t)return e;if(!e.toLowerCase().startsWith(t.toLowerCase()))return null;let n=t.endsWith("/")?t.length-1:t.length,r=e.charAt(n);return r&&"/"!==r?null:e.slice(n)||"/"}function ee(e,t,n,r){return`Cannot include a '${e}' character in a manually specified \`to.${t}\` field [${JSON.stringify(r)}].  Please separate it out to the \`to.${n}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`}function te(e){return e.filter(((e,t)=>0===t||e.route.path&&e.route.path.length>0))}function ne(e){let t=te(e);return t.map(((e,n)=>n===t.length-1?e.pathname:e.pathnameBase))}function re(e,t,n){let r,s=arguments.length>3&&void 0!==arguments[3]&&arguments[3];"string"===typeof e?r=M(e):(r={...e},R(!r.pathname||!r.pathname.includes("?"),ee("?","pathname","search",r)),R(!r.pathname||!r.pathname.includes("#"),ee("#","pathname","hash",r)),R(!r.search||!r.search.includes("#"),ee("#","search","hash",r)));let a,i=""===e||""===r.pathname,o=i?"/":r.pathname;if(null==o)a=n;else{let e=t.length-1;if(!s&&o.startsWith("..")){let t=o.split("/");for(;".."===t[0];)t.shift(),e-=1;r.pathname=t.join("/")}a=e>=0?t[e]:"/"}let l=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"/",{pathname:n,search:r="",hash:s=""}="string"===typeof e?M(e):e,a=n?n.startsWith("/")?n:function(e,t){let n=t.replace(/\/+$/,"").split("/");return e.split("/").forEach((e=>{".."===e?n.length>1&&n.pop():"."!==e&&n.push(e)})),n.length>1?n.join("/"):"/"}(n,t):t;return{pathname:a,search:ie(r),hash:oe(s)}}(r,a),u=o&&"/"!==o&&o.endsWith("/"),c=(i||"."===o)&&n.endsWith("/");return l.pathname.endsWith("/")||!u&&!c||(l.pathname+="/"),l}var se=e=>e.join("/").replace(/\/\/+/g,"/"),ae=e=>e.replace(/\/+$/,"").replace(/^\/*/,"/"),ie=e=>e&&"?"!==e?e.startsWith("?")?e:"?"+e:"",oe=e=>e&&"#"!==e?e.startsWith("#")?e:"#"+e:"";function le(e){return null!=e&&"number"===typeof e.status&&"string"===typeof e.statusText&&"boolean"===typeof e.internal&&"data"in e}var ue=["POST","PUT","PATCH","DELETE"],ce=(new Set(ue),["GET",...ue]);new Set(ce),Symbol("ResetLoaderData");var he=T.createContext(null);he.displayName="DataRouter";var de=T.createContext(null);de.displayName="DataRouterState";var pe=T.createContext({isTransitioning:!1});pe.displayName="ViewTransition";var fe=T.createContext(new Map);fe.displayName="Fetchers";var me=T.createContext(null);me.displayName="Await";var ge=T.createContext(null);ge.displayName="Navigation";var ye=T.createContext(null);ye.displayName="Location";var be=T.createContext({outlet:null,matches:[],isDataRoute:!1});be.displayName="Route";var ve=T.createContext(null);ve.displayName="RouteError";function xe(){return null!=T.useContext(ye)}function we(){return R(xe(),"useLocation() may be used only in the context of a <Router> component."),T.useContext(ye).location}var ke="You should call navigate() in a React.useEffect(), not when your component is first rendered.";function Se(e){T.useContext(ge).static||T.useLayoutEffect(e)}function Ne(){let{isDataRoute:e}=T.useContext(be);return e?function(){let{router:e}=Oe("useNavigate"),t=Fe("useNavigate"),n=T.useRef(!1);Se((()=>{n.current=!0}));let r=T.useCallback((async function(r){let s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};D(n.current,ke),n.current&&("number"===typeof r?e.navigate(r):await e.navigate(r,{fromRouteId:t,...s}))}),[e,t]);return r}():function(){R(xe(),"useNavigate() may be used only in the context of a <Router> component.");let e=T.useContext(he),{basename:t,navigator:n}=T.useContext(ge),{matches:r}=T.useContext(be),{pathname:s}=we(),a=JSON.stringify(ne(r)),i=T.useRef(!1);Se((()=>{i.current=!0}));let o=T.useCallback((function(r){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(D(i.current,ke),!i.current)return;if("number"===typeof r)return void n.go(r);let l=re(r,JSON.parse(a),s,"path"===o.relative);null==e&&"/"!==t&&(l.pathname="/"===l.pathname?t:se([t,l.pathname])),(o.replace?n.replace:n.push)(l,o.state,o)}),[t,n,a,s,e]);return o}()}T.createContext(null);function Ie(e){let{relative:t}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{matches:n}=T.useContext(be),{pathname:r}=we(),s=JSON.stringify(ne(n));return T.useMemo((()=>re(e,JSON.parse(s),r,"path"===t)),[e,s,r,t])}function Ce(e,t,n,r){R(xe(),"useRoutes() may be used only in the context of a <Router> component.");let{navigator:s,static:a}=T.useContext(ge),{matches:i}=T.useContext(be),o=i[i.length-1],l=o?o.params:{},u=o?o.pathname:"/",c=o?o.pathnameBase:"/",h=o&&o.route;{let e=h&&h.path||"";Pe(u,!h||e.endsWith("*")||e.endsWith("*?"),`You rendered descendant <Routes> (or called \`useRoutes()\`) at "${u}" (under <Route path="${e}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.\n\nPlease change the parent <Route path="${e}"> to <Route path="${"/"===e?"*":`${e}/*`}">.`)}let d,p=we();if(t){let e="string"===typeof t?M(t):t;R("/"===c||e.pathname?.startsWith(c),`When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${c}" but pathname "${e.pathname}" was given in the \`location\` prop.`),d=e}else d=p;let f=d.pathname||"/",m=f;if("/"!==c){let e=c.replace(/^\//,"").split("/");m="/"+f.replace(/^\//,"").split("/").slice(e.length).join("/")}let g=!a&&n&&n.matches&&n.matches.length>0?n.matches:P(e,{pathname:m});D(h||null!=g,`No routes matched location "${d.pathname}${d.search}${d.hash}" `),D(null==g||void 0!==g[g.length-1].route.element||void 0!==g[g.length-1].route.Component||void 0!==g[g.length-1].route.lazy,`Matched leaf route at location "${d.pathname}${d.search}${d.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`);let y=Re(g&&g.map((e=>Object.assign({},e,{params:Object.assign({},l,e.params),pathname:se([c,s.encodeLocation?s.encodeLocation(e.pathname).pathname:e.pathname]),pathnameBase:"/"===e.pathnameBase?c:se([c,s.encodeLocation?s.encodeLocation(e.pathnameBase).pathname:e.pathnameBase])}))),i,n,r);return t&&y?T.createElement(ye.Provider,{value:{location:{pathname:"/",search:"",hash:"",state:null,key:"default",...d},navigationType:"POP"}},y):y}function Te(){let e=Me(),t=le(e)?`${e.status} ${e.statusText}`:e instanceof Error?e.message:JSON.stringify(e),n=e instanceof Error?e.stack:null,r="rgba(200,200,200, 0.5)",s={padding:"0.5rem",backgroundColor:r},a={padding:"2px 4px",backgroundColor:r},i=null;return console.error("Error handled by React Router default ErrorBoundary:",e),i=T.createElement(T.Fragment,null,T.createElement("p",null,"\ud83d\udcbf Hey developer \ud83d\udc4b"),T.createElement("p",null,"You can provide a way better UX than this when your app throws errors by providing your own ",T.createElement("code",{style:a},"ErrorBoundary")," or"," ",T.createElement("code",{style:a},"errorElement")," prop on your route.")),T.createElement(T.Fragment,null,T.createElement("h2",null,"Unexpected Application Error!"),T.createElement("h3",{style:{fontStyle:"italic"}},t),n?T.createElement("pre",{style:s},n):null,i)}var Ae=T.createElement(Te,null),Ee=class extends T.Component{constructor(e){super(e),this.state={location:e.location,revalidation:e.revalidation,error:e.error}}static getDerivedStateFromError(e){return{error:e}}static getDerivedStateFromProps(e,t){return t.location!==e.location||"idle"!==t.revalidation&&"idle"===e.revalidation?{error:e.error,location:e.location,revalidation:e.revalidation}:{error:void 0!==e.error?e.error:t.error,location:t.location,revalidation:e.revalidation||t.revalidation}}componentDidCatch(e,t){console.error("React Router caught the following error during render",e,t)}render(){return void 0!==this.state.error?T.createElement(be.Provider,{value:this.props.routeContext},T.createElement(ve.Provider,{value:this.state.error,children:this.props.component})):this.props.children}};function $e(e){let{routeContext:t,match:n,children:r}=e,s=T.useContext(he);return s&&s.static&&s.staticContext&&(n.route.errorElement||n.route.ErrorBoundary)&&(s.staticContext._deepestRenderedBoundaryId=n.route.id),T.createElement(be.Provider,{value:t},r)}function Re(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(null==e){if(!n)return null;if(n.errors)e=n.matches;else{if(0!==t.length||n.initialized||!(n.matches.length>0))return null;e=n.matches}}let r=e,s=n?.errors;if(null!=s){let e=r.findIndex((e=>e.route.id&&void 0!==s?.[e.route.id]));R(e>=0,`Could not find a matching route for errors on route IDs: ${Object.keys(s).join(",")}`),r=r.slice(0,Math.min(r.length,e+1))}let a=!1,i=-1;if(n)for(let o=0;o<r.length;o++){let e=r[o];if((e.route.HydrateFallback||e.route.hydrateFallbackElement)&&(i=o),e.route.id){let{loaderData:t,errors:s}=n,o=e.route.loader&&!t.hasOwnProperty(e.route.id)&&(!s||void 0===s[e.route.id]);if(e.route.lazy||o){a=!0,r=i>=0?r.slice(0,i+1):[r[0]];break}}}return r.reduceRight(((e,o,l)=>{let u,c=!1,h=null,d=null;n&&(u=s&&o.route.id?s[o.route.id]:void 0,h=o.route.errorElement||Ae,a&&(i<0&&0===l?(Pe("route-fallback",!1,"No `HydrateFallback` element provided to render during initial hydration"),c=!0,d=null):i===l&&(c=!0,d=o.route.hydrateFallbackElement||null)));let p=t.concat(r.slice(0,l+1)),f=()=>{let t;return t=u?h:c?d:o.route.Component?T.createElement(o.route.Component,null):o.route.element?o.route.element:e,T.createElement($e,{match:o,routeContext:{outlet:e,matches:p,isDataRoute:null!=n},children:t})};return n&&(o.route.ErrorBoundary||o.route.errorElement||0===l)?T.createElement(Ee,{location:n.location,revalidation:n.revalidation,component:h,error:u,children:f(),routeContext:{outlet:null,matches:p,isDataRoute:!0}}):f()}),null)}function De(e){return`${e} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`}function Oe(e){let t=T.useContext(he);return R(t,De(e)),t}function _e(e){let t=T.useContext(de);return R(t,De(e)),t}function Fe(e){let t=function(e){let t=T.useContext(be);return R(t,De(e)),t}(e),n=t.matches[t.matches.length-1];return R(n.route.id,`${e} can only be used on routes that contain a unique "id"`),n.route.id}function Me(){let e=T.useContext(ve),t=_e("useRouteError"),n=Fe("useRouteError");return void 0!==e?e:t.errors?.[n]}var Le={};function Pe(e,t,n){t||Le[e]||(Le[e]=!0,D(!1,n))}T.memo((function(e){let{routes:t,future:n,state:r}=e;return Ce(t,void 0,r,n)}));function ze(e){R(!1,"A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.")}function Be(e){let{basename:t="/",children:n=null,location:r,navigationType:s="POP",navigator:a,static:i=!1}=e;R(!xe(),"You cannot render a <Router> inside another <Router>. You should never have more than one in your app.");let o=t.replace(/^\/*/,"/"),l=T.useMemo((()=>({basename:o,navigator:a,static:i,future:{}})),[o,a,i]);"string"===typeof r&&(r=M(r));let{pathname:u="/",search:c="",hash:h="",state:d=null,key:p="default"}=r,f=T.useMemo((()=>{let e=J(u,o);return null==e?null:{location:{pathname:e,search:c,hash:h,state:d,key:p},navigationType:s}}),[o,u,c,h,d,p,s]);return D(null!=f,`<Router basename="${o}"> is not able to match the URL "${u}${c}${h}" because it does not start with the basename, so the <Router> won't render anything.`),null==f?null:T.createElement(ge.Provider,{value:l},T.createElement(ye.Provider,{children:n,value:f}))}function Ve(e){let{children:t,location:n}=e;return Ce(We(t),n)}T.Component;function We(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=[];return T.Children.forEach(e,((e,r)=>{if(!T.isValidElement(e))return;let s=[...t,r];if(e.type===T.Fragment)return void n.push.apply(n,We(e.props.children,s));R(e.type===ze,`[${"string"===typeof e.type?e.type:e.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`),R(!e.props.index||!e.props.children,"An index route cannot have child routes.");let a={id:e.props.id||s.join("-"),caseSensitive:e.props.caseSensitive,element:e.props.element,Component:e.props.Component,index:e.props.index,path:e.props.path,loader:e.props.loader,action:e.props.action,hydrateFallbackElement:e.props.hydrateFallbackElement,HydrateFallback:e.props.HydrateFallback,errorElement:e.props.errorElement,ErrorBoundary:e.props.ErrorBoundary,hasErrorBoundary:!0===e.props.hasErrorBoundary||null!=e.props.ErrorBoundary||null!=e.props.errorElement,shouldRevalidate:e.props.shouldRevalidate,handle:e.props.handle,lazy:e.props.lazy};e.props.children&&(a.children=We(e.props.children,s)),n.push(a)})),n}var Ue="get",je="application/x-www-form-urlencoded";function Ge(e){return null!=e&&"string"===typeof e.tagName}var He=null;var qe=new Set(["application/x-www-form-urlencoded","multipart/form-data","text/plain"]);function Ke(e){return null==e||qe.has(e)?e:(D(!1,`"${e}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${je}"`),null)}function Xe(e,t){let n,r,s,a,i;if(function(e){return Ge(e)&&"form"===e.tagName.toLowerCase()}(e)){let i=e.getAttribute("action");r=i?J(i,t):null,n=e.getAttribute("method")||Ue,s=Ke(e.getAttribute("enctype"))||je,a=new FormData(e)}else if(function(e){return Ge(e)&&"button"===e.tagName.toLowerCase()}(e)||function(e){return Ge(e)&&"input"===e.tagName.toLowerCase()}(e)&&("submit"===e.type||"image"===e.type)){let i=e.form;if(null==i)throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');let o=e.getAttribute("formaction")||i.getAttribute("action");if(r=o?J(o,t):null,n=e.getAttribute("formmethod")||i.getAttribute("method")||Ue,s=Ke(e.getAttribute("formenctype"))||Ke(i.getAttribute("enctype"))||je,a=new FormData(i,e),!function(){if(null===He)try{new FormData(document.createElement("form"),0),He=!1}catch(e){He=!0}return He}()){let{name:t,type:n,value:r}=e;if("image"===n){let e=t?`${t}.`:"";a.append(`${e}x`,"0"),a.append(`${e}y`,"0")}else t&&a.append(t,r)}}else{if(Ge(e))throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');n=Ue,r=null,s=je,i=e}return a&&"text/plain"===s&&(i=a,a=void 0),{action:r,method:n.toLowerCase(),encType:s,formData:a,body:i}}function Qe(e,t){if(!1===e||null===e||"undefined"===typeof e)throw new Error(t)}async function Ye(e,t){if(e.id in t)return t[e.id];try{let n=await import(e.module);return t[e.id]=n,n}catch(n){return console.error(`Error loading route module \`${e.module}\`, reloading page...`),console.error(n),window.__reactRouterContext&&window.__reactRouterContext.isSpaMode,window.location.reload(),new Promise((()=>{}))}}function Ze(e){return null!=e&&"string"===typeof e.page}function Je(e){return null!=e&&(null==e.href?"preload"===e.rel&&"string"===typeof e.imageSrcSet&&"string"===typeof e.imageSizes:"string"===typeof e.rel&&"string"===typeof e.href)}function et(e,t,n,r,s,a){let i=(e,t)=>!n[t]||e.route.id!==n[t].route.id,o=(e,t)=>n[t].pathname!==e.pathname||n[t].route.path?.endsWith("*")&&n[t].params["*"]!==e.params["*"];return"assets"===a?t.filter(((e,t)=>i(e,t)||o(e,t))):"data"===a?t.filter(((t,a)=>{let l=r.routes[t.route.id];if(!l||!l.hasLoader)return!1;if(i(t,a)||o(t,a))return!0;if(t.route.shouldRevalidate){let r=t.route.shouldRevalidate({currentUrl:new URL(s.pathname+s.search+s.hash,window.origin),currentParams:n[0]?.params||{},nextUrl:new URL(e,window.origin),nextParams:t.params,defaultShouldRevalidate:!0});if("boolean"===typeof r)return r}return!0})):[]}function tt(e,t){let{includeHydrateFallback:n}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return r=e.map((e=>{let r=t.routes[e.route.id];if(!r)return[];let s=[r.module];return r.clientActionModule&&(s=s.concat(r.clientActionModule)),r.clientLoaderModule&&(s=s.concat(r.clientLoaderModule)),n&&r.hydrateFallbackModule&&(s=s.concat(r.hydrateFallbackModule)),r.imports&&(s=s.concat(r.imports)),s})).flat(1),[...new Set(r)];var r}function nt(e,t){let n=new Set,r=new Set(t);return e.reduce(((e,s)=>{if(t&&!Ze(s)&&"script"===s.as&&s.href&&r.has(s.href))return e;let a=JSON.stringify(function(e){let t={},n=Object.keys(e).sort();for(let r of n)t[r]=e[r];return t}(s));return n.has(a)||(n.add(a),e.push({key:a,link:s})),e}),[])}function rt(e){return{__html:e}}Symbol("SingleFetchRedirect");function st(e,t){let n="string"===typeof e?new URL(e,"undefined"===typeof window?"server://singlefetch/":window.location.origin):e;return"/"===n.pathname?n.pathname="_root.data":t&&"/"===J(n.pathname,t)?n.pathname=`${t.replace(/\/$/,"")}/_root.data`:n.pathname=`${n.pathname.replace(/\/$/,"")}.data`,n}T.Component;function at(e){let{error:t,isOutsideRemixApp:n}=e;console.error(t);let r,s=T.createElement("script",{dangerouslySetInnerHTML:{__html:'\n        console.log(\n          "\ud83d\udcbf Hey developer \ud83d\udc4b. You can provide a way better UX than this when your app throws errors. Check out https://remix.run/guides/errors for more information."\n        );\n      '}});if(le(t))return T.createElement(it,{title:"Unhandled Thrown Response!"},T.createElement("h1",{style:{fontSize:"24px"}},t.status," ",t.statusText),s);if(t instanceof Error)0;else{let e=null==t?"Unknown Error":"object"===typeof t&&"toString"in t?t.toString():JSON.stringify(t);new Error(e)}return T.createElement(it,{title:"Application Error!",isOutsideRemixApp:n},T.createElement("h1",{style:{fontSize:"24px"}},"Application Error"),T.createElement("pre",{style:{padding:"2rem",background:"hsla(10, 50%, 50%, 0.1)",color:"red",overflow:"auto"}},r.stack),s)}function it(e){let{title:t,renderScripts:n,isOutsideRemixApp:r,children:s}=e,{routeModules:a}=ht();return a.root?.Layout&&!r?s:T.createElement("html",{lang:"en"},T.createElement("head",null,T.createElement("meta",{charSet:"utf-8"}),T.createElement("meta",{name:"viewport",content:"width=device-width,initial-scale=1,viewport-fit=cover"}),T.createElement("title",null,t)),T.createElement("body",null,T.createElement("main",{style:{fontFamily:"system-ui, sans-serif",padding:"2rem"}},s,n?T.createElement(bt,null):null)))}function ot(e){return!0===e}function lt(){let e=T.useContext(he);return Qe(e,"You must render this element inside a <DataRouterContext.Provider> element"),e}function ut(){let e=T.useContext(de);return Qe(e,"You must render this element inside a <DataRouterStateContext.Provider> element"),e}var ct=T.createContext(void 0);function ht(){let e=T.useContext(ct);return Qe(e,"You must render this element inside a <HydratedRouter> element"),e}function dt(e,t){return n=>{e&&e(n),n.defaultPrevented||t(n)}}function pt(e,t,n){if(n&&!yt)return[e[0]];if(t){let n=e.findIndex((e=>void 0!==t[e.route.id]));return e.slice(0,n+1)}return e}function ft(e){let{page:t,...n}=e,{router:r}=lt(),s=T.useMemo((()=>P(r.routes,t,r.basename)),[r.routes,t,r.basename]);return s?T.createElement(gt,{page:t,matches:s,...n}):null}function mt(e){let{manifest:t,routeModules:n}=ht(),[r,s]=T.useState([]);return T.useEffect((()=>{let r=!1;return async function(e,t,n){let r=await Promise.all(e.map((async e=>{let r=t.routes[e.route.id];if(r){let e=await Ye(r,n);return e.links?e.links():[]}return[]})));return nt(r.flat(1).filter(Je).filter((e=>"stylesheet"===e.rel||"preload"===e.rel)).map((e=>"stylesheet"===e.rel?{...e,rel:"prefetch",as:"style"}:{...e,rel:"prefetch"})))}(e,t,n).then((e=>{r||s(e)})),()=>{r=!0}}),[e,t,n]),r}function gt(e){let{page:t,matches:n,...r}=e,s=we(),{manifest:a,routeModules:i}=ht(),{basename:o}=lt(),{loaderData:l,matches:u}=ut(),c=T.useMemo((()=>et(t,n,u,a,s,"data")),[t,n,u,a,s]),h=T.useMemo((()=>et(t,n,u,a,s,"assets")),[t,n,u,a,s]),d=T.useMemo((()=>{if(t===s.pathname+s.search+s.hash)return[];let e=new Set,r=!1;if(n.forEach((t=>{let n=a.routes[t.route.id];n&&n.hasLoader&&(!c.some((e=>e.route.id===t.route.id))&&t.route.id in l&&i[t.route.id]?.shouldRevalidate||n.hasClientLoader?r=!0:e.add(t.route.id))})),0===e.size)return[];let u=st(t,o);return r&&e.size>0&&u.searchParams.set("_routes",n.filter((t=>e.has(t.route.id))).map((e=>e.route.id)).join(",")),[u.pathname+u.search]}),[o,l,s,a,c,n,t,i]),p=T.useMemo((()=>tt(h,a)),[h,a]),f=mt(h);return T.createElement(T.Fragment,null,d.map((e=>T.createElement("link",{key:e,rel:"prefetch",as:"fetch",href:e,...r}))),p.map((e=>T.createElement("link",{key:e,rel:"modulepreload",href:e,...r}))),f.map((e=>{let{key:t,link:n}=e;return T.createElement("link",{key:t,...n})})))}ct.displayName="FrameworkContext";var yt=!1;function bt(e){let{manifest:t,serverHandoffString:n,isSpaMode:r,ssr:s,renderMeta:a}=ht(),{router:i,static:o,staticContext:l}=lt(),{matches:u}=ut(),c=ot(s);a&&(a.didRenderScripts=!0);let h=pt(u,null,r);T.useEffect((()=>{0}),[]);let d=T.useMemo((()=>{let r=l?`window.__reactRouterContext = ${n};window.__reactRouterContext.stream = new ReadableStream({start(controller){window.__reactRouterContext.streamController = controller;}}).pipeThrough(new TextEncoderStream());`:" ",s=o?`${t.hmr?.runtime?`import ${JSON.stringify(t.hmr.runtime)};`:""}${c?"":`import ${JSON.stringify(t.url)}`};\n${h.map(((e,n)=>{let r=`route${n}`,s=t.routes[e.route.id];Qe(s,`Route ${e.route.id} not found in manifest`);let{clientActionModule:a,clientLoaderModule:i,clientMiddlewareModule:o,hydrateFallbackModule:l,module:u}=s,c=[...a?[{module:a,varName:`${r}_clientAction`}]:[],...i?[{module:i,varName:`${r}_clientLoader`}]:[],...o?[{module:o,varName:`${r}_clientMiddleware`}]:[],...l?[{module:l,varName:`${r}_HydrateFallback`}]:[],{module:u,varName:`${r}_main`}];return 1===c.length?`import * as ${r} from ${JSON.stringify(u)};`:[c.map((e=>`import * as ${e.varName} from "${e.module}";`)).join("\n"),`const ${r} = {${c.map((e=>`...${e.varName}`)).join(",")}};`].join("\n")})).join("\n")}\n  ${c?`window.__reactRouterManifest = ${JSON.stringify(function(e,t){let n=new Set(t.state.matches.map((e=>e.route.id))),r=t.state.location.pathname.split("/").filter(Boolean),s=["/"];for(r.pop();r.length>0;)s.push(`/${r.join("/")}`),r.pop();s.forEach((e=>{let r=P(t.routes,e,t.basename);r&&r.forEach((e=>n.add(e.route.id)))}));let a=[...n].reduce(((t,n)=>Object.assign(t,{[n]:e.routes[n]})),{});return{...e,routes:a}}(t,i),null,2)};`:""}\n  window.__reactRouterRouteModules = {${h.map(((e,t)=>`${JSON.stringify(e.route.id)}:route${t}`)).join(",")}};\n\nimport(${JSON.stringify(t.entry.module)});`:" ";return T.createElement(T.Fragment,null,T.createElement("script",{...e,suppressHydrationWarning:!0,dangerouslySetInnerHTML:rt(r),type:void 0}),T.createElement("script",{...e,suppressHydrationWarning:!0,dangerouslySetInnerHTML:rt(s),type:"module",async:!0}))}),[]),p=yt?[]:t.entry.imports.concat(tt(h,t,{includeHydrateFallback:!0}));return yt?null:T.createElement(T.Fragment,null,c?null:T.createElement("link",{rel:"modulepreload",href:t.url,crossOrigin:e.crossOrigin}),T.createElement("link",{rel:"modulepreload",href:t.entry.module,crossOrigin:e.crossOrigin}),function(e){return[...new Set(e)]}(p).map((t=>T.createElement("link",{key:t,rel:"modulepreload",href:t,crossOrigin:e.crossOrigin}))),d)}function vt(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return e=>{t.forEach((t=>{"function"===typeof t?t(e):null!=t&&(t.current=e)}))}}var xt="undefined"!==typeof window&&"undefined"!==typeof window.document&&"undefined"!==typeof window.document.createElement;try{xt&&(window.__reactRouterVersion="7.4.1")}catch(E9){}function wt(e){let{basename:t,children:n,window:r}=e,s=T.useRef();null==s.current&&(s.current=$({window:r,v5Compat:!0}));let a=s.current,[i,o]=T.useState({action:a.action,location:a.location}),l=T.useCallback((e=>{T.startTransition((()=>o(e)))}),[o]);return T.useLayoutEffect((()=>a.listen(l)),[a,l]),T.createElement(Be,{basename:t,children:n,location:i.location,navigationType:i.action,navigator:a})}var kt=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,St=T.forwardRef((function(e,t){let n,{onClick:r,discover:s="render",prefetch:a="none",relative:i,reloadDocument:o,replace:l,state:u,target:c,to:h,preventScrollReset:d,viewTransition:p,...f}=e,{basename:m}=T.useContext(ge),g="string"===typeof h&&kt.test(h),y=!1;if("string"===typeof h&&g&&(n=h,xt))try{let e=new URL(window.location.href),t=h.startsWith("//")?new URL(e.protocol+h):new URL(h),n=J(t.pathname,m);t.origin===e.origin&&null!=n?h=n+t.search+t.hash:y=!0}catch(E9){D(!1,`<Link to="${h}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`)}let b=function(e){let{relative:t}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};R(xe(),"useHref() may be used only in the context of a <Router> component.");let{basename:n,navigator:r}=T.useContext(ge),{hash:s,pathname:a,search:i}=Ie(e,{relative:t}),o=a;return"/"!==n&&(o="/"===a?n:se([n,a])),r.createHref({pathname:o,search:i,hash:s})}(h,{relative:i}),[v,x,w]=function(e,t){let n=T.useContext(ct),[r,s]=T.useState(!1),[a,i]=T.useState(!1),{onFocus:o,onBlur:l,onMouseEnter:u,onMouseLeave:c,onTouchStart:h}=t,d=T.useRef(null);T.useEffect((()=>{if("render"===e&&i(!0),"viewport"===e){let e=new IntersectionObserver((e=>{e.forEach((e=>{i(e.isIntersecting)}))}),{threshold:.5});return d.current&&e.observe(d.current),()=>{e.disconnect()}}}),[e]),T.useEffect((()=>{if(r){let e=setTimeout((()=>{i(!0)}),100);return()=>{clearTimeout(e)}}}),[r]);let p=()=>{s(!0)},f=()=>{s(!1),i(!1)};return n?"intent"!==e?[a,d,{}]:[a,d,{onFocus:dt(o,p),onBlur:dt(l,f),onMouseEnter:dt(u,p),onMouseLeave:dt(c,f),onTouchStart:dt(h,p)}]:[!1,d,{}]}(a,f),k=function(e){let{target:t,replace:n,state:r,preventScrollReset:s,relative:a,viewTransition:i}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},o=Ne(),l=we(),u=Ie(e,{relative:a});return T.useCallback((c=>{if(function(e,t){return 0===e.button&&(!t||"_self"===t)&&!function(e){return!!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey)}(e)}(c,t)){c.preventDefault();let t=void 0!==n?n:F(l)===F(u);o(e,{replace:t,state:r,preventScrollReset:s,relative:a,viewTransition:i})}}),[l,o,u,n,r,t,e,s,a,i])}(h,{replace:l,state:u,target:c,preventScrollReset:d,relative:i,viewTransition:p});let S=T.createElement("a",{...f,...w,href:n||b,onClick:y||o?r:function(e){r&&r(e),e.defaultPrevented||k(e)},ref:vt(t,x),target:c,"data-discover":g||"render"!==s?void 0:"true"});return v&&!g?T.createElement(T.Fragment,null,S,T.createElement(ft,{page:b})):S}));St.displayName="Link";var Nt=T.forwardRef((function(e,t){let{"aria-current":n="page",caseSensitive:r=!1,className:s="",end:a=!1,style:i,to:o,viewTransition:l,children:u,...c}=e,h=Ie(o,{relative:c.relative}),d=we(),p=T.useContext(de),{navigator:f,basename:m}=T.useContext(ge),g=null!=p&&function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=T.useContext(pe);R(null!=n,"`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?");let{basename:r}=Tt("useViewTransitionState"),s=Ie(e,{relative:t.relative});if(!n.isTransitioning)return!1;let a=J(n.currentLocation.pathname,r)||n.currentLocation.pathname,i=J(n.nextLocation.pathname,r)||n.nextLocation.pathname;return null!=Y(s.pathname,i)||null!=Y(s.pathname,a)}(h)&&!0===l,y=f.encodeLocation?f.encodeLocation(h).pathname:h.pathname,b=d.pathname,v=p&&p.navigation&&p.navigation.location?p.navigation.location.pathname:null;r||(b=b.toLowerCase(),v=v?v.toLowerCase():null,y=y.toLowerCase()),v&&m&&(v=J(v,m)||v);const x="/"!==y&&y.endsWith("/")?y.length-1:y.length;let w,k=b===y||!a&&b.startsWith(y)&&"/"===b.charAt(x),S=null!=v&&(v===y||!a&&v.startsWith(y)&&"/"===v.charAt(y.length)),N={isActive:k,isPending:S,isTransitioning:g},I=k?n:void 0;w="function"===typeof s?s(N):[s,k?"active":null,S?"pending":null,g?"transitioning":null].filter(Boolean).join(" ");let C="function"===typeof i?i(N):i;return T.createElement(St,{...c,"aria-current":I,className:w,ref:t,style:C,to:o,viewTransition:l},"function"===typeof u?u(N):u)}));Nt.displayName="NavLink";var It=T.forwardRef(((e,t)=>{let{discover:n="render",fetcherKey:r,navigate:s,reloadDocument:a,replace:i,state:o,method:l=Ue,action:u,onSubmit:c,relative:h,preventScrollReset:d,viewTransition:p,...f}=e,m=$t(),g=function(e){let{relative:t}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{basename:n}=T.useContext(ge),r=T.useContext(be);R(r,"useFormAction must be used inside a RouteContext");let[s]=r.matches.slice(-1),a={...Ie(e||".",{relative:t})},i=we();if(null==e){a.search=i.search;let e=new URLSearchParams(a.search),t=e.getAll("index");if(t.some((e=>""===e))){e.delete("index"),t.filter((e=>e)).forEach((t=>e.append("index",t)));let n=e.toString();a.search=n?`?${n}`:""}}e&&"."!==e||!s.route.index||(a.search=a.search?a.search.replace(/^\?/,"?index&"):"?index");"/"!==n&&(a.pathname="/"===a.pathname?n:se([n,a.pathname]));return F(a)}(u,{relative:h}),y="get"===l.toLowerCase()?"get":"post",b="string"===typeof u&&kt.test(u);return T.createElement("form",{ref:t,method:y,action:g,onSubmit:a?c:e=>{if(c&&c(e),e.defaultPrevented)return;e.preventDefault();let t=e.nativeEvent.submitter,n=t?.getAttribute("formmethod")||l;m(t||e.currentTarget,{fetcherKey:r,method:n,navigate:s,replace:i,state:o,relative:h,preventScrollReset:d,viewTransition:p})},...f,"data-discover":b||"render"!==n?void 0:"true"})}));function Ct(e){return`${e} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`}function Tt(e){let t=T.useContext(he);return R(t,Ct(e)),t}It.displayName="Form";var At=0,Et=()=>`__${String(++At)}__`;function $t(){let{router:e}=Tt("useSubmit"),{basename:t}=T.useContext(ge),n=Fe("useRouteId");return T.useCallback((async function(r){let s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{action:a,method:i,encType:o,formData:l,body:u}=Xe(r,t);if(!1===s.navigate){let t=s.fetcherKey||Et();await e.fetch(t,n,s.action||a,{preventScrollReset:s.preventScrollReset,formData:l,body:u,formMethod:s.method||i,formEncType:s.encType||o,flushSync:s.flushSync})}else await e.navigate(s.action||a,{preventScrollReset:s.preventScrollReset,formData:l,body:u,formMethod:s.method||i,formEncType:s.encType||o,replace:s.replace,state:s.state,fromRouteId:n,flushSync:s.flushSync,viewTransition:s.viewTransition})}),[e,t,n])}new TextEncoder;const Rt=["/","/about","/datasets","/visualisation"];var Dt={color:void 0,size:void 0,className:void 0,style:void 0,attr:void 0},Ot=T.createContext&&T.createContext(Dt),_t=["attr","size","title"];function Ft(e,t){if(null==e)return{};var n,r,s=function(e,t){if(null==e)return{};var n={};for(var r in e)if(Object.prototype.hasOwnProperty.call(e,r)){if(t.indexOf(r)>=0)continue;n[r]=e[r]}return n}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}function Mt(){return Mt=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},Mt.apply(this,arguments)}function Lt(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function Pt(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?Lt(Object(n),!0).forEach((function(t){zt(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):Lt(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function zt(e,t,n){return t=function(e){var t=function(e,t){if("object"!=typeof e||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var r=n.call(e,t||"default");if("object"!=typeof r)return r;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"==typeof t?t:t+""}(t),t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function Bt(e){return e&&e.map(((e,t)=>T.createElement(e.tag,Pt({key:t},e.attr),Bt(e.child))))}function Vt(e){return t=>T.createElement(Wt,Mt({attr:Pt({},e.attr)},t),Bt(e.child))}function Wt(e){var t=t=>{var n,{attr:r,size:s,title:a}=e,i=Ft(e,_t),o=s||t.size||"1em";return t.className&&(n=t.className),e.className&&(n=(n?n+" ":"")+e.className),T.createElement("svg",Mt({stroke:"currentColor",fill:"currentColor",strokeWidth:"0"},t.attr,r,i,{className:n,style:Pt(Pt({color:e.color||t.color},t.style),e.style),height:o,width:o,xmlns:"http://www.w3.org/2000/svg"}),a&&T.createElement("title",null,a),e.children)};return void 0!==Ot?T.createElement(Ot.Consumer,null,(e=>t(e))):t(Dt)}function Ut(e){return Vt({tag:"svg",attr:{viewBox:"0 0 16 16",fill:"currentColor"},child:[{tag:"path",attr:{d:"M8.08074 5.36891L10.2202 7.50833L4.46802 7.50833L4.46802 8.50833L10.1473 8.50833L8.08073 10.5749L8.78784 11.282L11.7444 8.32545L11.7444 7.61835L8.78784 4.6618L8.08074 5.36891Z"},child:[]},{tag:"path",attr:{d:"M8 14C4.68629 14 2 11.3137 2 8C2 4.68629 4.68629 2 8 2C11.3137 2 14 4.68629 14 8C14 11.3137 11.3137 14 8 14ZM8 13C10.7614 13 13 10.7614 13 8C13 5.23858 10.7614 3 8 3C5.23858 3 3 5.23858 3 8C3 10.7614 5.23858 13 8 13Z"},child:[]}]})(e)}function jt(e){return Vt({tag:"svg",attr:{viewBox:"0 0 16 16",fill:"currentColor"},child:[{tag:"path",attr:{fillRule:"evenodd",clipRule:"evenodd",d:"M8 8.707l3.646 3.647.708-.707L8.707 8l3.647-3.646-.707-.708L8 7.293 4.354 3.646l-.707.708L7.293 8l-3.646 3.646.707.708L8 8.707z"},child:[]}]})(e)}function Gt(e){return Vt({tag:"svg",attr:{viewBox:"0 0 24 24",fill:"currentColor"},child:[{tag:"path",attr:{d:"M12 0a12 12 0 1 0 0 24 12 12 0 0 0 0-24zm3.163 21.783h-.093a.513.513 0 0 1-.382-.14.513.513 0 0 1-.14-.372v-1.406c.006-.467.01-.94.01-1.416a3.693 3.693 0 0 0-.151-1.028 1.832 1.832 0 0 0-.542-.875 8.014 8.014 0 0 0 2.038-.471 4.051 4.051 0 0 0 1.466-.964c.407-.427.71-.943.885-1.506a6.77 6.77 0 0 0 .3-2.13 4.138 4.138 0 0 0-.26-1.476 3.892 3.892 0 0 0-.795-1.284 2.81 2.81 0 0 0 .162-.582c.033-.2.05-.402.05-.604 0-.26-.03-.52-.09-.773a5.309 5.309 0 0 0-.221-.763.293.293 0 0 0-.111-.02h-.11c-.23.002-.456.04-.674.111a5.34 5.34 0 0 0-.703.26 6.503 6.503 0 0 0-.661.343c-.215.127-.405.249-.573.362a9.578 9.578 0 0 0-5.143 0 13.507 13.507 0 0 0-.572-.362 6.022 6.022 0 0 0-.672-.342 4.516 4.516 0 0 0-.705-.261 2.203 2.203 0 0 0-.662-.111h-.11a.29.29 0 0 0-.11.02 5.844 5.844 0 0 0-.23.763c-.054.254-.08.513-.081.773 0 .202.017.404.051.604.033.199.086.394.16.582A3.888 3.888 0 0 0 5.702 10a4.142 4.142 0 0 0-.263 1.476 6.871 6.871 0 0 0 .292 2.12c.181.563.483 1.08.884 1.516.415.422.915.75 1.466.964.653.25 1.337.41 2.033.476a1.828 1.828 0 0 0-.452.633 2.99 2.99 0 0 0-.2.744 2.754 2.754 0 0 1-1.175.27 1.788 1.788 0 0 1-1.065-.3 2.904 2.904 0 0 1-.752-.824 3.1 3.1 0 0 0-.292-.382 2.693 2.693 0 0 0-.372-.343 1.841 1.841 0 0 0-.432-.24 1.2 1.2 0 0 0-.481-.101c-.04.001-.08.005-.12.01a.649.649 0 0 0-.162.02.408.408 0 0 0-.13.06.116.116 0 0 0-.06.1.33.33 0 0 0 .14.242c.093.074.17.131.232.171l.03.021c.133.103.261.214.382.333.112.098.213.209.3.33.09.119.168.246.231.381.073.134.15.288.231.463.188.474.522.875.954 1.145.453.243.961.364 1.476.351.174 0 .349-.01.522-.03.172-.028.343-.057.515-.091v1.743a.5.5 0 0 1-.533.521h-.062a10.286 10.286 0 1 1 6.324 0v.005z"},child:[]}]})(e)}n(844);Object.create(null);const Ht={},qt=(e,t,n,r)=>{Yt(n)&&Ht[n]||(Yt(n)&&(Ht[n]=new Date),((e,t,n,r)=>{const s=[n,{code:t,...r||{}}];if(e?.services?.logger?.forward)return e.services.logger.forward(s,"warn","react-i18next::",!0);Yt(s[0])&&(s[0]=`react-i18next:: ${s[0]}`),e?.services?.logger?.warn?e.services.logger.warn(...s):console?.warn&&console.warn(...s)})(e,t,n,r))},Kt=(e,t)=>()=>{if(e.isInitialized)t();else{const n=()=>{setTimeout((()=>{e.off("initialized",n)}),0),t()};e.on("initialized",n)}},Xt=(e,t,n)=>{e.loadNamespaces(t,Kt(e,n))},Qt=(e,t,n,r)=>{if(Yt(n)&&(n=[n]),e.options.preload&&e.options.preload.indexOf(t)>-1)return Xt(e,n,r);n.forEach((t=>{e.options.ns.indexOf(t)<0&&e.options.ns.push(t)})),e.loadLanguages(t,Kt(e,r))},Yt=e=>"string"===typeof e,Zt=/&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g,Jt={"&amp;":"&","&#38;":"&","&lt;":"<","&#60;":"<","&gt;":">","&#62;":">","&apos;":"'","&#39;":"'","&quot;":'"',"&#34;":'"',"&nbsp;":" ","&#160;":" ","&copy;":"\xa9","&#169;":"\xa9","&reg;":"\xae","&#174;":"\xae","&hellip;":"\u2026","&#8230;":"\u2026","&#x2F;":"/","&#47;":"/"},en=e=>Jt[e];let tn={bindI18n:"languageChanged",bindI18nStore:"",transEmptyNodeValue:"",transSupportBasicHtmlNodes:!0,transWrapTextNodes:"",transKeepBasicHtmlNodesFor:["br","strong","i","p"],useSuspense:!0,unescape:e=>e.replace(Zt,en)};let nn;const rn={type:"3rdParty",init(e){!function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};tn={...tn,...e}}(e.options.react),(e=>{nn=e})(e)}},sn=(0,T.createContext)();class an{constructor(){this.usedNamespaces={}}addUsedNamespaces(e){e.forEach((e=>{this.usedNamespaces[e]||(this.usedNamespaces[e]=!0)}))}getUsedNamespaces(){return Object.keys(this.usedNamespaces)}}const on=(e,t,n,r)=>e.getFixedT(t,n,r),ln=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{i18n:n}=t,{i18n:r,defaultNS:s}=(0,T.useContext)(sn)||{},a=n||r||nn;if(a&&!a.reportNamespaces&&(a.reportNamespaces=new an),!a){qt(a,"NO_I18NEXT_INSTANCE","useTranslation: You will need to pass in an i18next instance by using initReactI18next");const e=(e,t)=>{return Yt(t)?t:"object"===typeof(n=t)&&null!==n&&Yt(t.defaultValue)?t.defaultValue:Array.isArray(e)?e[e.length-1]:e;var n},t=[e,{},!1];return t.t=e,t.i18n={},t.ready=!1,t}a.options.react?.wait&&qt(a,"DEPRECATED_OPTION","useTranslation: It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");const i={...tn,...a.options.react,...t},{useSuspense:o,keyPrefix:l}=i;let u=e||s||a.options?.defaultNS;u=Yt(u)?[u]:u||["translation"],a.reportNamespaces.addUsedNamespaces?.(u);const c=(a.isInitialized||a.initializedStoreOnce)&&u.every((e=>function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return t.languages&&t.languages.length?t.hasLoadedNamespace(e,{lng:n.lng,precheck:(t,r)=>{if(n.bindI18n?.indexOf("languageChanging")>-1&&t.services.backendConnector.backend&&t.isLanguageChangingTo&&!r(t.isLanguageChangingTo,e))return!1}}):(qt(t,"NO_LANGUAGES","i18n.languages were undefined or empty",{languages:t.languages}),!0)}(e,a,i))),h=((e,t,n,r)=>(0,T.useCallback)(on(e,t,n,r),[e,t,n,r]))(a,t.lng||null,"fallback"===i.nsMode?u:u[0],l),d=()=>h,p=()=>on(a,t.lng||null,"fallback"===i.nsMode?u:u[0],l),[f,m]=(0,T.useState)(d);let g=u.join();t.lng&&(g=`${t.lng}${g}`);const y=((e,t)=>{const n=(0,T.useRef)();return(0,T.useEffect)((()=>{n.current=t?n.current:e}),[e,t]),n.current})(g),b=(0,T.useRef)(!0);(0,T.useEffect)((()=>{const{bindI18n:e,bindI18nStore:n}=i;b.current=!0,c||o||(t.lng?Qt(a,t.lng,u,(()=>{b.current&&m(p)})):Xt(a,u,(()=>{b.current&&m(p)}))),c&&y&&y!==g&&b.current&&m(p);const r=()=>{b.current&&m(p)};return e&&a?.on(e,r),n&&a?.store.on(n,r),()=>{b.current=!1,a&&e?.split(" ").forEach((e=>a.off(e,r))),n&&a&&n.split(" ").forEach((e=>a.store.off(e,r)))}}),[a,g]),(0,T.useEffect)((()=>{b.current&&c&&m(d)}),[a,l,c]);const v=[f,a,c];if(v.t=f,v.i18n=a,v.ready=c,c)return v;if(!c&&!o)return v;throw new Promise((e=>{t.lng?Qt(a,t.lng,u,(()=>e())):Xt(a,u,(()=>e()))}))};const un=e=>"string"===typeof e,cn=()=>{let e,t;const n=new Promise(((n,r)=>{e=n,t=r}));return n.resolve=e,n.reject=t,n},hn=e=>null==e?"":""+e,dn=/###/g,pn=e=>e&&e.indexOf("###")>-1?e.replace(dn,"."):e,fn=e=>!e||un(e),mn=(e,t,n)=>{const r=un(t)?t.split("."):t;let s=0;for(;s<r.length-1;){if(fn(e))return{};const t=pn(r[s]);!e[t]&&n&&(e[t]=new n),e=Object.prototype.hasOwnProperty.call(e,t)?e[t]:{},++s}return fn(e)?{}:{obj:e,k:pn(r[s])}},gn=(e,t,n)=>{const{obj:r,k:s}=mn(e,t,Object);if(void 0!==r||1===t.length)return void(r[s]=n);let a=t[t.length-1],i=t.slice(0,t.length-1),o=mn(e,i,Object);for(;void 0===o.obj&&i.length;)a=`${i[i.length-1]}.${a}`,i=i.slice(0,i.length-1),o=mn(e,i,Object),o&&o.obj&&"undefined"!==typeof o.obj[`${o.k}.${a}`]&&(o.obj=void 0);o.obj[`${o.k}.${a}`]=n},yn=(e,t)=>{const{obj:n,k:r}=mn(e,t);if(n)return n[r]},bn=(e,t,n)=>{for(const r in t)"__proto__"!==r&&"constructor"!==r&&(r in e?un(e[r])||e[r]instanceof String||un(t[r])||t[r]instanceof String?n&&(e[r]=t[r]):bn(e[r],t[r],n):e[r]=t[r]);return e},vn=e=>e.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g,"\\$&");var xn={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;","/":"&#x2F;"};const wn=e=>un(e)?e.replace(/[&<>"'\/]/g,(e=>xn[e])):e;const kn=[" ",",","?","!",";"],Sn=new class{constructor(e){this.capacity=e,this.regExpMap=new Map,this.regExpQueue=[]}getRegExp(e){const t=this.regExpMap.get(e);if(void 0!==t)return t;const n=new RegExp(e);return this.regExpQueue.length===this.capacity&&this.regExpMap.delete(this.regExpQueue.shift()),this.regExpMap.set(e,n),this.regExpQueue.push(e),n}}(20),Nn=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:".";if(!e)return;if(e[t])return e[t];const r=t.split(n);let s=e;for(let a=0;a<r.length;){if(!s||"object"!==typeof s)return;let e,t="";for(let i=a;i<r.length;++i)if(i!==a&&(t+=n),t+=r[i],e=s[t],void 0!==e){if(["string","number","boolean"].indexOf(typeof e)>-1&&i<r.length-1)continue;a+=i-a+1;break}s=e}return s},In=e=>e&&e.replace("_","-"),Cn={type:"logger",log(e){this.output("log",e)},warn(e){this.output("warn",e)},error(e){this.output("error",e)},output(e,t){console&&console[e]&&console[e].apply(console,t)}};class Tn{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.init(e,t)}init(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.prefix=t.prefix||"i18next:",this.logger=e||Cn,this.options=t,this.debug=t.debug}log(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return this.forward(t,"log","",!0)}warn(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return this.forward(t,"warn","",!0)}error(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return this.forward(t,"error","")}deprecate(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return this.forward(t,"warn","WARNING DEPRECATED: ",!0)}forward(e,t,n,r){return r&&!this.debug?null:(un(e[0])&&(e[0]=`${n}${this.prefix} ${e[0]}`),this.logger[t](e))}create(e){return new Tn(this.logger,{prefix:`${this.prefix}:${e}:`,...this.options})}clone(e){return(e=e||this.options).prefix=e.prefix||this.prefix,new Tn(this.logger,e)}}var An=new Tn;class En{constructor(){this.observers={}}on(e,t){return e.split(" ").forEach((e=>{this.observers[e]||(this.observers[e]=new Map);const n=this.observers[e].get(t)||0;this.observers[e].set(t,n+1)})),this}off(e,t){this.observers[e]&&(t?this.observers[e].delete(t):delete this.observers[e])}emit(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];if(this.observers[e]){Array.from(this.observers[e].entries()).forEach((e=>{let[t,r]=e;for(let s=0;s<r;s++)t(...n)}))}if(this.observers["*"]){Array.from(this.observers["*"].entries()).forEach((t=>{let[r,s]=t;for(let a=0;a<s;a++)r.apply(r,[e,...n])}))}}}class $n extends En{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{ns:["translation"],defaultNS:"translation"};super(),this.data=e||{},this.options=t,void 0===this.options.keySeparator&&(this.options.keySeparator="."),void 0===this.options.ignoreJSONStructure&&(this.options.ignoreJSONStructure=!0)}addNamespaces(e){this.options.ns.indexOf(e)<0&&this.options.ns.push(e)}removeNamespaces(e){const t=this.options.ns.indexOf(e);t>-1&&this.options.ns.splice(t,1)}getResource(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};const s=void 0!==r.keySeparator?r.keySeparator:this.options.keySeparator,a=void 0!==r.ignoreJSONStructure?r.ignoreJSONStructure:this.options.ignoreJSONStructure;let i;e.indexOf(".")>-1?i=e.split("."):(i=[e,t],n&&(Array.isArray(n)?i.push(...n):un(n)&&s?i.push(...n.split(s)):i.push(n)));const o=yn(this.data,i);return!o&&!t&&!n&&e.indexOf(".")>-1&&(e=i[0],t=i[1],n=i.slice(2).join(".")),!o&&a&&un(n)?Nn(this.data&&this.data[e]&&this.data[e][t],n,s):o}addResource(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{silent:!1};const a=void 0!==s.keySeparator?s.keySeparator:this.options.keySeparator;let i=[e,t];n&&(i=i.concat(a?n.split(a):n)),e.indexOf(".")>-1&&(i=e.split("."),r=t,t=i[1]),this.addNamespaces(t),gn(this.data,i,r),s.silent||this.emit("added",e,t,n,r)}addResources(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{silent:!1};for(const s in n)(un(n[s])||Array.isArray(n[s]))&&this.addResource(e,t,s,n[s],{silent:!0});r.silent||this.emit("added",e,t,n)}addResourceBundle(e,t,n,r,s){let a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:{silent:!1,skipCopy:!1},i=[e,t];e.indexOf(".")>-1&&(i=e.split("."),r=n,n=t,t=i[1]),this.addNamespaces(t);let o=yn(this.data,i)||{};a.skipCopy||(n=JSON.parse(JSON.stringify(n))),r?bn(o,n,s):o={...o,...n},gn(this.data,i,o),a.silent||this.emit("added",e,t,n)}removeResourceBundle(e,t){this.hasResourceBundle(e,t)&&delete this.data[e][t],this.removeNamespaces(t),this.emit("removed",e,t)}hasResourceBundle(e,t){return void 0!==this.getResource(e,t)}getResourceBundle(e,t){return t||(t=this.options.defaultNS),"v1"===this.options.compatibilityAPI?{...this.getResource(e,t)}:this.getResource(e,t)}getDataByLanguage(e){return this.data[e]}hasLanguageSomeTranslations(e){const t=this.getDataByLanguage(e);return!!(t&&Object.keys(t)||[]).find((e=>t[e]&&Object.keys(t[e]).length>0))}toJSON(){return this.data}}var Rn={processors:{},addPostProcessor(e){this.processors[e.name]=e},handle(e,t,n,r,s){return e.forEach((e=>{this.processors[e]&&(t=this.processors[e].process(t,n,r,s))})),t}};const Dn={};class On extends En{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};super(),((e,t,n)=>{e.forEach((e=>{t[e]&&(n[e]=t[e])}))})(["resourceStore","languageUtils","pluralResolver","interpolator","backendConnector","i18nFormat","utils"],e,this),this.options=t,void 0===this.options.keySeparator&&(this.options.keySeparator="."),this.logger=An.create("translator")}changeLanguage(e){e&&(this.language=e)}exists(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{interpolation:{}};if(void 0===e||null===e)return!1;const n=this.resolve(e,t);return n&&void 0!==n.res}extractFromKey(e,t){let n=void 0!==t.nsSeparator?t.nsSeparator:this.options.nsSeparator;void 0===n&&(n=":");const r=void 0!==t.keySeparator?t.keySeparator:this.options.keySeparator;let s=t.ns||this.options.defaultNS||[];const a=n&&e.indexOf(n)>-1,i=!this.options.userDefinedKeySeparator&&!t.keySeparator&&!this.options.userDefinedNsSeparator&&!t.nsSeparator&&!((e,t,n)=>{t=t||"",n=n||"";const r=kn.filter((e=>t.indexOf(e)<0&&n.indexOf(e)<0));if(0===r.length)return!0;const s=Sn.getRegExp(`(${r.map((e=>"?"===e?"\\?":e)).join("|")})`);let a=!s.test(e);if(!a){const t=e.indexOf(n);t>0&&!s.test(e.substring(0,t))&&(a=!0)}return a})(e,n,r);if(a&&!i){const t=e.match(this.interpolator.nestingRegexp);if(t&&t.length>0)return{key:e,namespaces:un(s)?[s]:s};const a=e.split(n);(n!==r||n===r&&this.options.ns.indexOf(a[0])>-1)&&(s=a.shift()),e=a.join(r)}return{key:e,namespaces:un(s)?[s]:s}}translate(e,t,n){if("object"!==typeof t&&this.options.overloadTranslationOptionHandler&&(t=this.options.overloadTranslationOptionHandler(arguments)),"object"===typeof t&&(t={...t}),t||(t={}),void 0===e||null===e)return"";Array.isArray(e)||(e=[String(e)]);const r=void 0!==t.returnDetails?t.returnDetails:this.options.returnDetails,s=void 0!==t.keySeparator?t.keySeparator:this.options.keySeparator,{key:a,namespaces:i}=this.extractFromKey(e[e.length-1],t),o=i[i.length-1],l=t.lng||this.language,u=t.appendNamespaceToCIMode||this.options.appendNamespaceToCIMode;if(l&&"cimode"===l.toLowerCase()){if(u){const e=t.nsSeparator||this.options.nsSeparator;return r?{res:`${o}${e}${a}`,usedKey:a,exactUsedKey:a,usedLng:l,usedNS:o,usedParams:this.getUsedParamsDetails(t)}:`${o}${e}${a}`}return r?{res:a,usedKey:a,exactUsedKey:a,usedLng:l,usedNS:o,usedParams:this.getUsedParamsDetails(t)}:a}const c=this.resolve(e,t);let h=c&&c.res;const d=c&&c.usedKey||a,p=c&&c.exactUsedKey||a,f=Object.prototype.toString.apply(h),m=void 0!==t.joinArrays?t.joinArrays:this.options.joinArrays,g=!this.i18nFormat||this.i18nFormat.handleAsObject,y=!un(h)&&"boolean"!==typeof h&&"number"!==typeof h;if(!(g&&h&&y&&["[object Number]","[object Function]","[object RegExp]"].indexOf(f)<0)||un(m)&&Array.isArray(h))if(g&&un(m)&&Array.isArray(h))h=h.join(m),h&&(h=this.extendTranslation(h,e,t,n));else{let r=!1,i=!1;const u=void 0!==t.count&&!un(t.count),d=On.hasDefaultValue(t),p=u?this.pluralResolver.getSuffix(l,t.count,t):"",f=t.ordinal&&u?this.pluralResolver.getSuffix(l,t.count,{ordinal:!1}):"",m=u&&!t.ordinal&&0===t.count&&this.pluralResolver.shouldUseIntlApi(),g=m&&t[`defaultValue${this.options.pluralSeparator}zero`]||t[`defaultValue${p}`]||t[`defaultValue${f}`]||t.defaultValue;!this.isValidLookup(h)&&d&&(r=!0,h=g),this.isValidLookup(h)||(i=!0,h=a);const y=(t.missingKeyNoValueFallbackToKey||this.options.missingKeyNoValueFallbackToKey)&&i?void 0:h,b=d&&g!==h&&this.options.updateMissing;if(i||r||b){if(this.logger.log(b?"updateKey":"missingKey",l,o,a,b?g:h),s){const e=this.resolve(a,{...t,keySeparator:!1});e&&e.res&&this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.")}let e=[];const n=this.languageUtils.getFallbackCodes(this.options.fallbackLng,t.lng||this.language);if("fallback"===this.options.saveMissingTo&&n&&n[0])for(let t=0;t<n.length;t++)e.push(n[t]);else"all"===this.options.saveMissingTo?e=this.languageUtils.toResolveHierarchy(t.lng||this.language):e.push(t.lng||this.language);const r=(e,n,r)=>{const s=d&&r!==h?r:y;this.options.missingKeyHandler?this.options.missingKeyHandler(e,o,n,s,b,t):this.backendConnector&&this.backendConnector.saveMissing&&this.backendConnector.saveMissing(e,o,n,s,b,t),this.emit("missingKey",e,o,n,h)};this.options.saveMissing&&(this.options.saveMissingPlurals&&u?e.forEach((e=>{const n=this.pluralResolver.getSuffixes(e,t);m&&t[`defaultValue${this.options.pluralSeparator}zero`]&&n.indexOf(`${this.options.pluralSeparator}zero`)<0&&n.push(`${this.options.pluralSeparator}zero`),n.forEach((n=>{r([e],a+n,t[`defaultValue${n}`]||g)}))})):r(e,a,g))}h=this.extendTranslation(h,e,t,c,n),i&&h===a&&this.options.appendNamespaceToMissingKey&&(h=`${o}:${a}`),(i||r)&&this.options.parseMissingKeyHandler&&(h="v1"!==this.options.compatibilityAPI?this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey?`${o}:${a}`:a,r?h:void 0):this.options.parseMissingKeyHandler(h))}else{if(!t.returnObjects&&!this.options.returnObjects){this.options.returnedObjectHandler||this.logger.warn("accessing an object - but returnObjects options is not enabled!");const e=this.options.returnedObjectHandler?this.options.returnedObjectHandler(d,h,{...t,ns:i}):`key '${a} (${this.language})' returned an object instead of string.`;return r?(c.res=e,c.usedParams=this.getUsedParamsDetails(t),c):e}if(s){const e=Array.isArray(h),n=e?[]:{},r=e?p:d;for(const a in h)if(Object.prototype.hasOwnProperty.call(h,a)){const e=`${r}${s}${a}`;n[a]=this.translate(e,{...t,joinArrays:!1,ns:i}),n[a]===e&&(n[a]=h[a])}h=n}}return r?(c.res=h,c.usedParams=this.getUsedParamsDetails(t),c):h}extendTranslation(e,t,n,r,s){var a=this;if(this.i18nFormat&&this.i18nFormat.parse)e=this.i18nFormat.parse(e,{...this.options.interpolation.defaultVariables,...n},n.lng||this.language||r.usedLng,r.usedNS,r.usedKey,{resolved:r});else if(!n.skipInterpolation){n.interpolation&&this.interpolator.init({...n,interpolation:{...this.options.interpolation,...n.interpolation}});const i=un(e)&&(n&&n.interpolation&&void 0!==n.interpolation.skipOnVariables?n.interpolation.skipOnVariables:this.options.interpolation.skipOnVariables);let o;if(i){const t=e.match(this.interpolator.nestingRegexp);o=t&&t.length}let l=n.replace&&!un(n.replace)?n.replace:n;if(this.options.interpolation.defaultVariables&&(l={...this.options.interpolation.defaultVariables,...l}),e=this.interpolator.interpolate(e,l,n.lng||this.language||r.usedLng,n),i){const t=e.match(this.interpolator.nestingRegexp);o<(t&&t.length)&&(n.nest=!1)}!n.lng&&"v1"!==this.options.compatibilityAPI&&r&&r.res&&(n.lng=this.language||r.usedLng),!1!==n.nest&&(e=this.interpolator.nest(e,(function(){for(var e=arguments.length,r=new Array(e),i=0;i<e;i++)r[i]=arguments[i];return s&&s[0]===r[0]&&!n.context?(a.logger.warn(`It seems you are nesting recursively key: ${r[0]} in key: ${t[0]}`),null):a.translate(...r,t)}),n)),n.interpolation&&this.interpolator.reset()}const i=n.postProcess||this.options.postProcess,o=un(i)?[i]:i;return void 0!==e&&null!==e&&o&&o.length&&!1!==n.applyPostProcessor&&(e=Rn.handle(o,e,t,this.options&&this.options.postProcessPassResolved?{i18nResolved:{...r,usedParams:this.getUsedParamsDetails(n)},...n}:n,this)),e}resolve(e){let t,n,r,s,a,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return un(e)&&(e=[e]),e.forEach((e=>{if(this.isValidLookup(t))return;const o=this.extractFromKey(e,i),l=o.key;n=l;let u=o.namespaces;this.options.fallbackNS&&(u=u.concat(this.options.fallbackNS));const c=void 0!==i.count&&!un(i.count),h=c&&!i.ordinal&&0===i.count&&this.pluralResolver.shouldUseIntlApi(),d=void 0!==i.context&&(un(i.context)||"number"===typeof i.context)&&""!==i.context,p=i.lngs?i.lngs:this.languageUtils.toResolveHierarchy(i.lng||this.language,i.fallbackLng);u.forEach((e=>{this.isValidLookup(t)||(a=e,!Dn[`${p[0]}-${e}`]&&this.utils&&this.utils.hasLoadedNamespace&&!this.utils.hasLoadedNamespace(a)&&(Dn[`${p[0]}-${e}`]=!0,this.logger.warn(`key "${n}" for languages "${p.join(", ")}" won't get resolved as namespace "${a}" was not yet loaded`,"This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")),p.forEach((n=>{if(this.isValidLookup(t))return;s=n;const a=[l];if(this.i18nFormat&&this.i18nFormat.addLookupKeys)this.i18nFormat.addLookupKeys(a,l,n,e,i);else{let e;c&&(e=this.pluralResolver.getSuffix(n,i.count,i));const t=`${this.options.pluralSeparator}zero`,r=`${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;if(c&&(a.push(l+e),i.ordinal&&0===e.indexOf(r)&&a.push(l+e.replace(r,this.options.pluralSeparator)),h&&a.push(l+t)),d){const n=`${l}${this.options.contextSeparator}${i.context}`;a.push(n),c&&(a.push(n+e),i.ordinal&&0===e.indexOf(r)&&a.push(n+e.replace(r,this.options.pluralSeparator)),h&&a.push(n+t))}}let o;for(;o=a.pop();)this.isValidLookup(t)||(r=o,t=this.getResource(n,e,o,i))})))}))})),{res:t,usedKey:n,exactUsedKey:r,usedLng:s,usedNS:a}}isValidLookup(e){return void 0!==e&&!(!this.options.returnNull&&null===e)&&!(!this.options.returnEmptyString&&""===e)}getResource(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return this.i18nFormat&&this.i18nFormat.getResource?this.i18nFormat.getResource(e,t,n,r):this.resourceStore.getResource(e,t,n,r)}getUsedParamsDetails(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const t=["defaultValue","ordinal","context","replace","lng","lngs","fallbackLng","ns","keySeparator","nsSeparator","returnObjects","returnDetails","joinArrays","postProcess","interpolation"],n=e.replace&&!un(e.replace);let r=n?e.replace:e;if(n&&"undefined"!==typeof e.count&&(r.count=e.count),this.options.interpolation.defaultVariables&&(r={...this.options.interpolation.defaultVariables,...r}),!n){r={...r};for(const e of t)delete r[e]}return r}static hasDefaultValue(e){const t="defaultValue";for(const n in e)if(Object.prototype.hasOwnProperty.call(e,n)&&t===n.substring(0,12)&&void 0!==e[n])return!0;return!1}}const _n=e=>e.charAt(0).toUpperCase()+e.slice(1);class Fn{constructor(e){this.options=e,this.supportedLngs=this.options.supportedLngs||!1,this.logger=An.create("languageUtils")}getScriptPartFromCode(e){if(!(e=In(e))||e.indexOf("-")<0)return null;const t=e.split("-");return 2===t.length?null:(t.pop(),"x"===t[t.length-1].toLowerCase()?null:this.formatLanguageCode(t.join("-")))}getLanguagePartFromCode(e){if(!(e=In(e))||e.indexOf("-")<0)return e;const t=e.split("-");return this.formatLanguageCode(t[0])}formatLanguageCode(e){if(un(e)&&e.indexOf("-")>-1){if("undefined"!==typeof Intl&&"undefined"!==typeof Intl.getCanonicalLocales)try{let t=Intl.getCanonicalLocales(e)[0];if(t&&this.options.lowerCaseLng&&(t=t.toLowerCase()),t)return t}catch(E9){}const t=["hans","hant","latn","cyrl","cans","mong","arab"];let n=e.split("-");return this.options.lowerCaseLng?n=n.map((e=>e.toLowerCase())):2===n.length?(n[0]=n[0].toLowerCase(),n[1]=n[1].toUpperCase(),t.indexOf(n[1].toLowerCase())>-1&&(n[1]=_n(n[1].toLowerCase()))):3===n.length&&(n[0]=n[0].toLowerCase(),2===n[1].length&&(n[1]=n[1].toUpperCase()),"sgn"!==n[0]&&2===n[2].length&&(n[2]=n[2].toUpperCase()),t.indexOf(n[1].toLowerCase())>-1&&(n[1]=_n(n[1].toLowerCase())),t.indexOf(n[2].toLowerCase())>-1&&(n[2]=_n(n[2].toLowerCase()))),n.join("-")}return this.options.cleanCode||this.options.lowerCaseLng?e.toLowerCase():e}isSupportedCode(e){return("languageOnly"===this.options.load||this.options.nonExplicitSupportedLngs)&&(e=this.getLanguagePartFromCode(e)),!this.supportedLngs||!this.supportedLngs.length||this.supportedLngs.indexOf(e)>-1}getBestMatchFromCodes(e){if(!e)return null;let t;return e.forEach((e=>{if(t)return;const n=this.formatLanguageCode(e);this.options.supportedLngs&&!this.isSupportedCode(n)||(t=n)})),!t&&this.options.supportedLngs&&e.forEach((e=>{if(t)return;const n=this.getLanguagePartFromCode(e);if(this.isSupportedCode(n))return t=n;t=this.options.supportedLngs.find((e=>e===n?e:e.indexOf("-")<0&&n.indexOf("-")<0?void 0:e.indexOf("-")>0&&n.indexOf("-")<0&&e.substring(0,e.indexOf("-"))===n||0===e.indexOf(n)&&n.length>1?e:void 0))})),t||(t=this.getFallbackCodes(this.options.fallbackLng)[0]),t}getFallbackCodes(e,t){if(!e)return[];if("function"===typeof e&&(e=e(t)),un(e)&&(e=[e]),Array.isArray(e))return e;if(!t)return e.default||[];let n=e[t];return n||(n=e[this.getScriptPartFromCode(t)]),n||(n=e[this.formatLanguageCode(t)]),n||(n=e[this.getLanguagePartFromCode(t)]),n||(n=e.default),n||[]}toResolveHierarchy(e,t){const n=this.getFallbackCodes(t||this.options.fallbackLng||[],e),r=[],s=e=>{e&&(this.isSupportedCode(e)?r.push(e):this.logger.warn(`rejecting language code not found in supportedLngs: ${e}`))};return un(e)&&(e.indexOf("-")>-1||e.indexOf("_")>-1)?("languageOnly"!==this.options.load&&s(this.formatLanguageCode(e)),"languageOnly"!==this.options.load&&"currentOnly"!==this.options.load&&s(this.getScriptPartFromCode(e)),"currentOnly"!==this.options.load&&s(this.getLanguagePartFromCode(e))):un(e)&&s(this.formatLanguageCode(e)),n.forEach((e=>{r.indexOf(e)<0&&s(this.formatLanguageCode(e))})),r}}let Mn=[{lngs:["ach","ak","am","arn","br","fil","gun","ln","mfe","mg","mi","oc","pt","pt-BR","tg","tl","ti","tr","uz","wa"],nr:[1,2],fc:1},{lngs:["af","an","ast","az","bg","bn","ca","da","de","dev","el","en","eo","es","et","eu","fi","fo","fur","fy","gl","gu","ha","hi","hu","hy","ia","it","kk","kn","ku","lb","mai","ml","mn","mr","nah","nap","nb","ne","nl","nn","no","nso","pa","pap","pms","ps","pt-PT","rm","sco","se","si","so","son","sq","sv","sw","ta","te","tk","ur","yo"],nr:[1,2],fc:2},{lngs:["ay","bo","cgg","fa","ht","id","ja","jbo","ka","km","ko","ky","lo","ms","sah","su","th","tt","ug","vi","wo","zh"],nr:[1],fc:3},{lngs:["be","bs","cnr","dz","hr","ru","sr","uk"],nr:[1,2,5],fc:4},{lngs:["ar"],nr:[0,1,2,3,11,100],fc:5},{lngs:["cs","sk"],nr:[1,2,5],fc:6},{lngs:["csb","pl"],nr:[1,2,5],fc:7},{lngs:["cy"],nr:[1,2,3,8],fc:8},{lngs:["fr"],nr:[1,2],fc:9},{lngs:["ga"],nr:[1,2,3,7,11],fc:10},{lngs:["gd"],nr:[1,2,3,20],fc:11},{lngs:["is"],nr:[1,2],fc:12},{lngs:["jv"],nr:[0,1],fc:13},{lngs:["kw"],nr:[1,2,3,4],fc:14},{lngs:["lt"],nr:[1,2,10],fc:15},{lngs:["lv"],nr:[1,2,0],fc:16},{lngs:["mk"],nr:[1,2],fc:17},{lngs:["mnk"],nr:[0,1,2],fc:18},{lngs:["mt"],nr:[1,2,11,20],fc:19},{lngs:["or"],nr:[2,1],fc:2},{lngs:["ro"],nr:[1,2,20],fc:20},{lngs:["sl"],nr:[5,1,2,3],fc:21},{lngs:["he","iw"],nr:[1,2,20,21],fc:22}],Ln={1:e=>Number(e>1),2:e=>Number(1!=e),3:e=>0,4:e=>Number(e%10==1&&e%100!=11?0:e%10>=2&&e%10<=4&&(e%100<10||e%100>=20)?1:2),5:e=>Number(0==e?0:1==e?1:2==e?2:e%100>=3&&e%100<=10?3:e%100>=11?4:5),6:e=>Number(1==e?0:e>=2&&e<=4?1:2),7:e=>Number(1==e?0:e%10>=2&&e%10<=4&&(e%100<10||e%100>=20)?1:2),8:e=>Number(1==e?0:2==e?1:8!=e&&11!=e?2:3),9:e=>Number(e>=2),10:e=>Number(1==e?0:2==e?1:e<7?2:e<11?3:4),11:e=>Number(1==e||11==e?0:2==e||12==e?1:e>2&&e<20?2:3),12:e=>Number(e%10!=1||e%100==11),13:e=>Number(0!==e),14:e=>Number(1==e?0:2==e?1:3==e?2:3),15:e=>Number(e%10==1&&e%100!=11?0:e%10>=2&&(e%100<10||e%100>=20)?1:2),16:e=>Number(e%10==1&&e%100!=11?0:0!==e?1:2),17:e=>Number(1==e||e%10==1&&e%100!=11?0:1),18:e=>Number(0==e?0:1==e?1:2),19:e=>Number(1==e?0:0==e||e%100>1&&e%100<11?1:e%100>10&&e%100<20?2:3),20:e=>Number(1==e?0:0==e||e%100>0&&e%100<20?1:2),21:e=>Number(e%100==1?1:e%100==2?2:e%100==3||e%100==4?3:0),22:e=>Number(1==e?0:2==e?1:(e<0||e>10)&&e%10==0?2:3)};const Pn=["v1","v2","v3"],zn=["v4"],Bn={zero:0,one:1,two:2,few:3,many:4,other:5};class Vn{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.languageUtils=e,this.options=t,this.logger=An.create("pluralResolver"),this.options.compatibilityJSON&&!zn.includes(this.options.compatibilityJSON)||"undefined"!==typeof Intl&&Intl.PluralRules||(this.options.compatibilityJSON="v3",this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.")),this.rules=(()=>{const e={};return Mn.forEach((t=>{t.lngs.forEach((n=>{e[n]={numbers:t.nr,plurals:Ln[t.fc]}}))})),e})(),this.pluralRulesCache={}}addRule(e,t){this.rules[e]=t}clearCache(){this.pluralRulesCache={}}getRule(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(this.shouldUseIntlApi()){const r=In("dev"===e?"en":e),s=t.ordinal?"ordinal":"cardinal",a=JSON.stringify({cleanedCode:r,type:s});if(a in this.pluralRulesCache)return this.pluralRulesCache[a];let i;try{i=new Intl.PluralRules(r,{type:s})}catch(n){if(!e.match(/-|_/))return;const r=this.languageUtils.getLanguagePartFromCode(e);i=this.getRule(r,t)}return this.pluralRulesCache[a]=i,i}return this.rules[e]||this.rules[this.languageUtils.getLanguagePartFromCode(e)]}needsPlural(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=this.getRule(e,t);return this.shouldUseIntlApi()?n&&n.resolvedOptions().pluralCategories.length>1:n&&n.numbers.length>1}getPluralFormsOfKey(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return this.getSuffixes(e,n).map((e=>`${t}${e}`))}getSuffixes(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=this.getRule(e,t);return n?this.shouldUseIntlApi()?n.resolvedOptions().pluralCategories.sort(((e,t)=>Bn[e]-Bn[t])).map((e=>`${this.options.prepend}${t.ordinal?`ordinal${this.options.prepend}`:""}${e}`)):n.numbers.map((n=>this.getSuffix(e,n,t))):[]}getSuffix(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=this.getRule(e,n);return r?this.shouldUseIntlApi()?`${this.options.prepend}${n.ordinal?`ordinal${this.options.prepend}`:""}${r.select(t)}`:this.getSuffixRetroCompatible(r,t):(this.logger.warn(`no plural rule found for: ${e}`),"")}getSuffixRetroCompatible(e,t){const n=e.noAbs?e.plurals(t):e.plurals(Math.abs(t));let r=e.numbers[n];this.options.simplifyPluralSuffix&&2===e.numbers.length&&1===e.numbers[0]&&(2===r?r="plural":1===r&&(r=""));const s=()=>this.options.prepend&&r.toString()?this.options.prepend+r.toString():r.toString();return"v1"===this.options.compatibilityJSON?1===r?"":"number"===typeof r?`_plural_${r.toString()}`:s():"v2"===this.options.compatibilityJSON||this.options.simplifyPluralSuffix&&2===e.numbers.length&&1===e.numbers[0]?s():this.options.prepend&&n.toString()?this.options.prepend+n.toString():n.toString()}shouldUseIntlApi(){return!Pn.includes(this.options.compatibilityJSON)}}const Wn=function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:".",s=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],a=((e,t,n)=>{const r=yn(e,n);return void 0!==r?r:yn(t,n)})(e,t,n);return!a&&s&&un(n)&&(a=Nn(e,n,r),void 0===a&&(a=Nn(t,n,r))),a},Un=e=>e.replace(/\$/g,"$$$$");class jn{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this.logger=An.create("interpolator"),this.options=e,this.format=e.interpolation&&e.interpolation.format||(e=>e),this.init(e)}init(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};e.interpolation||(e.interpolation={escapeValue:!0});const{escape:t,escapeValue:n,useRawValueToEscape:r,prefix:s,prefixEscaped:a,suffix:i,suffixEscaped:o,formatSeparator:l,unescapeSuffix:u,unescapePrefix:c,nestingPrefix:h,nestingPrefixEscaped:d,nestingSuffix:p,nestingSuffixEscaped:f,nestingOptionsSeparator:m,maxReplaces:g,alwaysFormat:y}=e.interpolation;this.escape=void 0!==t?t:wn,this.escapeValue=void 0===n||n,this.useRawValueToEscape=void 0!==r&&r,this.prefix=s?vn(s):a||"{{",this.suffix=i?vn(i):o||"}}",this.formatSeparator=l||",",this.unescapePrefix=u?"":c||"-",this.unescapeSuffix=this.unescapePrefix?"":u||"",this.nestingPrefix=h?vn(h):d||vn("$t("),this.nestingSuffix=p?vn(p):f||vn(")"),this.nestingOptionsSeparator=m||",",this.maxReplaces=g||1e3,this.alwaysFormat=void 0!==y&&y,this.resetRegExp()}reset(){this.options&&this.init(this.options)}resetRegExp(){const e=(e,t)=>e&&e.source===t?(e.lastIndex=0,e):new RegExp(t,"g");this.regexp=e(this.regexp,`${this.prefix}(.+?)${this.suffix}`),this.regexpUnescape=e(this.regexpUnescape,`${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`),this.nestingRegexp=e(this.nestingRegexp,`${this.nestingPrefix}(.+?)${this.nestingSuffix}`)}interpolate(e,t,n,r){let s,a,i;const o=this.options&&this.options.interpolation&&this.options.interpolation.defaultVariables||{},l=e=>{if(e.indexOf(this.formatSeparator)<0){const s=Wn(t,o,e,this.options.keySeparator,this.options.ignoreJSONStructure);return this.alwaysFormat?this.format(s,void 0,n,{...r,...t,interpolationkey:e}):s}const s=e.split(this.formatSeparator),a=s.shift().trim(),i=s.join(this.formatSeparator).trim();return this.format(Wn(t,o,a,this.options.keySeparator,this.options.ignoreJSONStructure),i,n,{...r,...t,interpolationkey:a})};this.resetRegExp();const u=r&&r.missingInterpolationHandler||this.options.missingInterpolationHandler,c=r&&r.interpolation&&void 0!==r.interpolation.skipOnVariables?r.interpolation.skipOnVariables:this.options.interpolation.skipOnVariables;return[{regex:this.regexpUnescape,safeValue:e=>Un(e)},{regex:this.regexp,safeValue:e=>this.escapeValue?Un(this.escape(e)):Un(e)}].forEach((t=>{for(i=0;s=t.regex.exec(e);){const n=s[1].trim();if(a=l(n),void 0===a)if("function"===typeof u){const t=u(e,s,r);a=un(t)?t:""}else if(r&&Object.prototype.hasOwnProperty.call(r,n))a="";else{if(c){a=s[0];continue}this.logger.warn(`missed to pass in variable ${n} for interpolating ${e}`),a=""}else un(a)||this.useRawValueToEscape||(a=hn(a));const o=t.safeValue(a);if(e=e.replace(s[0],o),c?(t.regex.lastIndex+=a.length,t.regex.lastIndex-=s[0].length):t.regex.lastIndex=0,i++,i>=this.maxReplaces)break}})),e}nest(e,t){let n,r,s,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=(e,t)=>{const n=this.nestingOptionsSeparator;if(e.indexOf(n)<0)return e;const r=e.split(new RegExp(`${n}[ ]*{`));let a=`{${r[1]}`;e=r[0],a=this.interpolate(a,s);const i=a.match(/'/g),o=a.match(/"/g);(i&&i.length%2===0&&!o||o.length%2!==0)&&(a=a.replace(/'/g,'"'));try{s=JSON.parse(a),t&&(s={...t,...s})}catch(E9){return this.logger.warn(`failed parsing options string in nesting for key ${e}`,E9),`${e}${n}${a}`}return s.defaultValue&&s.defaultValue.indexOf(this.prefix)>-1&&delete s.defaultValue,e};for(;n=this.nestingRegexp.exec(e);){let o=[];s={...a},s=s.replace&&!un(s.replace)?s.replace:s,s.applyPostProcessor=!1,delete s.defaultValue;let l=!1;if(-1!==n[0].indexOf(this.formatSeparator)&&!/{.*}/.test(n[1])){const e=n[1].split(this.formatSeparator).map((e=>e.trim()));n[1]=e.shift(),o=e,l=!0}if(r=t(i.call(this,n[1].trim(),s),s),r&&n[0]===e&&!un(r))return r;un(r)||(r=hn(r)),r||(this.logger.warn(`missed to resolve ${n[1]} for nesting ${e}`),r=""),l&&(r=o.reduce(((e,t)=>this.format(e,t,a.lng,{...a,interpolationkey:n[1].trim()})),r.trim())),e=e.replace(n[0],r),this.regexp.lastIndex=0}return e}}const Gn=e=>{const t={};return(n,r,s)=>{let a=s;s&&s.interpolationkey&&s.formatParams&&s.formatParams[s.interpolationkey]&&s[s.interpolationkey]&&(a={...a,[s.interpolationkey]:void 0});const i=r+JSON.stringify(a);let o=t[i];return o||(o=e(In(r),s),t[i]=o),o(n)}};class Hn{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this.logger=An.create("formatter"),this.options=e,this.formats={number:Gn(((e,t)=>{const n=new Intl.NumberFormat(e,{...t});return e=>n.format(e)})),currency:Gn(((e,t)=>{const n=new Intl.NumberFormat(e,{...t,style:"currency"});return e=>n.format(e)})),datetime:Gn(((e,t)=>{const n=new Intl.DateTimeFormat(e,{...t});return e=>n.format(e)})),relativetime:Gn(((e,t)=>{const n=new Intl.RelativeTimeFormat(e,{...t});return e=>n.format(e,t.range||"day")})),list:Gn(((e,t)=>{const n=new Intl.ListFormat(e,{...t});return e=>n.format(e)}))},this.init(e)}init(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{interpolation:{}};this.formatSeparator=t.interpolation.formatSeparator||","}add(e,t){this.formats[e.toLowerCase().trim()]=t}addCached(e,t){this.formats[e.toLowerCase().trim()]=Gn(t)}format(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};const s=t.split(this.formatSeparator);if(s.length>1&&s[0].indexOf("(")>1&&s[0].indexOf(")")<0&&s.find((e=>e.indexOf(")")>-1))){const e=s.findIndex((e=>e.indexOf(")")>-1));s[0]=[s[0],...s.splice(1,e)].join(this.formatSeparator)}const a=s.reduce(((e,t)=>{const{formatName:s,formatOptions:a}=(e=>{let t=e.toLowerCase().trim();const n={};if(e.indexOf("(")>-1){const r=e.split("(");t=r[0].toLowerCase().trim();const s=r[1].substring(0,r[1].length-1);"currency"===t&&s.indexOf(":")<0?n.currency||(n.currency=s.trim()):"relativetime"===t&&s.indexOf(":")<0?n.range||(n.range=s.trim()):s.split(";").forEach((e=>{if(e){const[t,...r]=e.split(":"),s=r.join(":").trim().replace(/^'+|'+$/g,""),a=t.trim();n[a]||(n[a]=s),"false"===s&&(n[a]=!1),"true"===s&&(n[a]=!0),isNaN(s)||(n[a]=parseInt(s,10))}}))}return{formatName:t,formatOptions:n}})(t);if(this.formats[s]){let t=e;try{const i=r&&r.formatParams&&r.formatParams[r.interpolationkey]||{},o=i.locale||i.lng||r.locale||r.lng||n;t=this.formats[s](e,o,{...a,...r,...i})}catch(i){this.logger.warn(i)}return t}return this.logger.warn(`there was no format function for ${s}`),e}),e);return a}}class qn extends En{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(),this.backend=e,this.store=t,this.services=n,this.languageUtils=n.languageUtils,this.options=r,this.logger=An.create("backendConnector"),this.waitingReads=[],this.maxParallelReads=r.maxParallelReads||10,this.readingCalls=0,this.maxRetries=r.maxRetries>=0?r.maxRetries:5,this.retryTimeout=r.retryTimeout>=1?r.retryTimeout:350,this.state={},this.queue=[],this.backend&&this.backend.init&&this.backend.init(n,r.backend,r)}queueLoad(e,t,n,r){const s={},a={},i={},o={};return e.forEach((e=>{let r=!0;t.forEach((t=>{const i=`${e}|${t}`;!n.reload&&this.store.hasResourceBundle(e,t)?this.state[i]=2:this.state[i]<0||(1===this.state[i]?void 0===a[i]&&(a[i]=!0):(this.state[i]=1,r=!1,void 0===a[i]&&(a[i]=!0),void 0===s[i]&&(s[i]=!0),void 0===o[t]&&(o[t]=!0)))})),r||(i[e]=!0)})),(Object.keys(s).length||Object.keys(a).length)&&this.queue.push({pending:a,pendingCount:Object.keys(a).length,loaded:{},errors:[],callback:r}),{toLoad:Object.keys(s),pending:Object.keys(a),toLoadLanguages:Object.keys(i),toLoadNamespaces:Object.keys(o)}}loaded(e,t,n){const r=e.split("|"),s=r[0],a=r[1];t&&this.emit("failedLoading",s,a,t),!t&&n&&this.store.addResourceBundle(s,a,n,void 0,void 0,{skipCopy:!0}),this.state[e]=t?-1:2,t&&n&&(this.state[e]=0);const i={};this.queue.forEach((n=>{((e,t,n)=>{const{obj:r,k:s}=mn(e,t,Object);r[s]=r[s]||[],r[s].push(n)})(n.loaded,[s],a),((e,t)=>{void 0!==e.pending[t]&&(delete e.pending[t],e.pendingCount--)})(n,e),t&&n.errors.push(t),0!==n.pendingCount||n.done||(Object.keys(n.loaded).forEach((e=>{i[e]||(i[e]={});const t=n.loaded[e];t.length&&t.forEach((t=>{void 0===i[e][t]&&(i[e][t]=!0)}))})),n.done=!0,n.errors.length?n.callback(n.errors):n.callback())})),this.emit("loaded",i),this.queue=this.queue.filter((e=>!e.done))}read(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:this.retryTimeout,a=arguments.length>5?arguments[5]:void 0;if(!e.length)return a(null,{});if(this.readingCalls>=this.maxParallelReads)return void this.waitingReads.push({lng:e,ns:t,fcName:n,tried:r,wait:s,callback:a});this.readingCalls++;const i=(i,o)=>{if(this.readingCalls--,this.waitingReads.length>0){const e=this.waitingReads.shift();this.read(e.lng,e.ns,e.fcName,e.tried,e.wait,e.callback)}i&&o&&r<this.maxRetries?setTimeout((()=>{this.read.call(this,e,t,n,r+1,2*s,a)}),s):a(i,o)},o=this.backend[n].bind(this.backend);if(2!==o.length)return o(e,t,i);try{const n=o(e,t);n&&"function"===typeof n.then?n.then((e=>i(null,e))).catch(i):i(null,n)}catch(l){i(l)}}prepareLoading(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3?arguments[3]:void 0;if(!this.backend)return this.logger.warn("No backend was added via i18next.use. Will not load resources."),r&&r();un(e)&&(e=this.languageUtils.toResolveHierarchy(e)),un(t)&&(t=[t]);const s=this.queueLoad(e,t,n,r);if(!s.toLoad.length)return s.pending.length||r(),null;s.toLoad.forEach((e=>{this.loadOne(e)}))}load(e,t,n){this.prepareLoading(e,t,{},n)}reload(e,t,n){this.prepareLoading(e,t,{reload:!0},n)}loadOne(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"";const n=e.split("|"),r=n[0],s=n[1];this.read(r,s,"read",void 0,void 0,((n,a)=>{n&&this.logger.warn(`${t}loading namespace ${s} for language ${r} failed`,n),!n&&a&&this.logger.log(`${t}loaded namespace ${s} for language ${r}`,a),this.loaded(e,n,a)}))}saveMissing(e,t,n,r,s){let a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:{},i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:()=>{};if(this.services.utils&&this.services.utils.hasLoadedNamespace&&!this.services.utils.hasLoadedNamespace(t))this.logger.warn(`did not save key "${n}" as the namespace "${t}" was not yet loaded`,"This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");else if(void 0!==n&&null!==n&&""!==n){if(this.backend&&this.backend.create){const l={...a,isUpdate:s},u=this.backend.create.bind(this.backend);if(u.length<6)try{let s;s=5===u.length?u(e,t,n,r,l):u(e,t,n,r),s&&"function"===typeof s.then?s.then((e=>i(null,e))).catch(i):i(null,s)}catch(o){i(o)}else u(e,t,n,r,i,l)}e&&e[0]&&this.store.addResource(e[0],t,n,r)}}}const Kn=()=>({debug:!1,initImmediate:!0,ns:["translation"],defaultNS:["translation"],fallbackLng:["dev"],fallbackNS:!1,supportedLngs:!1,nonExplicitSupportedLngs:!1,load:"all",preload:!1,simplifyPluralSuffix:!0,keySeparator:".",nsSeparator:":",pluralSeparator:"_",contextSeparator:"_",partialBundledLanguages:!1,saveMissing:!1,updateMissing:!1,saveMissingTo:"fallback",saveMissingPlurals:!0,missingKeyHandler:!1,missingInterpolationHandler:!1,postProcess:!1,postProcessPassResolved:!1,returnNull:!1,returnEmptyString:!0,returnObjects:!1,joinArrays:!1,returnedObjectHandler:!1,parseMissingKeyHandler:!1,appendNamespaceToMissingKey:!1,appendNamespaceToCIMode:!1,overloadTranslationOptionHandler:e=>{let t={};if("object"===typeof e[1]&&(t=e[1]),un(e[1])&&(t.defaultValue=e[1]),un(e[2])&&(t.tDescription=e[2]),"object"===typeof e[2]||"object"===typeof e[3]){const n=e[3]||e[2];Object.keys(n).forEach((e=>{t[e]=n[e]}))}return t},interpolation:{escapeValue:!0,format:e=>e,prefix:"{{",suffix:"}}",formatSeparator:",",unescapePrefix:"-",nestingPrefix:"$t(",nestingSuffix:")",nestingOptionsSeparator:",",maxReplaces:1e3,skipOnVariables:!0}}),Xn=e=>(un(e.ns)&&(e.ns=[e.ns]),un(e.fallbackLng)&&(e.fallbackLng=[e.fallbackLng]),un(e.fallbackNS)&&(e.fallbackNS=[e.fallbackNS]),e.supportedLngs&&e.supportedLngs.indexOf("cimode")<0&&(e.supportedLngs=e.supportedLngs.concat(["cimode"])),e),Qn=()=>{};class Yn extends En{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1?arguments[1]:void 0;var n;if(super(),this.options=Xn(e),this.services={},this.logger=An,this.modules={external:[]},n=this,Object.getOwnPropertyNames(Object.getPrototypeOf(n)).forEach((e=>{"function"===typeof n[e]&&(n[e]=n[e].bind(n))})),t&&!this.isInitialized&&!e.isClone){if(!this.options.initImmediate)return this.init(e,t),this;setTimeout((()=>{this.init(e,t)}),0)}}init(){var e=this;let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=arguments.length>1?arguments[1]:void 0;this.isInitializing=!0,"function"===typeof t&&(n=t,t={}),!t.defaultNS&&!1!==t.defaultNS&&t.ns&&(un(t.ns)?t.defaultNS=t.ns:t.ns.indexOf("translation")<0&&(t.defaultNS=t.ns[0]));const r=Kn();this.options={...r,...this.options,...Xn(t)},"v1"!==this.options.compatibilityAPI&&(this.options.interpolation={...r.interpolation,...this.options.interpolation}),void 0!==t.keySeparator&&(this.options.userDefinedKeySeparator=t.keySeparator),void 0!==t.nsSeparator&&(this.options.userDefinedNsSeparator=t.nsSeparator);const s=e=>e?"function"===typeof e?new e:e:null;if(!this.options.isClone){let t;this.modules.logger?An.init(s(this.modules.logger),this.options):An.init(null,this.options),this.modules.formatter?t=this.modules.formatter:"undefined"!==typeof Intl&&(t=Hn);const n=new Fn(this.options);this.store=new $n(this.options.resources,this.options);const a=this.services;a.logger=An,a.resourceStore=this.store,a.languageUtils=n,a.pluralResolver=new Vn(n,{prepend:this.options.pluralSeparator,compatibilityJSON:this.options.compatibilityJSON,simplifyPluralSuffix:this.options.simplifyPluralSuffix}),!t||this.options.interpolation.format&&this.options.interpolation.format!==r.interpolation.format||(a.formatter=s(t),a.formatter.init(a,this.options),this.options.interpolation.format=a.formatter.format.bind(a.formatter)),a.interpolator=new jn(this.options),a.utils={hasLoadedNamespace:this.hasLoadedNamespace.bind(this)},a.backendConnector=new qn(s(this.modules.backend),a.resourceStore,a,this.options),a.backendConnector.on("*",(function(t){for(var n=arguments.length,r=new Array(n>1?n-1:0),s=1;s<n;s++)r[s-1]=arguments[s];e.emit(t,...r)})),this.modules.languageDetector&&(a.languageDetector=s(this.modules.languageDetector),a.languageDetector.init&&a.languageDetector.init(a,this.options.detection,this.options)),this.modules.i18nFormat&&(a.i18nFormat=s(this.modules.i18nFormat),a.i18nFormat.init&&a.i18nFormat.init(this)),this.translator=new On(this.services,this.options),this.translator.on("*",(function(t){for(var n=arguments.length,r=new Array(n>1?n-1:0),s=1;s<n;s++)r[s-1]=arguments[s];e.emit(t,...r)})),this.modules.external.forEach((e=>{e.init&&e.init(this)}))}if(this.format=this.options.interpolation.format,n||(n=Qn),this.options.fallbackLng&&!this.services.languageDetector&&!this.options.lng){const e=this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);e.length>0&&"dev"!==e[0]&&(this.options.lng=e[0])}this.services.languageDetector||this.options.lng||this.logger.warn("init: no languageDetector is used and no lng is defined");["getResource","hasResourceBundle","getResourceBundle","getDataByLanguage"].forEach((t=>{this[t]=function(){return e.store[t](...arguments)}}));["addResource","addResources","addResourceBundle","removeResourceBundle"].forEach((t=>{this[t]=function(){return e.store[t](...arguments),e}}));const a=cn(),i=()=>{const e=(e,t)=>{this.isInitializing=!1,this.isInitialized&&!this.initializedStoreOnce&&this.logger.warn("init: i18next is already initialized. You should call init just once!"),this.isInitialized=!0,this.options.isClone||this.logger.log("initialized",this.options),this.emit("initialized",this.options),a.resolve(t),n(e,t)};if(this.languages&&"v1"!==this.options.compatibilityAPI&&!this.isInitialized)return e(null,this.t.bind(this));this.changeLanguage(this.options.lng,e)};return this.options.resources||!this.options.initImmediate?i():setTimeout(i,0),a}loadResources(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Qn;const n=un(e)?e:this.language;if("function"===typeof e&&(t=e),!this.options.resources||this.options.partialBundledLanguages){if(n&&"cimode"===n.toLowerCase()&&(!this.options.preload||0===this.options.preload.length))return t();const e=[],r=t=>{if(!t)return;if("cimode"===t)return;this.services.languageUtils.toResolveHierarchy(t).forEach((t=>{"cimode"!==t&&e.indexOf(t)<0&&e.push(t)}))};if(n)r(n);else{this.services.languageUtils.getFallbackCodes(this.options.fallbackLng).forEach((e=>r(e)))}this.options.preload&&this.options.preload.forEach((e=>r(e))),this.services.backendConnector.load(e,this.options.ns,(e=>{e||this.resolvedLanguage||!this.language||this.setResolvedLanguage(this.language),t(e)}))}else t(null)}reloadResources(e,t,n){const r=cn();return"function"===typeof e&&(n=e,e=void 0),"function"===typeof t&&(n=t,t=void 0),e||(e=this.languages),t||(t=this.options.ns),n||(n=Qn),this.services.backendConnector.reload(e,t,(e=>{r.resolve(),n(e)})),r}use(e){if(!e)throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");if(!e.type)throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");return"backend"===e.type&&(this.modules.backend=e),("logger"===e.type||e.log&&e.warn&&e.error)&&(this.modules.logger=e),"languageDetector"===e.type&&(this.modules.languageDetector=e),"i18nFormat"===e.type&&(this.modules.i18nFormat=e),"postProcessor"===e.type&&Rn.addPostProcessor(e),"formatter"===e.type&&(this.modules.formatter=e),"3rdParty"===e.type&&this.modules.external.push(e),this}setResolvedLanguage(e){if(e&&this.languages&&!(["cimode","dev"].indexOf(e)>-1))for(let t=0;t<this.languages.length;t++){const e=this.languages[t];if(!(["cimode","dev"].indexOf(e)>-1)&&this.store.hasLanguageSomeTranslations(e)){this.resolvedLanguage=e;break}}}changeLanguage(e,t){var n=this;this.isLanguageChangingTo=e;const r=cn();this.emit("languageChanging",e);const s=e=>{this.language=e,this.languages=this.services.languageUtils.toResolveHierarchy(e),this.resolvedLanguage=void 0,this.setResolvedLanguage(e)},a=(e,a)=>{a?(s(a),this.translator.changeLanguage(a),this.isLanguageChangingTo=void 0,this.emit("languageChanged",a),this.logger.log("languageChanged",a)):this.isLanguageChangingTo=void 0,r.resolve((function(){return n.t(...arguments)})),t&&t(e,(function(){return n.t(...arguments)}))},i=t=>{e||t||!this.services.languageDetector||(t=[]);const n=un(t)?t:this.services.languageUtils.getBestMatchFromCodes(t);n&&(this.language||s(n),this.translator.language||this.translator.changeLanguage(n),this.services.languageDetector&&this.services.languageDetector.cacheUserLanguage&&this.services.languageDetector.cacheUserLanguage(n)),this.loadResources(n,(e=>{a(e,n)}))};return e||!this.services.languageDetector||this.services.languageDetector.async?!e&&this.services.languageDetector&&this.services.languageDetector.async?0===this.services.languageDetector.detect.length?this.services.languageDetector.detect().then(i):this.services.languageDetector.detect(i):i(e):i(this.services.languageDetector.detect()),r}getFixedT(e,t,n){var r=this;const s=function(e,t){let a;if("object"!==typeof t){for(var i=arguments.length,o=new Array(i>2?i-2:0),l=2;l<i;l++)o[l-2]=arguments[l];a=r.options.overloadTranslationOptionHandler([e,t].concat(o))}else a={...t};a.lng=a.lng||s.lng,a.lngs=a.lngs||s.lngs,a.ns=a.ns||s.ns,""!==a.keyPrefix&&(a.keyPrefix=a.keyPrefix||n||s.keyPrefix);const u=r.options.keySeparator||".";let c;return c=a.keyPrefix&&Array.isArray(e)?e.map((e=>`${a.keyPrefix}${u}${e}`)):a.keyPrefix?`${a.keyPrefix}${u}${e}`:e,r.t(c,a)};return un(e)?s.lng=e:s.lngs=e,s.ns=t,s.keyPrefix=n,s}t(){return this.translator&&this.translator.translate(...arguments)}exists(){return this.translator&&this.translator.exists(...arguments)}setDefaultNamespace(e){this.options.defaultNS=e}hasLoadedNamespace(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!this.isInitialized)return this.logger.warn("hasLoadedNamespace: i18next was not initialized",this.languages),!1;if(!this.languages||!this.languages.length)return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty",this.languages),!1;const n=t.lng||this.resolvedLanguage||this.languages[0],r=!!this.options&&this.options.fallbackLng,s=this.languages[this.languages.length-1];if("cimode"===n.toLowerCase())return!0;const a=(e,t)=>{const n=this.services.backendConnector.state[`${e}|${t}`];return-1===n||0===n||2===n};if(t.precheck){const e=t.precheck(this,a);if(void 0!==e)return e}return!!this.hasResourceBundle(n,e)||(!(this.services.backendConnector.backend&&(!this.options.resources||this.options.partialBundledLanguages))||!(!a(n,e)||r&&!a(s,e)))}loadNamespaces(e,t){const n=cn();return this.options.ns?(un(e)&&(e=[e]),e.forEach((e=>{this.options.ns.indexOf(e)<0&&this.options.ns.push(e)})),this.loadResources((e=>{n.resolve(),t&&t(e)})),n):(t&&t(),Promise.resolve())}loadLanguages(e,t){const n=cn();un(e)&&(e=[e]);const r=this.options.preload||[],s=e.filter((e=>r.indexOf(e)<0&&this.services.languageUtils.isSupportedCode(e)));return s.length?(this.options.preload=r.concat(s),this.loadResources((e=>{n.resolve(),t&&t(e)})),n):(t&&t(),Promise.resolve())}dir(e){if(e||(e=this.resolvedLanguage||(this.languages&&this.languages.length>0?this.languages[0]:this.language)),!e)return"rtl";const t=this.services&&this.services.languageUtils||new Fn(Kn());return["ar","shu","sqr","ssh","xaa","yhd","yud","aao","abh","abv","acm","acq","acw","acx","acy","adf","ads","aeb","aec","afb","ajp","apc","apd","arb","arq","ars","ary","arz","auz","avl","ayh","ayl","ayn","ayp","bbz","pga","he","iw","ps","pbt","pbu","pst","prp","prd","ug","ur","ydd","yds","yih","ji","yi","hbo","men","xmn","fa","jpr","peo","pes","prs","dv","sam","ckb"].indexOf(t.getLanguagePartFromCode(e))>-1||e.toLowerCase().indexOf("-arab")>1?"rtl":"ltr"}static createInstance(){return new Yn(arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},arguments.length>1?arguments[1]:void 0)}cloneInstance(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Qn;const n=e.forkResourceStore;n&&delete e.forkResourceStore;const r={...this.options,...e,isClone:!0},s=new Yn(r);void 0===e.debug&&void 0===e.prefix||(s.logger=s.logger.clone(e));return["store","services","language"].forEach((e=>{s[e]=this[e]})),s.services={...this.services},s.services.utils={hasLoadedNamespace:s.hasLoadedNamespace.bind(s)},n&&(s.store=new $n(this.store.data,r),s.services.resourceStore=s.store),s.translator=new On(s.services,r),s.translator.on("*",(function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];s.emit(e,...n)})),s.init(r,t),s.translator.options=r,s.translator.backendConnector.services.utils={hasLoadedNamespace:s.hasLoadedNamespace.bind(s)},s}toJSON(){return{options:this.options,store:this.store,language:this.language,languages:this.languages,resolvedLanguage:this.resolvedLanguage}}}const Zn=Yn.createInstance();Zn.createInstance=Yn.createInstance;Zn.createInstance,Zn.dir,Zn.init,Zn.loadResources,Zn.reloadResources,Zn.use,Zn.changeLanguage,Zn.getFixedT,Zn.t,Zn.exists,Zn.setDefaultNamespace,Zn.hasLoadedNamespace,Zn.loadNamespaces,Zn.loadLanguages;const Jn=JSON.parse('{"nav":{"about":"ABOUT","home":"HOME","datasets":"DATASETS","visualisation":"VISUALISATION"},"footer":{"readAbout":"Read about it here","basedOn":"Based on the","madeToMeasure":"Made to Measure project"},"Visualise your internet footprint!":"Visualise your internet footprint!"}'),er=JSON.parse('{"nav":{"about":"\xdcBER UNS","home":"HOME","datasets":"DATENS\xc4TZE","visualisation":"VISUALISIERUNG"},"footer":{"readAbout":"Lesen Sie hier dar\xfcber","basedOn":"Basierend auf dem","madeToMeasure":"Made to Measure-Projekt"},"Visualise your internet footprint!":"Visualisieren Sie Ihren Internet-Fu\xdfabdruck!"}');Zn.use(rn).init({resources:{en:{translation:Jn},de:{translation:er}},lng:"en",fallbackLng:"en",interpolation:{escapeValue:!1}});var tr=n(579);const nr=()=>{const{t:e}=ln(),[t,n]=(0,T.useState)(!1),r=t=>{switch(t){case"/":return e("nav.home");case"/about":return e("nav.about");case"/datasets":return e("nav.datasets");case"/visualisation":return e("nav.visualisation");default:return t.label}};return(0,tr.jsxs)(tr.Fragment,{children:[(0,tr.jsx)("div",{className:"w-full flex justify-start backdrop-blur-sm fixed h-14 top-0 z-40",children:(0,tr.jsx)("div",{className:"fixed top-4 left-3 z-50 flex flex-col gap-[5px] cursor-pointer",onClick:()=>n(!0),children:[3,2.5,1.5].map(((e,t)=>(0,tr.jsx)("span",{className:"block h-[4px] bg-white rounded-[1px] origin-left animate-grow ",style:{width:10*e+"px",animationDelay:100*t+"ms"}},t)))})}),(0,tr.jsxs)("div",{className:`fixed top-0 left-0 h-full w-4/6 max-w-80 bg-slate-200/30 backdrop-blur-sm transform \n        ${t?"translate-x-0":"-translate-x-full"} \n        transition-transform duration-300 ease-in-out z-50 shadow-lg`,children:[(0,tr.jsx)(jt,{size:25,onClick:()=>n(!1),className:"absolute top-4 right-4"}),(0,tr.jsx)("nav",{className:"mt-12 p-4",children:(0,tr.jsx)("ul",{className:"space-y-4",children:Rt.map(((e,t)=>(0,tr.jsx)("li",{children:(0,tr.jsxs)(St,{to:e,className:"block py-2 px-4 text-lg font-mono font-semibold text-white no-underline hover:text-sky-950 hover:italic",onClick:()=>n(!1),children:[r(e)," "]})},t)))})})]}),t&&(0,tr.jsx)("div",{className:"fixed inset-0 bg-black opacity-50 z-40",onClick:()=>n(!1)})]})},rr=n.p+"static/media/en.891482a7c7eff9bb0c06.png",sr="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZAAAAEYCAYAAAByXKB5AAAAAXNSR0IArs4c6QAAAZ5lWElmTU0AKgAAAAgACQEOAAIAAABeAAAAegESAAMAAAABAAEAAAEaAAUAAAABAAAA2AEbAAUAAAABAAAA4AExAAIAAAAeAAAA6AEyAAIAAAAUAAABBgE7AAIAAAAJAAABGoKYAAIAAAAvAAABJIdpAAQAAAABAAABVAAAAABPcmlnaW5hbCBhdXRob3IgaHR0cDovL2NvbW1vbnMud2lraW1lZGlhLm9yZy93aWtpL1VzZXI6U2tvcHAgTW9kaWZpY2F0aW9ucyAtIGNvbnZlcnRlZCB0byBQTkcAAAAASAAAAAEAAABIAAAAAUFkb2JlIEZpcmV3b3JrcyBDUzYgKFdpbmRvd3MpADIwMTQ6MTA6MTcgMTY6MzI6NTEAUGhpbDIwMDcAAGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LXNhLzMuMC8AAAAEkAQAAgAAABQAAAGKoAEAAwAAAAEAAQAAoAIABAAAAAEAAAGQoAMABAAAAAEAAAEYAAAAADIwMTQ6MTA6MTcgMTU6NTU6MzAA/M8sggAAAAlwSFlzAAALEwAACxMBAJqcGAAACORpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDYuMC4wIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6eG1wUmlnaHRzPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvcmlnaHRzLyIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgICAgICAgICB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iPgogICAgICAgICA8eG1wUmlnaHRzOldlYlN0YXRlbWVudD5odHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1zYS8zLjAvPC94bXBSaWdodHM6V2ViU3RhdGVtZW50PgogICAgICAgICA8eG1wUmlnaHRzOk1hcmtlZD5UcnVlPC94bXBSaWdodHM6TWFya2VkPgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8ZGM6dGl0bGU+CiAgICAgICAgICAgIDxyZGY6QWx0PgogICAgICAgICAgICAgICA8cmRmOmxpIHhtbDpsYW5nPSJ4LWRlZmF1bHQiPkZsYWcgb2YgR2VybWFueSBpY29uPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOkFsdD4KICAgICAgICAgPC9kYzp0aXRsZT4KICAgICAgICAgPGRjOmRlc2NyaXB0aW9uPgogICAgICAgICAgICA8cmRmOkFsdD4KICAgICAgICAgICAgICAgPHJkZjpsaSB4bWw6bGFuZz0ieC1kZWZhdWx0Ij5PcmlnaW5hbCBhdXRob3IgaHR0cDovL2NvbW1vbnMud2lraW1lZGlhLm9yZy93aWtpL1VzZXI6U2tvcHAgTW9kaWZpY2F0aW9ucyAtIGNvbnZlcnRlZCB0byBQTkc8L3JkZjpsaT4KICAgICAgICAgICAgPC9yZGY6QWx0PgogICAgICAgICA8L2RjOmRlc2NyaXB0aW9uPgogICAgICAgICA8ZGM6cmlnaHRzPgogICAgICAgICAgICA8cmRmOkFsdD4KICAgICAgICAgICAgICAgPHJkZjpsaSB4bWw6bGFuZz0ieC1kZWZhdWx0Ij5odHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1zYS8zLjAvPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOkFsdD4KICAgICAgICAgPC9kYzpyaWdodHM+CiAgICAgICAgIDxkYzpzdWJqZWN0PgogICAgICAgICAgICA8cmRmOkJhZz4KICAgICAgICAgICAgICAgPHJkZjpsaT5HZXJtYW55PC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGk+R2VybWFuPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGk+ZmxhZzwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpPmljb248L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaT5zbWFsbDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpPnNoYWRvdzwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpPmJvcmRlcjwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpPnBuZzwvcmRmOmxpPgogICAgICAgICAgICA8L3JkZjpCYWc+CiAgICAgICAgIDwvZGM6c3ViamVjdD4KICAgICAgICAgPGRjOmNyZWF0b3I+CiAgICAgICAgICAgIDxyZGY6U2VxPgogICAgICAgICAgICAgICA8cmRmOmxpPlBoaWwyMDA3PC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC9kYzpjcmVhdG9yPgogICAgICAgICA8cGhvdG9zaG9wOkNhcHRpb25Xcml0ZXI+RmxhZyBvZiBHZXJtYW55PC9waG90b3Nob3A6Q2FwdGlvbldyaXRlcj4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTQtMTAtMTdUMTY6MzI6NTFaPC94bXA6TW9kaWZ5RGF0ZT4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBGaXJld29ya3MgQ1M2IChXaW5kb3dzKTwveG1wOkNyZWF0b3JUb29sPgogICAgICAgICA8eG1wOkNyZWF0ZURhdGU+MjAxNC0xMC0xN1QxNTo1NTozMFo8L3htcDpDcmVhdGVEYXRlPgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICAgICA8dGlmZjpYUmVzb2x1dGlvbj43MjwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzI8L3RpZmY6WVJlc29sdXRpb24+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgpSA0QCAAAKcElEQVR4Ae3asancUBRFUcm83LETV+rGXIg7MLiEnxjkH7gB7fSsgcnmBFpc2Azovq7r+fz6ECBAgACBVwJfXv3ajwkQIECAwH8BAXEKBAgQIJAEBCSxGREgQICAgLgBAgQIEEgCApLYjAgQIEBAQNwAAQIECCQBAUlsRgQIECAgIG6AAAECBJKAgCQ2IwIECBAQEDdAgAABAklAQBKbEQECBAgIiBsgQIAAgSQgIInNiAABAgQExA0QIECAQBIQkMRmRIAAAQIC4gYIECBAIAkISGIzIkCAAAEBcQMECBAgkAQEJLEZESBAgICAuAECBAgQSAICktiMCBAgQEBA3AABAgQIJAEBSWxGBAgQICAgboAAAQIEkoCAJDYjAgQIEBAQN0CAAAECSUBAEpsRAQIECAiIGyBAgACBJCAgic2IAAECBATEDRAgQIBAEhCQxGZEgAABAgLiBggQIEAgCQhIYjMiQIAAAQFxAwQIECCQBAQksRkRIECAgIC4AQIECBBIAgKS2IwIECBAQEDcAAECBAgkAQFJbEYECBAgICBugAABAgSSgIAkNiMCBAgQEBA3QIAAAQJJQEASmxEBAgQICIgbIECAAIEkICCJzYgAAQIEBMQNECBAgEASEJDEZkSAAAECAuIGCBAgQCAJCEhiMyJAgAABAXEDBAgQIJAEBCSxGREgQICAgLgBAgQIEEgCApLYjAgQIEBAQNwAAQIECCQBAUlsRgQIECAgIG6AAAECBJKAgCQ2IwIECBAQEDdAgAABAklAQBKbEQECBAgIiBsgQIAAgSQgIInNiAABAgQExA0QIECAQBIQkMRmRIAAAQIC4gYIECBAIAkISGIzIkCAAAEBcQMECBAgkAQEJLEZESBAgICAuAECBAgQSAICktiMCBAgQEBA3AABAgQIJAEBSWxGBAgQICAgboAAAQIEkoCAJDYjAgQIEBAQN0CAAAECSUBAEpsRAQIECAiIGyBAgACBJCAgic2IAAECBATEDRAgQIBAEhCQxGZEgAABAgLiBggQIEAgCQhIYjMiQIAAAQFxAwQIECCQBAQksRkRIECAgIC4AQIECBBIAgKS2IwIECBAQEDcAAECBAgkAQFJbEYECBAgICBugAABAgSSgIAkNiMCBAgQEBA3QIAAAQJJ4HxPMyMCBAgQWBe4PwGedQTPT4AAAQLvBc7P9xsLAgQIECBw3b/9A3EGBAgQIBAEzkcYmRAgQIAAgeM1LEdAgAABAkVAP4qaDQECBAhcAuIICBAgQCAJCEhiMyJAgAABAXEDBAgQIJAEBCSxGREgQICAgLgBAgQIEEgCApLYjAgQIEBAQNwAAQIECCQBAUlsRgQIECAgIG6AAAECBJKAgCQ2IwIECBAQEDdAgAABAklAQBKbEQECBAgIiBsgQIAAgSQgIInNiAABAgQExA0QIECAQBIQkMRmRIAAAQIC4gYIECBAIAkISGIzIkCAAAEBcQMECBAgkAQEJLEZESBAgICAuAECBAgQSAICktiMCBAgQEBA3AABAgQIJAEBSWxGBAgQICAgboAAAQIEkoCAJDYjAgQIEBAQN0CAAAECSUBAEpsRAQIECAiIGyBAgACBJCAgic2IAAECBATEDRAgQIBAEhCQxGZEgAABAgLiBggQIEAgCQhIYjMiQIAAAQFxAwQIECCQBAQksRkRIECAgIC4AQIECBBIAgKS2IwIECBAQEDcAAECBAgkAQFJbEYECBAgICBugAABAgSSgIAkNiMCBAgQEBA3QIAAAQJJQEASmxEBAgQICIgbIECAAIEkICCJzYgAAQIEBMQNECBAgEASEJDEZkSAAAECAuIGCBAgQCAJCEhiMyJAgAABAXEDBAgQIJAEBCSxGREgQICAgLgBAgQIEEgCApLYjAgQIEBAQNwAAQIECCQBAUlsRgQIECAgIG6AAAECBJKAgCQ2IwIECBAQEDdAgAABAklAQBKbEQECBAgIiBsgQIAAgSQgIInNiAABAgQExA0QIECAQBIQkMRmRIAAAQIC4gYIECBAIAkISGIzIkCAAAEBcQMECBAgkAQEJLEZESBAgICAuAECBAgQSAICktiMCBAgQEBA3AABAgQIJAEBSWxGBAgQICAgboAAAQIEkoCAJDYjAgQIEBAQN0CAAAECSUBAEpsRAQIECAiIGyBAgACBJCAgic2IAAECBATEDRAgQIBAEhCQxGZEgAABAgLiBggQIEAgCQhIYjMiQIAAAQFxAwQIECCQBAQksRkRIECAgIC4AQIECBBIAgKS2IwIECBA4NzfIBAgQIAAgfcC5++f9yMLAgQIECBwvv6AQIAAAQIE3gvcz6/reT+zIECAAIF1gfN8rBN4fgIECBAoAuf2HlZxsyFAgMC8gHzMnwAAAgQINAEBaW5WBAgQmBcQkPkTAECAAIEmICDNzYoAAQLzAgIyfwIACBAg0AQEpLlZESBAYF5AQOZPAAABAgSagIA0NysCBAjMCwjI/AkAIECAQBMQkOZmRYAAgXkBAZk/AQAECBBoAgLS3KwIECAwLyAg8ycAgAABAk1AQJqbFQECBOYFBGT+BAAQIECgCQhIc7MiQIDAvICAzJ8AAAIECDQBAWluVgQIEJgXEJD5EwBAgACBJiAgzc2KAAEC8wICMn8CAAgQINAEBKS5WREgQGBeQEDmTwAAAQIEmoCANDcrAgQIzAsIyPwJACBAgEATEJDmZkWAAIF5AQGZPwEABAgQaAIC0tysCBAgMC8gIPMnAIAAAQJNQECamxUBAgTmBQRk/gQAECBAoAkISHOzIkCAwLyAgMyfAAACBAg0AQFpblYECBCYFxCQ+RMAQIAAgSYgIM3NigABAvMCAjJ/AgAIECDQBASkuVkRIEBgXkBA5k8AAAECBJqAgDQ3KwIECMwLCMj8CQAgQIBAExCQ5mZFgACBeQEBmT8BAAQIEGgCAtLcrAgQIDAvICDzJwCAAAECTUBAmpsVAQIE5gUEZP4EABAgQKAJCEhzsyJAgMC8gIDMnwAAAgQINAEBaW5WBAgQmBcQkPkTAECAAIEmICDNzYoAAQLzAgIyfwIACBAg0AQEpLlZESBAYF5AQOZPAAABAgSagIA0NysCBAjMCwjI/AkAIECAQBMQkOZmRYAAgXkBAZk/AQAECBBoAgLS3KwIECAwLyAg8ycAgAABAk1AQJqbFQECBOYFBGT+BAAQIECgCQhIc7MiQIDAvICAzJ8AAAIECDQBAWluVgQIEJgXEJD5EwBAgACBJiAgzc2KAAEC8wICMn8CAAgQINAEBKS5WREgQGBeQEDmTwAAAQIEmoCANDcrAgQIzAsIyPwJACBAgEATEJDmZkWAAIF5AQGZPwEABAgQaAIC0tysCBAgMC8gIPMnAIAAAQJNQECamxUBAgTmBQRk/gQAECBAoAkISHOzIkCAwLyAgMyfAAACBAg0AQFpblYECBCYFxCQ+RMAQIAAgSYgIM3NigABAvMCAjJ/AgAIECDQBASkuVkRIEBgXkBA5k8AAAECBJqAgDQ3KwIECMwLCMj8CQAgQIBAExCQ5mZFgACBeYF/kHcPRLQTV54AAAAASUVORK5CYII=";function ar(e){return Vt({tag:"svg",attr:{fill:"currentColor",viewBox:"0 0 16 16"},child:[{tag:"path",attr:{fillRule:"evenodd",d:"M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708"},child:[]}]})(e)}const ir=()=>{const{i18n:e}=ln(),[t,n]=(0,T.useState)(!1),r=t=>{e.changeLanguage(t),n(!1)};(0,T.useEffect)((()=>(document.body.style.overflow=t?"hidden":"auto",()=>{document.body.style.overflow="auto"})),[t]);return(0,tr.jsxs)("div",{className:"relative",children:[" ",(0,tr.jsxs)("button",{onClick:()=>n(!t),className:"flex items-center p-2 hover:bg-gray-200 w-full",children:[(0,tr.jsx)("img",{src:(s=e.language,"en"===s?rr:"de"===s?sr:null),alt:"en"===e.language?"English":"German",className:"w-7 h-5 rounded-sm mr-2"}),(0,tr.jsx)(ar,{})]}),(0,tr.jsxs)("div",{className:"absolute -top-4 right-0 max-w-full w-24 bg-slate-50/95 backdrop-blur-sm shadow-lg rounded-md pb-2 pt-5\n                transform transition-all duration-300 ease-in-out\n                "+(t?"opacity-100 translate-y-0 z-40":"opacity-0 -translate-y-full z-0"),children:[(0,tr.jsxs)("button",{onClick:()=>r("en"),className:"flex items-center p-2 hover:bg-gray-200 w-full font-mono text-sm",children:[(0,tr.jsx)("img",{src:rr,alt:"English",className:"w-7 h-5 rounded-sm mr-2 "+("en"===e.language?"":"opacity-65")}),"EN"]}),(0,tr.jsxs)("button",{onClick:()=>r("de"),className:"flex items-center p-2 hover:bg-gray-200 w-full font-mono text-sm",children:[(0,tr.jsx)("img",{src:sr,alt:"German",className:"w-7 h-5 rounded-sm mr-2 "+("de"===e.language?"":"opacity-65")}),"DE"]})]}),t&&(0,tr.jsx)("div",{className:"fixed h-dvh inset-0 bg-black opacity-20 z-30",onClick:()=>n(!1)})]});var s},or=()=>{const{t:e}=ln();return(0,tr.jsxs)("footer",{className:"h-52 w-full text-white flex justify-around items-end p-6 space-x-8 z-10",style:{background:"linear-gradient(244deg,rgba(4, 66, 35, 1) 0%, rgba(15, 92, 110, 1) 100%)"},children:[(0,tr.jsxs)("div",{className:"h-full flex flex-col justify-between",children:[(0,tr.jsxs)("p",{className:"font-mono text-sm",children:[(0,tr.jsx)(St,{className:"text-sky-300 hover:underline hover:text-indigo-300",to:"/about",children:e("nav.about")}),(0,tr.jsx)("br",{}),e("footer.readAbout")," ",(0,tr.jsx)(Ut,{className:"inline"})]}),(0,tr.jsxs)("p",{className:"font-mono text-sm",children:[e("footer.basedOn")," ",(0,tr.jsx)(St,{className:"text-sky-300 hover:underline hover:text-indigo-300",to:"https://www.madetomeasure.online/de/",children:e("footer.madeToMeasure")})]})]}),(0,tr.jsxs)("div",{className:"flex-col justify-between flex h-full",children:[(0,tr.jsx)(ir,{}),(0,tr.jsxs)(St,{to:"https://github.com/mothman2503/footprint-vis",className:"flex items-center text-sky-300 font-mono hover:text-indigo-300",children:[(0,tr.jsx)(Gt,{className:"mr-2 sky-300"})," GitHub"]})]})]})},lr=n.p+"static/media/logo.edbc34a01be7dfd9eb9b.png",ur=e=>{let{words:t,speed:n=100,delay:r=1e3,initialDelay:s=500,disableSpaces:a=!1,disableCursor:i=!1,onComplete:o}=e;const{i18n:l}=ln(),[u,c]=(0,T.useState)(""),[h,d]=(0,T.useState)(""),[p,f]=(0,T.useState)(-1),[m,g]=(0,T.useState)(0),[y,b]=(0,T.useState)(!1),[v,x]=(0,T.useState)(!0),[w,k]=(0,T.useState)(!0),S=(0,T.useRef)(null),N=(0,T.useRef)(null);return(0,T.useEffect)((()=>{c(""),d(""),f(-1),g(0),b(!1),k(!0);const e=setTimeout((()=>{b(!0),f(0)}),s);return()=>clearTimeout(e)}),[l.language,s]),(0,T.useEffect)((()=>{if(y&&!(p>=t.length))return m<t[p].length?S.current=setTimeout((()=>{d((e=>e+t[p][m])),g(m+1)}),n):N.current=setTimeout((()=>{c((e=>e+h+(a?"":" "))),d(""),p===t.length-1?(k(!1),null===o||void 0===o||o()):(f(p+1),g(0))}),r),()=>{clearTimeout(S.current),clearTimeout(N.current)}}),[m,p,t,n,r,a,o,h,y]),(0,T.useEffect)((()=>{if(!w)return;const e=setInterval((()=>{x((e=>!e))}),200);return()=>clearInterval(e)}),[w]),(0,tr.jsxs)("span",{children:[u+h,(0,tr.jsx)("span",{style:{display:"inline-block",width:"8px",height:"18px",backgroundColor:v&&w&&!i?"black":"transparent",marginLeft:"2px"}})]})};class cr{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class hr{refCount(e){return dr("refCount")}incRef(e){return dr("incRef")}timerAvailable(){return!0}time(e){return dr("time")}read(e){return dr("read")}readSync(e){return dr("readSync")}readToGPU(e,t){return dr("readToGPU")}numDataIds(){return dr("numDataIds")}disposeData(e,t){return dr("disposeData")}write(e,t,n){return dr("write")}move(e,t,n,r,s){return dr("move")}createTensorFromGPUData(e,t,n){return dr("createTensorFromGPUData")}memory(){return dr("memory")}floatPrecision(){return dr("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return dr("dispose")}}function dr(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function pr(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,gr(e,t,n)}function fr(e,t,n){return Math.max(e,Math.min(t,n))}function mr(e){return e%2===0?e:e+1}function gr(e,t,n){const r=e[t];e[t]=e[n],e[n]=r}function yr(e,t){if(!e)throw new Error("string"===typeof t?t:t())}function br(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";yr(wr(e,t),(()=>n+` Shapes ${e} and ${t} must match`))}function vr(e){yr(null!=e,(()=>"The input to the tensor constructor must be a non-null value."))}function xr(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function wr(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function kr(e){return e%1===0}function Sr(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function Nr(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function Ir(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e=>0,n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return new Promise(((s,a)=>{let i=0;const o=()=>{if(e())return void s();i++;const l=t(i);null!=n&&i>=n?a():null!=r?r(o,l):setTimeout(o,l)};o()}))}function Cr(e,t){let n=1,r=-1;for(let a=0;a<e.length;++a)if(e[a]>=0)n*=e[a];else if(-1===e[a]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${a}`);r=a}else if(e[a]<0)throw Error(`Shapes can not be < 0. Found ${e[a]} at dim ${a}`);if(-1===r){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const s=e.slice();return s[r]=t/n,s}function Tr(e,t){const n=t.length;return e=null==e?t.map(((e,t)=>t)):[].concat(e),yr(e.every((e=>e>=-n&&e<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`)),yr(e.every((e=>kr(e))),(()=>`All values in axis param must be integers but got axis ${e}`)),e.map((e=>e<0?n+e:e))}function Ar(e,t){const n=[],r=[],s=null!=t&&Array.isArray(t)&&0===t.length,a=null==t||s?null:Tr(t,e).sort();let i=0;for(let o=0;o<e.length;++o){if(null!=a){if(a[i]===o&&1!==e[o])throw new Error(`Can't squeeze axis ${o} since its dim '${e[o]}' is not 1`);(null==a[i]||a[i]>o)&&1===e[o]&&(n.push(e[o]),r.push(o)),a[i]<=o&&i++}1!==e[o]&&(n.push(e[o]),r.push(o))}return{newShape:n,keptDims:r}}function Er(e,t){return $r(e,t)}function $r(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);n=new Array(t)}return n}function Rr(e,t){return"complex64"!==t&&(("float32"!==t||"complex64"===e)&&(("int32"!==t||"float32"===e||"complex64"===e)&&("bool"!==t||"bool"!==e)))}function Dr(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function Or(e){return"string"===typeof e||e instanceof String}function _r(e){return"number"===typeof e}function Fr(e){return Array.isArray(e)?Fr(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":_r(e)?"float32":Or(e)?"string":function(e){return"boolean"===typeof e}(e)?"bool":"float32"}function Mr(e){return!!(e&&e.constructor&&e.call&&e.apply)}function Lr(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function Pr(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function zr(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=new Array;if(1===t.length){const a=t[0]*(r?2:1);for(let t=0;t<a;t++)s[t]=n[e+t]}else{const a=t[0],i=t.slice(1),o=i.reduce(((e,t)=>e*t))*(r?2:1);for(let t=0;t<a;t++)s[t]=zr(e+t*o,i,n,r)}return s}function Br(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(0===e.length)return t[0];const r=e.reduce(((e,t)=>e*t))*(n?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return zr(0,e,t,n)}function Vr(e,t){const n=Wr(e,t);for(let r=0;r<n.length;r++)n[r]=1;return n}function Wr(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function Ur(e,t){const n=e.reduce(((e,t)=>e*t),1);if(null==t||"float32"===t)return Br(e,new Float32Array(n));if("int32"===t)return Br(e,new Int32Array(n));if("bool"===t)return Br(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function jr(e){e.forEach((t=>{yr(Number.isInteger(t)&&t>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`))}))}function Gr(e,t,n){if(0===t)return 0;if(1===t)return e[0];let r=e[e.length-1];for(let s=0;s<e.length-1;++s)r+=n[s]*e[s];return r}function Hr(e,t,n){if(0===t)return[];if(1===t)return[e];const r=new Array(t);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(e/n[s]),e-=r[s]*n[s];return r[r.length-1]=e,r}function qr(e){return e&&e.then&&"function"===typeof e.then}const Kr="tfjsflags";class Xr{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Qr,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&(Yr().getBool("IS_TEST")||Yr().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];Yr().getBool("IS_TEST")||Yr().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(qr(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if("undefined"===typeof this.global||"undefined"===typeof this.global.location||"undefined"===typeof this.global.location.search)return;const e=this.getQueryParams(this.global.location.search);if(Kr in e){e[Kr].split(",").forEach((e=>{const[t,n]=e.split(":");this.urlFlags[t]=function(e,t){const n=t.toLowerCase();return"true"===n||"false"===n?"true"===n:""+ +n===n?+n:t}(0,n)}))}}}function Qr(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(function(e){for(var n=arguments.length,r=new Array(n>1?n-1:0),s=1;s<n;s++)r[s-1]=arguments[s];return function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,r[0],r[1]),r.join("=")})),t}function Yr(){return Jr}let Zr,Jr=null;function es(){if(null==Zr){let e;if("undefined"!==typeof window)e=window;else if("undefined"!==typeof n.g)e=n.g;else if("undefined"!==typeof process)e=process;else{if("undefined"===typeof self)throw new Error("Could not find a global object");e=self}Zr=e}return Zr}function ts(e,t){const n=function(){const e=es();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{const r=t();return n.set(e,r),n.get(e)}}const ns="Abs",rs="Acos",ss="Acosh",as="Add",is="AddN",os="All",ls="Any",us="ArgMax",cs="ArgMin",hs="Asin",ds="Asinh",ps="Atan",fs="Atanh",ms="Atan2",gs="AvgPool",ys="AvgPoolGrad",bs="AvgPool3D",vs="AvgPool3DGrad",xs="BatchMatMul",ws="BatchToSpaceND",ks="Bincount",Ss="BitwiseAnd",Ns="BroadcastArgs",Is="Cast",Cs="Ceil",Ts="ClipByValue",As="Complex",Es="ComplexAbs",$s="Concat",Rs="Conv2D",Ds="Conv2DBackpropFilter",Os="Conv2DBackpropInput",_s="Conv3D",Fs="Conv3DBackpropFilterV2",Ms="Conv3DBackpropInputV2",Ls="Cos",Ps="Cosh",zs="Cumprod",Bs="Cumsum",Vs="CropAndResize",Ws="DenseBincount",Us="DepthToSpace",js="DepthwiseConv2dNative",Gs="DepthwiseConv2dNativeBackpropFilter",Hs="DepthwiseConv2dNativeBackpropInput",qs="Diag",Ks="Dilation2D",Xs="Dilation2DBackpropInput",Qs="Dilation2DBackpropFilter",Ys="Draw",Zs="RealDiv",Js="Einsum",ea="Elu",ta="EluGrad",na="Erf",ra="Equal",sa="Exp",aa="ExpandDims",ia="Expm1",oa="FFT",la="Fill",ua="FlipLeftRight",ca="Floor",ha="FloorDiv",da="FusedBatchNorm",pa="GatherV2",fa="GatherNd",ma="Greater",ga="GreaterEqual",ya="Identity",ba="IFFT",va="Imag",xa="IsFinite",wa="IsInf",ka="IsNan",Sa="LeakyRelu",Na="Less",Ia="LessEqual",Ca="LinSpace",Ta="Log",Aa="Log1p",Ea="LogicalAnd",$a="LogicalNot",Ra="LogicalOr",Da="LRN",Oa="LRNGrad",_a="Max",Fa="Maximum",Ma="MaxPool",La="MaxPoolGrad",Pa="MaxPool3D",za="MaxPool3DGrad",Ba="MaxPoolWithArgmax",Va="Mean",Wa="Min",Ua="Minimum",ja="MirrorPad",Ga="Mod",Ha="Multinomial",qa="Multiply",Ka="Neg",Xa="NotEqual",Qa="NonMaxSuppressionV3",Ya="NonMaxSuppressionV4",Za="NonMaxSuppressionV5",Ja="OnesLike",ei="OneHot",ti="Pack",ni="PadV2",ri="Pow",si="Prelu",ai="Prod",ii="RaggedGather",oi="RaggedRange",li="RaggedTensorToTensor",ui="Range",ci="Real",hi="Reciprocal",di="Relu",pi="Reshape",fi="ResizeNearestNeighbor",mi="ResizeNearestNeighborGrad",gi="ResizeBilinear",yi="ResizeBilinearGrad",bi="Relu6",vi="Reverse",xi="Round",wi="Rsqrt",ki="ScatterNd",Si="TensorScatterUpdate",Ni="SearchSorted",Ii="Select",Ci="Selu",Ti="Slice",Ai="Sin",Ei="Sinh",$i="Sign",Ri="Sigmoid",Di="Softplus",Oi="Sqrt",_i="Sum",Fi="SpaceToBatchND",Mi="SplitV",Li="Softmax",Pi="SparseFillEmptyRows",zi="SparseReshape",Bi="SparseSegmentMean",Vi="SparseSegmentSum",Wi="SparseToDense",Ui="SquaredDifference",ji="Square",Gi="StaticRegexReplace",Hi="StridedSlice",qi="StringNGrams",Ki="StringSplit",Xi="StringToHashBucketFast",Qi="Sub",Yi="Tan",Zi="Tanh",Ji="Tile",eo="TopK",to="Transform",no="Transpose",ro="Unique",so="Unpack",ao="UnsortedSegmentSum",io="ZerosLike",oo="Step",lo="FromPixels",uo="RotateWithOffset",co="_FusedMatMul",ho="FusedConv2D",po="FusedDepthwiseConv2D";function fo(){Yr().getBool("IS_TEST")||Yr().getBool("PROD")||console.warn(...arguments)}function mo(){Yr().getBool("IS_TEST")||Yr().getBool("PROD")||console.log(...arguments)}const go=ts("kernelRegistry",(()=>new Map)),yo=ts("gradRegistry",(()=>new Map));function bo(e,t){const n=So(e,t);return go.get(n)}function vo(e){return yo.get(e)}function xo(e){const t=go.entries(),n=[];for(;;){const{done:r,value:s}=t.next();if(r)break;const[a,i]=s,[o]=a.split("_");o===e&&n.push(i)}return n}function wo(e){const{kernelName:t,backendName:n}=e,r=So(t,n);go.has(r)&&fo(`The kernel '${t}' for backend '${n}' is already registered`),go.set(r,e)}function ko(e){const{kernelName:t}=e;yo.has(t)&&Yr().getBool("DEBUG")&&fo(`Overriding the gradient for '${t}'`),yo.set(t,e)}function So(e,t){return`${t}_${e}`}function No(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var Io=n(353);const Co=n.n(Io)()||Io;function To(e){return Co.fromString(e,!0,16)}const Ao=To("c3a5c85c97cb3127"),Eo=To("b492b66fbe98f273"),$o=To("9ae16a3b2f90404f");function Ro(e){return e.xor(e.shru(47))}function Do(e,t,n){const r=e.slice(t,t+n);return Co.fromBytes(Array.from(r),!0,!0)}function Oo(e,t){return Do(e,t,8)}function _o(e,t){return Do(e,t,4)}function Fo(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function Mo(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:To("9ddfea08eb382d69"),r=e.xor(t).mul(n);r=r.xor(r.shru(47));let s=t.xor(r).mul(n);return s=s.xor(s.shru(47)),s=s.mul(n),s}function Lo(e,t,n,r){return function(e,t,n,r,s,a){s=s.add(e),a=Fo(a.add(s).add(r),21);const i=s;return s=(s=s.add(t)).add(n),a=a.add(Fo(s,44)),[s.add(r),a.add(i)]}(Oo(e,t),Oo(e,t+8),Oo(e,t+16),Oo(e,t+24),n,r)}function Po(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=Co.fromNumber(81,!0);if(t<=32)return t<=16?function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;if(t>=8){const n=$o.add(2*t),r=Oo(e,0).add($o),s=Oo(e,t-8);return Mo(Fo(s,37).mul(n).add(r),Fo(r,25).add(s).mul(n),n)}if(t>=4){const n=$o.add(2*t);return Mo(_o(e,0).shl(3).add(t),_o(e,t-4),n)}if(t>0){const n=e[0]+(e[t>>1]<<8),r=t+(e[t-1]<<2);return Ro($o.mul(n).xor(Ao.mul(r))).mul($o)}return $o}(e,t):function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=$o.add(2*t),r=Oo(e,0).mul(Eo),s=Oo(e,8),a=Oo(e,t-8).mul(n),i=Oo(e,t-16).mul($o);return Mo(Fo(r.add(s),43).add(Fo(a,30)).add(i),r.add(Fo(s.add($o),18)).add(a),n)}(e,t);if(t<=64)return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=$o.add(2*t),r=Oo(e,0).mul($o),s=Oo(e,8),a=Oo(e,t-8).mul(n),i=Oo(e,t-16).mul($o),o=Fo(r.add(s),43).add(Fo(a,30)).add(i),l=Mo(o,r.add(Fo(s.add($o),18)).add(a),n),u=Oo(e,16).mul(n),c=Oo(e,24),h=o.add(Oo(e,t-32)).mul(n),d=l.add(Oo(e,t-24)).mul(n);return Mo(Fo(u.add(c),43).add(Fo(h,30)).add(d),u.add(Fo(c.add(r),18)).add(h),n)}(e,t);let r=n,s=n.mul(Eo).add(113),a=Ro(s.mul($o).add(113)).mul($o),i=[Co.UZERO,Co.UZERO],o=[Co.UZERO,Co.UZERO];r=r.mul($o).add(Oo(e,0));let l=0;const u=64*(t-1>>6),c=u+(t-1&63)-63;do{r=Fo(r.add(s).add(i[0]).add(Oo(e,l+8)),37).mul(Eo),s=Fo(s.add(i[1]).add(Oo(e,l+48)),42).mul(Eo),r=r.xor(o[1]),s=s.add(i[0]).add(Oo(e,l+40)),a=Fo(a.add(o[0]),33).mul(Eo),i=Lo(e,l,i[1].mul(Eo),r.add(o[0])),o=Lo(e,l+32,a.add(o[1]),s.add(Oo(e,l+16))),[a,r]=[r,a],l+=64}while(l!==u);const h=Eo.add(a.and(255).shl(1));return l=c,o[0]=o[0].add(t-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),r=Fo(r.add(s).add(i[0]).add(Oo(e,l+8)),37).mul(h),s=Fo(s.add(i[1]).add(Oo(e,l+48)),42).mul(h),r=r.xor(o[1].mul(9)),s=s.add(i[0].mul(9).add(Oo(e,l+40))),a=Fo(a.add(o[0]),33).mul(h),i=Lo(e,l,i[1].mul(h),r.add(o[0])),o=Lo(e,l+32,a.add(o[1]),s.add(Oo(e,l+16))),[a,r]=[r,a],Mo(Mo(i[0],o[0],h).add(Ro(s).mul(Ao)).add(a),Mo(i[1],o[1],h).add(r),h)}function zo(e,t){return"string"===t?Wo(e):Bo([e],t)}function Bo(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=Go(e)),Yr().getBool("DEBUG")&&function(e,t){for(let n=0;n<e.length;n++){const r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error(`Unknown data type ${t}`)}function Vo(){return Yr().platform.now()}function Wo(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",Yr().platform.encode(e,t)}function Uo(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",Yr().platform.decode(e,t)}function jo(e){return null!=Yr().platform.isTypedArray?Yr().platform.isTypedArray(e):No(e)}function Go(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==t&&(t=[]),"boolean"===typeof e||"number"===typeof e||"string"===typeof e||qr(e)||null==e||jo(e)&&n)t.push(e);else if(Array.isArray(e)||jo(e))for(let r=0;r<e.length;++r)Go(e[r],t,n);else{let r=-1;for(const t of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(t)&&(r=Math.max(r,Number(t)));for(let s=0;s<=r;s++)Go(e[s],t,n)}return t}class Ho{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new Ko)}profileKernel(e,t,n){let r;const s=()=>{r=n()};let a;const i=Vo();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(s);else{s();for(const e of r)e.dataSync();a=Promise.resolve({kernelMs:Vo()-i})}if(Yr().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let o=0;o<r.length;o++){const t=r[o];t.data().then((n=>{qo(n,t.dtype,e)}))}return{kernelName:e,outputs:r,inputs:t,timeMs:a.then((e=>e.kernelMs)),extraInfo:a.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:r,inputs:s,extraInfo:a}=e;n.forEach((e=>{Promise.all([e.data(),r,a]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],s,n[2])}))}))}}function qo(e,t,n){if("float32"!==t)return!1;for(let r=0;r<e.length;r++){const t=e[r];if(isNaN(t)||!isFinite(t))return console.warn(`Found ${t} in the result of '${n}'`),!0}return!1}class Ko{logKernelProfile(e,t,n,r,s,a){const i="number"===typeof r?Nr(`${r}ms`,9):r.error,o=Nr(e,25),l=t.rank,u=t.size,c=Nr(t.shape.toString(),14);let h="";for(const d in s){const e=s[d];if(null!=e){const n=e.shape||t.shape,r=n.length;h+=`${d}: ${r}D ${r>0?n:""} `}}console.log(`%c${o}\t%c${i}\t%c${l}D ${c}\t%c${u}\t%c${h}\t%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function Xo(e,t,n,r){const s=Pr(t),a=function(e,t,n,r){const s=xr(t),a=r[r.length-1],i=new Array(a).fill(0),o=t.length,l="complex64"===n?Jo(e):e;if(o>1)for(let u=0;u<s/a;u++){const e=u*a;for(let t=0;t<a;t++)i[t]=Math.max(i[t],Qo(l[e+t],0,n).length)}return i}(e,t,n,s),i=t.length,o=Zo(e,t,n,s,a),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${i}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(o.map((e=>"    "+e)).join("\n")),l.join("\n")}function Qo(e,t,n){let r;return r=Array.isArray(e)?`${parseFloat(e[0].toFixed(7))} + ${parseFloat(e[1].toFixed(7))}j`:Or(e)?`'${e}'`:"bool"===n?Yo(e):parseFloat(e.toFixed(7)).toString(),Nr(r,t)}function Yo(e){return 0===e?"false":"true"}function Zo(e,t,n,r,s){let a=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const i="complex64"===n?2:1,o=t[0],l=t.length;if(0===l){if("complex64"===n){return[Qo(Jo(e)[0],0,n)]}return"bool"===n?[Yo(e[0])]:[e[0].toString()]}if(1===l){if(o>20){const t=3*i;let r=Array.from(e.slice(0,t)),a=Array.from(e.slice((o-3)*i,o*i));return"complex64"===n&&(r=Jo(r),a=Jo(a)),["["+r.map(((e,t)=>Qo(e,s[t],n))).join(", ")+", ..., "+a.map(((e,t)=>Qo(e,s[o-3+t],n))).join(", ")+"]"]}return["["+("complex64"===n?Jo(e):Array.from(e)).map(((e,t)=>Qo(e,s[t],n))).join(", ")+"]"]}const u=t.slice(1),c=r.slice(1),h=r[0]*i,d=[];if(o>20){for(let t=0;t<3;t++){const r=t*h,a=r+h;d.push(...Zo(e.slice(r,a),u,n,c,s,!1))}d.push("...");for(let t=o-3;t<o;t++){const r=t*h,a=r+h;d.push(...Zo(e.slice(r,a),u,n,c,s,t===o-1))}}else for(let m=0;m<o;m++){const t=m*h,r=t+h;d.push(...Zo(e.slice(t,r),u,n,c,s,m===o-1))}const p=2===l?",":"";d[0]="["+(o>0?d[0]+p:"");for(let m=1;m<d.length-1;m++)d[m]=" "+d[m]+p;let f=",\n";for(let m=2;m<l;m++)f+="\n";return d[d.length-1]=" "+d[d.length-1]+"]"+(a?"":f),d}function Jo(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}class el{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=xr(e),null!=n){const e=n.length;yr(e===this.size,(()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||$r(t,this.size),this.strides=Pr(e)}set(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];0===n.length&&(n=[0]),yr(n.length===this.rank,(()=>`The number of provided coordinates (${n.length}) must match the rank (${this.rank})`));const s=this.locToIndex(n);this.values[s]=e}get(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];0===t.length&&(t=[0]);let r=0;for(const a of t){if(a<0||a>=this.shape[r]){const e=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(e)}r++}let s=t[t.length-1];for(let a=0;a<t.length-1;++a)s+=this.strides[a]*t[a];return this.values[s]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return tl().makeTensor(this.values,this.shape,this.dtype)}}let tl=null,nl=null,rl=null;class sl{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=xr(e),this.strides=Pr(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return nl.buffer(this.shape,this.dtype,e)}bufferSync(){return nl.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return Br(this.shape,e,"complex64"===this.dtype)}arraySync(){return Br(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const e=tl().read(this.dataId);if("string"===this.dtype){const n=await e;try{return n.map((e=>Uo(e)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),tl().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=tl().readSync(this.dataId);if("string"===this.dtype)try{return e.map((e=>Uo(e)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await tl().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),tl().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return nl.print(this,e)}clone(){return this.throwIfDisposed(),nl.clone(this)}toString(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return Xo(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),nl.cast(this,e)}variable(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1?arguments[1]:void 0,n=arguments.length>2?arguments[2]:void 0;return this.throwIfDisposed(),tl().makeVariable(this,e,t,n)}}function al(){return ts("Tensor",(()=>sl))}Object.defineProperty(sl,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),al();class il extends sl{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!wr(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);tl().disposeTensor(this),this.dataId=e.dataId,tl().incRef(this,null)}dispose(){tl().disposeVariable(this),this.isDisposedInternal=!0}}var ol,ll,ul,cl,hl;Object.defineProperty(il,Symbol.hasInstance,{value:e=>e instanceof sl&&null!=e.assign&&e.assign instanceof Function}),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(ol||(ol={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(ll||(ll={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(ul||(ul={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(cl||(cl={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(hl||(hl={}));const dl={float32:cl,int32:ll,bool:ul,complex64:hl};function pl(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return dl[e][t]}function fl(e){return pl(e,"int32")}function ml(e){return null!=e&&"object"===typeof e&&"texture"in e&&e.texture instanceof WebGLTexture}function gl(e){return"undefined"!==typeof GPUBuffer&&null!=e&&"object"===typeof e&&"buffer"in e&&e.buffer instanceof GPUBuffer}function yl(e,t){if(e.dtype===t.dtype)return[e,t];const n=pl(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function bl(e,t){return t.some((t=>t.id===e.id))}function vl(e){const t=[];return xl(e,t,new Set),t}function xl(e,t,n){if(null==e)return;if(e instanceof sl)return void t.push(e);if(r=e,!Array.isArray(r)&&"object"!==typeof r)return;var r;const s=e;for(const a in s){const e=s[a];n.has(e)||(n.add(e),xl(e,t,n))}}function wl(e){return null!=e.kernelName}class kl{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((e=>e.name))))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Sl{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new kl}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return e in this.registryFactory?(fo(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new Ho(this.backendInstance),!0}setupRegisteredKernels(){xo(this.backendName).forEach((e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(e){xo(e).forEach((t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])}))}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const n=t.factory();if(!n||n instanceof hr||"function"!==typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,r=n.then((n=>!(t<this.pendingBackendInitId)&&(this.registry[e]=n,this.pendingBackendInit=null,!0))).catch((n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,fo(`Initialization of backend ${e} failed`),fo(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(n){return fo(`Initialization of backend ${e} failed`),fo(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority))}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:r,asyncInit:s}=this.initializeBackend(n);if(s||r)return{name:n,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),r=n.backend,s=this.readSync(t),a=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,s,n.shape,n.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,r=null;if(null==t){if("function"!==typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!==typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!==typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(r){throw t(),r}}nextTensorId(){return Sl.nextTensorId++}nextVariableId(){return Sl.nextVariableId++}clone(e){const t=Il.runKernel(ya,{x:e}),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],(e=>({x:()=>{const t={x:e},n={dtype:"float32"};return Il.runKernel(Is,t,n)}})),[],{}),t}runKernel(e,t,n){null==this.backendName&&this.backend;if(!(null!=bo(e,this.backendName)))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const r=this.backend.numDataIds();let s=0;n.forEach((e=>{s+="complex64"===e.dtype?3:1}));const a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=r-t-s-a;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[];const r=this.isTapeOn(),s=this.state.numBytes,a=this.state.numTensors;let i,o;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const l=wl(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(wl(e)){const{kernelName:t,inputs:s,attrs:a}=e;null==this.backendName&&this.backend;const l=bo(t,this.backendName);yr(null!=l,(()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`)),i=()=>{const e=this.backend.numDataIds();o=l.kernelFunc({inputs:s,attrs:a,backend:this.backend});const i=Array.isArray(o)?o:[o];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,i);const u=i.map((e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e)));if(r){const e=this.getTensorsForGradient(t,s,u);n=this.saveTensorsForBackwardMode(e)}return u}}else{const{forwardFunc:t}=e,s=e=>{r&&(n=e.map((e=>this.keep(this.clone(e)))))};i=()=>{const e=this.backend.numDataIds();o=this.tidy((()=>t(this.backend,s)));const n=Array.isArray(o)?o:[o];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,e,n),n}}const{inputs:u,attrs:c}=e,h=wl(e)?null:e.backwardsFunc;let d;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(d=this.profiler.profileKernel(l,u,(()=>i())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),t=d.outputs):t=i()})),r&&this.addTapeNode(l,u,t,h,n,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map((e=>null!=u[e]?u[e].shape:null)),outputShapes:t.map((e=>e.shape)),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(o)?t:t[0]}saveTensorsForBackwardMode(e){const t=e.map((e=>this.keep(this.clone(e))));return t}getTensorsForGradient(e,t,n){const r=vo(e);if(null!=r){const e=r.inputsToSave||[],s=r.outputsToSave||[];let a;r.saveAllInputs?(yr(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array.")),a=Object.keys(t).map((e=>t[e]))):a=e.map((e=>t[e]));const i=n.filter(((e,t)=>s[t]));return a.concat(i)}return[]}makeTensor(e,t,n,r){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let s=e;"string"===n&&Or(e[0])&&(s=e.map((e=>Wo(e))));const a=r.write(s,t,n),i=new sl(t,n,a,this.nextTensorId());if(this.trackTensor(i,r),"string"===n){const e=this.state.tensorInfo.get(a),t=function(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}(s);this.state.numBytes+=t-e.bytes,e.bytes=t}return i}makeTensorFromDataId(e,t,n,r){const s={dataId:e,shape:t,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(s,r)}makeTensorFromTensorInfo(e,t){const{dataId:n,shape:r,dtype:s}=e,a=new sl(r,s,n,this.nextTensorId());return this.trackTensor(a,t),a}makeVariable(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;n=n||this.nextVariableId().toString(),null!=r&&r!==e.dtype&&(e=e.cast(r));const s=new il(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[s.name])throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*Dr(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof il||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const t=e.size*Dr(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,r,s,a){const i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:s},o=vo(e);null!=o&&(r=o.gradFunc),null!=r&&(i.gradient=e=>(e=e.map(((e,t)=>{if(null==e){const e=n[t],r=Wr(e.size,e.dtype);return this.makeTensor(r,e.shape,e.dtype)}return e})),r(e.length>1?e:e[0],s,a))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=vl(e),n=new Set(t.map((e=>e.id)));for(let s=0;s<this.state.activeScope.track.length;s++){const e=this.state.activeScope.track[s];e.kept||n.has(e.id)||e.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach((e=>{e.kept||e.scopeId!==r.id||this.track(e)}))}gradients(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(yr(t.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const s=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));yr(s instanceof sl,(()=>"The result y returned by f() must be a tensor."));const a=function(e,t,n){const r={},s={};for(let l=0;l<t.length;l++)r[t[l].id]=!0;for(let l=0;l<e.length;l++){const n=e[l],a=n.inputs;for(const e in a){const i=a[e];let o=!1;for(let e=0;e<t.length;e++)if(r[i.id]){n.outputs.forEach((e=>r[e.id]=!0)),o=!0,s[n.id]=!0;break}if(o)break}}const a={};a[n.id]=!0;const i={};for(let l=e.length-1;l>=0;l--){const t=e[l],n=t.inputs;for(let e=0;e<t.outputs.length;e++)if(a[t.outputs[e].id]){for(const e in n)a[n[e].id]=!0,i[t.id]=!0;break}}const o=[];for(let l=0;l<e.length;l++){const t=e[l];if(s[t.id]&&i[t.id]){const e={};for(const s in t.inputs){const n=t.inputs[s];r[n.id]&&(e[s]=n)}const n=Object.assign({},t);n.inputs=e,n.outputs=t.outputs,o.push(n)}}return o}(this.state.activeTape,t,s);if(!r&&0===a.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const e={};e[s.id]=null==n?function(e){const t=Vr(xr(e),"float32");return Il.makeTensor(t,e,"float32")}(s.shape):n,function(e,t,n,r){for(let s=t.length-1;s>=0;s--){const a=t[s],i=[];if(a.outputs.forEach((t=>{const n=e[t.id];null!=n?i.push(n):i.push(null)})),null==a.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);const o=a.gradient(i);for(const t in a.inputs){if(!(t in o))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(o)}.`);const s=n((()=>o[t]()));if("float32"!==s.dtype)throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${s.dtype}'`);const i=a.inputs[t];if(!wr(s.shape,i.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${t}' has shape '${s.shape}', which does not match the shape of the input '${i.shape}'`);if(null==e[i.id])e[i.id]=s;else{const t=e[i.id];e[i.id]=r(t,s),t.dispose()}}}}(e,a,(e=>this.tidy(e)),Cl);const r=t.map((t=>e[t.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((e=>{for(const t of e.saved)t.dispose()})),this.state.activeTape=null),{value:s,grads:r}}))}customGrad(e){var t=this;return yr(Mr(e),(()=>"The f passed in customGrad(f) must be a function.")),function(){for(var n=arguments.length,r=new Array(n),s=0;s<n;s++)r[s]=arguments[s];let a;yr(r.every((e=>e instanceof sl)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const i={};r.forEach(((e,t)=>{i[t]=e}));return t.runKernelFunc({forwardFunc:(t,n)=>(a=e(...r,n),yr(a.value instanceof sl,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),yr(Mr(a.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),a.value),backwardsFunc:(e,t)=>{const n=a.gradFunc(e,t),s=Array.isArray(n)?n:[n];yr(s.length===r.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),yr(s.every((e=>e instanceof sl)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const i={};return s.forEach(((e,t)=>{i[t]=()=>e})),i},inputs:i})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=Vo(),n=await this.backend.time(e);return n.wallMs=Vo()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new kl;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function Nl(){const e=es();if(null==e._tfengine){const t=new Xr(e);e._tfengine=new Sl(t)}var t;return t=e._tfengine.ENV,Jr=t,tl=()=>e._tfengine,e._tfengine}Sl.nextTensorId=0,Sl.nextVariableId=0;const Il=Nl();function Cl(e,t){const n={a:e,b:t};return Il.runKernel(as,n)}let Tl;function Al(e){if(void 0!==Tl)return Tl;if(e||"undefined"!==typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;const t=e.userAgent||e.vendor||("undefined"!==typeof window?window.opera:"");if(!t){const t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function El(){return"undefined"!==typeof window&&null!=window.document||"undefined"!==typeof WorkerGlobalScope}const $l=Yr();function Rl(e,t){let n=e;if(jo(e))return"string"===t?[]:[e.length];if(ml(e)){const t=e.channels||"RGBA";return[e.height,e.width*t.length]}if(gl(e))return[e.buffer.size/(null==t?4:Dr(t))];if(!Array.isArray(e))return[];const r=[];for(;Array.isArray(n)||jo(n)&&"string"!==t;)r.push(n.length),n=n[0];return Array.isArray(e)&&Yr().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Dl(e,r,[]),r}function Dl(e,t,n){if(n=n||[],!Array.isArray(e)&&!jo(e))return void yr(0===t.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`));yr(t.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`)),yr(e.length===t[0],(()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`));const r=t.slice(1);for(let s=0;s<e.length;++s)Dl(e[s],r,n.concat(s))}function Ol(e,t,n,r){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function _l(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(e instanceof al())return Ol(r,e.dtype,t,n),e;let s=Fr(e);if("string"!==s&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),Ol(r,s,t,n),null==e||!jo(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e){const r=null==e?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}const a=Rl(e,s);jo(e)||Array.isArray(e)||(e=[e]);const i="string"!==s?Bo(e,s):Go(e,[],!0);return Il.makeTensor(i,a,s)}function Fl(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map(((e,s)=>_l(e,`${t}[${s}]`,n,r)))}$l.registerFlag("DEBUG",(()=>!1),(e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),$l.registerFlag("IS_BROWSER",(()=>El())),$l.registerFlag("IS_NODE",(()=>"undefined"!==typeof process&&"undefined"!==typeof process.versions&&"undefined"!==typeof process.versions.node)),$l.registerFlag("IS_CHROME",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),$l.registerFlag("IS_SAFARI",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor))),$l.registerFlag("PROD",(()=>!1)),$l.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>$l.getBool("DEBUG"))),$l.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),$l.registerFlag("IS_TEST",(()=>!1)),$l.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>$l.getBool("DEBUG"))),$l.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),$l.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>!1)),$l.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>!1));const Ml="__op";function Ll(e){const t=Object.keys(e);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+=Ml;const s=function(){Il.startScope(n);try{const e=r(...arguments);return qr(e)&&console.error("Cannot return a Promise inside of tidy."),Il.endScope(e),e}catch(e){throw Il.endScope(null),e}};return Object.defineProperty(s,"name",{value:n,configurable:!0}),s}const Pl=Ll({complex_:function(e,t){const n=_l(e,"real","complex"),r=_l(t,"imag","complex");br(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);const s={real:n,imag:r};return Il.runKernel(As,s)}});function zl(e,t,n,r){if(null==r)r=Fr(e);else if("complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(gl(e)||ml(e)){if("float32"!==r&&"int32"!==r)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return Il.backend.createTensorFromGPUData(e,t||n,r)}if(!jo(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){jr(t);const e=xr(t),r=xr(n);yr(e===r,(()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${r}`));for(let s=0;s<n.length;++s){const e=n[s],r=s!==n.length-1||e!==xr(t.slice(s));yr(n[s]===t[s]||!r,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `))}}return jo(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==r?Bo(e,r):Go(e,[],!0),Il.makeTensor(e,t,r)}function Bl(e,t,n){return zl(e,t,Rl(e,n),n)}const Vl={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class Wl{static join(e){return new Wl(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,null==e)return;if(e instanceof Array||(e=[e]),0===(e=e.map((e=>jo(e)?e.buffer:e))).length)return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let n=0;n<e.length;n++){const r=e[n];n!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const s=t+r.byteLength;this.shards.push({buffer:r,start:t,end:s}),t=s}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.byteLength;if(0===this.shards.length)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const n=this.findShardForByte(e);if(-1===n)throw new Error(`Could not find start shard for byte ${e}`);const r=new ArrayBuffer(t-e),s=new Uint8Array(r);let a=0;for(let i=n;i<this.shards.length;i++){const n=this.shards[i],r=e+a-n.start,o=a,l=Math.min(t,n.end)-n.start,u=new Uint8Array(n.buffer,r,l-r);if(s.set(u,o),a+=u.length,t<n.end)break}return r}findShardForByte(e){if(0===this.shards.length||e<0||e>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(t){return e<t.start?-1:e>=t.end?1:0}if(0===t(this.shards[this.previousShardIndex]))return this.previousShardIndex;const n=function(e,t){let n=0,r=e.length;for(;n<=r;){const s=Math.floor((r-n)/2)+n,a=t(e[s]);if(0===a)return s;a<0?r=s:n=s+1}return-1}(this.shards,t);return-1===n?-1:(this.previousShardIndex=n,this.previousShardIndex)}}function Ul(){return Il}function jl(){return Il.memory()}function Gl(e,t){return Il.tidy(e,t)}function Hl(e){vl(e).forEach((e=>e.dispose()))}function ql(e){return Il.keep(e)}function Kl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Il.registerBackend(e,t,n)}function Xl(){return Il.backend}rl=function(e){Yr().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")};const Ql=4;async function Yl(e,t){const n=[],r=[],s=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);for(let a=0;a<s.length;++a){const i=s[a],o=Array.isArray(e)?e[a].tensor:e[i];if("float32"!==o.dtype&&"int32"!==o.dtype&&"bool"!==o.dtype&&"string"!==o.dtype&&"complex64"!==o.dtype)throw new Error(`Unsupported dtype in weight '${i}': ${o.dtype}`);const l={name:i,shape:o.shape,dtype:o.dtype};if("string"===o.dtype){const e=new Promise((async e=>{const t=await o.bytes(),n=t.reduce(((e,t)=>e+t.length),0)+Ql*t.length,r=new Uint8Array(n);let s=0;for(let a=0;a<t.length;a++){const e=t[a],n=new Uint8Array(new Uint32Array([e.length]).buffer);r.set(n,s),s+=Ql,r.set(e,s),s+=e.length}e(r)}));r.push(e)}else r.push(o.data());null!=t&&(l.group=t),n.push(l)}return{data:su(await Promise.all(r)),specs:n}}function Zl(e,t){const n=new Wl(e),r={};let s=0;for(const a of t){const e=Jl(a,((e,t)=>n.slice(s+e,s+t)));r[a.name]=tu(a,n.slice(s,s+e)),s+=e}return r}function Jl(e,t){const n=xr(e.shape);let r;if("quantization"in e){const t=e.quantization;r=Vl[t.dtype]}else{if("string"===e.dtype){let e=0;for(let r=0;r<n;r++)e+=Ql+new Uint32Array(t(e,e+Ql))[0];return e}r=Vl[e.dtype]}return n*r}async function eu(e,t){const n=xr(e.shape);let r;if("quantization"in e){const t=e.quantization;r=Vl[t.dtype]}else{if("string"===e.dtype){let e=0;for(let r=0;r<n;r++)e+=Ql+new Uint32Array(await t(e,e+Ql))[0];return e}r=Vl[e.dtype]}return n*r}function tu(e,t){const n=e.name,r=e.dtype,s=e.shape,a=xr(s);let i,o=0;if("quantization"in e){const s=e.quantization;if("uint8"===s.dtype||"uint16"===s.dtype){if(!("min"in s)||!("scale"in s))throw new Error(`Weight ${e.name} with quantization ${s.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==s.dtype)throw new Error(`Weight ${e.name} has unknown quantization dtype ${s.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==r)throw new Error(`Weight ${e.name} is quantized with ${s.dtype} which only supports weights of type float32 not ${r}.`)}const l=Vl[s.dtype],u="uint8"===s.dtype?new Uint8Array(t):new Uint16Array(t);if("float32"===r)if("uint8"===s.dtype||"uint16"===s.dtype){i=new Float32Array(u.length);for(let e=0;e<u.length;e++){const t=u[e];i[e]=t*s.scale+s.min}}else{if("float16"!==s.dtype)throw new Error(`Unsupported quantization type ${s.dtype} for weight type float32.`);{const e=function(){const e=function(){const e=e=>{let t=e<<13,n=0;for(;0===(8388608&t);)n-=8388608,t<<=1;return t&=-8388609,n+=947912704,t|n},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}(),t=function(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}(),n=function(){const e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}();return r=>{const s=new ArrayBuffer(4*r.length),a=new Uint32Array(s);for(let i=0;i<r.length;i++){const s=r[i],o=e[n[s>>10]+(1023&s)]+t[s>>10];a[i]=o}return new Float32Array(s)}}();i=e(u)}}else{if("int32"!==r)throw new Error(`Unsupported dtype in weight '${n}': ${r}`);if("uint8"!==s.dtype&&"uint16"!==s.dtype)throw new Error(`Unsupported quantization type ${s.dtype} for weight type int32.`);i=new Int32Array(u.length);for(let e=0;e<u.length;e++){const t=u[e];i[e]=Math.round(t*s.scale+s.min)}}o+=a*l}else if("string"===r){const n=xr(e.shape);i=[];for(let e=0;e<n;e++){const e=new Uint32Array(t.slice(o,o+Ql))[0];o+=Ql;const n=new Uint8Array(t.slice(o,o+e));i.push(n),o+=e}}else{const e=Vl[r];if("float32"===r)i=new Float32Array(t);else if("int32"===r)i=new Int32Array(t);else{if("bool"!==r){if("complex64"===r){i=new Float32Array(t);const e=new Float32Array(i.length/2),n=new Float32Array(i.length/2);for(let t=0;t<e.length;t++)e[t]=i[2*t],n[t]=i[2*t+1];const r=Bl(e,s,"float32"),a=Bl(n,s,"float32"),o=Pl(r,a);return r.dispose(),a.dispose(),o}throw new Error(`Unsupported dtype in weight '${n}': ${r}`)}i=new Uint8Array(t)}o+=a*e}return Bl(i,s,r)}async function nu(e,t,n){let r=new Uint8Array(t);for(;r.byteLength<n;){const{done:t,value:s}=await e.read();if(t&&null==s){const e=n-r.byteLength;throw new Error(`Reader is done but ${e} bytes are still expected`)}const a=new Uint8Array(r.length+s.byteLength);a.set(r,0),a.set(new Uint8Array(s),r.length),r=a}return r.buffer}async function ru(e,t){const n={},r=e.getReader();let s=new ArrayBuffer(0);for(const a of t){const e=await eu(a,(async(e,t)=>(s=await nu(r,s,t),s.slice(e,t))));s=await nu(r,s,e);const t=s.slice(0,e);s=s.slice(e);const i=tu(a,t);if(n[a.name]=i,"webgpu"===Il.backendName){const e=Xl();"uploadToGPU"in e&&xr(i.shape)>=Yr().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&e.uploadToGPU(i.dataId)}}return n}function su(e){if(null===e)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0;const n=[];e.forEach((e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${e.constructor.name}`)}));const r=new Uint8Array(t);let s=0;return n.forEach((e=>{r.set(new Uint8Array(e.buffer),s),s+=e.byteLength})),r.buffer}const au="undefined"!==typeof Buffer&&("undefined"===typeof Blob||"undefined"===typeof atob||"undefined"===typeof btoa);function iu(e){return au?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function ou(e){return Wl.join(e)}function lu(e){for(e=e.trim();e.endsWith("/");)e=e.slice(0,e.length-1);const t=e.split("/");return t[t.length-1]}function uu(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(n.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}function cu(e,t,n){const r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(r.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=n}return null!=e.signature&&(r.signature=e.signature),null!=e.userDefinedMetadata&&(r.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(r.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(r.initializerSignature=e.initializerSignature),r}async function hu(e,t){let n,r;return null!=e.weightsManifest&&([n,r]=await t(e.weightsManifest)),cu(e,n,r)}function du(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:iu(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:iu(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:new Wl(e.weightData).byteLength}}function pu(e){const t=[];for(const n of e)t.push(...n.weights);return t}class fu{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==fu.instance&&(fu.instance=new fu),fu.instance}static registerSaveRouter(e){fu.getInstance().saveRouters.push(e)}static registerLoadRouter(e){fu.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return fu.getHandlers(e,"save")}static getLoadHandlers(e,t){return fu.getHandlers(e,"load",t)}static getHandlers(e,t,n){const r=[];return("load"===t?fu.getInstance().loadRouters:fu.getInstance().saveRouters).forEach((t=>{const s=t(e,n);null!==s&&r.push(s)})),r}}const mu=e=>fu.registerSaveRouter(e),gu=e=>fu.registerLoadRouter(e),yu=e=>fu.getSaveHandlers(e),bu=(e,t)=>fu.getLoadHandlers(e,t),vu="tensorflowjs",xu="models_store",wu="model_info_store";function ku(){if(!Yr().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"===typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function Su(e){const t=e.result;t.createObjectStore(xu,{keyPath:"modelPath"}),t.createObjectStore(wu,{keyPath:"modelPath"})}class Nu{constructor(e){if(this.indexedDB=ku(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{const r=this.indexedDB.open(vu,1);r.onupgradeneeded=()=>Su(r),r.onsuccess=()=>{const s=r.result;if(null==t){const t=s.transaction(xu,"readonly"),r=t.objectStore(xu).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return s.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(r.result.modelArtifacts)},r.onerror=e=>(s.close(),n(r.error)),t.oncomplete=()=>s.close()}else{t.weightData=Wl.join(t.weightData);const r=du(t),i=s.transaction(wu,"readwrite");let o,l,u=i.objectStore(wu);try{o=u.put({modelPath:this.modelPath,modelArtifactsInfo:r})}catch(a){return n(a)}o.onsuccess=()=>{l=s.transaction(xu,"readwrite");const o=l.objectStore(xu);let c;try{c=o.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:r})}catch(a){return n(a)}c.onsuccess=()=>e({modelArtifactsInfo:r}),c.onerror=e=>{u=i.objectStore(wu);const t=u.delete(this.modelPath);t.onsuccess=()=>(s.close(),n(c.error)),t.onerror=e=>(s.close(),n(c.error))}},o.onerror=e=>(s.close(),n(o.error)),i.oncomplete=()=>{null==l?s.close():l.oncomplete=()=>s.close()}}},r.onerror=e=>n(r.error)}))}}Nu.URL_SCHEME="indexeddb://";const Iu=e=>{return Yr().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Nu.URL_SCHEME)?(t=e.slice(Nu.URL_SCHEME.length),new Nu(t)):null;var t};fu.registerSaveRouter(Iu),fu.registerLoadRouter(Iu);class Cu{constructor(){this.indexedDB=ku()}async listModels(){return new Promise(((e,t)=>{const n=this.indexedDB.open(vu,1);n.onupgradeneeded=()=>Su(n),n.onsuccess=()=>{const r=n.result,s=r.transaction(wu,"readonly"),a=s.objectStore(wu).getAll();a.onsuccess=()=>{const t={};for(const e of a.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},a.onerror=e=>(r.close(),t(a.error)),s.oncomplete=()=>r.close()},n.onerror=e=>t(n.error)}))}async removeModel(e){var t;return e=(t=e).startsWith(Nu.URL_SCHEME)?t.slice(Nu.URL_SCHEME.length):t,new Promise(((t,n)=>{const r=this.indexedDB.open(vu,1);r.onupgradeneeded=()=>Su(r),r.onsuccess=()=>{const s=r.result,a=s.transaction(wu,"readwrite"),i=a.objectStore(wu),o=i.get(e);let l;o.onsuccess=()=>{if(null==o.result)return s.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const r=i.delete(e),a=()=>{l=s.transaction(xu,"readwrite");const r=l.objectStore(xu).delete(e);r.onsuccess=()=>t(o.result.modelArtifactsInfo),r.onerror=e=>n(o.error)};r.onsuccess=a,r.onerror=e=>(a(),s.close(),n(o.error))}},o.onerror=e=>(s.close(),n(o.error)),a.oncomplete=()=>{null==l?s.close():l.oncomplete=()=>s.close()}},r.onerror=e=>n(r.error)}))}}const Tu="/",Au="tensorflowjs_models",Eu="info",$u="model_topology",Ru="weight_specs",Du="weight_data",Ou="model_metadata";function _u(e){return{info:[Au,e,Eu].join(Tu),topology:[Au,e,$u].join(Tu),weightSpecs:[Au,e,Ru].join(Tu),weightData:[Au,e,Du].join(Tu),modelMetadata:[Au,e,Ou].join(Tu)}}function Fu(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function Mu(e){const t=e.split(Tu);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(Tu)}class Lu{constructor(e){if(!Yr().getBool("IS_BROWSER")||"undefined"===typeof window||"undefined"===typeof window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=_u(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),s=du(e),a=Wl.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,function(e){if(au)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let r=0,s=t.length;r<s;r++)n+=String.fromCharCode(t[r]);return btoa(n)}(a));const t={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(t)),{modelArtifactsInfo:s}}catch(t){throw Fu(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;const s=this.LS.getItem(this.keys.modelMetadata);if(null!=s){const e=JSON.parse(s);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(t.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}const a=this.LS.getItem(this.keys.weightData);if(null==a)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=function(e){if(au){const t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let r=0;r<t.length;++r)n.set([t.charCodeAt(r)],r);return n.buffer}(a),t}}Lu.URL_SCHEME="localstorage://";const Pu=e=>{return Yr().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Lu.URL_SCHEME)?(t=e.slice(Lu.URL_SCHEME.length),new Lu(t)):null;var t};fu.registerSaveRouter(Pu),fu.registerLoadRouter(Pu);class zu{constructor(){yr(Yr().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),yr("undefined"===typeof window||"undefined"!==typeof window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const e={},t=Au+Tu,n=Tu+Eu;for(let r=0;r<this.LS.length;++r){const s=this.LS.key(r);if(s.startsWith(t)&&s.endsWith(n)){e[Mu(s)]=JSON.parse(this.LS.getItem(s))}}return e}async removeModel(e){var t;const n=_u(e=(t=e).startsWith(Lu.URL_SCHEME)?t.slice(Lu.URL_SCHEME.length):t);if(null==this.LS.getItem(n.info))throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(n.info));return Fu(n),r}}const Bu="://";class Vu{constructor(){this.managers={}}static getInstance(){return null==Vu.instance&&(Vu.instance=new Vu),Vu.instance}static registerManager(e,t){yr(null!=e,(()=>"scheme must not be undefined or null.")),e.endsWith(Bu)&&(e=e.slice(0,e.indexOf(Bu))),yr(e.length>0,(()=>"scheme must not be an empty string."));const n=Vu.getInstance();yr(null==n.managers[e],(()=>`A model store manager is already registered for scheme '${e}'.`)),n.managers[e]=t}static getManager(e){const t=Vu.getInstance().managers[e];if(null==t)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(Vu.getInstance().managers)}}function Wu(e){if(-1===e.indexOf(Bu))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Vu.getSchemes().join(",")}`);return{scheme:e.split(Bu)[0],path:e.split(Bu)[1]}}async function Uu(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];yr(e!==t,(()=>`Old path and new path are the same: '${e}'`));const r=fu.getLoadHandlers(e);yr(r.length>0,(()=>`Copying failed because no load handler is found for source URL ${e}.`)),yr(r.length<2,(()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${e}.`));const s=r[0],a=fu.getSaveHandlers(t);yr(a.length>0,(()=>`Copying failed because no save handler is found for destination URL ${t}.`)),yr(a.length<2,(()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`));const i=a[0],o=Wu(e).scheme,l=Wu(e).path,u=o===Wu(e).scheme,c=await s.load();n&&u&&await Vu.getManager(o).removeModel(l);const h=await i.save(c);return n&&!u&&await Vu.getManager(o).removeModel(l),h.modelArtifactsInfo}async function ju(){const e=Vu.getSchemes(),t={};for(const n of e){const e=await Vu.getManager(n).listModels();for(const r in e){t[n+Bu+r]=e[r]}}return t}async function Gu(e){const t=Wu(e);return Vu.getManager(t.scheme).removeModel(t.path)}async function Hu(e,t){return Uu(e,t,!1)}async function qu(e,t){return Uu(e,t,!0)}class Ku{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){"undefined"!==typeof window&&Yr().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(e),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(e=>{if(e.source===window&&e.data.name===this.messageName){e.stopPropagation();(0,this.functionRefs[e.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}}),!0))):setTimeout(e,t)}isTypedArray(e){return No(e)}}if(Yr().get("IS_BROWSER")){Yr().setPlatform("browser",new Ku);try{Vu.registerManager(Lu.URL_SCHEME,new zu)}catch($9){}try{Vu.registerManager(Nu.URL_SCHEME,new Cu)}catch($9){}}const Xu=()=>n(817);let Qu;class Yu{constructor(){this.util=n(590),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=Yr().global.fetch?Yr().global.fetch(e,t):(null==Qu&&(Qu=Xu()),Qu(e,t))}now(){const e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}function Zu(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2?arguments[2]:void 0;return t=t||"float32",jr(e),new el(e,t,n)}Yr().get("IS_NODE")&&!Yr().get("IS_BROWSER")&&Yr().setPlatform("node",new Yu);const Ju=Ll({cast_:function(e,t){const n=_l(e,"x","cast");if(!function(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const r={x:n},s={dtype:t};return Il.runKernel(Is,r,s)}});const ec=Ll({clone_:function(e){const t={x:_l(e,"x","clone","string_or_numeric")};return Il.runKernel(ya,t)}});function tc(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];console.log(e.toString(t))}Nl();nl={buffer:Zu,cast:Ju,clone:ec,print:tc};const nc=Ll({add_:function(e,t){let n=_l(e,"a","add"),r=_l(t,"b","add");[n,r]=yl(n,r);const s={a:n,b:r};return Il.runKernel(as,s)}});const rc=Ll({floorDiv_:function(e,t){let n=_l(e,"a","floorDiv"),r=_l(t,"b","floorDiv");[n,r]=yl(n,r);const s={a:n,b:r};return Il.runKernel(ha,s)}});const sc=Ll({div_:function(e,t){let n=_l(e,"a","div"),r=_l(t,"b","div");if([n,r]=yl(n,r),"int32"===n.dtype&&"int32"===r.dtype)return rc(n,r);const s={a:n,b:r};return Il.runKernel(Zs,s,{})}});const ac=Ll({mul_:function(e,t){let n=_l(e,"a","mul"),r=_l(t,"b","mul");[n,r]=yl(n,r);const s={a:n,b:r};return Il.runKernel(qa,s)}});const ic=Ll({sqrt_:function(e){const t={x:_l(e,"x","sqrt","float32")};return Il.runKernel(Oi,t)}});const oc=Ll({square_:function(e){const t=_l(e,"x","square");return Il.runKernel("Square",{x:t},{})}});const lc=Ll({zerosLike_:function(e){const t={x:_l(e,"x","zerosLike")};return Il.runKernel(io,t)}});function uc(e){return Il.customGrad(e)}function cc(e,t){if((jo(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&jo(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return zl(e,[],[],t)}const hc=new Map,dc=new Map;class pc{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class fc{constructor(){this.classNameMap={}}static getMap(){return null==fc.instance&&(fc.instance=new fc),fc.instance}static register(e){fc.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function mc(e,t,n){yr(null!=e.className,(()=>"Class being registered does not have the static className property defined.")),yr("string"===typeof e.className,(()=>"className is required to be a string, but got type "+typeof e.className)),yr(e.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),"undefined"===typeof t&&(t="Custom"),"undefined"===typeof n&&(n=e.className);const r=t+">"+n;return fc.register(e),hc.set(r,e),dc.set(e,r),e}class gc extends pc{minimize(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2?arguments[2]:void 0;const{value:r,grads:s}=this.computeGradients(e,n);if(null!=n){const e=n.map((e=>({name:e.name,tensor:s[e.name]})));this.applyGradients(e)}else this.applyGradients(s);return Hl(s),t?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return function(e,t){yr(Mr(e),(()=>"The f passed in variableGrads(f) must be a function")),yr(null==t||Array.isArray(t)&&t.every((e=>e instanceof il)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));const n=null!=t;if(!n){t=[];for(const e in Il.registeredVariables)t.push(Il.registeredVariables[e])}const r=n?t.filter((e=>!e.trainable)):null,s=t.length;t=t.filter((e=>e.trainable)),yr(t.length>0,(()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`));const{value:a,grads:i}=Il.gradients(e,t,null,!0);yr(i.some((e=>null!=e)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),yr(0===a.rank,(()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`));const o={};return t.forEach(((e,t)=>{null!=i[t]&&(o[e.name]=i[t])})),null!=r&&r.forEach((e=>o[e.name]=null)),{value:a,grads:o}}(e,t)}dispose(){null!=this.iterations_&&Hl(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:cc(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(gc,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});class yc extends gc{static get className(){return"Adadelta"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=Il.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=Il.registeredVariables[t],s=!1;null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:Gl((()=>lc(r).variable(s)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:Gl((()=>lc(r).variable(s)))});const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const i=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;Gl((()=>{const e=nc(ac(i,this.rho),ac(oc(a),1-this.rho)),t=ac(sc(ic(nc(o,this.epsilon)),ic(nc(i,this.epsilon))),a),n=nc(ac(o,this.rho),ac(oc(t),1-this.rho));i.assign(e),o.assign(n);const s=nc(ac(t,-this.learningRate),r);r.assign(s)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(Hl(this.accumulatedGrads.map((e=>e.variable))),Hl(this.accumulatedUpdates.map((e=>e.variable))))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){const t=(e=await this.extractIterations(e)).length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedUpdates=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}function bc(e,t,n){jr(e);const r={shape:e,value:t,dtype:n=n||Fr(t)};return Il.runKernel(la,{},r)}class vc extends gc{static get className(){return"Adagrad"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1;super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=Il.registeredVariables[t];if(null==this.accumulatedGrads[n]){const e=!1;this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:Gl((()=>bc(r.shape,this.initialAccumulatorValue).variable(e)))}}const s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;const a=this.accumulatedGrads[n].variable;Gl((()=>{const e=nc(a,oc(s));a.assign(e);const t=nc(ac(sc(s,ic(nc(e,Il.backend.epsilon()))),-this.learningRate),r);r.assign(t)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&Hl(this.accumulatedGrads.map((e=>e.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulatedGrads=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}const xc=Ll({pow_:function(e,t){let n=_l(e,"base","pow"),r=_l(t,"exp","pow");[n,r]=yl(n,r);const s={a:n,b:r};return Il.runKernel(ri,s)}});const wc=Ll({sub_:function(e,t){let n=_l(e,"a","sub"),r=_l(t,"b","sub");[n,r]=yl(n,r);const s={a:n,b:r};return Il.runKernel(Qi,s)}});class kc extends gc{static get className(){return"Adam"}constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Gl((()=>{this.accBeta1=cc(t).variable(),this.accBeta2=cc(n).variable()})),null==r&&(this.epsilon=Il.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);Gl((()=>{const n=wc(1,this.accBeta1),r=wc(1,this.accBeta2);t.forEach(((t,s)=>{const a=Il.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[s]&&(this.accumulatedFirstMoment[s]={originalName:`${t}/m`,variable:Gl((()=>lc(a).variable(i)))}),null==this.accumulatedSecondMoment[s]&&(this.accumulatedSecondMoment[s]={originalName:`${t}/v`,variable:Gl((()=>lc(a).variable(i)))});const o=Array.isArray(e)?e[s].tensor:e[t];if(null==o)return;const l=this.accumulatedFirstMoment[s].variable,u=this.accumulatedSecondMoment[s].variable,c=nc(ac(l,this.beta1),ac(o,1-this.beta1)),h=nc(ac(u,this.beta2),ac(oc(o),1-this.beta2)),d=sc(c,n),p=sc(h,r);l.assign(c),u.assign(h);const f=nc(ac(sc(d,nc(ic(p),this.epsilon)),-this.learningRate),a);a.assign(f)})),this.accBeta1.assign(ac(this.accBeta1,this.beta1)),this.accBeta2.assign(ac(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&Hl(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedSecondMoment&&Hl(this.accumulatedSecondMoment.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),Gl((()=>{this.accBeta1.assign(xc(this.beta1,this.iterations_+1)),this.accBeta2.assign(xc(this.beta2,this.iterations_+1))}));const t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedSecondMoment=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}const Sc=Ll({abs_:function(e){const t=_l(e,"x","abs");if("complex64"===t.dtype){const e={x:t};return Il.runKernel(Es,e)}{const e={x:t};return Il.runKernel(ns,e)}}});function Nc(e,t){const n=e.length,r=[];for(let s=0;s<n;s++){const a=n-1-s,i=e[a]||1;(t[t.length-1-s]||1)>1&&1===i&&r.unshift(a)}return r}function Ic(e,t){const n=[];for(let r=0;r<t.length;r++){const s=e[e.length-r-1],a=t.length-r-1,i=t[a];(null==s||1===s&&i>1)&&n.unshift(a)}return n}function Cc(e,t){const n=Math.max(e.length,t.length),r=new Array(n);for(let s=0;s<n;s++){let a=e[e.length-s-1];null==a&&(a=1);let i=t[t.length-s-1];if(null==i&&(i=1),1===a)r[n-s-1]=i;else if(1===i)r[n-s-1]=a;else{if(a!==i){throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`)}r[n-s-1]=a}}return r}const Tc=Ll({maximum_:function(e,t){let n=_l(e,"a","maximum"),r=_l(t,"b","maximum");[n,r]=yl(n,r),"bool"===n.dtype&&(n=Ju(n,"int32"),r=Ju(r,"int32")),Cc(n.shape,r.shape);const s={a:n,b:r};return Il.runKernel(Fa,s)}});class Ac extends gc{static get className(){return"Adamax"}constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Gl((()=>{this.iteration=cc(0).variable(),this.accBeta1=cc(t).variable()})),null==r&&(this.epsilon=Il.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);Gl((()=>{const n=wc(1,this.accBeta1),r=sc(-this.learningRate,nc(ac(this.iteration,this.decay),1));t.forEach(((t,s)=>{const a=Il.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[s]&&(this.accumulatedFirstMoment[s]={originalName:`${t}/m`,variable:lc(a).variable(i)}),null==this.accumulatedWeightedInfNorm[s]&&(this.accumulatedWeightedInfNorm[s]={originalName:`${t}/v`,variable:lc(a).variable(i)});const o=Array.isArray(e)?e[s].tensor:e[t];if(null==o)return;const l=this.accumulatedFirstMoment[s].variable,u=this.accumulatedWeightedInfNorm[s].variable,c=nc(ac(l,this.beta1),ac(o,1-this.beta1)),h=ac(u,this.beta2),d=Sc(o),p=Tc(h,d);l.assign(c),u.assign(p);const f=nc(ac(sc(r,n),sc(c,nc(p,this.epsilon))),a);a.assign(f)})),this.iteration.assign(nc(this.iteration,1)),this.accBeta1.assign(ac(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&Hl(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedWeightedInfNorm&&Hl(this.accumulatedWeightedInfNorm.map((e=>e.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}class Ec extends gc{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const s=Il.registeredVariables[t];Gl((()=>{const e=nc(ac(this.c,r),s);s.assign(e)}))})),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=ql(cc(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}class $c extends Ec{static get className(){return"Momentum"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=cc(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=Il.registeredVariables[t];if(null==this.accumulations[n]){const e=!1;this.accumulations[n]={originalName:`${t}/momentum`,variable:Gl((()=>lc(r).variable(e)))}}const s=this.accumulations[n].variable,a=Array.isArray(e)?e[n].tensor:e[t];null!=a&&Gl((()=>{let e;const t=nc(ac(this.m,s),a);e=this.useNesterov?nc(ac(this.c,nc(a,ac(t,this.m))),r):nc(ac(this.c,t),r),s.assign(t),r.assign(e)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&Hl(this.accumulations.map((e=>e.variable)))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulations=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}class Rc extends gc{static get className(){return"RMSProp"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,null==r&&(this.epsilon=Il.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=Il.registeredVariables[t],s=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:Gl((()=>lc(r).variable(s)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:Gl((()=>lc(r).variable(s)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:Gl((()=>lc(r).variable(s)))});const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const i=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;Gl((()=>{const e=nc(ac(i,this.decay),ac(oc(a),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[n].variable,s=nc(ac(t,this.decay),ac(a,1-this.decay)),l=sc(ac(a,this.learningRate),ic(wc(e,nc(oc(s),this.epsilon)))),u=nc(ac(o,this.momentum),l);i.assign(e),t.assign(s),o.assign(u);const c=wc(r,u);r.assign(c)}else{const e=nc(ac(i,this.decay),ac(oc(a),1-this.decay)),t=nc(ac(o,this.momentum),sc(ac(a,this.learningRate),ic(nc(e,this.epsilon))));i.assign(e),o.assign(t);const n=wc(r,t);r.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&Hl(this.accumulatedMeanSquares.map((e=>e.variable))),null!=this.accumulatedMeanGrads&&this.centered&&Hl(this.accumulatedMeanGrads.map((e=>e.variable))),null!=this.accumulatedMoments&&Hl(this.accumulatedMoments.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedMoments=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}const Dc=[yc,vc,kc,Ac,$c,Rc,Ec];function Oc(e){return new Promise((e=>setTimeout(e))).then(e)}class _c{constructor(e){if(!Yr().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(_c.URL_SCHEME)&&(e=e.slice(_c.URL_SCHEME.length)),null!=e&&0!==e.length||(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if("undefined"===typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=Wl.join(e.weightData),n=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const t=uu(e,[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}]),r=window.URL.createObjectURL(new Blob([JSON.stringify(t)],{type:"application/json"})),s=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(s.download=this.modelJsonFileName,s.href=r,await Oc((()=>s.dispatchEvent(new MouseEvent("click")))),null!=e.weightData){const e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=n,await Oc((()=>e.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:du(e)}}}}_c.URL_SCHEME="downloads://";class Fc{constructor(e){if(null==e||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise(((e,t)=>{const n=new FileReader;n.onload=n=>{const r=JSON.parse(n.target.result),s=r.modelTopology;if(null==s)return void t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));if(null==r.weightsManifest)return void t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));if(0===this.weightsFiles.length)return void e({modelTopology:s});const a=hu(r,(e=>this.loadWeights(e)));e(a)},n.onerror=e=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)}))}loadWeights(e){const t=[],n=[];for(const a of e)t.push(...a.weights),n.push(...a.paths);const r=this.checkManifestAndWeightFiles(e),s=n.map((e=>this.loadWeightsFile(e,r[e])));return Promise.all(s).then((e=>[t,e]))}loadWeightsFile(e,t){return new Promise(((n,r)=>{const s=new FileReader;s.onload=e=>{const t=e.target.result;n(t)},s.onerror=t=>r(`Failed to weights data from file of path '${e}'.`),s.readAsArrayBuffer(t)}))}checkManifestAndWeightFiles(e){const t=[],n=this.weightsFiles.map((e=>lu(e.name))),r={};for(const s of e)s.paths.forEach((e=>{const s=lu(e);if(-1!==t.indexOf(s))throw new Error(`Duplicate file basename found in weights manifest: '${s}'`);if(t.push(s),-1===n.indexOf(s))throw new Error(`Weight file with basename '${s}' is not provided.`);r[e]=this.weightsFiles[n.indexOf(s)]}));if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}function Mc(e){return new Fc(e)}function Lc(e,t,n,r){!function(e){yr(null!=e&&Array.isArray(e)&&e.length>0,(()=>"promises must be a none empty array"))}(e),function(e,t){yr(e>=0&&e<=1,(()=>`Progress fraction must be in range [0, 1], but got startFraction ${e}`)),yr(t>=0&&t<=1,(()=>`Progress fraction must be in range [0, 1], but got endFraction ${t}`)),yr(t>=e,(()=>`startFraction must be no more than endFraction, but got startFraction ${e} and endFraction ${t}`))}(n=null==n?0:n,r=null==r?1:r);let s=0;return Promise.all(e.map((a=>(a.then((a=>{const i=n+ ++s/e.length*(r-n);return t(i),a})),a))))}async function Pc(e,t){null==t&&(t={});const n=null==t.fetchFunc?Yr().platform.fetch:t.fetchFunc,r=e.map((e=>n(e,t.requestInit,{isBinary:!0}))),s=(null==t.onProgress?await Promise.all(r):await Lc(r,t.onProgress,0,.5)).map((e=>e.arrayBuffer()));return null==t.onProgress?await Promise.all(s):await Lc(s,t.onProgress,.5,1)}async function zc(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return Bc((e=>Pc(e,{requestInit:r})))(e,t,n)}function Bc(e){return async function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",r=arguments.length>2?arguments[2]:void 0;const s=t.map((()=>!1)),a={},i=null!=r?r.map((()=>!1)):[],o=[];if(t.forEach(((e,t)=>{let n=0;e.weights.forEach((e=>{const l="quantization"in e?e.quantization.dtype:e.dtype,u=Vl[l]*xr(e.shape),c=()=>{s[t]=!0,null==a[t]&&(a[t]=[]),a[t].push({manifestEntry:e,groupOffset:n,sizeBytes:u})};null!=r?r.forEach(((t,n)=>{t===e.name&&(c(),i[n]=!0)})):c(),o.push(e.name),n+=u}))})),!i.every((e=>e))){const e=r.filter(((e,t)=>!i[t]));throw new Error(`Could not find weights in manifest with names: ${e.join(", ")}. \nManifest JSON has weights with names: ${o.join(", ")}.`)}const l=s.reduce(((e,t,n)=>(t&&e.push(n),e)),[]),u=[];l.forEach((e=>{t[e].paths.forEach((e=>{const t=n+(n.endsWith("/")?"":"/")+e;u.push(t)}))}));const c=await e(u),h={};let d=0;return l.forEach((e=>{const n=t[e].paths.length,r=new Wl(c.slice(d,d+n));a[e].forEach((e=>{const t=Zl(r.slice(e.groupOffset,e.groupOffset+e.sizeBytes),[e.manifestEntry]);for(const n in t)h[n]=t[n]})),d+=n})),h}}fu.registerSaveRouter((e=>Yr().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(_c.URL_SCHEME)?function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"model";return new _c(e)}(e.slice(_c.URL_SCHEME.length)):null));class Vc{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(yr("function"===typeof t.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=t.fetchFunc):this.fetch=Yr().platform.fetch,yr(null!=e&&e.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(e)&&yr(2===e.length,(()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`)),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=uu(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);if(t.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=e.weightData){const n=Wl.join(e.weightData);t.body.append("model.weights.bin",new Blob([n],{type:"application/octet-stream"}),"model.weights.bin")}const r=await this.fetch(this.path,t);if(r.ok)return{modelArtifactsInfo:du(e),responses:[r]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`)}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch(E9){let t=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}const n=t.modelTopology,r=t.weightsManifest;if(null==n&&null==r)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();return hu(await this.loadModelJSON(),(e=>this.loadWeights(e)))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=pu(e.weightsManifest);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:()=>function(e,t){var n;const r=null==t.fetchFunc?Yr().platform.fetch:t.fetchFunc;let s,a=0;return null===(n=t.onProgress)||void 0===n||n.call(t,0),new ReadableStream({pull:async n=>{for(var i;a<e.length;){if(!s){const n=(await r(e[a],t.requestInit,{isBinary:!0})).body;s=n.getReader()}const{done:o,value:l}=await s.read();if(!o)return void n.enqueue(l);a++,s=void 0,null===(i=t.onProgress)||void 0===i||i.call(t,a/e.length)}n.close()}})}(t,this.loadOptions)})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),r=e.substring(0,t),s=n>t?e.substring(n):"";return[r+"/",s]}(t),s=this.weightPathPrefix||n,a=[],i=[];for(const o of e)for(const e of o.paths)null!=this.weightUrlConverter?i.push(this.weightUrlConverter(e)):a.push(s+e+r);return this.weightUrlConverter&&a.push(...await Promise.all(i)),a}async loadWeights(e){const t=await this.getWeightUrls(e);return[pu(e),await Pc(t,this.loadOptions)]}}function Wc(e){return null!=e.match(Vc.URL_SCHEME_REGEX)}Vc.URL_SCHEME_REGEX=/^https?:\/\//;const Uc=(e,t)=>{if("undefined"===typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every((e=>Wc(e))):Wc(e),n)return jc(e,t)}return null};function jc(e,t){return new Vc(e,t)}function Gc(e,t){return jc(e,t)}fu.registerSaveRouter(Uc),fu.registerLoadRouter(Uc);class Hc{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class qc{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class Kc{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function Xc(e,t,n,r){return new Kc(Qc(...arguments))}function Qc(e,t,n,r){if(1===arguments.length){return null!=e.modelTopology||null!=e.weightSpecs?new Hc(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Hc({modelTopology:e}))}return console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Hc({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:r})}function Yc(e){return new qc(e)}function Zc(e){return new qc(e)}function Jc(e,t,n){if(vr(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const r=Rl(e,n);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return zl(e,t,r,n)}const eh=-2,th=-1;function nh(e,t,n){const r=e.shape.length;yr(r===t.length,(()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`)),yr(r===n.length,(()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`));for(let s=0;s<r;++s)yr(t[s]+n[s]<=e.shape[s],(()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${t[s]+n[s]}) would overflow input.shape[${s}] (${e.shape[s]})`))}function rh(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function sh(e,t,n){const r=[];for(let s=0;s<e.length;s++)r[s]=Math.ceil((t[s]-e[s])/n[s]);return r}function ah(e,t,n,r){const s=[...e];for(let a=s.length;a<r.length;a++)s.push(1);for(let a=0;a<n;a++)0===a?s[t]=1:(s.splice(t,0,1),s.pop());return s}function ih(e,t,n){return n<=e?n:n-(t-1)}function oh(e,t){const n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function lh(e,t,n,r,s,a,i,o,l){const u=e.length;let c=new Array(u),h=new Array(u),d=new Array(u);if(t.length&&n>0){const l=t[0],u=n+1;c=uh(i,l,u,r,e),h=ch(o,l,u,s,e),d=ah(a,l,u,e)}else for(let p=0;p<u;p++)c[p]=dh(i,r,a,e,p,l),h[p]=ph(o,s,a,e,p,l),d[p]=hh(a,p,l);return{begin:c,end:h,strides:d}}function uh(e,t,n,r,s){const a=[...s],i=oh(n,t);for(let o=0;o<a.length;o++)if(i.indexOf(o)>-1)a[o]=0;else{const s=ih(t,n,o);let i=r[s];e&1<<s&&(i=0),a[o]=i}return a}function ch(e,t,n,r,s){const a=[...s],i=oh(n,t);for(let o=0;o<a.length;o++)if(i.indexOf(o)>-1)a[o]=Number.MAX_SAFE_INTEGER;else{const s=ih(t,n,o);let i=r[s];e&1<<s&&(i=Number.MAX_SAFE_INTEGER),a[o]=i}for(let o=0;o<a.length;o++){const e=s[o];a[o]<0&&(a[o]+=e),a[o]=fr(0,a[o],s[o])}return a}function hh(e,t,n){let r=e[t];return(n&1<<t||null==r)&&(r=1),r}function dh(e,t,n,r,s,a){let i=t[s];const o=n[s]||1;(e&1<<s||a&1<<s||null==i)&&(i=o>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const l=r[s];return i<0&&(i+=l),i=fr(0,i,l-1),i}function ph(e,t,n,r,s,a){let i=t[s];const o=n[s]||1;(e&1<<s||a&1<<s||null==i)&&(i=o>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=r[s];return i<0&&(i+=l),i=o>0?fr(0,i,l):fr(-1,i,l-1),i}function fh(e,t,n){let r=n.length;for(let s=0;s<n.length;s++)if(n[s]>1){r=s;break}for(let s=r+1;s<n.length;s++)if(t[s]>0||n[s]!==e[s])return!1;return!0}function mh(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function gh(e,t,n){let r;const s=e.shape.length;let a;return r="number"===typeof t?[t,...new Array(s-1).fill(0)]:t.length<s?t.concat(new Array(s-t.length).fill(0)):t.slice(),r.forEach((e=>{yr(-1!==e,(()=>"slice() does not support negative begin indexing."))})),a=null==n?new Array(s).fill(-1):"number"===typeof n?[n,...new Array(s-1).fill(-1)]:n.length<s?n.concat(new Array(s-n.length).fill(-1)):n,a=a.map(((t,n)=>t>=0?t:(yr(-1===t,(()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`)),e.shape[n]-r[n]))),[r,a]}function yh(e,t,n,r,s,a,i,o,l){let u;if(null==r?(u=new Array(t.length),u.fill(1)):u=r,null!=i&&0!==(i&i-1))throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const h={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:u.slice(),beginMask:s,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};for(let v=0;v<h.dims;v++)c&&0!==(1<<v&o)&&h.numAddAxisAfterEllipsis++,1<<v&i&&(c=!0);c||(h.ellipsisMask|=1<<h.dims,h.dims++);const d={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){const s=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<s;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(eh),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=e.begin&&(t.begin[n]=e.begin[r]),null!=e.end&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(th),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}(h,d);let p=!0,f=!0,m=!0;const g=[],y=[];for(let v=0;v<e.length;++v){if(0===d.strides[v])throw Error(`strides[${v}] must be non-zero`);const t=!!(d.shrinkAxisMask&1<<v),n=e[v];if(-1===n){g.push(t?1:-1);continue}const r=[d.beginMask&1<<v,d.endMask&1<<v],s=[d.strides[v]>0?0:-1,d.strides[v]>0?n:n-1];if(t&&d.strides[v]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===d.strides[v];const a=!!(d.beginMask&1<<v&&d.endMask&1<<v);if(d.beginValid&&d.endValid){if(t){const e=d.begin[v]<0?n+d.begin[v]:d.begin[v];if(d.begin[v]=e,d.end[v]=d.begin[v]+1,e<0||e>=n)throw Error(`slice index ${d.begin[v]} of dimension ${v} out of bounds.`)}else d.begin[v]=bh(d.begin[v],0,d.strides[v],n,r,s),d.end[v]=bh(d.end[v],1,d.strides[v],n,r,s);const e=1===d.strides[v]&&0===d.begin[v]&&d.end[v]===n;p=p&&e,f=f&&(0===v&&1===d.strides[v]||e)}else p=p&&1===d.strides[v]&&a,f=f&&(0===v&&1===d.strides[v]||a);let i,o=!1;if(d.beginValid&&d.endValid?(i=d.end[v]-d.begin[v],o=!0):t?(i=1,o=!0):a&&n>=0&&(i=d.strides[v]<0?-n:n,o=!0),o){let e;e=0===i||i<0!==d.strides[v]<0?0:Math.trunc(i/d.strides[v])+(i%d.strides[v]!==0?1:0),g.push(e)}else g.push(-1)}for(let v=0;v<d.finalShapeGatherIndices.length;++v){const e=d.finalShapeGatherIndices[v];e>=0?y.push(g[e]):e===eh&&y.push(1)}const b=y.filter(((e,t)=>d.finalShapeGatherIndices[t]!==eh));return{finalShapeSparse:b,finalShape:y,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:d.begin,end:d.end,strides:d.strides}}function bh(e,t,n,r,s,a){if(s[t])return n>0?a[t]:a[t+1&1];{const t=e<0?r+e:e;return t<a[0]?a[0]:t>a[1]?a[1]:t}}const vh=Ll({acos_:function(e){const t={x:_l(e,"x","acos")};return Il.runKernel(rs,t)}});const xh=Ll({acosh_:function(e){const t={x:_l(e,"x","acosh")};return Il.runKernel(ss,t)}});const wh=Ll({addN_:function(e){yr(Array.isArray(e),(()=>"The argument passed to tf.addN() must be a list of tensors")),yr(e.length>=1,(()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`));const t=e.map(((e,t)=>_l(e,`tensors${t}`,"addN"))),n=t[0];t.forEach((e=>{if(e.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")})),t.forEach((e=>{if(!wr(e.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}));const r=t;return Il.runKernel(is,r)}});const kh=Ll({all_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:_l(e,"x","all","bool")},s={axis:t,keepDims:n};return Il.runKernel(os,r,s)}});const Sh=Ll({any_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:_l(e,"x","any","bool")},s={axis:t,keepDims:n};return Il.runKernel(ls,r,s)}});const Nh=Ll({argMax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:_l(e,"x","argMax")},r={axis:t};return Il.runKernel(us,n,r)}});const Ih=Ll({argMin_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:_l(e,"x","argMin")},r={axis:t};return Il.runKernel(cs,n,r)}});const Ch=Ll({asin_:function(e){const t={x:_l(e,"x","asin")};return Il.runKernel(hs,t)}});const Th=Ll({asinh_:function(e){const t={x:_l(e,"x","asinh")};return Il.runKernel(ds,t)}});const Ah=Ll({atan_:function(e){const t={x:_l(e,"x","atan")};return Il.runKernel(ps,t)}});const Eh=Ll({atan2_:function(e,t){let n=_l(e,"a","atan2"),r=_l(t,"b","atan2");[n,r]=yl(n,r);const s={a:n,b:r};return Il.runKernel(ms,s)}});const $h=Ll({atanh_:function(e){const t={x:_l(e,"x","atanh")};return Il.runKernel(fs,t)}});function Rh(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",a=arguments.length>5?arguments[5]:void 0;return _h(e,[...t,e[3]],n,a,r,null,null,jh(s))}function Dh(e,t,n,r,s,a){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast";const[o,l]=Lh(t);let u;if("channelsLast"===i)u=[o,l,e[3],e[3]];else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);u=[o,l,e[1],e[1]]}return _h(e,u,n,r,s,a,!1,i)}function Oh(e,t,n,r,s,a){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NDHWC";const[o,l,u]=Ph(t);let c,h;if("NDHWC"===i)h="channelsLast",c=[o,l,u,e[4],e[4]];else{if("NCDHW"!==i)throw new Error(`Unknown dataFormat ${i}`);h="channelsFirst",c=[o,l,u,e[1],e[1]]}return Fh(e,c,n,r,s,!1,h,a)}function _h(e,t,n,r,s,a){let i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:"channelsLast",[l,u,c,h]=[-1,-1,-1,-1];if("channelsLast"===o)[l,u,c,h]=e;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[l,h,u,c]=e}const[d,p,,f]=t,[m,g]=Lh(n),[y,b]=Lh(r),v=zh(d,y),x=zh(p,b),{padInfo:w,outHeight:k,outWidth:S}=function(e,t,n,r,s,a,i,o,l){let u,c,h;if("number"===typeof e){u={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const s=function(e,t,n,r,s){null==r&&(r=Mh(e,t,n));const a=e[0],i=e[1],o=Bh((a-t+2*r)/n+1,s),l=Bh((i-t+2*r)/n+1,s);return[o,l]}([t,n],a,r,e,o);c=s[0],h=s[1]}else if("same"===e){c=Math.ceil(t/r),h=Math.ceil(n/s);const e=Math.max(0,(c-1)*r+a-t),o=Math.max(0,(h-1)*s+i-n),l=Math.floor(e/2),d=e-l,p=Math.floor(o/2);u={top:l,bottom:d,left:p,right:o-p,type:"SAME"}}else if("valid"===e)u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-a+1)/r),h=Math.ceil((n-i+1)/s);else{if("object"!==typeof e)throw Error(`Unknown padding parameter: ${e}`);{const d="channelsLast"===l?e[1][0]:e[2][0],p="channelsLast"===l?e[1][1]:e[2][1],f="channelsLast"===l?e[2][0]:e[3][0],m="channelsLast"===l?e[2][1]:e[3][1];u={top:d,bottom:p,left:f,right:m,type:0===d&&0===p&&0===f&&0===m?"VALID":"EXPLICIT"},c=Bh((t-a+d+p)/r+1,o),h=Bh((n-i+f+m)/s+1,o)}}return{padInfo:u,outHeight:c,outWidth:h}}(s,u,c,m,g,v,x,a,o),N=i?f*h:f;let I;return"channelsFirst"===o?I=[l,N,k,S]:"channelsLast"===o&&(I=[l,k,S,N]),{batchSize:l,dataFormat:o,inHeight:u,inWidth:c,inChannels:h,outHeight:k,outWidth:S,outChannels:N,padInfo:w,strideHeight:m,strideWidth:g,filterHeight:d,filterWidth:p,effectiveFilterHeight:v,effectiveFilterWidth:x,dilationHeight:y,dilationWidth:b,inShape:e,outShape:I,filterShape:t}}function Fh(e,t,n,r,s){let a=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast",o=arguments.length>7?arguments[7]:void 0,[l,u,c,h,d]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[l,u,c,h,d]=e;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[l,d,u,c,h]=e}const[p,f,m,,g]=t,[y,b,v]=Ph(n),[x,w,k]=Ph(r),S=zh(p,x),N=zh(f,w),I=zh(m,k),{padInfo:C,outDepth:T,outHeight:A,outWidth:E}=function(e,t,n,r,s,a,i,o,l,u,c){let h,d,p,f;"valid"===e&&(e=0);if("number"===typeof e){h={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const m=function(e,t,n,r,s,a){null==s&&(s=Mh(e,t[0],r[0]));const i=[0,0,0,n];for(let o=0;o<3;o++)e[o]+2*s>=t[o]&&(i[o]=Bh((e[o]-t[o]+2*s)/r[o]+1,a));return i}([t,n,r,1],[o,l,u],1,[s,a,i],e,c);d=m[0],p=m[1],f=m[2]}else{if("same"!==e)throw Error(`Unknown padding parameter: ${e}`);{d=Math.ceil(t/s),p=Math.ceil(n/a),f=Math.ceil(r/i);const e=(d-1)*s+o-t,c=(p-1)*a+l-n,m=(f-1)*i+u-r,g=Math.floor(e/2),y=e-g,b=Math.floor(c/2),v=c-b,x=Math.floor(m/2);h={top:b,bottom:v,left:x,right:m-x,front:g,back:y,type:"SAME"}}}return{padInfo:h,outDepth:d,outHeight:p,outWidth:f}}(s,u,c,h,y,b,v,S,N,I,o),$=a?g*d:g;let R;return"channelsFirst"===i?R=[l,$,T,A,E]:"channelsLast"===i&&(R=[l,T,A,E,$]),{batchSize:l,dataFormat:i,inDepth:u,inHeight:c,inWidth:h,inChannels:d,outDepth:T,outHeight:A,outWidth:E,outChannels:$,padInfo:C,strideDepth:y,strideHeight:b,strideWidth:v,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:S,effectiveFilterHeight:N,effectiveFilterWidth:I,dilationDepth:x,dilationHeight:w,dilationWidth:k,inShape:e,outShape:R,filterShape:t}}function Mh(e,t,n){const r=zh(t,arguments.length>3&&void 0!==arguments[3]?arguments[3]:1);return Math.floor((e[0]*(n-1)-n+r)/2)}function Lh(e){return"number"===typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function Ph(e){return"number"===typeof e?[e,e,e]:e}function zh(e,t){return t<=1?e:e+(e-1)*(t-1)}function Bh(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function Vh(e){const[t,n,r]=Lh(e);return 1===t&&1===n&&1===r}function Wh(e,t){return Vh(e)||Vh(t)}function Uh(e){return Lh(e).every((e=>e>0))}function jh(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function Gh(e,t,n){if(null!=n){if("string"===typeof t)throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if("number"===typeof t)yr(kr(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`));else{if("object"!==typeof t)throw Error(`Error in ${e}: Unknown padding parameter: ${t}`);t.forEach((t=>{t.forEach((t=>{yr(kr(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`))}))}))}}}const Hh=Ll({reshape_:function(e,t){const n={x:_l(e,"x","reshape","string_or_numeric")},r={shape:t};return Il.runKernel(pi,n,r)}});const qh=Ll({avgPool_:function(e,t,n,r,s){const a=_l(e,"x","avgPool","float32");yr(Wh(n,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`));let i=a,o=!1;3===a.rank&&(o=!0,i=Hh(a,[1,a.shape[0],a.shape[1],a.shape[2]])),yr(4===i.rank,(()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`)),Gh("avgPool",r,s);const l={x:i},u={filterSize:t,strides:n,pad:r,dimRoundingMode:s};let c=Il.runKernel(gs,l,u);return c=Ju(c,a.dtype),o?Hh(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const Kh=Ll({avgPool3d_:function(e,t,n,r,s){let a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const i=_l(e,"x","avgPool3d","float32");let o=i,l=!1;4===i.rank&&(l=!0,o=Hh(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),yr(5===o.rank,(()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`)),yr("NDHWC"===a,(()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`)),yr("number"===typeof n&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,(()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`)),Gh("avgPool3d",r,s);const u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:a};let h=Il.runKernel(bs,u,c);return h=Ju(h,o.dtype),l?Hh(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const Xh=Ll({concat_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;yr(e.length>=1,(()=>"Pass at least one tensor to concat"));const n=Fl(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)})),1===n.length)return ec(n[0]);const r=n,s={axis:t};return Il.runKernel($s,r,s)}});const Qh=Ll({matMul_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=_l(e,"a","matMul"),a=_l(t,"b","matMul");[s,a]=yl(s,a);const i={a:s,b:a},o={transposeA:n,transposeB:r};return Il.runKernel(xs,i,o)}});const Yh=Ll({sigmoid_:function(e){const t={x:_l(e,"x","sigmoid","float32")};return Il.runKernel(Ri,t)}});const Zh=Ll({slice_:function(e,t,n){const r=_l(e,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");const s={x:r},a={begin:t,size:n};return Il.runKernel(Ti,s,a)}});const Jh=Ll({tanh_:function(e){const t={x:_l(e,"x","tanh","float32")};return Il.runKernel(Zi,t)}});const ed=Ll({basicLSTMCell_:function(e,t,n,r,s,a){const i=_l(e,"forgetBias","basicLSTMCell"),o=_l(t,"lstmKernel","basicLSTMCell"),l=_l(n,"lstmBias","basicLSTMCell"),u=_l(r,"data","basicLSTMCell"),c=_l(s,"c","basicLSTMCell"),h=_l(a,"h","basicLSTMCell"),d=Xh([u,h],1),p=Qh(d,o),f=nc(p,l),m=f.shape[0],g=f.shape[1]/4,y=[m,g],b=Zh(f,[0,0],y),v=Zh(f,[0,g],y),x=Zh(f,[0,2*g],y),w=Zh(f,[0,3*g],y),k=nc(ac(Yh(b),Jh(v)),ac(c,Yh(nc(i,x))));return[k,ac(Jh(k),Yh(w))]}});const td=Ll({batchToSpaceND_:function(e,t,n){const r=_l(e,"x","batchToSpaceND"),s=t.reduce(((e,t)=>e*t));yr(r.rank>=1+t.length,(()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`)),yr(n.length===t.length,(()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`)),yr(r.shape[0]%s===0,(()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${s}`));const a={x:r},i={blockShape:t,crops:n};return Il.runKernel(ws,a,i)}});const nd=Ll({batchNorm_:function(e,t,n,r,s,a){null==a&&(a=.001);const i=_l(e,"x","batchNorm"),o=_l(t,"mean","batchNorm"),l=_l(n,"variance","batchNorm");let u,c;null!=s&&(u=_l(s,"scale","batchNorm")),null!=r&&(c=_l(r,"offset","batchNorm")),yr(o.rank===l.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),yr(null==c||o.rank===c.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),yr(null==u||o.rank===u.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const h={x:function(e){let t;return t=0===e.rank||1===e.rank?Hh(e,[1,1,1,e.size]):2===e.rank?Hh(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?Hh(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}(i),scale:u,offset:c,mean:o,variance:l},d={varianceEpsilon:a},p=Il.runKernel(da,h,d);return Hh(p,i.shape)}});const rd=Ll({batchNorm2d_:function(e,t,n,r,s,a){const i=_l(e,"x","batchNorm"),o=_l(t,"mean","batchNorm"),l=_l(n,"variance","batchNorm");let u,c;return null!=s&&(u=_l(s,"scale","batchNorm")),null!=r&&(c=_l(r,"offset","batchNorm")),yr(2===i.rank,(()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`)),yr(2===o.rank||1===o.rank,(()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`)),yr(2===l.rank||1===l.rank,(()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`)),null!=u&&yr(2===u.rank||1===u.rank,(()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`)),null!=c&&yr(2===c.rank||1===c.rank,(()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`)),nd(i,o,l,c,u,a)}});const sd=Ll({batchNorm3d_:function(e,t,n,r,s,a){const i=_l(e,"x","batchNorm"),o=_l(t,"mean","batchNorm"),l=_l(n,"variance","batchNorm");let u,c;return null!=s&&(u=_l(s,"scale","batchNorm")),null!=r&&(c=_l(r,"offset","batchNorm")),yr(3===i.rank,(()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`)),yr(3===o.rank||1===o.rank,(()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`)),yr(3===l.rank||1===l.rank,(()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`)),null!=u&&yr(3===u.rank||1===u.rank,(()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`)),null!=c&&yr(3===c.rank||1===c.rank,(()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`)),nd(i,o,l,c,u,a)}});const ad=Ll({batchNorm4d_:function(e,t,n,r,s,a){const i=_l(e,"x","batchNorm"),o=_l(t,"mean","batchNorm"),l=_l(n,"variance","batchNorm");let u,c;return null!=s&&(u=_l(s,"scale","batchNorm")),null!=r&&(c=_l(r,"offset","batchNorm")),yr(4===i.rank,(()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`)),yr(4===o.rank||1===o.rank,(()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`)),yr(4===l.rank||1===l.rank,(()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`)),null!=u&&yr(4===u.rank||1===u.rank,(()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`)),null!=c&&yr(4===c.rank||1===c.rank,(()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`)),nd(i,o,l,c,u,a)}});const id=Ll({bincount_:function(e,t,n){const r=_l(e,"x","bincount"),s=_l(t,"weights","bincount");yr("int32"===r.dtype,(()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`)),yr(n>=0,(()=>`size must be non-negative, but got ${n}.`)),yr(s.size===r.size||0===s.size,(()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`));const a={x:r,weights:s},i={size:n};return Il.runKernel(ks,a,i)}});const od=Ll({bitwiseAnd_:function(e,t){const n=_l(e,"x","bitwiseAnd"),r=_l(t,"y","bitwiseAnd");if(!wr(n.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${r.shape}`);if("int32"!==n.dtype||"int32"!==r.dtype)throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${r.dtype}`);const s={a:n,b:r};return Il.runKernel(Ss,s)}});const ld=Ll({broadcastArgs_:function(e,t){const n=_l(e,"s0","broadcastArgs","int32"),r=_l(t,"s1","broadcastArgs","int32");if(1!==n.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(1!==r.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);const s={s0:n,s1:r};return Il.runKernel(Ns,s)}});const ud=Ll({broadcastTo_:function(e,t){let n=_l(e,"broadcastTo","x");const r=n.shape;if(jr(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){const e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=Hh(n,e)}const s=n.shape,a=Array.from(t);for(let u=t.length-1;u>=0;u--)if(s[u]===t[u])a[u]=1;else if(1!==n.shape[u])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);const i=a.map(((e,t)=>e>1?t:-1)).filter((e=>e>=0));if(0===i.length)return ec(n);const o={x:n},l={reps:a};return Il.runKernel(Ji,o,l)}});const cd=Ll({ceil_:function(e){const t={x:_l(e,"x","ceil","float32")};return Il.runKernel(Cs,t)}});const hd=Ll({clipByValue_:function(e,t,n){const r=_l(e,"x","clipByValue");if(yr(t<=n,(()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`)),t===n)return bc(r.shape,t,r.dtype);const s={x:r},a={clipValueMin:t,clipValueMax:n};return Il.runKernel(Ts,s,a)}});const dd=Ll({concat1d_:function(e){return Xh(e,0)}});const pd=Ll({concat2d_:function(e,t){return Xh(e,t)}});const fd=Ll({concat3d_:function(e,t){return Xh(e,t)}});const md=Ll({concat4d_:function(e,t){return Xh(e,t)}});const gd=Ll({conv2d_:function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0;const o=_l(e,"x","conv2d","float32"),l=_l(t,"filter","conv2d","float32");let u=o,c=!1;3===o.rank&&(c=!0,u=Hh(o,[1,o.shape[0],o.shape[1],o.shape[2]])),yr(4===u.rank,(()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`)),yr(4===l.rank,(()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`)),Gh("conv2d",r,i);const h="NHWC"===s?u.shape[3]:u.shape[1];yr(h===l.shape[2],(()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${l.shape[2]}.`)),yr(Wh(n,a),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`)),yr(Uh(a),(()=>"Error in conv2D: Dilated rates should be larger than 0.")),yr(Uh(n),(()=>"Error in conv2D: Strides should be larger than 0."));const d={x:u,filter:l},p={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i},f=Il.runKernel(Rs,d,p);return c?Hh(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const yd=Ll({conv1d_:function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NWC",a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,i=arguments.length>6?arguments[6]:void 0;const o=_l(e,"x","conv1d"),l=_l(t,"filter","conv1d");let u=o,c=!1;2===o.rank&&(c=!0,u=Hh(o,[1,o.shape[0],o.shape[1]])),yr(3===u.rank,(()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`)),yr(3===l.rank,(()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`)),Gh("conv1d",r,i),yr(u.shape[2]===l.shape[1],(()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`)),yr(Wh(n,a),(()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${a}'`)),yr(Uh(a),(()=>"Error in conv1D: Dilated rates should be larger than 0.")),yr(Uh(n),(()=>"Error in conv1D: Stride should be larger than 0.")),yr("NWC"===s,(()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`));const h=Hh(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=Hh(u,[u.shape[0],1,u.shape[1],u.shape[2]]),p=gd(d,h,[1,n],r,"NHWC",[1,a],i);return Hh(p,c?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}});const bd=Ll({conv2DBackpropInput_:function(e,t,n,r,s){let a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",i=arguments.length>6?arguments[6]:void 0;yr(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let o=e,l=t,u=!1;3===t.rank&&(u=!0,l=Hh(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),yr(4===o.length,(()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`)),yr(4===l.rank,(()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`)),yr(4===n.rank,(()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`));const c="NHWC"===a?o[3]:o[1],h="NHWC"===a?l.shape[3]:l.shape[1];yr(c===n.shape[2],(()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`)),yr(h===n.shape[3],(()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${n.shape[3]}.`)),Gh("conv2dDerInput",s,i);const d={dy:l,filter:n},p={strides:r,pad:s,dataFormat:a,dimRoundingMode:i,inputShape:o},f=Il.runKernel(Os,d,p);return u?Hh(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const vd=Ll({conv2dTranspose_:function(e,t,n,r,s,a){const i=_l(e,"x","conv2dTranspose"),o=_l(t,"filter","conv2dTranspose");return bd(n,i,o,r,s,"NHWC",a)}});const xd=Ll({conv3d_:function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NDHWC",a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1,1];const i=_l(e,"x","conv3d"),o=_l(t,"filter","conv3d");let l=i,u=!1;4===i.rank&&(u=!0,l=Hh(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),yr(5===l.rank,(()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`)),yr(5===o.rank,(()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`)),yr(l.shape[4]===o.shape[3],(()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`)),yr(Wh(n,a),(()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`)),yr("NDHWC"===s,(()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`)),yr(Uh(a),(()=>"Error in conv3D: Dilated rates should be larger than 0.")),yr(Uh(n),(()=>"Error in conv3D: Strides should be larger than 0."));const c={x:l,filter:o},h={strides:n,pad:r,dataFormat:s,dilations:a},d=Il.runKernel(_s,c,h);return u?Hh(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const wd=Ll({conv3DBackpropInput_:function(e,t,n,r,s){yr(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let a=e,i=t,o=!1;4===t.rank&&(o=!0,i=Hh(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),a=[1,e[0],e[1],e[2],e[3]]);const l=a[4],u=i.shape[4];yr(5===a.length,(()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`)),yr(5===i.rank,(()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`)),yr(5===n.rank,(()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`)),yr(l===n.shape[3],(()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`)),yr(u===n.shape[4],(()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`));const c={dy:i,filter:n},h={pad:s,strides:r,inputShape:a},d=Il.runKernel(Ms,c,h);return o?Hh(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const kd=Ll({conv3dTranspose_:function(e,t,n,r,s){const a=_l(e,"x","conv3dTranspose"),i=_l(t,"filter","conv3dTranspose");return wd(n,a,i,r,s)}});const Sd=Ll({cos_:function(e){const t={x:_l(e,"x","cos","float32")};return Il.runKernel(Ls,t)}});const Nd=Ll({cosh_:function(e){const t={x:_l(e,"x","cosh","float32")};return Il.runKernel(Ps,t)}});const Id=Ll({cumprod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s={x:_l(e,"x","cumprod")},a={axis:t,exclusive:n,reverse:r};return Il.runKernel(zs,s,a)}});const Cd=Ll({cumsum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s={x:_l(e,"x","cumsum")},a={axis:t,exclusive:n,reverse:r};return Il.runKernel(Bs,s,a)}});const Td=Ll({denseBincount_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=_l(e,"x","denseBincount"),a=_l(t,"weights","denseBincount");yr("int32"===s.dtype,(()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`)),yr(s.rank<=2,(()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`)),yr(n>=0,(()=>`size must be non-negative, but got ${n}.`)),yr(a.size===s.size||0===a.size,(()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${a.shape}.`));const i={x:s,weights:a},o={size:n,binaryOutput:r};return Il.runKernel(Ws,i,o)}});const Ad=Ll({depthToSpace_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"NHWC";const r=_l(e,"x","depthToSpace","float32"),s="NHWC"===n?r.shape[1]:r.shape[2],a="NHWC"===n?r.shape[2]:r.shape[3],i="NHWC"===n?r.shape[3]:r.shape[1];yr(t>1,(()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`)),yr(s*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${t}  for depthToSpace with input shape\n    ${r.shape}`)),yr(a*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${a} and ${t} for depthToSpace with input shape\n        ${r.shape}`)),yr(i%(t*t)===0,(()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${r.shape}`));const o={x:r},l={blockSize:t,dataFormat:n};return Il.runKernel(Us,o,l)}});const Ed=Ll({depthwiseConv2d_:function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0;const o=_l(e,"x","depthwiseConv2d","float32"),l=_l(t,"filter","depthwiseConv2d","float32");let u=o,c=!1;3===o.rank&&(c=!0,u=Hh(o,[1,o.shape[0],o.shape[1],o.shape[2]])),yr(4===u.rank,(()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`)),yr(4===l.rank,(()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`));const h="NHWC"===s?u.shape[3]:u.shape[1];yr(h===l.shape[2],(()=>`Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${l.shape[2]}.`)),Gh("depthwiseConv2d",r,i);const d={x:u,filter:l},p={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i},f=Il.runKernel(js,d,p);return c?Hh(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const $d=Ll({diag_:function(e){const t={x:_l(e,"x","diag")};return Il.runKernel(qs,t)}});const Rd=Ll({dilation2d_:function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[1,1],a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC";const i=_l(e,"x","dilation2d"),o=_l(t,"filter","dilation2d");yr(3===i.rank||4===i.rank,(()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`)),yr(3===o.rank,(()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`)),yr("NHWC"===a,(()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a}`));let l=i,u=!1;3===i.rank&&(l=Hh(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0),yr(l.shape[3]===o.shape[2],(()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`));const c={x:l,filter:o},h={strides:n,pad:r,dilations:s},d=Il.runKernel(Ks,c,h);return u?Hh(d,[d.shape[1],d.shape[2],d.shape[3]]):d}});const Dd=Ll({equal_:function(e,t){let n=_l(e,"a","equal","string_or_numeric"),r=_l(t,"b","equal","string_or_numeric");[n,r]=yl(n,r),Cc(n.shape,r.shape);const s={a:n,b:r};return Il.runKernel(ra,s)}});const Od=Ll({where_:function(e,t,n){const r=_l(t,"a","where"),s=_l(n,"b","where"),a=_l(e,"condition","where","bool"),i=Cc(Cc(a.shape,r.shape),s.shape),o={condition:ud(a,i),t:ud(r,i),e:ud(s,i)};return Il.runKernel(Ii,o)}});const _d=Ll({divNoNan_:function(e,t){let n=_l(e,"a","div"),r=_l(t,"b","div");[n,r]=yl(n,r);const s=sc(n,r),a=lc(s),i=Dd(r,a);return Od(i,a,s)}});const Fd=Ll({dot_:function(e,t){const n=_l(e,"t1","dot"),r=_l(t,"t2","dot");yr((1===n.rank||2===n.rank)&&(1===r.rank||2===r.rank),(()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`));const s=1===n.rank?n.size:n.shape[1],a=1===r.rank?r.size:r.shape[0];if(yr(s===a,(()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${a}.`)),1===n.rank&&1===r.rank){const e=Hh(n,[1,-1]),t=Hh(r,[-1,1]),s=Qh(e,t);return Hh(s,[])}if(1===n.rank&&2===r.rank){const e=Hh(n,[1,-1]),t=Hh(r,[r.shape[0],r.shape[1]]),s=Qh(e,t);return Hh(s,[s.size])}if(2===n.rank&&1===r.rank){const e=Hh(r,[-1,1]),t=Qh(n,e);return Hh(t,[t.size])}{const e=Hh(r,[r.shape[0],r.shape[1]]);return Qh(n,e)}}});const Md=Ll({einsum_:function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];const s=n.map(((e,t)=>_l(e,`tensors${t}`,"einsum"))),a={equation:e};return Il.runKernel(Js,s,a)}});const Ld=Ll({elu_:function(e){const t={x:_l(e,"x","elu","float32")};return Il.runKernel(ea,t)}});const Pd=Ll({ensureShape_:function(e,t){const n=_l(e,"x","ensureShape","string_or_numeric");if(!function(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(null!==e[n]&&null!==t[n]&&e[n]!==t[n])return!1;return!0}(n.shape,t))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${t}`);return e}});const zd=Ll({erf_:function(e){let t=_l(e,"x","erf");yr("int32"===t.dtype||"float32"===t.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===t.dtype&&(t=Ju(t,"float32"));const n={x:t};return Il.runKernel(na,n)}});function Bd(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function Vd(e,t,n){const r=e.length+t.length,s=[];let a=0,i=0;for(let o=0;o<r;o++)-1===n.indexOf(o)?s.push(e[a++]):s.push(t[i++]);return s}function Wd(e,t){const n=[],r=e.length;for(let s=0;s<r;s++)-1===t.indexOf(s)&&n.push(e[s]);return[n,t.map((t=>e[t]))]}function Ud(e,t){return Vd(e,t.map((e=>1)),t)}function jd(e,t,n){yr(Bd(t,n),(()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`))}function Gd(e,t){if(Bd(e,t))return null;const n=[];for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);return e.forEach((e=>n.push(e))),n}function Hd(e){return e.map(((e,t)=>[t,e])).sort(((e,t)=>e[1]-t[1])).map((e=>e[0]))}function qd(e,t){const n=[];for(let r=t-e;r<t;++r)n.push(r);return n}const Kd=Ll({max_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:_l(e,"x","max")},s={reductionIndices:t,keepDims:n};return Il.runKernel(_a,r,s)}});const Xd=Ll({min_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:_l(e,"x","min")},s={axis:t,keepDims:n};return Il.runKernel(Wa,r,s)}});const Qd=Ll({sum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=_l(e,"x","sum");"bool"===r.dtype&&(r=Ju(r,"int32"));const s={x:r},a={axis:t,keepDims:n};return Il.runKernel(_i,s,a)}});function Yd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(0===e.rank)return Sc(e);if(1!==e.rank&&null===n)return Yd(Hh(e,[-1]),t,n);if(1===e.rank||"number"===typeof n||Array.isArray(n)&&1===n.length){if(1===t)return Qd(Sc(e),n);if(t===1/0)return Kd(Sc(e),n);if(t===-1/0)return Xd(Sc(e),n);if("euclidean"===t||2===t)return ic(Qd(xc(Sc(e),cc(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&2===n.length){if(1===t)return Kd(Qd(Sc(e),n[0]),n[1]-1);if(t===1/0)return Kd(Qd(Sc(e),n[1]),n[0]);if(t===-1/0)return Xd(Qd(Sc(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return ic(Qd(oc(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const Zd=Ll({norm_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"euclidean",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=Yd(e=_l(e,"x","norm"),t,n);let a=s.shape;if(r){const t=Tr(n,e.shape);a=Ud(s.shape,t)}return Hh(s,a)}});const Jd=Ll({euclideanNorm_:function(e){return Zd(e,"euclidean",arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}});const ep=Ll({exp_:function(e){const t={x:_l(e,"x","exp")};return Il.runKernel(sa,t)}});const tp=Ll({expandDims_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=_l(e,"x","expandDims","string_or_numeric");yr(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));const r={input:n},s={dim:t};return Il.runKernel(aa,r,s)}});const np=Ll({expm1_:function(e){const t={x:_l(e,"x","expm1")};return Il.runKernel(ia,t)}});const rp=Ll({tile_:function(e,t){const n=_l(e,"x","tile","string_or_numeric");yr(n.rank===t.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`));const r={x:n},s={reps:t};return Il.runKernel(Ji,r,s)}});const sp=Ll({eye_:function(e,t,n){null==t&&(t=e);const r=Zu([e,t],arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32"),s=e<=t?e:t;for(let i=0;i<s;++i)r.set(1,i,i);const a=Hh(r.toTensor(),[e,t]);if(null==n)return a;if(1===n.length)return rp(tp(a,0),[n[0],1,1]);if(2===n.length)return rp(tp(tp(a,0),0),[n[0],n[1],1,1]);if(3===n.length)return rp(tp(tp(tp(a,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}});const ap=Ll({floor_:function(e){const t={x:_l(e,"x","floor","float32")};return Il.runKernel(ca,t)}});const ip=Ll({gather_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const s={x:_l(e,"x","gather"),indices:_l(t,"indices","gather","int32")},a={axis:n,batchDims:r};return Il.runKernel(pa,s,a)}});const op=Ll({greater_:function(e,t){let n=_l(e,"a","greater","string_or_numeric"),r=_l(t,"b","greater","string_or_numeric");[n,r]=yl(n,r),Cc(n.shape,r.shape);const s={a:n,b:r};return Il.runKernel(ma,s)}});const lp=Ll({greaterEqual_:function(e,t){let n=_l(e,"a","greaterEqual","string_or_numeric"),r=_l(t,"b","greaterEqual","string_or_numeric");[n,r]=yl(n,r),Cc(n.shape,r.shape);const s={a:n,b:r};return Il.runKernel(ga,s)}});const up=Ll({imag_:function(e){const t={input:_l(e,"input","imag")};return Il.runKernel(va,t)}});const cp=Ll({isFinite_:function(e){const t={x:_l(e,"x","isFinite")};return Il.runKernel(xa,t)}});const hp=Ll({isInf_:function(e){const t={x:_l(e,"x","isInf")};return Il.runKernel(wa,t)}});const dp=Ll({isNaN_:function(e){const t={x:_l(e,"x","isNaN")};return Il.runKernel(ka,t)}});const pp=Ll({leakyRelu_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.2;const n={x:_l(e,"x","leakyRelu")},r={alpha:t};return Il.runKernel(Sa,n,r)}});const fp=Ll({less_:function(e,t){let n=_l(e,"a","less","string_or_numeric"),r=_l(t,"b","less","string_or_numeric");[n,r]=yl(n,r),Cc(n.shape,r.shape);const s={a:n,b:r};return Il.runKernel(Na,s)}});const mp=Ll({lessEqual_:function(e,t){let n=_l(e,"a","lessEqual","string_or_numeric"),r=_l(t,"b","lessEqual","string_or_numeric");[n,r]=yl(n,r),Cc(n.shape,r.shape);const s={a:n,b:r};return Il.runKernel(Ia,s)}});function gp(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");const r={start:e,stop:t,num:n};return Il.runKernel(Ca,{},r)}const yp=Ll({localResponseNormalization_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5;const a=_l(e,"x","localResponseNormalization");yr(4===a.rank||3===a.rank,(()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${a.rank}.`)),yr(kr(t),(()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`));let i=a,o=!1;3===a.rank&&(o=!0,i=Hh(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const l={x:i},u={depthRadius:t,bias:n,alpha:r,beta:s},c=Il.runKernel(Da,l,u);return o?Hh(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const bp=Ll({log_:function(e){const t={x:_l(e,"x","log","float32")};return Il.runKernel(Ta,t)}});const vp=Ll({log1p_:function(e){const t={x:_l(e,"x","log1p")};return Il.runKernel(Aa,t)}});const xp=Ll({neg_:function(e){const t={x:_l(e,"x","neg")};return Il.runKernel(Ka,t)}});const wp=Ll({softplus_:function(e){const t={x:_l(e,"x","softplus")};return Il.runKernel(Di,t)}});const kp=Ll({logSigmoid_:function(e){const t=_l(e,"x","logSigmoid");return uc((e=>({value:xp(wp(xp(e))),gradFunc:t=>ac(t,Yh(xp(e)))})))(t)}});const Sp=Ll({logSoftmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=_l(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);const r=uc(((e,n)=>{const r=Kd(e,t,!0),s=wc(e,r),a=wc(Ju(s,"float32"),bp(Qd(ep(s),t,!0)));n([a]);return{value:a,gradFunc:(e,n)=>{const[r]=n,s=ep(r);return wc(e,ac(Qd(e,t,!0),s))}}}));return r(n)}});const Np=Ll({logSumExp_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r=_l(e,"x","logSumExp"),s=Tr(t,r.shape),a=Kd(r,s,!0),i=wc(r,a),o=ep(i),l=Qd(o,s),u=bp(l),c=nc(Hh(a,u.shape),u);if(n){const e=Ud(c.shape,s);return Hh(c,e)}return c}});const Ip=Ll({logicalAnd_:function(e,t){const n=_l(e,"a","logicalAnd","bool"),r=_l(t,"b","logicalAnd","bool");Cc(n.shape,r.shape);const s={a:n,b:r};return Il.runKernel(Ea,s)}});const Cp=Ll({logicalNot_:function(e){const t={x:_l(e,"x","logicalNot","bool")};return Il.runKernel($a,t)}});const Tp=Ll({logicalOr_:function(e,t){const n=_l(e,"a","logicalOr","bool"),r=_l(t,"b","logicalOr","bool");Cc(n.shape,r.shape);const s={a:n,b:r};return Il.runKernel(Ra,s)}});const Ap=Ll({logicalXor_:function(e,t){const n=_l(e,"a","logicalXor","bool"),r=_l(t,"b","logicalXor","bool");return Cc(n.shape,r.shape),Ip(Tp(e,t),Cp(Ip(e,t)))}}),Ep=2147483648;const $p=Ll({searchSorted_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"left";const r=_l(e,"sortedSequence","searchSorted"),s=_l(t,"values","searchSorted"),a=r.shape[r.shape.length-1],i=s.shape[s.shape.length-1],o=Hh(r,[-1,a]),l=Hh(s,[-1,i]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(xr(l.shape)>=Ep)throw new Error("values tensor size must less than 2147483648");if(o.shape[1]>=Ep)throw new Error(`trailing dim_size must less than 2147483648 for int32 output type, was ${o.shape[1]}`);const u={sortedSequence:o,values:l},c={side:n};return Il.runKernel(Ni,u,c)}});function Rp(e,t){return $p(e,t,"left")}const Dp=Ll({maxPool_:function(e,t,n,r,s){const a=_l(e,"x","maxPool");let i=a,o=!1;3===a.rank&&(o=!0,i=Hh(a,[1,a.shape[0],a.shape[1],a.shape[2]])),yr(4===i.rank,(()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`)),yr(Wh(n,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`)),Gh("maxPool",r,s);const l={x:i},u={filterSize:t,strides:n,pad:r,dimRoundingMode:s},c=Il.runKernel(Ma,l,u);return o?Hh(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const Op=Ll({maxPool3d_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[1,1,1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0,s=arguments.length>4?arguments[4]:void 0,a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const i=_l(e,"x","maxPool3d");let o=i,l=!1;4===i.rank&&(l=!0,o=Hh(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),yr(5===o.rank,(()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`)),yr("NDHWC"===a,(()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`)),Gh("maxPool3d",r,s);const u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:a},h=Il.runKernel(Pa,u,c);return l?Hh(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const _p=Ll({maxPoolWithArgmax_:function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];const a={x:_l(e,"x","maxPoolWithArgmax")},i={filterSize:t,strides:n,pad:r,includeBatchInIndex:s},o=Il.runKernel(Ba,a,i);return{result:o[0],indexes:o[1]}}});const Fp=Ll({mean_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:_l(e,"x","mean")},s={axis:t,keepDims:n};return Il.runKernel(Va,r,s)}});function Mp(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(jr(e),"complex64"===t){const t=Mp(e,"float32"),n=Mp(e,"float32");return Pl(t,n)}const n=Wr(xr(e),t);return Il.makeTensor(n,e,t)}function Lp(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(jr(e),"complex64"===t){const t=Lp(e,"float32"),n=Mp(e,"float32");return Pl(t,n)}const n=Vr(xr(e),t);return Il.makeTensor(n,e,t)}function Pp(e,t){let{indexing:n="xy"}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if("xy"!==n&&"ij"!==n)throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(void 0===e)return[];let r=_l(e,"x","meshgrid",e instanceof sl?e.dtype:"float32");if(void 0===t)return[r];let s=_l(t,"y","meshgrid",t instanceof sl?t.dtype:"float32");const a=xr(r.shape),i=xr(s.shape);return"xy"===n?(r=Hh(r,[1,-1]),s=Hh(s,[-1,1]),[Qh(Lp([i,1],r.dtype),r),Qh(s,Lp([1,a],s.dtype))]):(r=Hh(r,[-1,1]),s=Hh(s,[1,-1]),[Qh(r,Lp([1,i],r.dtype)),Qh(Lp([a,1],s.dtype),s)])}const zp=Ll({minimum_:function(e,t){let n=_l(e,"a","minimum"),r=_l(t,"b","minimum");[n,r]=yl(n,r),"bool"===n.dtype&&(n=Ju(n,"int32"),r=Ju(r,"int32")),Cc(n.shape,r.shape);const s={a:n,b:r};return Il.runKernel(Ua,s)}});const Bp=Ll({mirrorPad_:function(e,t,n){yr("reflect"===n||"symmetric"===n,(()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`));const r=_l(e,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");yr(t.length===r.rank,(()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`));const s="reflect"===n?1:0;for(let o=0;o<r.rank;o++)yr(2===t[o].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),yr(t[o][0]>=0&&t[o][0]<=r.shape[o]-s&&t[o][1]>=0&&t[o][1]<=r.shape[o]-s,(()=>`Padding in dimension ${o} cannot be greater than or equal to ${r.shape[o]-s} or less than 0 for input of shape ${r.shape}`));const a={paddings:t,mode:n},i={x:r};return Il.runKernel(ja,i,a)}});const Vp=Ll({mod_:function(e,t){let n=_l(e,"a","mod"),r=_l(t,"b","mod");[n,r]=yl(n,r);const s={a:n,b:r};return Il.runKernel(Ga,s)}});const Wp=Ll({moments_:function(e){let t=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const n=Tr(arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,(e=_l(e,"x","moments")).shape),r=Fp(e,n,t);let s=r.shape;t||(s=Ud(r.shape,n));const a=oc(wc(Ju(e,"float32"),Hh(r,s)));return{mean:r,variance:Fp(a,n,t)}}});const Up=Ll({multiRNNCell_:function(e,t,n,r){const s=_l(t,"data","multiRNNCell"),a=Fl(n,"c","multiRNNCell"),i=Fl(r,"h","multiRNNCell");let o=s;const l=[];for(let h=0;h<e.length;h++){const t=e[h](o,a[h],i[h]);l.push(t[0]),l.push(t[1]),o=t[1]}const u=[],c=[];for(let h=0;h<l.length;h+=2)u.push(l[h]),c.push(l[h+1]);return[u,c]}});const jp=Ll({multinomial_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=_l(e,"logits","multinomial"),a=s.size,i=s.rank;if(a<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${a}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();const o={logits:1===i?Hh(s,[1,-1]):s},l={numSamples:t,seed:n,normalized:r},u=Il.runKernel(Ha,o,l);return 1===i?Hh(u,[u.size]):u}});const Gp=Ll({notEqual_:function(e,t){let n=_l(e,"a","notEqual","string_or_numeric"),r=_l(t,"b","notEqual","string_or_numeric");[n,r]=yl(n,r),Cc(n.shape,r.shape);const s={a:n,b:r};return Il.runKernel(Xa,s)}});const Hp=Ll({oneHot_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"int32";if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const a={indices:_l(e,"indices","oneHot","int32")},i={dtype:s,depth:t,onValue:n,offValue:r};return Il.runKernel(ei,a,i)}});const qp=Ll({onesLike_:function(e){const t={x:_l(e,"x","onesLike")};return Il.runKernel(Ja,t)}});const Kp=Ll({outerProduct_:function(e,t){const n=_l(e,"v1","outerProduct"),r=_l(t,"v2","outerProduct");yr(1===n.rank&&1===r.rank,(()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`));const s=Hh(n,[-1,1]),a=Hh(r,[1,-1]);return Qh(s,a)}});const Xp=Ll({pad_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const r=_l(e,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const s={paddings:t,constantValue:n},a={x:r};return Il.runKernel(ni,a,s)}});const Qp=Ll({pad1d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return yr(2===t.length,(()=>"Invalid number of paddings. Must be length of 2.")),Xp(e,[t],n)}});const Yp=Ll({pad2d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return yr(2===t.length&&2===t[0].length&&2===t[1].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Xp(e,t,n)}});const Zp=Ll({pad3d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return yr(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Xp(e,t,n)}});const Jp=Ll({pad4d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return yr(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Xp(e,t,n)}});const ef=Ll({spaceToBatchND_:function(e,t,n){const r=_l(e,"x","spaceToBatchND");yr(r.rank>=1+t.length,(()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`)),yr(n.length===t.length,(()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`)),yr(r.shape.reduce(((e,r,s)=>s>0&&s<=t.length?e&&(r+n[s-1][0]+n[s-1][1])%t[s-1]===0:e),!0),(()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`));const s={x:r},a={blockShape:t,paddings:n};return Il.runKernel(Fi,s,a)}});const tf=Ll({pool_:function(e,t,n,r,s,a,i){null==s&&(s=[1,1]),null==a&&(a=1),0===r&&(r="valid");const o=_l(e,"x","maxPool");let l=o,u=!1;3===o.rank&&(u=!0,l=Hh(o,[1,o.shape[0],o.shape[1],o.shape[2]])),yr(Wh(a,s),(()=>`Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${s}'`));const c=Dh(l.shape,t,a,s,r),h=[c.dilationHeight,c.dilationWidth];let d;d="same"===r?function(e,t){const n=e.map(((e,n)=>e+(e-1)*(t[n]-1))),r=n.map((e=>e-1)),s=r.map((e=>Math.floor(e/2))),a=r.map(((e,t)=>e-s[t]));return r.map(((e,t)=>[s[t],a[t]]))}([c.filterHeight,c.filterWidth],h):[[0,0],[0,0]];const p=1===h[0]&&1===h[1],[f,m]=function(e,t,n){const r=n.map((e=>e[0])),s=n.map((e=>e[1])),a=e.concat(r,s),i=t.map(((e,t)=>(e-a[t]%e)%e)),o=s.map(((e,t)=>e+i[t])),l=t.map(((e,t)=>[r[t],o[t]])),u=t.map(((e,t)=>[0,i[t]]));return[l,u]}([c.inHeight,c.inWidth],h,d),g=p?r:"valid",y=p?l:ef(l,h,f),b=("avg"===n?()=>qh(y,t,a,g,i):()=>Dp(y,t,a,g,i))(),v=p?b:td(b,h,m);return u?Hh(v,[v.shape[1],v.shape[2],v.shape[3]]):v}});const nf=Ll({prelu_:function(e,t){const n={x:_l(e,"x","prelu"),alpha:_l(t,"alpha","prelu")};return Il.runKernel(si,n)}});const rf=Ll({prod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=_l(e,"x","prod");"bool"===r.dtype&&(r=Ju(r,"int32"));const s={x:r},a={axis:t,keepDims:n};return Il.runKernel(ai,s,a)}});const sf=Ll({raggedGather_:function(e,t,n,r){const s=e.map(((e,t)=>_l(e,`tensors${t}`,"raggedGather","int32"))),a={paramsNestedSplits:s,paramsDenseValues:_l(t,"paramsDenseValues","raggedGather"),indices:_l(n,"indices","raggedGather","int32")},i={outputRaggedRank:r},o=Il.runKernel(ii,a,i);return{outputNestedSplits:o.slice(0,o.length-1),outputDenseValues:o[o.length-1]}}});const af=Ll({raggedRange_:function(e,t,n){const r=_l(e,"starts","raggedRange"),s={starts:r,limits:_l(t,"limits","raggedRange",r.dtype),deltas:_l(n,"deltas","raggedRange",r.dtype)},a=Il.runKernel(oi,s);return{rtNestedSplits:a[0],rtDenseValues:a[1]}}});const of=Ll({raggedTensorToTensor_:function(e,t,n,r,s){const a=_l(e,"shape","raggedTensorToTensor","int32"),i=_l(t,"values","raggedTensorToTensor"),o=_l(n,"defaultValue","raggedTensorToTensor",i.dtype),l=r.map(((e,t)=>_l(e,`tensors${t}`,"raggedTensorToTensor","int32"))),u={shape:a,values:i,defaultValue:o,rowPartitionTensors:l},c={rowPartitionTypes:s};return Il.runKernel(li,u,c)}});const lf=Ll({rand_:function(e,t,n){jr(e);const r=xr(e);let s=null;if(null==n||"float32"===n)s=new Float32Array(r);else if("int32"===n)s=new Int32Array(r);else{if("bool"!==n)throw new Error(`Unknown data type ${n}`);s=new Uint8Array(r)}for(let a=0;a<r;a++)s[a]=t();return Il.makeTensor(s,e,n)}});var uf=n(334);class cf{constructor(e,t,n,r,s){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const a=s||Math.random();this.random=uf.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){const e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let r,s,a;do{r=2*this.random()-1,s=2*this.random()-1,a=r*r+s*s}while(a>=1||0===a);const i=Math.sqrt(-2*Math.log(a)/a);e=this.mean+this.stdDev*r*i,t=this.mean+this.stdDev*s*i,this.truncated&&!this.isValidTruncated(e)||(n=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class hf{constructor(e,t,n,r){this.alpha=e,this.beta=1/t,this.dtype=n;const s=r||Math.random();this.randu=uf.alea(s.toString()),this.randn=new cf(0,1,n,!1,this.randu()),this.d=e<1?e+2/3:e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,r,s,a;for(;;){do{r=this.randn.nextValue(),a=1+this.c*r}while(a<=0);if(a*=a*a,e=r*r,t=1-.331*e*e,n=.5*e+this.d*(1-a+Math.log(a)),s=this.randu(),s<t||Math.log(s)<n)break}return a=1/this.beta*this.d*a,this.alpha<1&&(a*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(a)}convertValue(e){return"float32"===this.dtype?e:Math.round(e)}}class df{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==r&&(r=Math.random()),"number"===typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=uf.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const pf=Ll({randomGamma_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",s=arguments.length>4?arguments[4]:void 0;if(jr(e),null==n&&(n=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw new Error(`Unsupported data type ${r}`);const a=new hf(t,n,r,s),i=Zu(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}});const ff=Ll({randomNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3?arguments[3]:void 0,s=arguments.length>4?arguments[4]:void 0;if(jr(e),null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);const a=new cf(t,n,r,!1,s),i=Zu(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}});const mf=Ll({randomStandardNormal_:function(e,t,n){if(null!=t&&"bool"===t)throw new Error(`Unsupported data type ${t}`);return ff(e,0,1,t,n)}});const gf=Ll({randomUniform_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",s=arguments.length>4?arguments[4]:void 0;jr(e);const a=Zu(e,r),i=new df(t,n,null,s);for(let o=0;o<a.values.length;o++)a.values[o]=i.nextValue();return a.toTensor()}});const yf=Ll({randomUniformInt_:function(e,t,n,r){return gf(e,t,n,"int32",r)}});function bf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32";if(0===n)throw new Error("Cannot have a step of zero");const s={start:e,stop:t,step:n,dtype:r};return Il.runKernel(ui,{},s)}const vf=Ll({real_:function(e){const t={input:_l(e,"input","real")};return Il.runKernel(ci,t)}});const xf=Ll({reciprocal_:function(e){const t={x:_l(e,"x","reciprocal")};return Il.runKernel(hi,t)}});const wf=Ll({relu_:function(e){const t={x:_l(e,"x","relu")};return Il.runKernel(di,t)}});const kf=Ll({relu6_:function(e){const t={x:_l(e,"x","relu6")};return Il.runKernel(bi,t)}});const Sf=Ll({reverse_:function(e,t){const n={x:_l(e,"x","reverse")},r={dims:t};return Il.runKernel(vi,n,r)}});const Nf=Ll({reverse1d_:function(e){const t=_l(e,"x","reverse");return yr(1===t.rank,(()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`)),Sf(t,0)}});const If=Ll({reverse2d_:function(e,t){const n=_l(e,"x","reverse");return yr(2===n.rank,(()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`)),Sf(n,t)}});const Cf=Ll({reverse3d_:function(e,t){const n=_l(e,"x","reverse");return yr(3===n.rank,(()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`)),Sf(n,t)}});const Tf=Ll({reverse4d_:function(e,t){const n=_l(e,"x","reverse");return yr(4===n.rank,(()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`)),Sf(n,t)}});const Af=Ll({round_:function(e){const t={x:_l(e,"x","round")};return Il.runKernel(xi,t)}});const Ef=Ll({rsqrt_:function(e){const t={x:_l(e,"x","rsqrt","float32")};return Il.runKernel(wi,t)}});const $f=Ll({selu_:function(e){const t={x:_l(e,"x","selu")};return Il.runKernel(Ci,t)}});const Rf=Ll({separableConv2d_:function(e,t,n,r,s){let a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NHWC";const o=_l(e,"x","separableConv2d"),l=_l(t,"depthwiseFilter","separableConv2d"),u=_l(n,"pointwiseFilter","separableConv2d");let c=o,h=!1;if(3===o.rank&&(h=!0,c=Hh(o,[1,o.shape[0],o.shape[1],o.shape[2]])),"NCHW"===i)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");yr(4===c.rank,(()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`)),yr(4===l.rank,(()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`)),yr(4===u.rank,(()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`)),yr(1===u.shape[0],(()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`)),yr(1===u.shape[1],(()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`));const d=l.shape[2],p=l.shape[3];yr(u.shape[2]===d*p,(()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*p}, but got ${u.shape[2]}.`));const f=Ed(c,l,r,s,i,a),m=gd(f,u,1,"valid",i);return h?Hh(m,[m.shape[1],m.shape[2],m.shape[3]]):m}});const Df=async function(e,t){const n=_l(e,"x","setdiff1d"),r=_l(t,"y","setdiff1d");yr(n.dtype===r.dtype,(()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`)),yr(1===n.rank,(()=>`x should be 1D tensor, but got x (${n.shape}).`)),yr(1===r.rank,(()=>`y should be 1D tensor, but got y (${r.shape}).`));const s=await n.data(),a=await r.data(),i=new Set(a);let o=0;for(let c=0;c<s.length;c++)i.has(s[c])||o++;const l=new el([o],n.dtype),u=new el([o],"int32");for(let c=0,h=0;c<s.length;c++)i.has(s[c])||(l.values[h]=s[c],u.values[h]=c,h++);return[l.toTensor(),u.toTensor()]};const Of=Ll({sign_:function(e){const t={x:_l(e,"x","sign")};return Il.runKernel($i,t)}});const _f=Ll({sin_:function(e){const t={x:_l(e,"x","sin","float32")};return Il.runKernel(Ai,t)}});const Ff=Ll({sinh_:function(e){const t={x:_l(e,"x","sinh")};return Il.runKernel(Ei,t)}});const Mf=Ll({slice1d_:function(e,t,n){const r=_l(e,"x","slice1d");return yr(1===r.rank,(()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`)),Zh(r,[t],[n])}});const Lf=Ll({slice2d_:function(e,t,n){const r=_l(e,"x","slice2d");return yr(2===r.rank,(()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`)),Zh(r,t,n)}});const Pf=Ll({slice3d_:function(e,t,n){const r=_l(e,"x","slice3d");return yr(3===r.rank,(()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`)),Zh(r,t,n)}});const zf=Ll({slice4d_:function(e,t,n){const r=_l(e,"x","slice4d");return yr(4===r.rank,(()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`)),Zh(r,t,n)}});const Bf=Ll({softmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=_l(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);const r={logits:n},s={dim:t};return Il.runKernel(Li,r,s)}});const Vf=Ll({fft_:function(e){yr("complex64"===e.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`));const t={input:e};return Il.runKernel(oa,t)}});const Wf=Ll({ifft_:function(e){yr("complex64"===e.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`));const t={input:e};return Il.runKernel(ba,t)}});const Uf=Ll({irfft_:function(e){const t=e.shape[e.shape.length-1],n=e.size/t;let r;if(t<=2){const s=Hh(e,[n,t]);r=Wf(s)}else{const s=[n,2*(t-1)],a=Hh(vf(e),[n,t]),i=Hh(up(e),[n,t]),o=Sf(Zh(a,[0,1],[n,t-2]),1),l=ac(Sf(Zh(i,[0,1],[n,t-2]),1),cc(-1)),u=Xh([a,o],1),c=Xh([i,l],1),h=Hh(Pl(u,c),[s[0],s[1]]);r=Wf(h)}if(r=vf(r),3===e.rank&&0!==e.shape[0]){const t=r,n=e.shape[0];r=Hh(r,[n,r.shape[0]/n,r.shape[1]]),t.dispose()}return r}});const jf=Ll({split_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const r={x:_l(e,"x","split")},s={numOrSizeSplits:t,axis:n};return Il.runKernel(Mi,r,s)}});const Gf=Ll({rfft_:function(e,t){yr("float32"===e.dtype,(()=>`The dtype for rfft() must be real value but got ${e.dtype}`));let n=e.shape[e.shape.length-1];const r=e.size/n;let s;if(null!=t&&t<n){const r=e.shape.map((e=>0)),a=e.shape.map((e=>e));a[e.shape.length-1]=t,s=Zh(e,r,a),n=t}else if(null!=t&&t>n){const r=e.shape.map((e=>e));r[e.shape.length-1]=t-n,s=Xh([e,Mp(r)],e.shape.length-1),n=t}else s=e;const a=lc(s),i=Hh(Pl(s,a),[r,n]),o=Vf(i),l=Math.floor(n/2)+1,u=vf(o),c=up(o),h=jf(u,[l,n-l],u.shape.length-1),d=jf(c,[l,n-l],c.shape.length-1),p=s.shape.slice();return p[s.shape.length-1]=l,Hh(Pl(h[0],d[0]),p)}});const Hf=Ll({squaredDifference_:function(e,t){let n=_l(e,"a","squaredDifference"),r=_l(t,"b","squaredDifference");[n,r]=yl(n,r),Cc(n.shape,r.shape);const s={a:n,b:r};return Il.runKernel(Ui,s,{})}});const qf=Ll({squeeze_:function(e,t){const n=_l(e,"x","squeeze","string_or_numeric");return Hh(n,Ar(n.shape,t).newShape)}});const Kf=Ll({stack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Fl(e,"tensors","stack","string_or_numeric");yr(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&yr(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const r=n,s={axis:t};return Il.runKernel(ti,r,s)}});const Xf=Ll({step_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:_l(e,"x","step")},r={alpha:t};return Il.runKernel(oo,n,r)}});const Qf=Ll({stridedSlice_:function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,l=arguments.length>8&&void 0!==arguments[8]?arguments[8]:0;const u={x:_l(e,"x","stridedSlice","string_or_numeric")},c={begin:t,end:n,strides:r,beginMask:s,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};return Il.runKernel(Hi,u,c)}});const Yf=Ll({tan_:function(e){const t={x:_l(e,"x","tan","float32")};return Il.runKernel(Yi,t)}});function Zf(e,t){vr(e);const n=Rl(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return zl(e,null,n,t)}function Jf(e,t,n){if(vr(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const r=Rl(e,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return zl(e,t,r,n)}function em(e,t,n){if(vr(e),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");const r=Rl(e,n);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return zl(e,t,r,n)}function tm(e,t,n){if(vr(e),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");const r=Rl(e,n);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return zl(e,t,r,n)}function nm(e,t,n){if(vr(e),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");const r=Rl(e,n);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return zl(e,t=t||r,r,n)}function rm(e,t,n){const r=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(a+` update.rank < ${s}. `);if(e.length<r+(n.rank-s))throw new Error(a+` Output shape length < ${r+(n.rank-s)}`);if(n.rank!==s+e.length-r)throw new Error(a+" update.rank != "+(s+e.length-r));for(let i=0;i<s;++i)if(n.shape[i]!==t.shape[i])throw new Error(a+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<n.rank-s;++i)if(n.shape[i+s]!==e[i+r])throw new Error(a+` updates.shape[${i+s}] (${n.shape[i+s]}) != shape[${i+s}] (${e[i+s]})`)}function sm(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}rm(n,t,e)}function am(e,t,n){const r=t.shape.length,s=r>1?t.shape[r-1]:1,a=n.length;let i=1;for(let l=s;l<a;++l)i*=n[l];const o=s<1?1:s;return{sliceRank:s,numUpdates:xr(t.shape)/o,sliceSize:i,strides:[...Pr(n.slice(0,s)),1],outputSize:xr(n)}}const im=Ll({tensorScatterUpdate_:function(e,t,n){const r=_l(e,"tensor","tensorScatterupdate"),s=_l(t,"indices","tensorScatterupdate","int32"),a=_l(n,"updates","tensorScatterupdate");if(sm(a,s,r.shape),r.dtype!==a.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${a.dtype}.`);const i={tensor:r,indices:s,updates:a};return Il.runKernel(Si,i,{})}});const om=Ll({topk_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const r=_l(e,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${t}`);const a={x:r},i={k:t,sorted:n},[o,l]=Il.runKernel(eo,a,i);return{values:o,indices:l}}});const lm=Ll({truncatedNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3?arguments[3]:void 0,s=arguments.length>4?arguments[4]:void 0;if(jr(e),null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const a=new cf(t,n,r,!0,s),i=Zu(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}});const um=Ll({unique_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=_l(e,"x","unique","string_or_numeric");yr(n.rank>0,(()=>"The input tensor must be at least 1D"));const r={x:n},s={axis:t},[a,i]=Il.runKernel(ro,r,s);return{values:a,indices:i}}});const cm=Ll({unsortedSegmentSum_:function(e,t,n){const r=_l(e,"x","unsortedSegmentSum"),s=_l(t,"segmentIds","unsortedSegmentSum","int32");yr(kr(n),(()=>"numSegments must be of dtype int"));const a={x:r,segmentIds:s},i={numSegments:n};return Il.runKernel(ao,a,i)}});const hm=Ll({unstack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=_l(e,"x","unstack","string_or_numeric");yr(t>=-n.shape.length&&t<n.shape.length,(()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`));const r={value:n},s={axis:t};return Il.runKernel(so,r,s)}});function dm(e,t){return $p(e,t,"right")}function pm(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return Il.makeVariable(e,t,n,r)}function fm(e,t){const n=[];for(let a=0;a<t.length;a++)t[a]&&n.push(a);const r=Zu(e,"int32"),s=Zu([n.length,e.length],"int32");for(let a=0;a<n.length;a++){const t=r.indexToLoc(n[a]),i=a*e.length;s.values.set(t,i)}return s.toTensor()}const mm=async function(e){const t=_l(e,"condition","whereAsync","bool"),n=await t.data(),r=fm(t.shape,n);return e!==t&&t.dispose(),r};const gm=async function(e,t,n){const r=_l(e,"tensor","boolMask"),s=_l(t,"mask","boolMask","bool"),a=null==n?0:n,i=s.rank,o=r.shape;yr(i>0,(()=>"mask cannot be scalar")),br(o.slice(a,a+i),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let m=a;m<a+i;m++)l*=o[m];const u=o.slice(0,a).concat([l],o.slice(a+i)),c=Hh(r,u),h=Hh(s,[-1]),d=await mm(h),p=qf(d,[1]),f=ip(c,p,a);return e!==r&&r.dispose(),t!==s&&s.dispose(),p.dispose(),c.dispose(),h.dispose(),d.dispose(),f};const ym=Ll({transpose_:function(e,t,n){const r=_l(e,"x","transpose");if(null==t&&(t=r.shape.map(((e,t)=>t)).reverse()),yr(r.rank===t.length,(()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`)),t.forEach((e=>{yr(e>=0&&e<r.rank,(()=>"All entries in 'perm' must be between 0 and "+(r.rank-1)+` but got ${t}`))})),r.rank<=1)return r.clone();const s={x:r},a={perm:t};return"complex64"===r.dtype?Gl((()=>{let e=vf(r),t=up(r);return e=Il.runKernel(no,{x:e},a),t=Il.runKernel(no,{x:t},a),n&&(t=xp(t)),Pl(e,t)})):Il.runKernel(no,s,a)}});const bm=Ll({movingAverage_:function(e,t,n,r){let s=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];const a=_l(e,"v","movingAverage"),i=_l(t,"x","movingAverage"),o=_l(n,"decay","movingAverage");!function(e,t){yr(e.dtype===t.dtype,(()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`))}(a,i),yr(wr(a.shape,i.shape),(()=>"Shape mismatch in v and x"));const l=cc(1),u=wc(l,o);let c=ac(wc(i,a),u);if(s){yr(null!=r,(()=>"When using zeroDebias: true, step is required."));const e=_l(r,"step","movingAverage");c=sc(c,wc(l,xc(o,e)))}return nc(a,c)}});const vm=Ll({scatterND_:function(e,t,n){jr(n);const r=_l(e,"indices","scatterND","int32"),s=_l(t,"updates","scatterND");sm(s,r,n);const a={indices:r,updates:s},i={shape:n};return Il.runKernel(ki,a,i)}});const xm=Ll({sparseToDense_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;jr(n);const s=_l(e,"sparseIndices","sparseToDense","int32"),a=_l(t,"sparseValues","sparseToDense","string_or_numeric"),i=_l(r,"defaultValue","sparseToDense",a.dtype);!function(e,t,n,r){if("int32"!==e.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);const s=e.rank>0?e.shape[0]:1,a=e.rank>1?e.shape[1]:1;if(n.length!==a)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${a}.`);const i=t.size;if(0!==t.rank&&(1!==t.rank||i!==s))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${s}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(s,a,n,i);const o={sparseIndices:s,sparseValues:a,defaultValue:i},l={outputShape:n};return Il.runKernel(Wi,o,l)}});const wm=Ll({gatherND_:function(e,t){const n=_l(t,"indices","gatherND","int32"),r={params:_l(e,"x","gatherND","string_or_numeric"),indices:n};return Il.runKernel(fa,r)}});const km=Ll({dropout_:function(e,t,n,r){const s=_l(e,"x","dropout");if(yr("float32"===s.dtype,(()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`)),yr(t>=0&&t<1,(()=>`rate must be a float in the range [0, 1), but got ${t}.`)),0===t)return e instanceof sl?s.clone():s;const a=function(e,t){if(null==t)return e.shape.slice();if(wr(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let r=0;r<e.shape.length;r++)null==t[r]&&null!=e.shape[r]?n.push(e.shape[r]):n.push(t[r]);return n}return t}(s,n),i=1-t,o=sc(ap(nc(gf(a,0,1,"float32",r),i)),i);return ac(s,o)}});function Sm(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function Nm(e,t,n){const r=1-e%2,s=new Float32Array(e);for(let a=0;a<e;++a){const i=2*Math.PI*a/(e+r-1);s[a]=t-n*Math.cos(i)}return Zf(s,"float32")}const Im=async function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;const r=_l(e,"predictions","inTopK"),s=_l(t,"targets","inTopK");yr(r.rank>1,(()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`)),yr(r.rank-1===s.rank,(()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`)),br(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const a=r.shape[r.shape.length-1];yr(n>0&&n<=a,(()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${a}), but got ${n}`));const i=await r.data(),o=await s.data(),[l,u]=[i.length/a,a],c=Er("bool",l);for(let h=0;h<l;h++){const e=h*u,t=i.subarray(e,e+u),r=[];for(let n=0;n<t.length;n++)r.push({value:t[n],index:n});r.sort(((e,t)=>t.value-e.value)),c[h]=0;for(let s=0;s<n;s++)if(r[s].index===o[h]){c[h]=1;break}}return e!==r&&r.dispose(),t!==s&&s.dispose(),Bl(c,s.shape,"bool")};const Cm=Ll({conv2DBackpropFilter_:function(e,t,n,r,s){let a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",i=arguments.length>6?arguments[6]:void 0,o=e;3===e.rank&&(o=Hh(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=Hh(t,[1,t.shape[0],t.shape[1],t.shape[2]])),yr(4===o.rank,(()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`)),yr(4===l.rank,(()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`)),yr(4===n.length,(()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`));const u="NHWC"===a?o.shape[3]:o.shape[1],c="NHWC"===a?l.shape[3]:l.shape[1];yr(u===n[2],(()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`)),yr(c===n[3],(()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`)),Gh("conv2dDerFilter",s,i);const h={x:o,dy:l},d={strides:r,pad:s,dataFormat:a,dimRoundingMode:i,filterShape:n};return Il.runKernel(Ds,h,d)}});function Tm(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return ac(e,Xf(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function Am(e,t){let n=t;const r=Ic(e.shape,t.shape);return r.length>0&&(n=Qd(n,r)),Hh(n,e.shape)}function Em(e,t,n,r){if("linear"===t)return e;if("relu"===t)return wf(e);if("elu"===t)return Ld(e);if("relu6"===t)return kf(e);if("prelu"===t)return nf(e,n);if("leakyrelu"===t)return pp(e,r);if("sigmoid"===t)return Yh(e);throw new Error(`Unknown fused activation ${t}.`)}const $m=(e,t)=>!(e>0)||"linear"===t;const Rm=Ll({fusedConv2d_:function(e){let{x:t,filter:n,strides:r,pad:s,dataFormat:a="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:l,activation:u="linear",preluActivationWeights:c,leakyreluAlpha:h}=e;if(u=u||"linear",!1===$m(Il.state.gradientDepth,u)){yr("NHWC"===a,(()=>`Error in fused conv2d: got dataFormat of ${a} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`));let e=gd(t,n,r,s,a,i,o);return null!=l&&(e=nc(e,l)),Em(e,u,c,h)}const d=_l(t,"x","conv2d","float32"),p=_l(n,"filter","conv2d","float32");let f=d,m=!1;3===d.rank&&(m=!0,f=Hh(d,[1,d.shape[0],d.shape[1],d.shape[2]])),yr(4===f.rank,(()=>`Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`)),yr(4===p.rank,(()=>`Error in fused conv2d: filter must be rank 4, but got rank ${p.rank}.`)),Gh("fused conv2d",s,o);const g="NHWC"===a?f.shape[3]:f.shape[1];yr(p.shape[2]===g,(()=>`Error in conv2d: depth of input (${g}) must match input depth for filter ${p.shape[2]}.`)),yr(Wh(r,i),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${r} and dilations '${i}'`));const y=_h(f.shape,p.shape,r,i,s,o);let b,v;if(null!=l&&(b=_l(l,"bias","fused conv2d"),[b]=yl(b,d),"NHWC"===a?Cc(y.outShape,b.shape):(yr(b.shape.length<=1,(()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${b.shape.length}.`)),yr(0===b.shape.length||b.shape[0]===y.outChannels||1===b.shape[0],(()=>`Error in fused conv2d: bias shape (${b.shape}) is not compatible with the number of output channels (${y.outChannels})`)))),null!=c){const e=c.shape;if(yr(e.length<=1||3===e.length,(()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${e.length}.`)),1===e.length)yr(1===e[0]||e[0]===y.outChannels,(()=>`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the number of output channels (${y.outChannels}).`));else if(3===e.length)try{Cc(e,y.outShape)}catch(E9){const n=`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the output shape of the conv2d (${y.outShape}).`;throw Error(n)}v=_l(c,"prelu weights","fused conv2d")}const x=(e,t)=>{yr("NHWC"===a,(()=>`Error in gradient of fused conv2D: got dataFormat of ${a} but only NHWC is currently supported.`));const[n,o,l,c]=t,h=Tm(e,l,u);yr(Vh(i),(()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`));const d=[bd(o.shape,h,n,r,s),Cm(o,h,n.shape,r,s)];if(null!=c){const e=Am(c,h);d.push(e)}return d},w={x:f,filter:p,bias:b,preluActivationWeights:v},k={strides:r,pad:s,dataFormat:a,dilations:i,dimRoundingMode:o,activation:u,leakyreluAlpha:h};if(null==l){const e=uc(((e,t,n)=>{let r=Il.runKernel(ho,w,k);return n([t,e,r]),m&&(r=Hh(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:x}}));return e(f,p)}{const e=uc(((e,t,n,r)=>{let s=Il.runKernel(ho,w,k);return r([t,e,s,n]),m&&(s=Hh(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:x}}));return e(f,p,b)}}});const Dm=Ll({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,r,s){let a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0,o=e;3===e.rank&&(o=Hh(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=Hh(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const u={x:o,dy:l},c={strides:r,pad:s,dimRoundingMode:i,dilations:a,filterShape:n};return Il.runKernel(Gs,u,c)}});const Om=Ll({depthwiseConv2dNativeBackpropInput_:function(e,t,n,r,s){let a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0,o=t,l=!1;3===t.rank&&(l=!0,o=Hh(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const u={dy:o,filter:n},c={strides:r,pad:s,dimRoundingMode:i,dilations:a,inputShape:e},h=Il.runKernel(Hs,u,c);return l?Hh(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});const _m=Ll({fusedDepthwiseConv2d_:function(e){let{x:t,filter:n,strides:r,pad:s,dataFormat:a="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:l,activation:u="linear",preluActivationWeights:c,leakyreluAlpha:h}=e;if(!1===$m(Il.state.gradientDepth,u)){let e=Ed(t,n,r,s,a,i,o);return null!=l&&(e=nc(e,l)),Em(e,u,c,h)}const d=_l(t,"x","depthwiseConv2d","float32"),p=_l(n,"filter","depthwiseConv2d","float32");let f=d,m=!1;3===d.rank&&(m=!0,f=Hh(d,[1,d.shape[0],d.shape[1],d.shape[2]])),yr(4===f.rank,(()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`)),yr(4===p.rank,(()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${p.rank}.`)),yr(f.shape[3]===p.shape[2],(()=>`Error in fused depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`)),null==i&&(i=[1,1]),yr(Wh(r,i),(()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${r} and dilations '${i}'`)),Gh("fused depthwiseConv2d",s,o);const g=_h(f.shape,p.shape,r,i,s,o,!0);let y,b;null!=l&&(y=_l(l,"bias","fused conv2d"),[y]=yl(y,d),Cc(g.outShape,y.shape)),null!=c&&(b=_l(c,"prelu weights","fused depthwiseConv2d"));const v=(e,t)=>{yr(Vh(i),(()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`));const[n,a,l,c]=t,h=Tm(e,l,u),d=Om(a.shape,h,n,r,s,i,o),p=Dm(a,h,n.shape,r,s,i,o);if(null!=c){return[d,p,Am(y,h)]}return[d,p]},x={x:f,filter:p,bias:y,preluActivationWeights:b},w={strides:r,pad:s,dataFormat:a,dilations:i,dimRoundingMode:o,activation:u,leakyreluAlpha:h};if(null==l){const e=uc(((e,t,n)=>{let r=Il.runKernel(po,x,w);return n([t,e,r]),m&&(r=Hh(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:v}}));return e(f,p)}{const e=uc(((e,t,n,r)=>{let s=Il.runKernel(po,x,w);return r([t,e,s,n]),m&&(s=Hh(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:v}}));return e(f,p,y)}}});const Fm=Ll({fusedMatMul_:function(e){let{a:t,b:n,transposeA:r=!1,transposeB:s=!1,bias:a,activation:i="linear",preluActivationWeights:o,leakyreluAlpha:l=.2}=e;if(!1===$m(Il.state.gradientDepth,i)){let e=Qh(t,n,r,s);return null!=a&&(e=nc(e,a)),Em(e,i,o,l)}let u=_l(t,"a","fused matMul"),c=_l(n,"b","fused matMul");[u,c]=yl(u,c);const h=r?u.shape[u.rank-2]:u.shape[u.rank-1],d=s?c.shape[c.rank-1]:c.shape[c.rank-2],p=r?u.shape[u.rank-1]:u.shape[u.rank-2],f=s?c.shape[c.rank-2]:c.shape[c.rank-1],m=u.shape.slice(0,-2),g=c.shape.slice(0,-2),y=xr(m),b=xr(g);yr(h===d,(()=>`Error in fused matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${u.shape} and ${c.shape} and transposeA=${r} and transposeB=${s} must match.`));const v=Cc(u.shape.slice(0,-2),c.shape.slice(0,-2)).concat([p,f]),x=Hh(u,r?[y,h,p]:[y,p,h]),w=Hh(c,s?[b,f,d]:[b,d,f]);let k,S;null!=a&&(k=_l(a,"bias","fused matMul"),[k]=yl(k,u),Cc(v,k.shape)),null!=o&&(S=_l(o,"prelu weights","fused matMul"));const N=(e,t)=>{const[n,o,l,u]=t,c=Tm(Hh(e,l.shape),l,i);let h,d;if(r||s?!r&&s?(h=Qh(c,o,!1,!1),d=Qh(c,n,!0,!1)):r&&!s?(h=Qh(o,c,!1,!0),d=Qh(n,c,!1,!1)):(h=Qh(o,c,!0,!0),d=Qh(c,n,!0,!0)):(h=Qh(c,o,!1,!0),d=Qh(n,c,!0,!1)),null!=a){return[h,d,Am(u,c)]}return[h,d]},I={a:x,b:w,bias:k,preluActivationWeights:S},C={transposeA:r,transposeB:s,activation:i,leakyreluAlpha:l};if(null==a){const e=uc(((e,t,n)=>{const r=Il.runKernel(co,I,C);return n([e,t,r]),{value:Hh(r,v),gradFunc:N}}));return e(x,w)}{const e=uc(((e,t,n,r)=>{const s=Il.runKernel(co,I,C);return r([e,t,s,n]),{value:Hh(s,v),gradFunc:N}}));return e(x,w,k)}}});const Mm=Ll({hammingWindow_:function(e){return Nm(e,.54,.46)}});const Lm=Ll({hannWindow_:function(e){return Nm(e,.5,.5)}});const Pm=Ll({frame_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,a=0;const i=[];for(;a+t<=e.size;)i.push(Zh(e,a,t)),a+=n;if(r)for(;a<e.size;){const r=a+t-e.size,o=Xh([Zh(e,a,t-r),bc([r],s)]);i.push(o),a+=n}return 0===i.length?Jf([],[0,t]):Hh(Xh(i),[i.length,t])}});const zm=Ll({stft_:function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Lm;null==r&&(r=Sm(t));const a=Pm(e,t,n),i=ac(a,s(t));return Gf(i,r)}});const Bm=Ll({cropAndResize_:function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"bilinear",a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const i=_l(e,"image","cropAndResize"),o=_l(t,"boxes","cropAndResize","float32"),l=_l(n,"boxInd","cropAndResize","int32"),u=o.shape[0];yr(4===i.rank,(()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`)),yr(2===o.rank&&4===o.shape[1],(()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${o.shape}.`)),yr(1===l.rank&&l.shape[0]===u,(()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${o.shape}.`)),yr(2===r.length,(()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`)),yr(r[0]>=1&&r[1]>=1,(()=>`cropSize must be atleast [1,1], but was ${r}`)),yr("bilinear"===s||"nearest"===s,(()=>`method must be bilinear or nearest, but was ${s}`));const c={image:i,boxes:o,boxInd:l},h={method:s,extrapolationValue:a,cropSize:r};return Il.runKernel(Vs,c,h)}});const Vm=Ll({flipLeftRight_:function(e){const t=_l(e,"image","flipLeftRight","float32");yr(4===t.rank,(()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`));const n={image:t};return Il.runKernel(ua,n,{})}});const Wm=Ll({grayscaleToRGB_:function(e){const t=_l(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];yr(t.rank>=2,(()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`)),yr(1===r,(()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`));const s=new Array(t.rank);return s.fill(1,0,n),s[n]=3,rp(t,s)}});const Um=Ll({rgbToGrayscale_:function(e){const t=_l(e,"image","RGBToGrayscale"),n=t.rank-1,r=t.shape[n];yr(t.rank>=2,(()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`)),yr(3===r,(()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`));const s=t.dtype,a=Ju(t,"float32"),i=Zf([.2989,.587,.114]);let o;switch(t.rank){case 2:o=Md("ij,j->i",a,i);break;case 3:o=Md("ijk,k->ij",a,i);break;case 4:o=Md("ijkl,l->ijk",a,i);break;case 5:o=Md("ijklm,m->ijkl",a,i);break;case 6:o=Md("ijklmn,n->ijklm",a,i);break;default:throw new Error("Not a valid tensor rank.")}return o=tp(o,-1),Ju(o,s)}});const jm=Ll({rotateWithOffset_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const s=_l(e,"image","rotateWithOffset","float32");yr(4===s.rank,(()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`));const a={image:s},i={radians:t,fillValue:n,center:r};return Il.runKernel(uo,a,i)}});function Gm(e,t,n,r,s,a){null==r&&(r=.5),null==s&&(s=Number.NEGATIVE_INFINITY),null==a&&(a=0);const i=e.shape[0];return n=Math.min(n,i),yr(0<=r&&r<=1,(()=>`iouThreshold must be in [0, 1], but was '${r}'`)),yr(2===e.rank,(()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`)),yr(4===e.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`)),yr(1===t.rank,(()=>"scores must be a 1D tensor")),yr(t.shape[0]===i,(()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`)),yr(0<=a&&a<=1,(()=>`softNmsSigma must be in [0, 1], but was '${a}'`)),{maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:a}}const Hm=Ll({nonMaxSuppression_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const a=_l(e,"boxes","nonMaxSuppression","float32"),i=_l(t,"scores","nonMaxSuppression","float32"),o=Gm(a,i,n,r,s);n=o.maxOutputSize,r=o.iouThreshold,s=o.scoreThreshold;const l={maxOutputSize:n,iouThreshold:r,scoreThreshold:s};return Il.runKernel(Qa,{boxes:a,scores:i},l)}});function qm(e,t,n){const r=function(e,t,n){return function(e,t,n){let r=0,s=e.length,a=0,i=!1;for(;r<s;){a=r+(s-r>>>1);const o=n(t,e[a]);o>0?r=a+1:(s=a,i=!o)}return i?r:-r-1}(e,t,n||Km)}(e,t,n),s=r<0?-(r+1):r;e.splice(s,0,t)}function Km(e,t){return e>t?1:e<t?-1:0}function Xm(e,t,n,r,s){return Zm(e,t,n,r,s,0)}function Qm(e,t,n,r,s,a){return Zm(e,t,n,r,s,0,!1,a,!0)}function Ym(e,t,n,r,s,a){return Zm(e,t,n,r,s,a,!0)}function Zm(e,t,n,r,s,a){let i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]&&arguments[7],l=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const u=[];for(let g=0;g<t.length;g++)t[g]>s&&u.push({score:t[g],boxIndex:g,suppressBeginIndex:0});u.sort(tg);const c=a>0?-.5/a:0,h=[],d=[];for(;h.length<n&&u.length>0;){const t=u.pop(),{score:n,boxIndex:a,suppressBeginIndex:i}=t;if(n<s)break;let o=!1;for(let l=h.length-1;l>=i;--l){const n=Jm(e,a,h[l]);if(n>=r){o=!0;break}if(t.score=t.score*eg(r,c,n),t.score<=s)break}t.suppressBeginIndex=h.length,o||(t.score===n?(h.push(a),d.push(t.score)):t.score>s&&qm(u,t,tg))}const p=h.length,f=n-p;o&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const m={selectedIndices:h};return i&&(m.selectedScores=d),l&&(m.validOutputs=p),m}function Jm(e,t,n){const r=e.subarray(4*t,4*t+4),s=e.subarray(4*n,4*n+4),a=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),h=Math.max(s[0],s[2]),d=Math.max(s[1],s[3]),p=(o-a)*(l-i),f=(h-u)*(d-c);if(p<=0||f<=0)return 0;const m=Math.max(a,u),g=Math.max(i,c),y=Math.min(o,h),b=Math.min(l,d),v=Math.max(y-m,0)*Math.max(b-g,0);return v/(p+f-v)}function eg(e,t,n){const r=Math.exp(t*n*n);return n<=e?r:0}function tg(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}const ng=async function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const a=_l(e,"boxes","nonMaxSuppressionAsync"),i=_l(t,"scores","nonMaxSuppressionAsync"),o=Gm(a,i,n,r,s);n=o.maxOutputSize,r=o.iouThreshold,s=o.scoreThreshold;const l=await Promise.all([a.data(),i.data()]),u=l[0],c=l[1],{selectedIndices:h}=Xm(u,c,n,r,s);return a!==e&&a.dispose(),i!==t&&i.dispose(),Zf(h,"int32")};const rg=Ll({nonMaxSuppressionWithScore_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const i=_l(e,"boxes","nonMaxSuppression"),o=_l(t,"scores","nonMaxSuppression"),l=Gm(i,o,n,r,s,a);n=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,a=l.softNmsSigma;const u={boxes:i,scores:o},c={maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:a},h=Il.runKernel(Za,u,c);return{selectedIndices:h[0],selectedScores:h[1]}}});const sg=async function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const i=_l(e,"boxes","nonMaxSuppressionAsync"),o=_l(t,"scores","nonMaxSuppressionAsync"),l=Gm(i,o,n,r,s,a);n=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,a=l.softNmsSigma;const u=await Promise.all([i.data(),o.data()]),c=u[0],h=u[1],{selectedIndices:d,selectedScores:p}=Ym(c,h,n,r,s,a);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:Zf(d,"int32"),selectedScores:Zf(p)}};const ag=Ll({nonMaxSuppressionPadded_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,a=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const i=_l(e,"boxes","nonMaxSuppression"),o=_l(t,"scores","nonMaxSuppression"),l=Gm(i,o,n,r,s,null),u={boxes:i,scores:o},c={maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:a},h=Il.runKernel(Ya,u,c);return{selectedIndices:h[0],validOutputs:h[1]}}});const ig=async function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,a=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const i=_l(e,"boxes","nonMaxSuppressionAsync"),o=_l(t,"scores","nonMaxSuppressionAsync"),l=Gm(i,o,n,r,s,null),u=l.maxOutputSize,c=l.iouThreshold,h=l.scoreThreshold,[d,p]=await Promise.all([i.data(),o.data()]),{selectedIndices:f,validOutputs:m}=Qm(d,p,u,c,h,a);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:Zf(f,"int32"),validOutputs:cc(m,"int32")}};const og=Ll({resizeBilinear_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=_l(e,"images","resizeBilinear");yr(3===s.rank||4===s.rank,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`)),yr(2===t.length,(()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`)),yr(!1===r||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let a=s,i=!1;3===s.rank&&(i=!0,a=Hh(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,o={images:a},l={alignCorners:n,halfPixelCenters:r,size:t},u=Il.runKernel(gi,o,l);return i?Hh(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const lg=Ll({resizeNearestNeighbor_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=_l(e,"images","resizeNearestNeighbor");yr(3===s.rank||4===s.rank,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`)),yr(2===t.length,(()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`)),yr("float32"===s.dtype||"int32"===s.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),yr(!1===r||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let a=s,i=!1;3===s.rank&&(i=!0,a=Hh(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,o={images:a},l={alignCorners:n,halfPixelCenters:r,size:t},u=Il.runKernel(fi,o,l);return i?Hh(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const ug=Ll({threshold_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"binary",n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const s=_l(e,"image","threshold"),a=s.shape[0]*s.shape[1];let i,o,l,u,c=ac(Zf([r]),255);if(yr(3===s.rank,(()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`)),yr(3===s.shape[2]||1===s.shape[2],(()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`)),yr("int32"===s.dtype||"float32"===s.dtype,(()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`)),yr("otsu"===t||"binary"===t,(()=>`Method must be binary or otsu, but was ${t}`)),3===s.shape[2]){[i,o,l]=jf(s,[1,1,1],-1);const e=ac(i,.2989),t=ac(o,.587),n=ac(l,.114);u=nc(nc(e,t),n)}else u=e;if("otsu"===t){c=function(e,t){let n,r,s,a,i,o,l=Zf([-1]),u=Zf([0]),c=Zf([0]);for(let h=0;h<e.size-1;h++){n=Zh(e,0,h+1),r=Zh(e,h+1),i=sc(Qd(n),t),o=sc(Qd(r),t);const d=Qd(ac(n,bf(0,n.size)));s=sc(d,Qd(n));const p=bc(r.shape,n.size),f=nc(bf(0,r.size),p),m=ac(r,f);a=sc(Qd(m),Qd(r));const g=wc(s,a),y=wc(s,a),b=ac(i,o);c=ac(ac(b,g),y);const v=op(c,u);u=Od(v,c,u),l=Od(v,Zf([h]),l)}return l}(id(Ju(Af(u),"int32"),Bl([]),256),a)}const h=n?mp(u,c):op(u,c);return Ju(ac(h,255),"int32")}});const cg=Ll({transform_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"nearest",r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"constant",s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,a=arguments.length>5?arguments[5]:void 0;const i=_l(e,"image","transform","float32"),o=_l(t,"transforms","transform","float32");yr(4===i.rank,(()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`)),yr(2===o.rank&&(o.shape[0]===i.shape[0]||1===o.shape[0])&&8===o.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),yr(null==a||2===a.length,(()=>`Error in transform: outputShape must be [height, width] or null, but got ${a}.`));const l={image:i,transforms:o},u={interpolation:n,fillMode:r,fillValue:s,outputShape:a};return Il.runKernel(to,l,u)}});const hg=Ll({bandPart_:function(e,t,n){const r=_l(e,"a","bandPart");yr(r.rank>=2,(()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`));const s=r.shape,[a,i]=r.shape.slice(-2);let o,l;"number"===typeof t?(yr(t%1===0,(()=>`bandPart(): numLower must be an integer, got ${t}.`)),yr(t<=a,(()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${a}).`)),o=_l(t<0?a:t,"numLower","bandPart")):(yr("int32"===t.dtype,(()=>"bandPart(): numLower's dtype must be an int32.")),o=Od(fp(t,0),a,zp(t,a))),"number"===typeof n?(yr(n%1===0,(()=>`bandPart(): numUpper must be an integer, got ${n}.`)),yr(n<=i,(()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`)),l=_l(n<0?i:n,"numUpper","bandPart")):(yr("int32"===n.dtype,(()=>"bandPart(): numUpper's dtype must be an int32.")),l=Od(fp(n,0),i,zp(n,i)));const u=Hh(bf(0,a,1,"int32"),[-1,1]),c=bf(0,i,1,"int32"),h=wc(u,c),d=Ip(mp(h,o),lp(h,xp(l))),p=Mp([a,i],r.dtype);return Hh(Kf(hm(Hh(r,[-1,a,i])).map((e=>Od(d,e,p)))),s)}});const dg=Ll({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,yr(null!=e&&e.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=e[0].shape[0];for(let t=1;t<e.length;++t)yr(e[t].shape[0]===n,(()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[t].shape[0]} vs. ${n})`))}else t=!0,e=jf(e,e.shape[0],0).map((e=>qf(e,[0])));yr(e.length<=e[0].shape[0],(()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`));const n=[],r=e;for(let s=0;s<e.length;++s)n.push(Il.tidy((()=>{let e=r[s];if(s>0)for(let t=0;t<s;++t){const r=ac(Qd(ac(n[t],e)),n[t]);e=wc(e,r)}return sc(e,Zd(e,"euclidean"))})));return t?Kf(n,0):n}});function pg(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return Il.tidy((()=>{yr(2===e.shape.length,(()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`));const n=e.shape[0],r=e.shape[1];let s=sp(n),a=ec(e);const i=Jf([[1]],[1,1]);let o=ec(i);const l=n>=r?r:n;for(let e=0;e<l;++e){const t=a,l=o,u=s;[o,a,s]=Il.tidy((()=>{const t=Zh(a,[e,e],[n-e,1]),l=Zd(t),u=Zh(a,[e,e],[1,1]),c=Od(op(u,0),Jf([[-1]]),Jf([[1]])),h=wc(u,ac(c,l)),d=sc(t,h);o=1===d.shape[0]?ec(i):Xh([i,Zh(d,[1,0],[d.shape[0]-1,d.shape[1]])],0);const p=xp(sc(Qh(c,h),l)),f=Zh(a,[e,0],[n-e,r]),m=ac(p,o),g=ym(o);if(0===e)a=wc(f,Qh(m,Qh(g,f)));else{const t=wc(f,Qh(m,Qh(g,f)));a=Xh([Zh(a,[0,0],[e,r]),t],0)}const y=ym(m),b=Zh(s,[0,e],[n,s.shape[1]-e]);if(0===e)s=wc(b,Qh(Qh(b,o),y));else{const t=wc(b,Qh(Qh(b,o),y));s=Xh([Zh(s,[0,0],[n,e]),t],1)}return[o,a,s]})),Hl([t,l,u])}return!t&&n>r&&(s=Zh(s,[0,0],[n,r]),a=Zh(a,[0,0],[r,r])),[s,a]}))}const fg=Ll({qr_:function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(yr(e.rank>=2,(()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`)),2===e.rank)return pg(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce(((e,t)=>e*t)),r=hm(Hh(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),s=[],a=[];r.forEach((e=>{const[n,r]=pg(e,t);s.push(n),a.push(r)}));return[Hh(Kf(s,0),e.shape),Hh(Kf(a,0),e.shape)]}}});var mg;!function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(mg||(mg={}));const gg=Ll({computeWeightedLoss_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:mg.SUM_BY_NONZERO_WEIGHTS;const r=_l(e,"losses","computeWeightedLoss");let s=null;null!=t&&(s=_l(t,"weights","computeWeightedLoss"));const a=null==s?r:ac(r,s);if(n===mg.NONE)return a;if(n===mg.SUM)return Qd(a);if(n===mg.MEAN){if(null==s)return Fp(a);{const e=r.size/s.size,t=sc(Qd(a),Qd(s));return e>1?sc(t,cc(e)):t}}if(n===mg.SUM_BY_NONZERO_WEIGHTS){if(null==s)return sc(Qd(a),cc(r.size));{const e=ac(s,Lp(r.shape)),t=Ju(Qd(Gp(e,cc(0))),"float32");return sc(Qd(a),t)}}throw Error(`Unknown reduction: ${n}`)}});const yg=Ll({absoluteDifference_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:mg.SUM_BY_NONZERO_WEIGHTS;const s=_l(e,"labels","absoluteDifference"),a=_l(t,"predictions","absoluteDifference");let i=null;null!=n&&(i=_l(n,"weights","absoluteDifference")),br(s.shape,a.shape,"Error in absoluteDifference: ");const o=Sc(wc(s,a));return gg(o,i,r)}});const bg=Ll({cosineDistance_:function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:mg.SUM_BY_NONZERO_WEIGHTS;const a=_l(e,"labels","cosineDistance"),i=_l(t,"predictions","cosineDistance");let o=null;null!=r&&(o=_l(r,"weights","cosineDistance")),br(a.shape,i.shape,"Error in cosineDistance: ");const l=cc(1),u=wc(l,Qd(ac(a,i),n,!0));return gg(u,o,s)}});const vg=Ll({hingeLoss_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:mg.SUM_BY_NONZERO_WEIGHTS,s=_l(e,"labels","hingeLoss");const a=_l(t,"predictions","hingeLoss");let i=null;null!=n&&(i=_l(n,"weights","hingeLoss")),br(s.shape,a.shape,"Error in hingeLoss: ");const o=cc(1);s=wc(ac(cc(2),s),o);const l=wf(wc(o,ac(s,a)));return gg(l,i,r)}});const xg=Ll({huberLoss_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:mg.SUM_BY_NONZERO_WEIGHTS;const a=_l(e,"labels","huberLoss"),i=_l(t,"predictions","huberLoss");let o=null;null!=n&&(o=_l(n,"weights","huberLoss")),br(a.shape,i.shape,"Error in huberLoss: ");const l=cc(r),u=Sc(wc(i,a)),c=zp(u,l),h=wc(u,c),d=nc(ac(cc(.5),oc(c)),ac(l,h));return gg(d,o,s)}});const wg=Ll({logLoss_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1e-7,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:mg.SUM_BY_NONZERO_WEIGHTS;const a=_l(e,"labels","logLoss"),i=_l(t,"predictions","logLoss");let o=null;null!=n&&(o=_l(n,"weights","logLoss")),br(a.shape,i.shape,"Error in logLoss: ");const l=cc(1),u=cc(r),c=xp(ac(a,bp(nc(i,u)))),h=ac(wc(l,a),bp(nc(wc(l,i),u))),d=wc(c,h);return gg(d,o,s)}});const kg=Ll({meanSquaredError_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:mg.SUM_BY_NONZERO_WEIGHTS;const s=_l(e,"labels","meanSquaredError"),a=_l(t,"predictions","meanSquaredError");let i=null;null!=n&&(i=_l(n,"weights","meanSquaredError")),br(s.shape,a.shape,"Error in meanSquaredError: ");const o=Hf(s,a);return gg(o,i,r)}});const Sg=Ll({sigmoidCrossEntropy_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:mg.SUM_BY_NONZERO_WEIGHTS,a=_l(e,"multiClassLabels","sigmoidCrossEntropy");const i=_l(t,"logits","sigmoidCrossEntropy");let o=null;if(null!=n&&(o=_l(n,"weights","sigmoidCrossEntropy")),br(a.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){const e=cc(r),t=cc(1),n=cc(.5);a=nc(ac(a,wc(t,e)),ac(n,e))}const l=function(e,t){const n=_l(e,"labels","sigmoidCrossEntropyWithLogits"),r=_l(t,"logits","sigmoidCrossEntropyWithLogits");br(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=wf(r),a=ac(r,n),i=vp(ep(xp(Sc(r))));return nc(wc(s,a),i)}(a,i);return gg(l,o,s)}});const Ng=Ll({softmaxCrossEntropy_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:mg.SUM_BY_NONZERO_WEIGHTS,a=_l(e,"onehotLabels","softmaxCrossEntropy");const i=_l(t,"logits","softmaxCrossEntropy");let o=null;if(null!=n&&(o=_l(n,"weights","softmaxCrossEntropy")),br(a.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){const e=cc(r),t=cc(1),n=cc(a.shape[1]);a=nc(ac(a,wc(t,e)),sc(e,n))}const l=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);const r=uc(((e,t,r)=>{const s=Np(t,[n],!0),a=wc(Ju(t,"float32"),s);r([e,a]);const i=xp(ac(a,e));return{value:Qd(i,[n]),gradFunc:(e,t)=>{const[r,s]=t,a=Ud(e.shape,[n]);return[ac(Hh(e,a),wc(Ju(r,"float32"),ep(s))),ac(Hh(e,a),wc(ep(s),Ju(r,"float32")))]}}}));return r(e,t)}(a,i);return gg(l,o,s)}});const Ig=Ll({sparseFillEmptyRows_:function(e,t,n,r){const s=_l(e,"indices","sparseFillEmptyRows","int32"),a=_l(t,"values","sparseFillEmptyRows"),i=_l(n,"denseShape","sparseFillEmptyRows","int32"),o=_l(r,"defaultValue","sparseFillEmptyRows",a.dtype);if(2!==s.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${s.shape}`);if(1!==a.rank)throw new Error(`Values should be Tensor1D but received shape ${a.shape}`);if(1!==i.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(0!==o.rank)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);const l={indices:s,values:a,denseShape:i,defaultValue:o},u=Il.runKernel(Pi,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}});const Cg=Ll({sparseReshape_:function(e,t,n){const r=_l(e,"inputIndices","sparseReshape","int32"),s=_l(t,"inputShape","sparseReshape","int32"),a=_l(n,"newShape","sparseReshape","int32");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==s.rank)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(1!==a.rank)throw new Error(`New shape should be Tensor1D but received shape ${a.shape}`);const i={inputIndices:r,inputShape:s,newShape:a},o=Il.runKernel(zi,i);return{outputIndices:o[0],outputShape:o[1]}}});const Tg=Ll({sparseSegmentMean_:function(e,t,n){const r=_l(e,"data","sparseSegmentMean"),s=_l(t,"indices","sparseSegmentMean","int32"),a=_l(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${s.shape}`);if(1!==a.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${a.shape}`);const i={data:r,indices:s,segmentIds:a};return Il.runKernel(Bi,i)}});const Ag=Ll({sparseSegmentSum_:function(e,t,n){const r=_l(e,"data","sparseSegmentSum"),s=_l(t,"indices","sparseSegmentSum","int32"),a=_l(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${s.shape}`);if(1!==a.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${a.shape}`);const i={data:r,indices:s,segmentIds:a};return Il.runKernel(Vi,i)}});const Eg=Ll({stringNGrams_:function(e,t,n,r,s,a,i,o){const l=_l(e,"data","stringNGrams","string");if("string"!==l.dtype)throw new Error("Data must be of datatype string");if(1!==l.shape.length)throw new Error(`Data must be a vector, saw: ${l.shape}`);const u=_l(t,"dataSplits","stringNGrams");if("int32"!==u.dtype)throw new Error("Data splits must be of datatype int32");const c={separator:n,nGramWidths:r,leftPad:s,rightPad:a,padWidth:i,preserveShortSequences:o},h={data:l,dataSplits:u},d=Il.runKernel(qi,h,c);return{nGrams:d[0],nGramsSplits:d[1]}}});const $g=Ll({stringSplit_:function(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const r=_l(e,"input","stringSplit","string"),s=_l(t,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==s.rank)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const a={skipEmpty:n},i={input:r,delimiter:s},o=Il.runKernel(Ki,i,a);return{indices:o[0],values:o[1],shape:o[2]}}});const Rg=Ll({stringToHashBucketFast_:function(e,t){const n=_l(e,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");const s={input:n};return Il.runKernel(Xi,s,r)}});const Dg=Ll({staticRegexReplace_:function(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const s=_l(e,"input","staticRegexReplace","string"),a={pattern:t,rewrite:n,replaceGlobal:r};return Il.runKernel(Gi,{x:s},a)}}),Og={fft:Vf,ifft:Wf,rfft:Gf,irfft:Uf},_g={hammingWindow:Mm,hannWindow:Lm,frame:Pm,stft:zm},Fg={flipLeftRight:Vm,grayscaleToRGB:Wm,resizeNearestNeighbor:lg,resizeBilinear:og,rgbToGrayscale:Um,rotateWithOffset:jm,cropAndResize:Bm,nonMaxSuppression:Hm,nonMaxSuppressionAsync:ng,nonMaxSuppressionWithScore:rg,nonMaxSuppressionWithScoreAsync:sg,nonMaxSuppressionPadded:ag,nonMaxSuppressionPaddedAsync:ig,threshold:ug,transform:cg},Mg={bandPart:hg,gramSchmidt:dg,qr:fg},Lg={absoluteDifference:yg,computeWeightedLoss:gg,cosineDistance:bg,hingeLoss:vg,huberLoss:xg,logLoss:wg,meanSquaredError:kg,sigmoidCrossEntropy:Sg,softmaxCrossEntropy:Ng},Pg={sparseFillEmptyRows:Ig,sparseReshape:Cg,sparseSegmentMean:Tg,sparseSegmentSum:Ag},zg={stringNGrams:Eg,stringSplit:$g,stringToHashBucketFast:Rg,staticRegexReplace:Dg};const Bg=class{static sgd(e){return new Ec(e)}static momentum(e,t){return new $c(e,t,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}static rmsprop(e){return new Rc(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]&&arguments[4])}static adam(){return new kc(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null)}static adadelta(){return new yc(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.95,arguments.length>2&&void 0!==arguments[2]?arguments[2]:null)}static adamax(){return new Ac(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.002,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]?arguments[4]:0)}static adagrad(e){return new vc(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1)}},Vg="undefined"!==typeof requestAnimationFrame?requestAnimationFrame:"undefined"!==typeof setImmediate?setImmediate:e=>e();function Wg(){return new Promise((e=>Vg((()=>e()))))}function Ug(e,t){const n=e[0].length;e.forEach(((e,t)=>{yr(e.length===n,(()=>`Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`))})),yr(t>=0&&t<n,(()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`));const r=e[0];e.forEach(((e,s)=>{for(let a=0;a<n;a++)yr(a===t||e[a]===r[a],(()=>`Error in concat${n}D: Shape of tensors[${s}] (${e}) does not match the shape of the rest (${r}) along the non-concatenated axis ${s}.`))}))}function jg(e,t){const n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}var Gg;function Hg(e,t,n){let r=new Array;if(null==n&&null==t)return r;if(null==t)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(null==n)return r;if(e+n.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${r.length}`);for(let s=1;s<n.length;++s){const a=n[s],i=r[r.length-n.length+s],o=r[i];if(a>=0)if(o>=0){if(o!==a)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${s+e}] = ${a} but shape[${s+e}] = ${o}`)}else r[i]=a}return r}function qg(e){const t={FIRST_DIM_SIZE:Gg.FIRST_DIM_SIZE,VALUE_ROWIDS:Gg.VALUE_ROWIDS,ROW_LENGTHS:Gg.ROW_LENGTHS,ROW_SPLITS:Gg.ROW_SPLITS,ROW_LIMITS:Gg.ROW_LIMITS,ROW_STARTS:Gg.ROW_STARTS},n=[];for(const r of e){if(!(r in t))break;n.push(t[r])}return n}function Kg(e){return 0===e.length?0:e[0]===Gg.FIRST_DIM_SIZE?e.length-1:e.length}function Xg(e,t){if(null==e||null==t)return;const n=e.length,r=t.length;if(n>=r)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let s=0;s<Math.min(n,r-1);++s){const n=e[s],r=t[s+1];if(n>=0&&r>=0&&1!==n&&n!==r)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${s-e.length}] = ${n} but ragged tensor input.flatValues.shape[${s-e.length}] = ${r}`)}}!function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"}(Gg||(Gg={}));const Qg=30;function Yg(e){return e<=Qg?e:Lr(e,Math.floor(Math.sqrt(e)))}function Zg(e,t,n){return[n*("number"===typeof e?e:e[0]),t*("number"===typeof e?e:e[1])]}function Jg(e,t,n){let r=[];if(!(arguments.length>3&&void 0!==arguments[3])||arguments[3])r=r.concat(t.slice(0)),r.push(e[0]/n),r=r.concat(e.slice(1));else{r=r.concat(e[0]);const n=t.length;for(let s=0;s<n;++s)r=r.concat([e[s+1]/t[s],t[s]]);r=r.concat(e.slice(n+1))}return r}function ey(e,t){const n=[];if(!(arguments.length>2&&void 0!==arguments[2])||arguments[2]){n.push(t);for(let r=t+1;r<e;++r)r<=2*t?(n.push(r),n.push(r-(t+1))):n.push(r)}else{const r=[],s=[];for(let n=1;n<e;++n)n>=2*t+1||n%2===1?s.push(n):r.push(n);n.push(...r),n.push(0),n.push(...s)}return n}function ty(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const s=[];r?s.push(e[0]/n):s.push(e[0]*n);for(let a=1;a<e.length;++a)a<=t.length?r?s.push(t[a-1]*e[a]):s.push(e[a]/t[a-1]):s.push(e[a]);return s}function ny(e,t){const n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function ry(e,t,n){const r=e.slice(0,1);for(let s=0;s<n;++s)r.push(e[s+1]-t[s][0]-t[s][1]);return r}function sy(e,t){const n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(0===xr(e.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);const s=t.shape,a=s[s.length-1];let i=1;for(let h=0;h<s.length-1;++h)i*=s[h];const o=e.shape,l=s.slice();l.pop();let u=1;for(let h=a;h<n;++h)u*=o[h],l.push(o[h]);const c=[...Pr(e.shape).map((e=>e/u)),1].slice(0,a);return[l,i,u,c]}const ay=1.7580993408473768,iy=1.0507009873554805,oy=.3275911,ly=.254829592,uy=-.284496736,cy=1.421413741,hy=-1.453152027,dy=1.061405429;function py(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);const n=new Float32Array(2*e.length);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function fy(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function my(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let s=0;s<e.length;s+=4)n[Math.floor(s/4)]=e[s],r[Math.floor(s/4)]=e[s+1];return{real:n,imag:r}}function gy(e){const t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let s=2;s<e.length;s+=4)n[Math.floor(s/4)]=e[s],r[Math.floor(s/4)]=e[s+1];return{real:n,imag:r}}function yy(e,t){return{real:e[2*t],imag:e[2*t+1]}}function by(e,t,n,r){e[2*r]=t,e[2*r+1]=n}function vy(e,t){const n=new Float32Array(e/2),r=new Float32Array(e/2);for(let s=0;s<Math.ceil(e/2);s++){const a=(t?2:-2)*Math.PI*(s/e);n[s]=Math.cos(a),r[s]=Math.sin(a)}return{real:n,imag:r}}function xy(e,t,n){const r=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(r),imag:Math.sin(r)}}const wy="->",ky=/->/g,Sy=",",Ny="...";function Iy(e,t){const n=((e=e.replace(/\s/g,"")).length-e.replace(ky,"").length)/wy.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${wy}").`);const[r,s]=e.split(wy);yr(-1===r.indexOf(Ny),(()=>`The ellipsis notation ("${Ny}") is not supported yet.`));const a=r.split(Sy),i=a.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let h=0;h<s.length;++h){const e=s[h];if(!a.some((t=>-1!==t.indexOf(e))))throw new Error(`Output subscripts contain the label ${e} not present in the input subscripts.`);-1===o.indexOf(e)&&o.push(e)}for(let h=0;h<r.length;++h){const e=r[h];-1===o.indexOf(e)&&e!==Sy&&o.push(e)}const l=new Array(a.length);for(let h=0;h<i;++h){if(new Set(a[h].split("")).size!==a[h].length)throw new Error(`Found duplicate axes in input component ${a[h]}. Support for duplicate axes in input is not implemented yet.`);l[h]=[];for(let e=0;e<a[h].length;++e)l[h].push(o.indexOf(a[h][e]))}const u=o.length,c=[];for(let h=s.length;h<u;++h)c.push(h);return{allDims:o,summedDims:c,idDims:l}}function Cy(e,t){let n=new Array(e);n.fill(-1);for(let s=0;s<t.length;++s)n[t[s]]=s;const r=[];for(let s=0;s<e;++s)-1===n[s]&&r.push(s);return n=n.filter((e=>-1!==e)),{permutationIndices:n,expandDims:r}}function Ty(e,t,n){const r=new Array(e);for(let s=0;s<n.length;++s){const e=n[s].shape;for(let n=0;n<t[s].length;++n)void 0===r[t[s][n]]?r[t[s][n]]=e[n]:yr(r[t[s][n]]===e[n],(()=>`Expected dimension ${r[t[s][n]]} at axis ${n} of input shaped ${JSON.stringify(e)}, but got dimension ${e[n]}`))}}function Ay(e,t){const n=e,r=[];let s=0;0===e.length&&n.push(-1),s=e.length+1;for(let i=0;i<s;++i)r.push([]);const a=[];for(let i=0;i<n.length;++i){const e=$y(t,n[i]);for(const t of e)-1===a.indexOf(t)&&(r[i].push(t),a.push(t))}return{path:n,steps:r}}function Ey(e){return e.every(((e,t)=>e===t))}function $y(e,t){const n=[];for(let r=0;r<e.length;++r)0!==e[r].length&&-1===e[r].indexOf(t)&&-1!==t||n.push(r);return n}function Ry(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=[];if("number"===typeof t)yr(e.shape[n]%t===0,(()=>"Number of splits must evenly divide the axis.")),r=new Array(t).fill(e.shape[n]/t);else{const s=t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0);yr(s<=1,(()=>"There should be only one negative value in split array."));const a=t.indexOf(-1);if(-1!==a){const r=t.reduce(((e,t)=>t>0?e+t:e));t[a]=e.shape[n]-r}yr(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),r=t}return r}function Dy(e){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${e}`}function Oy(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function _y(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function Fy(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function My(e,t){return`size ${e} must be non-negative, not ${t}`}function Ly(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function Py(e,t){return`Input to reshape is a SparseTensor with ${xr(e)}\n  dense values, but the requested shape requires a multiple of ${xr(t)}. inputShape=${e} outputShape= ${t}`}function zy(e,t){return`Input to reshape is a tensor with ${xr(e)} dense values, but the requested shape has ${xr(t)}. inputShape=${e} outputShape=${t}`}function By(){return"segment ids must be >= 0"}function Vy(){return"segment ids are not increasing"}function Wy(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function Uy(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}function jy(e,t){let n,r=!1;for(e<=Qg?(n=e,r=!0):n=Lr(e,Math.floor(Math.sqrt(e)));!r;)n>t||n===e?r=!0:n=Lr(e,n+1);return n}function Gy(e,t,n){const r=[],s=e.length;for(let a=0;a<s;a++)a!==t?r.push(e[a]):r.push(n);return r}function Hy(e,t,n,r){const s=t.shape.length,a=e.shape.length;if(0!==r&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>a)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${a}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let h=0;h<r;++h)if(e.shape[h]!==t.shape[h])throw new Error(`x.shape[${h}]: ${e.shape[h]} should be equal to indices.shape[${h}]: ${t.shape[h]}.`);const i=e.shape[n],o=[];let l=1,u=1,c=1;for(let h=0;h<r;++h)o.push(e.shape[h]),l*=e.shape[h];for(let h=r;h<n;h++)o.push(e.shape[h]),u*=e.shape[h];for(let h=r;h<s;h++)o.push(t.shape[h]);for(let h=n+1;h<a;h++)o.push(e.shape[h]),c*=e.shape[h];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:i,outputShape:o}}function qy(e){try{return e.map((e=>Uo(e)))}catch($9){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${$9}`)}}function Ky(e){return e.map((e=>Wo(e)))}!function(){for(const e of Dc)mc(e)}();const Xy={kernelName:ns,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ac(e,Xf(Ju(n,"float32"),-1))}}},Qy={kernelName:rs,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=oc(Ju(n,"float32")),r=ic(wc(cc(1),t));return xp(sc(e,r))}}}},Yy={kernelName:ss,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=ic(wc(oc(Ju(n,"float32")),1));return sc(e,t)}}}},Zy={kernelName:as,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Cc(n.shape,r.shape);return{a:()=>{let t=e;const r=Ic(n.shape,s);return r.length>0&&(t=Qd(t,r)),Hh(t,n.shape)},b:()=>{let t=e;const n=Ic(r.shape,s);return n.length>0&&(t=Qd(t,n)),Hh(t,r.shape)}}}},Jy={kernelName:is,saveAllInputs:!0,gradFunc:(e,t)=>{const n={};return t.forEach(((t,r)=>{n[r]=()=>e.clone()})),n}},eb={kernelName:us,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>lc(n)}}},tb={kernelName:cs,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>lc(n)}}},nb={kernelName:hs,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>sc(e,ic(wc(cc(1),oc(Ju(n,"float32")))))}}},rb={kernelName:ds,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=ic(nc(cc(1),oc(Ju(n,"float32"))));return sc(e,t)}}}},sb={kernelName:ms,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Cc(n.shape,r.shape);return{a:()=>{const t=nc(oc(n),oc(r));let a=ac(e,sc(r,t));const i=Ic(n.shape,s);return i.length>0&&(a=Qd(a,i)),Hh(a,n.shape)},b:()=>{const t=nc(oc(n),oc(r));let a=xp(ac(e,sc(n,t)));const i=Ic(r.shape,s);return i.length>0&&(a=Qd(a,i)),Hh(a,r.shape)}}}},ab={kernelName:ps,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>sc(e,nc(oc(Ju(n,"float32")),1))}}},ib={kernelName:fs,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>sc(e,wc(cc(1),oc(Ju(n,"float32"))))}}};const ob=Ll({avgPool3dGrad_:function(e,t,n,r,s,a){const i=_l(e,"dy","avgPool3dGrad"),o=_l(t,"input","avgPool3dGrad");let l=i,u=o,c=!1;4===o.rank&&(c=!0,l=Hh(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),u=Hh(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),yr(5===l.rank,(()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`)),yr(5===u.rank,(()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`)),Gh("avgPool3dGrad",s,a);const h={dy:l,input:u},d={filterSize:n,strides:r,pad:s,dimRoundingMode:a},p=Il.runKernel(vs,h,d);return c?Hh(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),lb={kernelName:bs,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:s,strides:a,pad:i,dimRoundingMode:o}=n;return{x:()=>ob(e,r,s,a,i,o)}}};const ub=Ll({avgPoolGrad_:function(e,t,n,r,s){const a=_l(e,"dy","avgPoolGrad"),i=_l(t,"input","avgPoolGrad");yr(i.rank===a.rank,(()=>`Rank of input (${i.rank}) does not match rank of dy (${a.rank})`));let o=i,l=a,u=!1;3===i.rank&&(u=!0,o=Hh(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=Hh(a,[1,a.shape[0],a.shape[1],a.shape[2]])),yr(4===l.rank,(()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`)),yr(4===o.rank,(()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`));const c={dy:l,input:o},h={filterSize:n,strides:r,pad:s},d=Il.runKernel(ys,c,h);return u?Hh(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),cb={kernelName:gs,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:s,strides:a,pad:i}=n;return{x:()=>ub(e,r,s,a,i)}}},hb={kernelName:xs,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{const[r,s]=t,{transposeA:a,transposeB:i}=n;return a||i?!a&&i?{a:()=>Qh(e,s,!1,!1),b:()=>Qh(e,r,!0,!1)}:a&&!i?{a:()=>Qh(s,e,!1,!0),b:()=>Qh(r,e,!1,!1)}:{a:()=>Qh(s,e,!0,!0),b:()=>Qh(e,r,!0,!0)}:{a:()=>Qh(e,s,!1,!0),b:()=>Qh(r,e,!0,!1)}}},db={kernelName:ws,gradFunc:(e,t,n)=>{const{blockShape:r,crops:s}=n;return{x:()=>ef(e,r,s)}}},pb={kernelName:"BroadcastTo",gradFunc:(e,t,n)=>{const r=n,s=r.inputShape,a=r.shape,i=Array.from(a);for(let l=s.length-1;l>=0;l--)if(s[l]===a[l])i[l]=1;else if(1!==s[l])throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${a}].`);const o=[];for(let l=0;l<i.length;l++)i[l]>1&&o.push(l);return{x:()=>Qd(e,o,!0)}}},fb={kernelName:Is,gradFunc:e=>({x:()=>e.clone()})},mb={kernelName:Cs,gradFunc:e=>({x:()=>lc(e)})},gb={kernelName:Ts,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{clipValueMin:s,clipValueMax:a}=n;return{x:()=>Od(Ip(lp(r,s),mp(r,a)),e,lc(e))}}},yb={kernelName:Es,inputsToSave:["x"],gradFunc:Xy.gradFunc},bb={kernelName:$s,saveAllInputs:!0,gradFunc:(e,t,n)=>{const r=t.map((e=>e.shape)),{axis:s}=n,a=Tr(s,t[0].shape)[0],i=r.map((e=>e[a]));return jf(e,i,a).map((e=>()=>e))}},vb={kernelName:Rs,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,{dilations:a,strides:i,pad:o,dataFormat:l}=n;return yr(Vh(a),(()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`)),{x:()=>bd(r.shape,e,s,i,o,l),filter:()=>Cm(r,e,s.shape,i,o,l)}}},xb={kernelName:Os,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,{strides:a,pad:i,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>gd(e,s,a,i,o,1,l),filter:()=>Cm(e,r,s.shape,a,i,o,l)}}};const wb=Ll({conv3DBackpropFilter_:function(e,t,n,r,s){let a=e;4===e.rank&&(a=Hh(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;4===i.rank&&(i=Hh(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),yr(5===a.rank,(()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${a.shape}.`)),yr(5===i.rank,(()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`)),yr(5===n.length,(()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`)),yr(a.shape[4]===n[3],(()=>`Error in conv3dDerFilter: depth of input ${a.shape[4]}) must match input depth in filter (${n[3]}.`)),yr(i.shape[4]===n[4],(()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`));const o={x:a,dy:i},l={strides:r,pad:s,filterShape:n};return Il.runKernel(Fs,o,l)}}),kb={kernelName:_s,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:s,pad:a}=n;yr(Vh(r),(()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`));const[i,o]=t;return{x:()=>wd(i.shape,e,o,s,a),filter:()=>wb(i,e,o.shape,s,a)}}},Sb={kernelName:Ls,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ac(xp(_f(Ju(n,"float32"))),e)}}},Nb={kernelName:Ps,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ac(Ff(Ju(n,"float32")),e)}}},Ib={kernelName:Bs,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s,exclusive:a,reverse:i}=n;return{x:()=>{const t=Gd([s],r.rank);let n=Cd(e,s,a,!i);return null!=t&&(n=ym(n,t)),n}}}},Cb={kernelName:js,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:s,pad:a,dimRoundingMode:i}=n,o=null==r?[1,1]:r;yr(Vh(o),(()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`));const[l,u]=t;return yr(4===l.rank,(()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`)),yr(4===u.rank,(()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`)),yr(l.shape[3]===u.shape[2],(()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`)),yr(Wh(s,o),(()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${o}'.`)),Gh("depthwiseConv2d",a,i),{x:()=>Om(l.shape,e,u,s,a,o,i),filter:()=>Dm(l,e,u.shape,s,a,o,i)}}},Tb={kernelName:Ks,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,a={x:r,filter:s,dy:e},i={x:r,filter:s,dy:e};return{x:()=>Il.runKernel(Xs,a,n),filter:()=>Il.runKernel(Qs,i,n)}}},Ab={kernelName:ea,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t,r={dy:e,y:n};return{x:()=>Il.runKernel(ta,r)}}},Eb={kernelName:na,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=ac(ep(xp(oc(n))),2/Math.sqrt(Math.PI));return{x:()=>ac(e,r)}}},$b={kernelName:sa,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ac(e,n)}}},Rb={kernelName:aa,inputsToSave:["input"],gradFunc:(e,t)=>{const[n]=t;return{input:()=>Hh(e,n.shape)}}},Db={kernelName:ia,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ac(e,ep(n))}}},Ob={kernelName:ca,gradFunc:e=>({x:()=>lc(e)})},_b={kernelName:ha,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Cc(n.shape,r.shape);return{a:()=>{const t=sc(e,Ju(r,"float32")),a=Ic(n.shape,s);return a.length>0?Hh(Qd(t,a),n.shape):t},b:()=>{let t=ac(e,Ju(n,"float32"));const a=Ic(r.shape,s);a.length>0&&(t=Hh(Qd(t,a),r.shape));const i=oc(r);return xp(sc(t,Ju(i,"float32")))}}}},Fb={kernelName:da,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{const{varianceEpsilon:r}=n,[s,a,i,o]=t,l=null==o?cc(1):o,u=Ic(a.shape,s.shape),c=[];if(1===a.rank){for(let e=0;e<s.shape.length-1;++e)c.push(s.shape[e]);c.push(1)}const h=wc(s,a),d=ac(e,l),p=Ef(nc(i,cc(r))),f=ac(ac(ac(p,p),p),cc(-.5));return{x:()=>1===a.rank?Hh(ac(ac(e,rp(Hh(p,[1,1,1,a.shape[0]]),c)),l),s.shape):Hh(ac(ac(e,p),l),s.shape),mean:()=>{let e=ac(ac(p,cc(-1)),d);return 1===a.rank&&(e=Qd(e,u)),Hh(e,a.shape)},variance:()=>{let e=ac(ac(f,h),d);return 1===a.rank&&(e=Qd(e,u)),Hh(e,a.shape)},scale:()=>{const t=ac(h,p);let n=ac(e,t);return 1===a.rank&&(n=Qd(n,u)),Hh(n,a.shape)},offset:()=>{let t=e;return 1===a.rank&&(t=Qd(t,u)),Hh(t,a.shape)}}}},Mb={kernelName:pa,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{const[r,s]=t,{axis:a,batchDims:i}=n,o=Tr(a,r.shape)[0],l=(e,t,n)=>()=>{const r=e.shape,s=t.size,i=r.slice(0,o),l=i.length,u=r.slice(a,r.length).slice(1),c=u.length,h=Lb(0,l),d=Lb(l+1,l+1+c),p=Pb([i,[s],u]),f=Hh(n,p),m=Hh(t,[s]),g=Pb([[l],h,d]),y=ym(f,g);let b=cm(y,m,e.shape[o]);const v=Hd(g);return b=ym(b,v),b};if(1===i){const t=r.shape[0],n=r.split(t,0),a=()=>{const t=Kf(n.map(((t,n)=>l(t,s.slice(n,1),e.slice(n,1))())));return t.reshape(r.shape)};return{x:a,indices:()=>s}}return{x:l(r,s,e),indices:()=>s}}};function Lb(e,t){const n=[];for(let r=e;r<t;++r)n.push(r);return n}function Pb(e){const t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}const zb={kernelName:ga,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>lc(n),b:()=>lc(r)}}},Bb={kernelName:ya,gradFunc:e=>({x:()=>Ju(e,"float32")})},Vb={kernelName:xa,gradFunc:e=>({x:()=>lc(e)})},Wb={kernelName:wa,gradFunc:e=>({x:()=>lc(e)})},Ub={kernelName:ka,gradFunc:e=>({x:()=>lc(e)})},jb={kernelName:Sa,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{alpha:s}=n,a=op(r,0);return{x:()=>Od(a,e,ac(e,s))}}},Gb={kernelName:Aa,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>sc(e,nc(n,1))}}},Hb={kernelName:Ta,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>sc(e,Ju(n,"float32"))}}},qb={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n;return{logits:()=>{const t=ep(r);return wc(e,ac(Qd(e,s,!0),t))}}}};const Kb=Ll({localResponseNormalizationBackprop_:function(e,t,n){const r={x:e,y:t,dy:n},s={depthRadius:arguments.length>3&&void 0!==arguments[3]?arguments[3]:5,bias:arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,alpha:arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,beta:arguments.length>6&&void 0!==arguments[6]?arguments[6]:.5};return Il.runKernel(Oa,r,s)}}),Xb={kernelName:Da,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{depthRadius:a,bias:i,alpha:o,beta:l}=n;return{x:()=>Kb(r,s,e,a,i,o,l)}}};function Qb(e,t,n,r){return t.rank<n.rank&&(t=Hh(t,Ud(t.shape,r))),e.rank<n.rank&&(e=Hh(e,Ud(e.shape,r))),{x:()=>ac(e,Ju(Dd(n,t),e.dtype))}}const Yb={kernelName:_a,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{reductionIndices:s}=r,a=t[0],i=Qb(e,t[1],a,Tr(s,a.shape));return{x:()=>i.x()}}},Zb={kernelName:Fa,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>ac(e,Ju(lp(n,r),"float32")),b:()=>ac(e,Ju(fp(n,r),"float32"))}}};const Jb=Ll({maxPool3dGrad_:function(e,t,n,r,s,a,i){const o=_l(e,"dy","maxPool3dGrad"),l=_l(t,"input","maxPool3dGrad"),u=_l(n,"output","maxPool3dGrad");let c=o,h=l,d=u,p=!1;4===l.rank&&(p=!0,c=Hh(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),h=Hh(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=Hh(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),yr(5===c.rank,(()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`)),yr(5===h.rank,(()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`)),yr(5===d.rank,(()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`)),Gh("maxPool3dGrad",a,i);const f={dy:c,input:h,output:d},m={filterSize:r,strides:s,pad:a,dimRoundingMode:i},g=Il.runKernel(za,f,m);return p?Hh(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}}),ev={kernelName:Pa,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=n;return{x:()=>Jb(e,r,s,a,i,o,l)}}};const tv=Ll({maxPoolGrad_:function(e,t,n,r,s,a,i){const o=_l(e,"dy","maxPoolGrad"),l=_l(t,"input","maxPoolGrad"),u=_l(n,"output","maxPoolGrad");yr(l.rank===o.rank,(()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`)),yr(4===o.rank,(()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`)),yr(4===l.rank,(()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`)),Gh("maxPoolGrad",a,i);const c={dy:o,input:l,output:u},h={filterSize:r,strides:s,pad:a,dimRoundingMode:i};return Il.runKernel(La,c,h)}}),nv={kernelName:Ma,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{filterSize:a,strides:i,pad:o}=n;return{x:()=>tv(e,r,s,a,i,o)}}},rv={kernelName:Va,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n,a=Tr(s,r.shape),i=xr(Wd(r.shape,a)[1]);return{x:()=>{const t=r.shape.slice();a.forEach((e=>{t[e]=1}));const n=Hh(e,t);return sc(ac(n,Lp(r.shape,"float32")),i)}}}},sv={kernelName:Wa,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{axis:s}=r,[a,i]=t,o=Qb(e,i,a,Tr(s,a.shape));return{x:()=>o.x()}}},av={kernelName:Ua,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>ac(e,Ju(mp(n,r),"float32")),b:()=>ac(e,Ju(op(n,r),"float32"))}}},iv={kernelName:ja,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:s}=n,a=s.map((e=>e[0]));return{x:()=>Zh(e,a,r.shape)}}},ov={kernelName:Ga,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Cc(n.shape,r.shape);return{a:()=>{const t=Ic(n.shape,s);return t.length>0?Hh(Qd(e,t),n.shape):e},b:()=>{const t=ac(e,xp(ap(sc(n,r)))),a=Ic(r.shape,s);return a.length>0?Hh(Qd(t,a),r.shape):t}}}},lv={kernelName:qa,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Cc(n.shape,r.shape);return{a:()=>{const t=ac(e,Ju(r,"float32")),a=Ic(n.shape,s);return a.length>0?Hh(Qd(t,a),n.shape):t},b:()=>{const t=ac(e,Ju(n,"float32")),a=Ic(r.shape,s);return a.length>0?Hh(Qd(t,a),r.shape):t}}}},uv={kernelName:ti,saveAllInputs:!0,gradFunc:(e,t,n)=>{const{axis:r}=n;return hm(e,r).map((e=>()=>e))}},cv={kernelName:ni,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:s}=n,a=s.map((e=>e[0]));return{x:()=>Zh(e,a,r.shape)}}},hv={kernelName:ri,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{const[n,r,s]=t,a=n,i=r,o=Cc(a.shape,i.shape);return{a:()=>{const t=Ju(i,"float32");let n=ac(e,ac(t,xc(a,wc(t,cc(1)))));const r=Ic(a.shape,o);return r.length>0&&(n=Qd(n,r)),Hh(n,a.shape)},b:()=>{const t=op(a,0),n=Od(t,bp(a),lc(a));let r=ac(e,ac(s,n));const l=Ic(i.shape,o);return l.length>0&&(r=Qd(r,l)),Hh(r,i.shape)}}}},dv={kernelName:si,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{const[n,r]=t,s=op(n,0);return{x:()=>Od(s,e,ac(e,r)),alpha:()=>{let t=Od(s,lc(e),ac(e,n));const a=Ic(r.shape,e.shape);return a.length>0&&(t=Qd(t,a)),Hh(t,r.shape)}}}};function pv(e,t,n){const r=e.shape.length,s=r-n.length,a=Gd(n,r);let i=e;null!=a&&(i=ym(e,a));const o=i.shape.slice(),l=o.splice(r-n.length,n.length).reduce(((e,t)=>e*t),1);o.push(l);let u=function(e,t,n){const r=e.shape.slice();r[n]=1;const s=Hh(t,r),a=Id(e,n,!0,!1),i=Id(e,n,!0,!0),o=ac(a,i);return ac(s,o)}(i.reshape(o),t,s);if(u=u.reshape(i.shape),null!=a){const e=Hd(a);u=ym(u,e)}return u}const fv={kernelName:ai,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n;let a=[];return a=void 0===s||null===s?r.shape.map(((e,t)=>t)):"number"===typeof s?[s]:s,{x:()=>pv(r,e,a)}}},mv={kernelName:Zs,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Cc(n.shape,r.shape);return{a:()=>{const t=sc(e,Ju(r,"float32")),a=Ic(n.shape,s);return a.length>0?Hh(Qd(t,a),n.shape):t},b:()=>{let t=ac(e,Ju(n,"float32"));const a=Ic(r.shape,s);a.length>0&&(t=Hh(Qd(t,a),r.shape));const i=oc(r);return xp(sc(t,Ju(i,"float32")))}}}},gv={kernelName:Ci,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=op(n,cc(0)),r=cc(ay),s=cc(iy),a=ac(e,s),i=ac(ac(e,r),ep(Ju(n,"float32")));return Od(t,a,i)}}}},yv={kernelName:Ti,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{begin:s,size:a}=n,i=r.shape,[o,l]=gh(r,s,a),u=[];for(let c=0;c<e.rank;c++)u.push([o[c],i[c]-o[c]-l[c]]);return{x:()=>Xp(e,u)}}},bv={kernelName:Fi,gradFunc:(e,t,n)=>{const{blockShape:r,paddings:s}=n;return{x:()=>td(e,r,s)}}},vv={kernelName:Mi,gradFunc:(e,t,n)=>{const{axis:r}=n;return{x:()=>Xh(e,r)}}},xv={kernelName:Ui,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=cc(2);return{a:()=>ac(e,ac(s,wc(n,r))),b:()=>ac(e,ac(s,wc(r,n)))}}},wv={kernelName:Qi,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Cc(n.shape,r.shape);return{a:()=>{let t=e;const r=Ic(n.shape,s);return r.length>0&&(t=Qd(t,r)),Hh(t,n.shape)},b:()=>{let t=e;const n=Ic(r.shape,s);return n.length>0&&(t=Qd(t,n)),Hh(xp(t),r.shape)}}}},kv={kernelName:_i,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,s=r.shape.slice(),{axis:a}=n;Tr(a,r.shape).forEach((e=>{s[e]=1}));const i=Hh(e,s),o=ac(i,Lp(r.shape,"float32"));return{x:()=>o}}},Sv={kernelName:Ji,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{reps:s}=n;return{x:()=>{let t=lc(r);if(1===r.rank)for(let n=0;n<s[0];++n)t=nc(t,Zh(e,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<s[0];++n)for(let a=0;a<s[1];++a)t=nc(t,Zh(e,[n*r.shape[0],a*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<s[0];++n)for(let a=0;a<s[1];++a)for(let i=0;i<s[2];++i)t=nc(t,Zh(e,[n*r.shape[0],a*r.shape[1],i*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let n=0;n<s[0];++n)for(let a=0;a<s[1];++a)for(let i=0;i<s[2];++i)for(let o=0;o<s[3];++o)t=nc(t,Zh(e,[n*r.shape[0],a*r.shape[1],i*r.shape[2],o*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return t}}}},Nv={kernelName:so,gradFunc:(e,t,n)=>{const r=n,{axis:s}=r;return{value:()=>Kf(e,s)}}},Iv={kernelName:ao,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>function(e,t){const n=Tc(t,lc(t)),r=ip(e,n);let s=lp(t,cc(0,"int32"));const a=r.rank-s.rank;for(let o=0;o<a;++o)s=tp(s,o+1);s=Ip(s,Lp(r.shape,"bool"));const i=lc(r);return Od(s,r,i)}(e,n)}}};const Cv=[Xy,Qy,Yy,Zy,Jy,eb,tb,nb,rb,sb,ab,ib,lb,cb,hb,db,pb,fb,mb,gb,yb,bb,xb,vb,kb,Sb,Nb,Ib,Cb,Tb,mv,Ab,Eb,$b,Rb,Db,_b,Ob,Fb,Mb,zb,Bb,Vb,Wb,Ub,jb,Gb,Hb,qb,Xb,Yb,Yb,Zb,ev,nv,rv,sv,av,iv,ov,lv,{kernelName:Ka,gradFunc:e=>({x:()=>xp(e)})},{kernelName:ei,inputsToSave:["indices"],gradFunc:(e,t)=>{const n=t[0];return{indices:()=>Mp(n.shape,"float32")}}},{kernelName:Ja,gradFunc:e=>({x:()=>lc(e)})},uv,cv,cv,hv,dv,fv,{kernelName:hi,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>sc(e,xp(oc(n)))}}},{kernelName:bi,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=ac(mp(n,6),Xf(n));return{x:()=>ac(e,Ju(r,"float32"))}}},{kernelName:di,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ac(e,Ju(Xf(n),"float32"))}}},{kernelName:pi,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Hh(e,n.shape)}}},{kernelName:gi,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,s={dy:e,images:r};return{images:()=>Il.runKernel(yi,s,n)}}},{kernelName:fi,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,s={dy:e,images:r};return{images:()=>Il.runKernel(mi,s,n)}}},{kernelName:vi,gradFunc:(e,t,n)=>{const{dims:r}=n,s=Tr(r,e.shape);return{x:()=>Sf(e,s)}}},{kernelName:xi,gradFunc:e=>({x:()=>lc(e)})},{kernelName:wi,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>xp(sc(e,ac(xc(n,1.5),2)))}}},{kernelName:Ii,inputsToSave:["condition"],gradFunc:(e,t)=>{const[n]=t;return{condition:()=>Ju(lc(n),"float32"),t:()=>ac(e,Ju(n,e.dtype)),e:()=>ac(e,Ju(Cp(n),e.dtype))}}},gv,{kernelName:Ri,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ac(e,ac(n,wc(cc(1),n)))}}},{kernelName:$i,gradFunc:e=>({x:()=>lc(e)})},{kernelName:Ai,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ac(Sd(Ju(n,"float32")),e)}}},{kernelName:Ei,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ac(Nd(Ju(n,"float32")),e)}}},yv,{kernelName:Li,outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{dim:s}=n,a=ac(e,r);return{logits:()=>wc(a,ac(Qd(a,[s],true),r))}}},{kernelName:Di,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ac(e,Yh(n))}}},bv,bv,vv,vv,{kernelName:Oi,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>sc(e,ac(ic(Ju(n,"float32")),2))}}},xv,{kernelName:ji,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ac(e,ac(Ju(n,"float32"),2))}}},{kernelName:oo,gradFunc:e=>({x:()=>lc(e)})},wv,kv,{kernelName:Yi,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>sc(e,oc(Sd(n)))}}},{kernelName:Zi,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ac(wc(cc(1),oc(n)),e)}}},Sv,{kernelName:no,gradFunc:(e,t,n)=>{const r=n,{perm:s}=r,a=Hd(s);return{x:()=>ym(e,a)}}},Nv,Iv,{kernelName:io,gradFunc:e=>({x:()=>lc(e)})}];for(const n of Cv)ko(n);al().prototype.abs=function(){return this.throwIfDisposed(),Sc(this)},al().prototype.acos=function(){return this.throwIfDisposed(),vh(this)},al().prototype.acosh=function(){return this.throwIfDisposed(),xh(this)},al().prototype.add=function(e){return this.throwIfDisposed(),nc(this,e)},al().prototype.all=function(e,t){return this.throwIfDisposed(),kh(this,e,t)},al().prototype.any=function(e,t){return this.throwIfDisposed(),Sh(this,e,t)},al().prototype.argMax=function(e){return this.throwIfDisposed(),Nh(this,e)},al().prototype.argMin=function(e){return this.throwIfDisposed(),Ih(this,e)},al().prototype.asScalar=function(){return this.throwIfDisposed(),yr(1===this.size,(()=>"The array must have only 1 element.")),Hh(this,[])},al().prototype.asType=function(e){return this.throwIfDisposed(),Ju(this,e)},al().prototype.as1D=function(){return this.throwIfDisposed(),Hh(this,[this.size])},al().prototype.as2D=function(e,t){return this.throwIfDisposed(),Hh(this,[e,t])},al().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),Hh(this,[e,t,n])},al().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),Hh(this,[e,t,n,r])},al().prototype.as5D=function(e,t,n,r,s){return this.throwIfDisposed(),Hh(this,[e,t,n,r,s])},al().prototype.asin=function(){return this.throwIfDisposed(),Ch(this)},al().prototype.asinh=function(){return this.throwIfDisposed(),Th(this)},al().prototype.atan=function(){return this.throwIfDisposed(),Ah(this)},al().prototype.atan2=function(e){return this.throwIfDisposed(),Eh(this,e)},al().prototype.atanh=function(){return this.throwIfDisposed(),$h(this)},al().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),qh(this,e,t,n,r)},al().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),td(this,e,t)},al().prototype.batchNorm=function(e,t,n,r,s){return this.throwIfDisposed(),nd(this,e,t,n,r,s)},al().prototype.broadcastTo=function(e){return this.throwIfDisposed(),ud(this,e)},al().prototype.cast=function(e){return this.throwIfDisposed(),Ju(this,e)},al().prototype.ceil=function(){return this.throwIfDisposed(),cd(this)},al().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),hd(this,e,t)},al().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof sl&&(e=[e]),Xh([this,...e],t)},al().prototype.conv1d=function(e,t,n,r,s,a){return this.throwIfDisposed(),yd(this,e,t,n,r,s,a)},al().prototype.conv2dTranspose=function(e,t,n,r,s){return this.throwIfDisposed(),vd(this,e,t,n,r,s)},al().prototype.conv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),gd(this,e,t,n,r,s,a)},al().prototype.cos=function(){return this.throwIfDisposed(),Sd(this)},al().prototype.cosh=function(){return this.throwIfDisposed(),Nd(this)},al().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),Id(this,e,t,n)},al().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),Cd(this,e,t,n)},al().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),Ad(this,e,t)},al().prototype.depthwiseConv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),Ed(this,e,t,n,r,s,a)},al().prototype.dilation2d=function(e,t,n,r,s){return this.throwIfDisposed(),Rd(this,e,t,n,r,s)},al().prototype.divNoNan=function(e){return this.throwIfDisposed(),_d(this,e)},al().prototype.div=function(e){return this.throwIfDisposed(),sc(this,e)},al().prototype.dot=function(e){return this.throwIfDisposed(),Fd(this,e)},al().prototype.elu=function(){return this.throwIfDisposed(),Ld(this)},al().prototype.equal=function(e){return this.throwIfDisposed(),Dd(this,e)},al().prototype.erf=function(){return this.throwIfDisposed(),zd(this)},al().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),Jd(this,e,t)},al().prototype.exp=function(){return this.throwIfDisposed(),ep(this)},al().prototype.expandDims=function(e){return this.throwIfDisposed(),tp(this,e)},al().prototype.expm1=function(){return this.throwIfDisposed(),np(this)},al().prototype.fft=function(){return this.throwIfDisposed(),Vf(this)},al().prototype.flatten=function(){return this.throwIfDisposed(),Hh(this,[this.size])},al().prototype.floor=function(){return this.throwIfDisposed(),ap(this)},al().prototype.floorDiv=function(e){return this.throwIfDisposed(),rc(this,e)},al().prototype.gather=function(e,t,n){return this.throwIfDisposed(),ip(this,e,t,n)},al().prototype.greaterEqual=function(e){return this.throwIfDisposed(),lp(this,e)},al().prototype.greater=function(e){return this.throwIfDisposed(),op(this,e)},al().prototype.ifft=function(){return this.throwIfDisposed(),Wf(this)},al().prototype.irfft=function(){return this.throwIfDisposed(),Uf(this)},al().prototype.isFinite=function(){return this.throwIfDisposed(),cp(this)},al().prototype.isInf=function(){return this.throwIfDisposed(),hp(this)},al().prototype.isNaN=function(){return this.throwIfDisposed(),dp(this)},al().prototype.leakyRelu=function(e){return this.throwIfDisposed(),pp(this,e)},al().prototype.lessEqual=function(e){return this.throwIfDisposed(),mp(this,e)},al().prototype.less=function(e){return this.throwIfDisposed(),fp(this,e)},al().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),yp(this,e,t,n,r)},al().prototype.logSigmoid=function(){return this.throwIfDisposed(),kp(this)},al().prototype.logSoftmax=function(e){return this.throwIfDisposed(),Sp(this,e)},al().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),Np(this,e,t)},al().prototype.log=function(){return this.throwIfDisposed(),bp(this)},al().prototype.log1p=function(){return this.throwIfDisposed(),vp(this)},al().prototype.logicalAnd=function(e){return this.throwIfDisposed(),Ip(this,e)},al().prototype.logicalNot=function(){return this.throwIfDisposed(),Cp(this)},al().prototype.logicalOr=function(e){return this.throwIfDisposed(),Tp(this,e)},al().prototype.logicalXor=function(e){return this.throwIfDisposed(),Ap(this,e)},al().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),Qh(this,e,t,n)},al().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),Dp(this,e,t,n,r)},al().prototype.max=function(e,t){return this.throwIfDisposed(),Kd(this,e,t)},al().prototype.maximum=function(e){return this.throwIfDisposed(),Tc(this,e)},al().prototype.mean=function(e,t){return this.throwIfDisposed(),Fp(this,e,t)},al().prototype.min=function(e,t){return this.throwIfDisposed(),Xd(this,e,t)},al().prototype.minimum=function(e){return this.throwIfDisposed(),zp(this,e)},al().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),Bp(this,e,t)},al().prototype.mod=function(e){return this.throwIfDisposed(),Vp(this,e)},al().prototype.mul=function(e){return this.throwIfDisposed(),ac(this,e)},al().prototype.neg=function(){return this.throwIfDisposed(),xp(this)},al().prototype.norm=function(e,t,n){return this.throwIfDisposed(),Zd(this,e,t,n)},al().prototype.notEqual=function(e){return this.throwIfDisposed(),Gp(this,e)},al().prototype.oneHot=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return this.throwIfDisposed(),Hp(this,e,t,n)},al().prototype.onesLike=function(){return this.throwIfDisposed(),qp(this)},al().prototype.pad=function(e,t){return this.throwIfDisposed(),Xp(this,e,t)},al().prototype.pool=function(e,t,n,r,s,a){return this.throwIfDisposed(),tf(this,e,t,n,r,s,a)},al().prototype.pow=function(e){return this.throwIfDisposed(),xc(this,e)},al().prototype.prelu=function(e){return this.throwIfDisposed(),nf(this,e)},al().prototype.prod=function(e,t){return this.throwIfDisposed(),rf(this,e,t)},al().prototype.reciprocal=function(){return this.throwIfDisposed(),xf(this)},al().prototype.relu=function(){return this.throwIfDisposed(),wf(this)},al().prototype.relu6=function(){return this.throwIfDisposed(),kf(this)},al().prototype.reshapeAs=function(e){return this.throwIfDisposed(),Hh(this,e.shape)},al().prototype.reshape=function(e){return this.throwIfDisposed(),Hh(this,e)},al().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),og(this,e,t,n)},al().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),lg(this,e,t,n)},al().prototype.reverse=function(e){return this.throwIfDisposed(),Sf(this,e)},al().prototype.rfft=function(){return this.throwIfDisposed(),Gf(this)},al().prototype.round=function(){return this.throwIfDisposed(),Af(this)},al().prototype.rsqrt=function(){return this.throwIfDisposed(),Ef(this)},al().prototype.selu=function(){return this.throwIfDisposed(),$f(this)},al().prototype.separableConv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),Rf(this,e,t,n,r,s,a)},al().prototype.sigmoid=function(){return this.throwIfDisposed(),Yh(this)},al().prototype.sign=function(){return this.throwIfDisposed(),Of(this)},al().prototype.sin=function(){return this.throwIfDisposed(),_f(this)},al().prototype.sinh=function(){return this.throwIfDisposed(),Ff(this)},al().prototype.slice=function(e,t){return this.throwIfDisposed(),Zh(this,e,t)},al().prototype.softmax=function(e){return this.throwIfDisposed(),Bf(this,e)},al().prototype.softplus=function(){return this.throwIfDisposed(),wp(this)},al().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),ef(this,e,t)},al().prototype.split=function(e,t){return this.throwIfDisposed(),jf(this,e,t)},al().prototype.sqrt=function(){return this.throwIfDisposed(),ic(this)},al().prototype.square=function(){return this.throwIfDisposed(),oc(this)},al().prototype.squaredDifference=function(e){return this.throwIfDisposed(),Hf(this,e)},al().prototype.squeeze=function(e){return this.throwIfDisposed(),qf(this,e)},al().prototype.stack=function(e,t){this.throwIfDisposed();const n=e instanceof sl?[this,e]:[this,...e];return Kf(n,t)},al().prototype.step=function(e){return this.throwIfDisposed(),Xf(this,e)},al().prototype.stridedSlice=function(e,t,n,r,s,a,i,o){return this.throwIfDisposed(),Qf(this,e,t,n,r,s,a,i,o)},al().prototype.sub=function(e){return this.throwIfDisposed(),wc(this,e)},al().prototype.sum=function(e,t){return this.throwIfDisposed(),Qd(this,e,t)},al().prototype.tan=function(){return this.throwIfDisposed(),Yf(this)},al().prototype.tanh=function(){return this.throwIfDisposed(),Jh(this)},al().prototype.tile=function(e){return this.throwIfDisposed(),rp(this,e)},al().prototype.toBool=function(){return this.throwIfDisposed(),Ju(this,"bool")},al().prototype.toFloat=function(){return this.throwIfDisposed(),Ju(this,"float32")},al().prototype.toInt=function(){return this.throwIfDisposed(),Ju(this,"int32")},al().prototype.topk=function(e,t){return this.throwIfDisposed(),om(this,e,t)},al().prototype.transpose=function(e){return this.throwIfDisposed(),ym(this,e)},al().prototype.unique=function(e){return this.throwIfDisposed(),um(this,e)},al().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),cm(this,e,t)},al().prototype.unstack=function(e){return this.throwIfDisposed(),hm(this,e)},al().prototype.where=function(e,t){return this.throwIfDisposed(),Od(e,this,t)},al().prototype.zerosLike=function(){return this.throwIfDisposed(),lc(this)};class Tv extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Tv.prototype)}}class Av extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Av.prototype)}}class Ev extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Ev.prototype)}}class $v extends Error{constructor(e){super(e),Object.setPrototypeOf(this,$v.prototype)}}class Rv extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Rv.prototype)}}Error;class Dv{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const e=this.cache.keys().next().value;this.cache.delete(e)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const e=this.cache.keys().next().value;this.cache.delete(e)}this.maxEntries=e}}function Ov(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}{const n=new Array(t);return n.fill(e),n}}function _v(e,t){if(!e)throw new Rv(t)}function Fv(e,t){let n=0;for(const r of e)r===t&&n++;return n}function Mv(e){return 1===e.length?e[0]:e}function Lv(e){return Array.isArray(e)?e:[e]}function Pv(e){const t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function zv(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,((e,t)=>t.toUpperCase()))}let Bv={};function Vv(e){if(null===e||void 0===e)return null;const t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function Wv(e){if(null!=e&&"object"===typeof e)if(Array.isArray(e))e.forEach((e=>Wv(e)));else{const t=Object.keys(e);for(const n of t){const t=e[n];null!=t&&"object"===typeof t&&(Array.isArray(t)||"ndarray"!==t.type||"number"!==typeof t.value?Wv(t):e[n]=t.value)}}}function Uv(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"object",s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if("string"===typeof e){const s=e;let a;if(s in n)a=n[s];else if(s in Bv)a=Bv[s];else if(a=t[s],null==a)throw new Ev(`Unknown ${r}: ${e}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}{const a=e;if(null==a.className||null==a.config)throw new Ev(`${r}: Improper config format: ${JSON.stringify(a)}.\n'className' and 'config' must set.`);const i=a.className;let o,l;if(i in n?[o,l]=n[i]:i in Bv?[o,l]=Bv.className:i in t&&([o,l]=t[i]),null==o)throw new Ev(`Unknown ${r}: ${i}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=l){const e={};for(const n of Object.keys(Bv))e[n]=Bv[n];for(const s of Object.keys(n))e[s]=n[s];a.config.customObjects=e;const t=Object.assign({},Bv);for(const s of Object.keys(n))Bv[s]=n[s];Wv(a.config);const r=l(o,a.config,n,s);return Bv=Object.assign({},t),r}{const e=Object.assign({},Bv);for(const r of Object.keys(n))Bv[r]=n[r];const t=new o(a.config);return Bv=Object.assign({},e),t}}}function jv(e,t){return-1*function(e,t){return e<t?-1:e>t?1:0}(e,t)}function Gv(e){if(null==e)return e;const t=[];for(const n of e)-1===t.indexOf(n)&&t.push(n);return t}function Hv(e){if(null==e)throw new Ev(`Invalid value in obj: ${JSON.stringify(e)}`);for(const t in e)if(e.hasOwnProperty(t))return!1;return!0}function qv(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new Ev(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function Kv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0;return _v(n>=0),_v(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every((e=>typeof e===t))}function Xv(e,t){Array.isArray(e)?(yr(e.length>0,(()=>`${t} is unexpectedly an empty array.`)),e.forEach(((e,n)=>Xv(e,`element ${n+1} of ${t}`)))):yr(Number.isInteger(e)&&e>0,(()=>`Expected ${t} to be a positive integer, but got ${Qv(e)}.`))}function Qv(e){return null===e?"null":Array.isArray(e)?"["+e.map((e=>Qv(e))).join(",")+"]":"string"===typeof e?`"${e}"`:`${e}`}function Yv(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}let Zv=0;function Jv(){return Zv++}const ex={};function tx(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return e in ex||(ex[e]=0),ex[e]+=1,e+ex[e].toString()}const nx=["channelsFirst","channelsLast"],rx=["nearest","bilinear"],sx=["valid","same","causal"],ax=["max","avg"],ix=["sum","mul","concat","ave"],ox=new Map;function lx(e){qv(nx,"DataFormat",e)}function ux(e){qv(sx,"PaddingMode",e)}function cx(e){qv(ax,"PoolMode",e)}const hx=[];function dx(e,t){hx.push(e);try{const e=t();return hx.pop(),e}catch(E9){throw hx.pop(),E9}}function px(e){if(!gx(e))throw new Error("Not a valid tensor name: '"+e+"'");return(0===hx.length?"":hx.join("/")+"/")+e}function fx(e){if(!gx(e))throw new Error("Not a valid tensor name: '"+e+"'");ox.has(e)||ox.set(e,0);const t=ox.get(e);if(ox.set(e,ox.get(e)+1),t>0){const n=`${e}_${t}`;return ox.set(n,1),n}return e}const mx=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function gx(e){return!!e.match(mx)}function yx(e,t,n){null==t&&(t=0),null==n&&(n=e.length);let r=1;for(let s=t;s<n;++s)r*=e[s];return r}function bx(e){if(0===e.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){const r=e[n];r<t&&(t=r)}return t}function vx(e){if(0===e.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){const r=e[n];r>t&&(t=r)}return t}function xx(e,t){if(t<e)throw new Ev(`end (${t}) < begin (${e}) is forbidden.`);const n=[];for(let r=e;r<t;++r)n.push(r);return n}let wx;function kx(){return null==wx&&(wx=Xl().epsilon()),wx}function Sx(e,t){return Ju(e,t)}function Nx(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),Hh(e,n)}function Ix(e,t,n){return Gl((()=>{switch(e.rank){case 1:return Mf(e,t,n);case 2:return Lf(e,[t,0],[n,e.shape[1]]);case 3:return Pf(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return zf(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return Zh(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return Zh(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new Ev(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function Cx(e,t,n){return Gl((()=>{switch(e.rank){case 1:return Mf(e,t,n);case 2:return Lf(e,[0,t],[e.shape[0],n]);case 3:return Pf(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return zf(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new Ev(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function Tx(e,t,n,r){return Gl((()=>{switch(e.rank){case 1:return Mf(e,t,n);case 2:switch(r){case 1:return Ix(e,t,n);case 2:return Cx(e,t,n);default:throw new Ev(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return Ix(e,t,n);case 2:return Pf(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return Cx(e,t,n);default:throw new Ev(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return Ix(e,t,n);case 2:return zf(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return zf(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return Cx(e,t,n);default:throw new Ev(`The axis is not within the rank of the tensor ${r}`)}default:throw new Ev(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function Ax(e){let t,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;return n<0&&(t=e[0].rank,n=0!==t?t:0),n===e[0].rank&&(n=-1),Xh(e,n)}function Ex(e,t){switch(e.rank){case 1:return dd([e,t]);case 2:return pd([e,t],0);case 3:return fd([e,t],0);case 4:return md([e,t],0);default:throw new Ev(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function $x(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new Ev(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return rp(e,t)}function Rx(e){return ff(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,arguments.length>3?arguments[3]:void 0,arguments.length>4?arguments[4]:void 0)}function Dx(e,t,n,r){if(e.rank<2||t.rank<2)throw new $v(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){if(e.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new $v(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(2===e.rank&&2===t.rank){return Fm({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?Fx(e.rank,r,"channelsLast"):null,activation:n})}{const s=e.shape.slice(),a=s.pop();e=Hh(e,[-1,a]);const i=t.shape.slice(),o=i.pop(),l=i.pop(),u=[...i,o],c=Array.from({length:t.rank},((e,n)=>0===n?t.rank-2:n<=t.rank-2?n-1:n));t=Hh(ym(t,c),[l,-1]);const h=[...s,...u];return Hh(Fm({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?Fx(e.rank,r,"channelsLast"):null,activation:n}),h)}}function Ox(e,t,n){return Gl((()=>(t=Array.isArray(t)?Zf(t,"int32"):Ju(t,"int32"),ip(e,t,n))))}function _x(e){return ac(e,e)}function Fx(e,t,n){const r=t.shape;if(1!==t.rank&&t.rank!==e)throw new Ev(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(5===e){if("channelsFirst"===n)return 1===r.length?Hh(t,[1,r[0],1,1,1]):Hh(t,[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===n)return 1===r.length?Hh(t,[1,1,1,1,r[0]]):Hh(t,[1].concat(r))}else if(4===e){if("channelsFirst"===n)return 1===r.length?Hh(t,[1,r[0],1,1]):Hh(t,[1,r[2],r[0],r[1]]);if("channelsLast"===n)return 1===r.length?Hh(t,[1,1,1,r[0]]):Hh(t,[1].concat(r))}else if(3===e){if("channelsFirst"===n)return 1===r.length?Hh(t,[1,r[0],1]):Hh(t,[1,r[1],r[0]]);if("channelsLast"===n)return 1===r.length?Hh(t,[1,1,r[0]]):Hh(t,[1].concat(r))}else if(e<3)return t;throw new Ev(`Unsupported input rank by biasAdd: ${t.rank}`)}function Mx(e,t,n){return Gl((()=>(null==n&&(n="channelsLast"),lx(n),nc(e,Fx(e.rank,t,n)))))}function Lx(e,t,n,r){return Gl((()=>km(e,t,n,r)))}function Px(e,t){return arguments.length>2&&void 0!==arguments[2]&&arguments[2]?e():t()}const zx=["fanIn","fanOut","fanAvg"],Bx=["normal","uniform","truncatedNormal"];class Vx extends pc{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class Wx extends Vx{apply(e,t){return Mp(e,t)}}Wx.className="Zeros",mc(Wx);class Ux extends Vx{apply(e,t){return Lp(e,t)}}Ux.className="Ones",mc(Ux);class jx extends Vx{constructor(e){if(super(),"object"!==typeof e)throw new Ev(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new Ev(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return Gl((()=>ac(cc(this.value),Lp(e,t))))}getConfig(){return{value:this.value}}}jx.className="Constant",mc(jx);class Gx extends Vx{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return gf(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}Gx.className="RandomUniform",mc(Gx);class Hx extends Vx{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new $v(`randomNormal does not support dType ${t}.`);return Rx(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}Hx.className="RandomNormal",mc(Hx);class qx extends Vx{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new $v(`truncatedNormal does not support dType ${t}.`);return lm(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}qx.className="TruncatedNormal",mc(qx);class Kx extends Vx{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,t){return Gl((()=>{if(2!==e.length||e[0]!==e[1])throw new Ev("Identity matrix initializer can only be used for 2D square matrices.");return ac(this.gain,sp(e[0]))}))}getConfig(){return{gain:this.gain}}}Kx.className="Identity",mc(Kx);class Xx extends Vx{constructor(e){if(super(),e.scale<0)throw new Ev(`scale must be a positive float. Got: ${e.scale}`);this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,function(e){qv(zx,"FanMode",e)}(this.mode),this.distribution=null==e.distribution?"normal":e.distribution,function(e){qv(Bx,"Distribution",e)}(this.distribution),this.seed=e.seed}apply(e,t){const n=function(e){let t,n,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"channelsLast";if(lx(r),2===e.length)t=e[0],n=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===r){const r=yx(e,2);t=e[1]*r,n=e[0]*r}else if("channelsLast"===r){const r=yx(e,0,e.length-2);t=e[e.length-2]*r,n=e[e.length-1]*r}}else{const r=yx(e);t=Math.sqrt(r),n=Math.sqrt(r)}return[t,n]}(e),r=n[0],s=n[1];let a=this.scale;if("fanIn"===this.mode?a/=Math.max(1,r):"fanOut"===this.mode?a/=Math.max(1,s):a/=Math.max(1,(r+s)/2),"normal"===this.distribution){const n=Math.sqrt(a);if("float32"!==(t=t||"float32")&&"int32"!==t)throw new $v(`${this.getClassName()} does not support dType ${t}.`);return lm(e,0,n,t,this.seed)}{const n=Math.sqrt(3*a);return gf(e,-n,n,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}Xx.className="VarianceScaling",mc(Xx);class Qx extends Xx{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Xx.className}}Qx.className="GlorotUniform",mc(Qx);class Yx extends Xx{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Xx.className}}Yx.className="GlorotNormal",mc(Yx);class Zx extends Xx{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Xx.className}}Zx.className="HeNormal",mc(Zx);class Jx extends Xx{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Xx.className}}Jx.className="HeUniform",mc(Jx);class ew extends Xx{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Xx.className}}ew.className="LeCunNormal",mc(ew);class tw extends Xx{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Xx.className}}tw.className="LeCunUniform",mc(tw);class nw extends Vx{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return Gl((()=>{if(e.length<2)throw new $v("Shape must be at least 2D.");if("int32"!==t&&"float32"!==t&&void 0!==t)throw new TypeError(`Unsupported data type ${t}.`);const n=xr(e.slice(0,-1)),r=e[e.length-1],s=n*r;s>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${s}) elements: Slowness may result.`);const a=Rx([Math.max(r,n),Math.min(r,n)],0,1,t,this.seed),i=Mg.qr(a,!1);let o=i[0];const l=i[1].flatten().stridedSlice([0],[Math.min(r,n)*Math.min(r,n)],[Math.min(r,n)+1]);return o=ac(o,l.sign()),n<r&&(o=o.transpose()),ac(cc(this.gain),o.reshape(e))}))}getConfig(){return{gain:this.gain,seed:this.seed}}}nw.className="Orthogonal",mc(nw);const rw={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function sw(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Uv(e,fc.getMap().classNameMap,t,"initializer")}function aw(e){return Vv(e)}function iw(e){if("string"===typeof e){const t=e in rw?rw[e]:e;if("GlorotNormal"===t)return new Yx;if("GlorotUniform"===t)return new Qx;if("HeNormal"===t)return new Zx;if("HeUniform"===t)return new Jx;if("LeCunNormal"===t)return new ew;if("LeCunUniform"===t)return new tw;{const e={};return e.className=t,e.config={},sw(e)}}return e instanceof Vx?e:sw(e)}function ow(e){return Array.isArray(e)&&Array.isArray(e[0])}function lw(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function uw(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new Ev(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function cw(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return e[0];throw new Ev(`Expected exactly 1 Shape; got ${e.length}`)}return e}function hw(e){let t=0;for(const n of e)0===n.shape.length?t+=1:t+=n.shape.reduce(((e,t)=>e*t));return t}const dw="Variable";class pw{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:dw,r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=Jv(),n=null==n?dw:n,this.originalName=px(n),this.name=fx(this.originalName),this.trainable_=r,this.constraint=s,this.val=pm(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),function(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function fw(e){return e.map((e=>e.read()))}function mw(e){e.forEach((e=>{e[0].write(e[1])}))}class gw{constructor(e){this.dtype=e.dtype,this.shape=e.shape,null!=e.shape?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class yw{constructor(e,t,n,r,s,a,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=s,this.outputTensorIndex=i,this.id=Jv(),null!=a&&(this.originalName=px(a),this.name=fx(this.originalName)),this.rank=t.length}}let bw=0;class vw{constructor(e,t){this.callArgs=t,this.id=bw++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const n of e.inboundLayers)null!=n&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)null!=t?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let xw=0;class ww extends pc{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=xw++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const e=this.getClassName();t=Pv(e)+"_"+tx(e)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let t;if(null!=e.batchInputShape)t=e.batchInputShape;else if(null!=e.inputShape){let n=null;null!=e.batchSize&&(n=e.batchSize),t=[n].concat(e.inputShape)}this.batchInputShape=t;let n=e.dtype;null==n&&(n=e.inputDType),null==n&&(n="float32"),this.dtype=n}null!=e.weights?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new Av(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new Ev(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return Mv(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return Mv(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Tv(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new Tv(`Layer ${this.name} is not connected, no input to return.`);return Mv(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new Tv(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Tv(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Mv(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map((e=>e()))}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach((t=>t.trainable=e)),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter((e=>e.trainable)):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter((e=>!e.trainable)).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=Lv(e);if(null==this.inputSpec||0===this.inputSpec.length)return;const n=Lv(this.inputSpec);if(t.length!==n.length)throw new Ev(`Layer ${this.name} expects ${n.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let r=0;r<t.length;r++){const e=t[r],s=n[r];if(null==s)continue;const a=e.rank;if(null!=s.ndim&&a!==s.ndim)throw new Ev(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${a}`);if(null!=s.maxNDim&&a>s.maxNDim)throw new Ev(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${a}`);if(null!=s.minNDim&&a<s.minNDim)throw new Ev(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${a}.`);if(null!=s.dtype&&e.dtype!==s.dtype)throw new Ev(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${e.dtype}.`);if(s.axes){const t=e.shape;for(const e in s.axes){const n=Number(e),a=s.axes[e],i=n>=0?t[n]:t[t.length+n];if(null!=a&&-1===[a,null].indexOf(i))throw new Ev(`Input ${r} is incompatible with layer ${this.name}: expected axis ${n} of input shape to have value ${a} but got shape ${t}.`)}}if(null!=s.shape)for(let t=0;t<s.shape.length;++t){const n=s.shape[t],a=e.shape[t];if(null!=n&&null!=a&&n!==a)throw new Ev(`Input ${r} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${e.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const n=Lv(e),r=function(e){let t=!0;for(const n of Lv(e))if(!(n instanceof yw)){t=!1;break}return t}(e),s=function(e){let t=!0;for(const n of Lv(e))if(n instanceof yw){t=!1;break}return t}(e);if(r===s)throw new Ev("Arguments to apply() must be all SymbolicTensors or all Tensors");return dx(this.name,(()=>{if(!this.built){this.assertInputCompatibility(e);const t=[];for(const n of Lv(e))t.push(n.shape);this.build(Mv(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&s&&(this._refCount=1)}if(this.assertInputCompatibility(e),s){let r=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,r);const s=Lv(r),a=[];for(let e of s)-1!==n.indexOf(e)&&(e=e.clone()),a.push(e);if(r=Mv(a),null!=this.activityRegularizer)throw new $v("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}{const n=function(e){e=Lv(e);const t=[];for(const n of e)t.push(n.shape);return Mv(t)}(e),r=this.computeOutputShape(n);let s;const a="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(e)?n[0]:n),s=null!=r&&r.length>0&&Array.isArray(r[0])?r.map(((n,r)=>new yw(a,n,this,Lv(e),t,this.name,r))):new yw(a,r,this,Lv(e),t,this.name),this.addInboundNode(e,s,null,null,n,r,t),this._refCount++,null!=this.activityRegularizer)throw new $v("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return s}}))}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach(((n,r)=>{null!=n&&null!=e[r]&&e[r]!==n&&(t=!0)})),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new Tv(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const n=JSON.stringify(t.outputShapes);-1===e.indexOf(n)&&e.push(n)}if(1===e.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new Tv(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Av(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return hw(this.weights)}build(e){this.built=!0}getWeights(){return fw(arguments.length>0&&void 0!==arguments[0]&&arguments[0]?this.trainableWeights:this.weights)}setWeights(e){Gl((()=>{const t=this.weights;if(t.length!==e.length)throw new Ev(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(0===t.length)return;const n=[],r=fw(t);for(let s=0;s<r.length;++s){const a=r[s],i=t[s],o=e[s];if(!wr(a.shape,o.shape))throw new Ev(`Layer weight shape ${a.shape} not compatible with provided weight shape ${o.shape}`);n.push([i,o])}mw(n)}))}addWeight(e,t,n,r,s,a,i,o){if(-1!==this._addedWeightNames.indexOf(e))throw new Ev(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=null!=o?o():iw("zeros"));const l=r.apply(t,n),u=new pw(l,n,e,a,i);return l.dispose(),null!=s&&this.addLoss((()=>s.apply(u.read()))),null==a&&(a=!0),a?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=Lv(e),void 0!==this._losses&&null!==this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);t.forEach((e=>{if(null!=e)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)}))}return null}return t}setMaskMetadata(e,t,n){if(!this.supportsMasking)return;const r=this.computeMask(e,n),s=Lv(t),a=Lv(r);if(s.length!==a.length)throw new Error(`${this.name} outputs ${s.length} tensors but ${s.length} masks for those tensors`);for(let i=0;i<s.length;i++)s[i].kerasMask=a[i]}addInboundNode(e,t,n,r,s,a){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null;const o=Lv(e);t=Lv(t),n=Lv(n),r=Lv(r),s=lw(s),a=lw(a);const l=[],u=[],c=[];for(const h of o)l.push(h.sourceLayer),u.push(h.nodeIndex),c.push(h.tensorIndex);new vw({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:c,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:s,outputShapes:a},i);for(let h=0;h<t.length;h++)t[h].sourceLayer=this,t[h].nodeIndex=this.inboundNodes.length-1,t[h].tensorIndex=h}getConfig(){const e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach((e=>e.dispose())),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return 0===--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function kw(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];{const e=t.inboundNodes[n];if(0===e.inboundLayers.length)return e.inputTensors;{const t=[];for(let n=0;n<e.inboundLayers.length;n++){const r=kw(e.inputTensors[n],e.inboundLayers[n],e.nodeIndices[n]);for(const e of r)-1===t.indexOf(e)&&t.push(e)}return t}}}class Sw extends ww{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:tx("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new Ev("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(null==t){if(null==e.inputShape)throw new Ev("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new Ev("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];const r=new yw(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new vw({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new Ev(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}Sw.className="InputLayer",mc(Sw);class Nw{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof Nw)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(null==e)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,n){if(null!=this.id2Value[e.id])throw new Ev(`Duplicate key: name=${e.name}, id=${e.id}`);return this.id2Value[e.id]=function(e,t){if(null==e.dtype||e.dtype===t.dtype)return t;try{return Ju(t,e.dtype)}catch($9){throw new Ev(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof yw){if(null==this.id2Value[e.id])throw new Ev(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}{const t=this.name2Id[e];if(null==t)throw new Ev(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof yw){if(null==this.id2Value[e.id])throw new Ev(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}{const t=this.name2Id[e];if(null==t)throw new Ev(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&Hl(this.id2Mask)}}const Iw=new Dv,Cw=new Dv;function Tw(e,t,n,r){const s=null!=n&&n.training,a=Array.isArray(e),i=a?e:[e],o=i.map((e=>e.name)),l=[],u=t.names();for(const f of o)-1!==u.indexOf(f)?l.push(t.getValue(f)):l.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const c=o.join(",")+"|"+t.names().sort().join(",");let h,d=Iw.get(c);if(null==d){const e=function(e,t){yr(null!=e&&e.length>0,(()=>"Expected at least one fetch, got none"));let n=[],r={};if(1===e.length){const s=Ew(e[0],t);n=s.sorted,r=s.recipientMap}else{const s=new Set;for(const a of e){const{sorted:e,recipientMap:i}=Ew(a,t);for(const t of e)s.has(t.name)||(n.push(t),s.add(t.name));for(const t in i)null==r[t]&&(r[t]=new Set),i[t].forEach((e=>r[t].add(e)))}}return{sorted:n,recipientCounts:Aw(r)}}(i,t);d=e.sorted,h=e.recipientCounts,Iw.put(c,d),Cw.put(c,h)}h={},s||Object.assign(h,Cw.get(c));const p=new Nw(t);for(let f=0;f<d.length;++f){if(null!=r){const e=jl().numTensors;e>r.maxNumTensors&&(r.maxNumTensors=e),e<r.minNumTensors&&(r.minNumTensors=e)}const e=d[f],a=e.sourceLayer;if(a instanceof Sw)continue;const i=[],u=[],c=[];let m=!1;for(const n of e.inputs){const e=p.getValue(n),r=p.getMask(n);i.push(e),u.push(r),null!=r&&(m=!0),s||(h[n.name]--,0!==h[n.name]||t.hasKey(n)||-1!==o.indexOf(n.name)||e.isDisposed||!0===n.sourceLayer.stateful||c.push(e))}m&&((n=n||{}).mask=u[0]);const g=Lv(a.apply(i,n));let y=null;a.supportsMasking&&(y=a.computeMask(i,u));const b=$w(e),v=Array.isArray(b)?b:[b];for(let t=0;t<v.length;++t){p.hasKey(v[t])||p.add(v[t],g[t],Array.isArray(y)?y[0]:y);const e=o.indexOf(v[t].name);-1!==e&&(l[e]=g[t])}s||Hl(c)}return p.disposeMasks(),a?l:l[0]}function Aw(e){const t={};for(const n in e)t[n]=e[n].size;return t}function Ew(e,t){const n=new Set,r=[],s={};for(const o of t.names())n.add(o);const a=[],i=[];for(a.push(e);a.length>0;){const e=a[a.length-1];if(n.has(e.name)){a.pop();continue}const t=i[i.length-1]===a.length-1;if(0===e.inputs.length||t)a.pop(),r.push(e),n.add(e.name),t&&i.pop();else{i.push(a.length-1);for(const t of e.inputs)null==s[t.name]&&(s[t.name]=new Set),s[t.name].add(e.name),n.has(t.name)||a.push(t)}}return{sorted:r,recipientMap:s}}function $w(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(const r of e.sourceLayer.inboundNodes[t].outputTensors)if(r.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}function Rw(e,t){return Gl((()=>ic(Qd(ac(e,e),t,!0))))}Yr().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",(()=>100),(function(e){null!=Iw&&Iw.setMaxEntries(e),null!=Cw&&Cw.setMaxEntries(e)}));class Dw extends pc{getConfig(){return{}}}class Ow extends Dw{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Gl((()=>{const t=Rw(e,this.axis),n=hd(t,0,this.maxValue);return ac(e,sc(n,nc(kx(),t)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}Ow.className="MaxNorm",mc(Ow);class _w extends Dw{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Gl((()=>sc(e,nc(kx(),Rw(e,this.axis)))))}getConfig(){return{axis:this.axis}}}_w.className="UnitNorm",mc(_w);class Fw extends Dw{apply(e){return wf(e)}}Fw.className="NonNeg",mc(Fw);class Mw extends Dw{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Gl((()=>{const t=Rw(e,this.axis),n=nc(ac(this.rate,hd(t,this.minValue,this.maxValue)),ac(1-this.rate,t));return ac(e,sc(n,nc(kx(),t)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}Mw.className="MinMaxNorm",mc(Mw);const Lw={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Pw(e){return Vv(e)}function zw(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Uv(e,fc.getMap().classNameMap,t,"constraint")}function Bw(e){if(null==e)return null;if("string"===typeof e){return zw({className:e in Lw?Lw[e]:e,config:{}})}return e instanceof Dw?e:zw(e)}async function Vw(e){if(null==e)return;const t=[],n=[],r=[];for(const s in e){const a=e[s];if("number"!==typeof a){const e=a;t.push(e.data()),n.push(s),r.push(e)}}if(t.length>0){const s=await Promise.all(t);for(let t=0;t<s.length;++t)e[n[t]]=s[t][0];Hl(r)}}function Ww(e){if(null!=e)for(const t in e){const n=e[t];"number"!==typeof n&&n.dispose()}}var Uw;!function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"}(Uw||(Uw={}));class jw{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class Gw{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:10;null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class Hw extends jw{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){null==t&&(t={});const n=null==t.size?0:t.size;this.seen+=n;for(const r in t){const e=t[r];if("number"===typeof e)this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+e*n;else{let t;r in this.totals?t=this.totals[r]:this.totals[r]=0;const s=Gl((()=>nc(this.totals[r],ac(e,n))));this.totals[r]=s,null!=t&&t.dispose()}}}async onEpochEnd(e,t){if(null!=t)for(const n of this.params.metrics)null!=this.totals[n]&&("number"===typeof this.totals[n]?t[n]=this.totals[n]/this.seen:Gl((()=>{const e=ac(sc(1,this.seen),this.totals[n]);t[n]=e,this.totals[n].dispose(),ql(t[n])})))}}class qw extends jw{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){null==t&&(t={}),this.epoch.push(e);for(const n in t)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){const e=[],t=[],n=[];for(const s in this.history){const r=this.history[s];for(let a=0;a<r.length;++a)if("number"!==typeof r[a]){const i=r[a];e.push(i.data()),t.push(s),n.push(a)}}const r=await Promise.all(e);for(let s=0;s<r.length;++s){this.history[t[s]][n[s]].dispose(),this.history[t[s]][n[s]]=r[s][0]}}}class Kw extends jw{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||Wg,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=e.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");_r(this.yieldEvery)&&(this.maybeWait=function(e,t,n){let r,s=null!=n?n():Vo();return function(){const a=null!=n?n():Vo();return a-s<t||(s=a,r=e(...arguments)),r}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){const r=[];null!=this.yield&&(await Vw(n),r.push(this.yield(e,t,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,null!=this.epochBegin&&(await Vw(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const n=[];null!=this.epochEnd&&(await Vw(t),n.push(this.epochEnd(e,t))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){null!=this.batchBegin&&(await Vw(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const n=[];null!=this.batchEnd&&(await Vw(t),n.push(this.batchEnd(e,t))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):_r(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){null!=this.trainBegin&&(await Vw(e),await this.trainBegin(e))}async onTrainEnd(e){null!=this.trainEnd&&(await Vw(e),await this.trainEnd(e))}}function Xw(e,t){if(null==e&&(e={}),e instanceof jw)return[e];if(Array.isArray(e)&&e[0]instanceof jw)return e;return Lv(e).map((e=>new Kw(e,t)))}class Qw{constructor(){}static registerCallbackConstructor(e,t){yr(e>=0&&Number.isInteger(e),(()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`)),Qw.checkForDuplicate(t),null==Qw.constructors[e]&&(Qw.constructors[e]=[]),Qw.constructors[e].push(t)}static checkForDuplicate(e){for(const t in Qw.constructors){Qw.constructors[+t].forEach((t=>{if(t===e)throw new Ev("Duplicate callback constructor.")}))}}static clear(){Qw.constructors={}}static createCallbacks(e){const t=[];for(const n in Qw.constructors){const r=+n;e>=r&&t.push(...Qw.constructors[r])}return t.map((e=>new e))}}function Yw(e,t,n,r,s,a,i,o,l){const u=new qw,c=[new Hw,...Qw.createCallbacks(t)];null!=e&&c.push(...e),c.push(u);const h=new Gw(c);return h.setParams({epochs:n,initialEpoch:r,samples:s,steps:a,batchSize:i,verbose:t,doValidation:o,metrics:l}),{callbackList:h,history:u}}function Zw(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return Uv(e,fc.getMap().classNameMap,t,"layer",n)}function Jw(e,t){return Gl((()=>{"float32"!==e.dtype&&(e=Ju(e,"float32"));const n=Qd(_x(e),t,!0),r=bc(n.shape,kx()),s=ic(Tc(n,r));return sc(e,s)}))}function ek(e,t){return Gl((()=>Fp(_x(wc(t,e)),-1)))}function tk(e,t){return Gl((()=>Fp(Sc(wc(t,e)),-1)))}function nk(e,t){return Gl((()=>{const n=wc(e,t),r=hd(Sc(e),kx(),Number.MAX_VALUE),s=Sc(sc(n,r));return ac(100,Fp(s,-1))}))}function rk(e,t){return Gl((()=>{const n=hd(t,kx(),Number.MAX_VALUE),r=bp(nc(1,n)),s=hd(e,kx(),Number.MAX_VALUE),a=bp(nc(1,s));return Fp(_x(wc(r,a)),-1)}))}function sk(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return Gl((()=>{if(n)t=Bf(t);else{const e=Qd(t,t.shape.length-1,!0);t=sc(t,e)}return t=hd(t,kx(),1-kx()),xp(Qd(ac(Ju(e,"float32"),bp(t)),t.shape.length-1))}))}function ak(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return Gl((()=>{const r=Ju(ap(function(e){const t=[yx(e.shape)];return Hh(e,t)}(e)),"int32"),s=(t=hd(t,kx(),1-kx())).shape;return sk(Hh(Hp(r,s[s.length-1]),s),t,n)}))}function ik(e,t){return Gl((()=>{let n;return n=hd(t,kx(),1-kx()),n=bp(sc(n,wc(1,n))),Fp(function(e,t){if(!wr(e.shape,t.shape))throw new Ev(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return Gl((()=>{const n=wf(t),r=xp(Sc(t));return nc(wc(n,ac(t,e)),vp(ep(r)))}))}(e,n),-1)}))}function ok(e,t){return Gl((()=>{const n=hd(e,kx(),1),r=hd(t,kx(),1);return Qd(ac(e,bp(sc(n,r))),-1)}))}function lk(e,t){return Gl((()=>{const n=Jw(e,-1),r=Jw(t,-1),s=ac(n,r);return xp(Qd(s,-1))}))}Qw.constructors={};const uk={meanSquaredError:ek,meanAbsoluteError:tk,meanAbsolutePercentageError:nk,meanSquaredLogarithmicError:rk,squaredHinge:function(e,t){return Gl((()=>{const n=Tc(0,wc(1,ac(e,t)));return Fp(_x(n),-1)}))},hinge:function(e,t){return Gl((()=>{const n=Tc(0,wc(1,ac(e,t)));return Fp(n,-1)}))},categoricalHinge:function(e,t){return Gl((()=>{const n=Qd(ac(e,t),-1),r=Kd(ac(wc(1,e),t),-1);return Tc(0,nc(1,wc(r,n)))}))},logcosh:function(e,t){return Gl((()=>{const n=Math.log(2),r=wc(t,e),s=wc(nc(r,wp(ac(-2,r))),n);return Fp(s,-1)}))},categoricalCrossentropy:sk,sparseCategoricalCrossentropy:ak,binaryCrossentropy:ik,kullbackLeiblerDivergence:ok,poisson:function(e,t){return Gl((()=>{const n=bp(nc(kx(),t));return Fp(wc(t,ac(e,n)),-1)}))},cosineProximity:lk};function ck(e){if("string"===typeof e){if(e in uk)return uk[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new Ev(t)}return e}function hk(e,t){return Gl((()=>{const n=ac(.5,qp(t)),r=Sx(op(t,n),e.dtype);return Fp(Dd(e,r),-1)}))}function dk(e,t){return Gl((()=>Sx(Dd(Nh(e,-1),Nh(t,-1)),"float32")))}function pk(e,t){return Gl((()=>Ju(Qd(Ip(Dd(e,1),Dd(t,1))),"float32")))}function fk(e,t){return ik(e,t)}function mk(e,t){return e.rank===t.rank&&(e=qf(e,[e.rank-1])),(t=Nh(t,-1)).dtype!==e.dtype&&(t=Ju(t,e.dtype)),Ju(Dd(e,t),"float32")}const gk=sk,yk=ak,bk={binaryAccuracy:hk,categoricalAccuracy:dk,precision:function(e,t){return Gl((()=>{const n=pk(e,t),r=function(e,t){return Gl((()=>Ju(Qd(Ip(Dd(e,0),Dd(t,1))),"float32")))}(e,t),s=nc(n,r);return Ju(Od(op(s,0),sc(n,s),0),"float32")}))},categoricalCrossentropy:gk,sparseCategoricalCrossentropy:yk,mse:ek,MSE:ek,mae:tk,MAE:tk,mape:nk,MAPE:nk,cosine:lk};function vk(e){if("string"===typeof e&&e in bk)return bk[e];if("string"!==typeof e&&null!=e)return e;throw new Ev(`Unknown metric ${e}`)}function xk(e){if(_v(null!==e,`Unknown LossOrMetricFn ${e}`),"string"===typeof e)return e;{let t;for(const n of Object.keys(uk))if(uk[n]===e){t=n;break}if(void 0!==t)return t;for(const n of Object.keys(bk))if(bk[n]===e){t=n;break}return void 0!==t?t:e.name}}const wk=1048576;function kk(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==e||"object"!==typeof e||Object.getPrototypeOf(e)!==Object.prototype||!Sk(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(e);n.length>wk&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function Sk(e){if(null===e)return!0;if("object"===typeof e){if(Object.getPrototypeOf(e)===Object.prototype){const t=Object.keys(e);for(const n of t){if("string"!==typeof n)return!1;if(!Sk(e[n]))return!1}return!0}if(Array.isArray(e)){for(const t of e)if(!Sk(t))return!1;return!0}return!1}{const t=typeof e;return"string"===t||"number"===t||"boolean"===t}}function Nk(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:console.log;const s=function(e){let t=!0;const n=[],r=[];for(const s in e.nodesByDepth)n.push(e.nodesByDepth[s]);for(const s of n){if(s.length>1||1===s.length&&s[0].inboundLayers.length>1){t=!1;break}r.push(...s)}if(t)for(const s of e.layers){let e=!1;for(const n of s.inboundNodes)if(-1!==r.indexOf(n)){if(e){t=!1;break}e=!0}if(!t)break}return t}(e),a=["Layer (type)","Input Shape","Output shape","Param #"];let i;if(s?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map((e=>Math.floor(t*e)))),!s){a.push("Receives inputs"),i=[];for(const t in e.nodesByDepth)i.push(...e.nodesByDepth[t])}r("_".repeat(t)),Ik(a,n,r),r("=".repeat(t));const o=e.layers;for(let c=0;c<o.length;++c)s?Ck(o[c],n,r):Tk(o[c],n,i,r),r((c===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();const l=function(e){let t;t=null!=e.collectedTrainableWeights?hw(e.collectedTrainableWeights):hw(e.trainableWeights);return t}(e),u=hw(e.nonTrainableWeights);r(`Total params: ${l+u}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${u}`),r("_".repeat(t))}function Ik(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log,r="";for(let s=0;s<e.length;++s)s>0&&(r=r.slice(0,r.length-1)+" "),r+=e[s],r=r.slice(0,t[s]),r+=" ".repeat(t[s]-r.length);n(r)}function Ck(e,t,n){let r,s;try{s=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch($9){s="multiple"}try{r=JSON.stringify(e.outputShape)}catch($9){r="multiple"}Ik([`${e.name} (${e.getClassName()})`,s,r,e.countParams().toString()],t,n)}function Tk(e,t,n,r){let s,a;try{a=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch($9){a="multiple"}try{s=JSON.stringify(e.outputShape)}catch($9){s="multiple"}const i=[];for(const c of e.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(c)))for(let e=0;e<c.inboundLayers.length;++e){const t=c.inboundLayers[e].name,n=c.nodeIndices[e],r=c.tensorIndices[e];i.push(`${t}[${n}][${r}]`)}const o=e.name,l=e.getClassName(),u=0===i.length?"":i[0];Ik([`${o} (${l})`,a,s,e.countParams().toString(),u],t,r);for(let c=1;c<i.length;++c)Ik(["","","","",i[c]],t,r)}function Ak(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"===typeof n}function Ek(e,t){if(null===e)return null;if("string"===typeof e)return zv(e);if("number"===typeof e||"boolean"===typeof e)return e;if(e instanceof Array){const n=[],r=e.length;for(let s=0;s<r;++s){const r=e[s];Ak(t,s,r)?n.push(r):n.push(Ek(r,t))}return n}{const t={};for(const n of Object.keys(e)){const r=e[n];if("name"===n&&"string"===typeof r)t[n]=r;else{const e=zv(n);t[e]=Ek(r,e)}}return t}}function $k(e,t){if(null===e||void 0===e)return null;if("string"===typeof e)return Pv(e);if("number"===typeof e||"boolean"===typeof e)return e;if(e instanceof Array){const n=[],r=e.length;for(let s=0;s<r;++s){const r=e[s];Ak(t,s,r)?n.push(r):n.push($k(r,t))}return n}{const t={};for(const n of Object.keys(e)){const r=e[n],s=Pv(n);t[s]="name"!==n&&"className"!==n||"string"!==typeof r?$k(r,n):r}return t}}const Rk="4.22.0";class Dk extends ww{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,null==this.name){const e=this.getClassName().toLowerCase();this.name=tx(e)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],Gv(this.inputs).length!==this.inputs.length)throw new Ev(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map((e=>e.name))}`);Gv(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map((e=>e.name))}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const y of this.outputs){const e=y.sourceLayer,t=y.nodeIndex,n=y.tensorIndex;this.outputLayers.push(e),this.outputLayersNodeIndices.push(t),this.outputLayersTensorIndices.push(n)}for(const y of this.inputs){const e=y.sourceLayer,t=y.nodeIndex,n=y.tensorIndex;_v(0===t,"input layer has >1 nodes"),_v(0===n,"input layer has >1 tensors"),this.inputLayers.push(e),this.inputLayersNodeIndices.push(t),this.inputLayersTensorIndices.push(n)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let y=0;y<this.inputLayers.length;y++){const t=this.inputLayers[y];if(!(t instanceof Sw))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${y} (0-based) originates from layer type ${t.getClassName()}.`);this.inputNames.push(t.name),this.feedInputShapes.push(t.batchInputShape),this.feedInputNames.push(t.name)}for(const y of this.outputLayers)this.outputNames.push(y.name);this.internalInputShapes=this.inputs.map((e=>e.shape)),this.internalOutputShapes=this.outputs.map((e=>e.shape));const t={},n={},r={},s={},a={},i=[],o=(e,t,n,r,s,l)=>{null!=r&&null!=s&&null!=l||(r=e.sourceLayer,s=e.nodeIndex,l=e.tensorIndex);const u=r.inboundNodes[s];if(-1!==n.indexOf(u))throw new Av(`The tensor ${e.name} at layer "${r.name}" is part of a cycle.`);if(-1!==t.indexOf(u))return;this.containerNodes.add(Dk.nodeKey(r,s)),r.id in a||(a[r.id]=Object.keys(a).length),-1===n.indexOf(u)&&n.push(u);const c=u.inboundLayers.length;for(let a=0;a<c;a++){const e=u.inputTensors[a],r=u.inboundLayers[a],s=u.nodeIndices[a],i=u.tensorIndices[a];o(e,t,n,r,s,i)}for(t.push(u);n.indexOf(u)>=0;)n.splice(n.indexOf(u),1);i.push(u)},l=[],u=[];for(const y of this.outputs)o(y,l,u);const c=i.slice().reverse();for(const y of c){n[y.id]=y,y.id in t||(t[y.id]=0);let e=t[y.id];const a=null==r[y.outboundLayer.id]?0:r[y.outboundLayer.id];e=Math.max(e,a),r[y.outboundLayer.id]=e,s[y.outboundLayer.id]=y.outboundLayer,t[y.id]=e;for(let r=0;r<y.inboundLayers.length;r++){const s=y.inboundLayers[r],a=y.nodeIndices[r],i=s.inboundNodes[a],o=null==t[i.id]?0:t[i.id];t[i.id]=Math.max(e+1,o),n[i.id]=i}}const h={};for(const y in t){const e=t[y];e in h||(h[e]=[]),h[e].push(n[y])}const d={};for(const y in r){const e=r[y];e in d||(d[e]=[]),d[e].push(s[y])}let p=Object.keys(d).map((e=>parseInt(e,10))).sort(jv);this.layers=[];for(const y of p){const e=d[y];e.sort(((e,t)=>{const n=a[e.id],r=a[t.id];return n<r?-1:n>r?1:0}));for(const t of e)t instanceof Dk&&this.internalContainerRefs.push(t),this.layers.push(t)}this.layersByDepth=d,p=Object.keys(h).map((e=>parseInt(e,10))).sort(jv);const f=this.inputs.slice(),m=[];for(const y of p)for(const e of h[y]){const t=e.outboundLayer;if(null!=t){for(const n of e.inputTensors)if(-1===f.indexOf(n))throw new Av(`Graph disconnected: cannot obtain value for tensor ${n} at layer "${t.name}". The following previous layers were accessed without issue: ${m}`);for(const t of e.outputTensors)f.push(t);m.push(t.name)}}this.nodesByDepth=h;const g=this.layers.map((e=>e.name));for(const y of g){const e=g.filter((e=>e===y)).length;if(1!==e)throw new Av(`The name "${y}" is used ${e} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new vw({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((e=>null)),outputMasks:this.outputs.map((e=>null)),inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs.map((e=>e.shape))}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(0===--this._refCount){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach((t=>{t._trainableWeights.forEach((t=>t.trainable=e))})),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new Ev("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n={};let r=0;const s=(e=>{const t=Object.keys(e);if(0===t.length)return!1;const n=t[0].split("/");return!isNaN(parseInt(n[n.length-1],10))})(e);s&&this.parseWeights(e);for(const i of this.layers)for(const[e,t]of i.weights.entries()){const a=s?`${t.name.split("/").slice(0,-1).join("/")+"/"}${e}`:t.originalName;if(null!=n[a])throw new Ev(`Duplicate weight name: ${a}`);n[a]=t,r++}const a=[];for(const i in e){let r=i;if(null==n[i]){const e=i.split("/");r=e.slice(0,-2).concat([e[e.length-1]]).join("/")}if(null!=n[r])a.push([n[r],e[i]]);else if(t)throw new Ev(`Provided weight data has no target variable: ${i}`);delete n[r]}if(t){const e=[];for(const t in n)e.push(t);if(e.length>0)throw new Ev(`${e.length} of ${r} weights are not set: ${e}`)}mw(a)}parseWeights(e){for(const t in Object.keys(e)){const n=t.split("/"),r=["vars","layer_checkpoint_dependencies"],s=n.map((e=>e.startsWith("_")?e.slice(1):e)).filter((e=>!r.includes(e))).join("/");s!==t&&(e[s]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${Rk}`,t.backend="TensorFlow.js",t}toJSON(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=$k(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return Gl((()=>{e=Lv(e);const n=new Nw;for(let t=0;t<this.inputs.length;++t)n.add(this.inputs[t],e[t]);return Tw(this.outputs,n,t)}))}computeMask(e,t){return Gl((()=>{let n;return e=Lv(e),n=null==t?Ov(null,e.length):Lv(t),this.runInternalGraph(e,n)[1]}))}computeOutputShape(e){const t=lw(e);if(t.length!==this.inputLayers.length)throw new Ev(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const n={};for(let i=0;i<t.length;i++){const e=this.inputLayers[i],r=t[i];n[e.name+"_0_0"]=r}const r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(jv);if(r.length>1)for(const i of r){const e=this.nodesByDepth[i];for(const t of e){const e=t.outboundLayer;if(-1!==this.inputLayers.map((e=>e.id)).indexOf(e.id))continue;const r=[];for(let i=0;i<t.inboundLayers.length;i++){const e=t.inboundLayers[i],s=t.nodeIndices[i],a=t.tensorIndices[i],o=n[`${e.name}_${s}_${a}`];r.push(o)}const s=lw(e.computeOutputShape(Mv(r))),a=e.inboundNodes.indexOf(t);for(let t=0;t<s.length;t++){n[`${e.name}_${a}_${t}`]=s[t]}}}const s=[],a=[];for(let i=0;i<this.outputLayers.length;i++){const e=this.outputLayers[i],t=this.outputLayersNodeIndices[i],n=this.outputLayersTensorIndices[i],r=`${e.name}_${t}_${n}`;a.push(r)}for(let i=0;i<a.length;i++){const e=a[i];_v(e in n),s.push(n[e])}return Mv(s)}runInternalGraph(e,t){null==t&&(t=Ov(null,e.length));const n={};for(let o=0;o<this.inputs.length;++o){const r=this.inputs[o],s=e[o],a=t[o];n[r.id]=[s,a]}const r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(jv);for(const o of r){const e=this.nodesByDepth[o];for(const t of e){const e=t.outboundLayer,r=t.inputTensors,s=t.outputTensors,a=new Array;for(const t of r)t.id in n&&a.push(n[t.id]);if(a.length===r.length){let r,i,o,l,u={};if(null!=t.callArgs&&(u=t.callArgs),1===a.length){const[t,n]=a[0];null==u.mask&&(u.mask=n),o=Lv(e.call(t,u)),l=Lv(e.computeMask(t,n)),r=[t],i=[n]}else r=a.map((e=>e[0])),i=a.map((e=>e[1])),null==u.mask&&(u.mask=i),o=Lv(e.call(r,u)),l=Lv(e.computeMask(r,i));if(e.activityRegularizer)throw new $v("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let e=0;e<s.length;++e){const t=s[e],r=o[e],a=l[e];n[t.id]=[r,a]}}}}const s=[],a=[],i=[];for(const o of this.outputs){_v(o.id in n,`Could not compute output ${o.name} : ${o.id}`);const[e,t]=n[o.id];i.push(e.shape),s.push(e),a.push(t)}return[s,a,i]}buildNodeConversionMap(e){const t={};let n;for(const r of this.layers){n=r instanceof Dk?1:0;for(let e=0;e<r.inboundNodes.length;e++){const s=Dk.nodeKey(r,e);this.containerNodes.has(s)&&(t[s]=n,n+=1)}}return t}getLayer(e,t){if(null!=t)return this.findLayer(t);if(null==e)throw new Ev("Provide either a layer name or layer index");if("number"===typeof e)return this.findLayer(e);for(const n of this.layers)if(n.name===e)return n;throw new Ev(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new Ev(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return Gl((()=>{const e=[];for(const t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){const r=Dk.nodeKey(t,n);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e}))}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(const a of this.layers){const e=a.getClassName(),r=a.getConfig(),s=[];for(let n=0;n<a.inboundNodes.length;n++){const e=a.inboundNodes[n],r=Dk.nodeKey(a,n);let i={};if(this.containerNodes.has(r)){if(e.callArgs)try{JSON.stringify(e.callArgs),i=e.callArgs}catch($9){console.warn(`Layer ${a.name} was passed non-serializable keyword arguments: ${e.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),i={}}if(e.inboundLayers.length>0){const n=[];for(let r=0;r<e.inboundLayers.length;r++){const s=e.inboundLayers[r],a=e.nodeIndices[r],o=e.tensorIndices[r];let l=t[Dk.nodeKey(s,a)];null==l&&(l=0),n.push([s.name,l,o,i])}s.push(n)}}}const i={};i.name=a.name,i.className=e,i.config=r,i.inboundNodes=s,n.push(i)}e.layers=n;const r=[];for(let a=0;a<this.inputLayers.length;a++){const e=this.inputLayers[a],n=this.inputLayersNodeIndices[a],s=Dk.nodeKey(e,n);if(!this.containerNodes.has(s))continue;let i=t[s];null!==i&&void 0!==i||(i=0);const o=this.inputLayersTensorIndices[a];r.push([e.name,i,o])}e.inputLayers=r;const s=[];for(let a=0;a<this.outputLayers.length;a++){const e=this.outputLayers[a],n=this.outputLayersNodeIndices[a],r=Dk.nodeKey(e,n);if(!this.containerNodes.has(r))continue;let i=t[r];null!==i&&void 0!==i||(i=0);const o=this.outputLayersTensorIndices[a];s.push([e.name,i,o])}return e.outputLayers=s,e}static fromConfig(e,t){let n=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r={},s={};function a(e,t){e.name in s?s[e.name].push(t):s[e.name]=[t]}function i(e,t){const n=[];let s;for(const i of t){const o=i[0],l=i[1],u=i[2];if(s=null==i[3]?{}:i[3],!(o in r))return void a(e,t);const c=r[o];if(c.inboundNodes.length<=l)return void a(e,t);const h=c.inboundNodes[l];n.push(h.outputTensors[u])}n.length>0&&e.apply(Mv(n),s)}function o(e){const s=e.name,i=Zw(e,null!=t.customObjects?t.customObjects:{});i.setFastWeightInitDuringBuild(n),r[s]=i;e.inboundNodes.forEach((e=>{if(!(e instanceof Array))throw new Ev(`Corrupted configuration, expected array for nodeData: ${e}`);a(i,e)}))}const l=t.name,u=t.layers;for(const f of u)o(f);for(;!Hv(s);)for(const e of u){const t=r[e.name];if(t.name in s){const e=s[t.name];delete s[t.name];for(const n of e)i(t,n)}}const c=[],h=[],d=t.inputLayers;for(const f of d){const e=f[0],t=f[1],n=f[2];_v(e in r);const s=r[e].inboundNodes[t].outputTensors;c.push(s[n])}const p=t.outputLayers;for(const f of p){const e=f[0],t=f[1],n=f[2];_v(e in r);const s=r[e].inboundNodes[t].outputTensors;h.push(s[n])}return new e({inputs:c,outputs:h,name:l})}get stateful(){if(this._stateful)throw new Ev("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){Gl((()=>{this.layers.forEach((e=>{e.stateful&&e.resetStates()}))}))}}function Ok(e,t,n){const r=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>null));if(1===r)return Array.isArray(e)&&1===e.length?e:"object"===typeof e&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}if("object"===typeof e&&Object.keys(e).length>0&&"object"===typeof e[Object.keys(e)[0]]){const n=[];return t.forEach((t=>{t in e?n.push(e[t]):n.push(null)})),n}throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}function _k(e,t){return Ok(e,t,"classWeight")}async function Fk(e,t,n,r){if(null!=t||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const t=Gl((()=>{if(1===e.shape.length)return ec(e);if(2===e.shape.length){if(e.shape[1]>1){return Nh(e,1)}if(1===e.shape[1])return Hh(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)})),r=Array.from(await t.data());Hl(t);const s=[];return r.forEach((e=>{if(null==n[e])throw new Error(`classWeight must contain all classes in the training data. The class ${e} exists in the data but not in classWeight`);s.push(n[e])})),Zf(s,"float32")}return null}function Mk(e,t){return ac(e,t)}function Lk(e,t){let n,r;const s=t;n=s.xs,r=s.ys,yr(null!=n&&null!=r,(()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`));const a=Pk("input",e.inputNames,n),i=Pk("output",e.outputNames,r),o=a[0].shape[0];yr(a.length===e.inputs.length,(()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${a.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`)),yr(i.length===e.outputs.length,(()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`));for(let l=0;l<a.length;l++)yr(a[l].shape[0]===o,(()=>`Batch size mismatch: input ${e.inputNames[l]} has ${a[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`));for(let l=0;l<i.length;l++)yr(i[l].shape[0]===o,(()=>`Batch size mismatch: output ${e.outputNames[l]} has ${i[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`));return{xs:a,ys:i}}function Pk(e,t,n){if(n instanceof sl)return[n];if(Array.isArray(n))return yr(n.length===t.length,(()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`)),n;{const r=[];for(const s of t){if(null==n[s])throw new Ev(`The feature data generated by the dataset lacks the required ${e} key '${s}'.`);r.push(n[s])}return r}}async function zk(e,t,n){const r=null!=n.batchesPerEpoch;if(yr(null!=e.optimizer,(()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).")),yr(null!=n,(()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.")),yr(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),(()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`)),yr(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),(()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`)),yr(null==n.validationSplit,(()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.")),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{const s=null!=n.validationData;let a,i;if(s)if(Bk(n.validationData))yr(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),(()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`));else{const e=function(e){if(3===e.length)throw new $v("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}(n.validationData);a=e.xs,i=e.ys}const o=e.makeTrainFunction(),l=e.getDedupedMetricsNames();let u;u=s?l.slice().concat(l.map((e=>"val_"+e))):l.slice();const c=Xw(n.callbacks,n.yieldEvery),h=null==n.verbose?1:n.verbose,{callbackList:d,history:p}=Yw(c,h,n.epochs,null,null,function(e,t){let n=null;null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size);return n}(t,n),null,s,u);d.setModel(e),e.history=p,await d.onTrainBegin(),e.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,m=await t.iterator();for(;f<n.epochs;){const u={};await d.onEpochBegin(f);let c=0,h=0;for(r||(m=await t.iterator());!r||c<n.batchesPerEpoch;){const t=await m.next();if(r&&t.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${c} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, `+n.batchesPerEpoch*n.epochs+" batches). You may need to use the repeat() function when building your dataset.");break}if(null!=t.value){const{xs:r,ys:s}=Lk(e,t.value),a={};a.batch=h,a.size=r[0].shape[0],await d.onBatchBegin(h,a);const i=[];if(null!=n.classWeight){const t=_k(n.classWeight,e.outputNames);for(let e=0;e<t.length;++e)i.push(await Fk(s[e],null,t[e]))}const u=r.concat(s).concat(i),p=o(u);Hl(u);for(let e=0;e<l.length;++e){const t=l[e],n=p[e];a[t]=n,ql(n)}await d.onBatchEnd(h,a),Ww(a),h++,c++}if(r?c>=n.batchesPerEpoch:t.done){if(s){let t;t=Bk(n.validationData)?Lv(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):Lv(e.evaluate(a,i,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<e.metricsNames.length;++n)u[`val_${e.metricsNames[n]}`]=t[n]}break}if(e.stopTraining_)break}if(await d.onEpochEnd(f,u),f++,e.stopTraining_)break}return await d.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function Bk(e){return"function"===typeof e.iterator}function Vk(e){yr(e>0&&Number.isInteger(e),(()=>`batchSize is required to be a positive integer, but got ${e}`))}function Wk(e,t,n){return null==e?[null]:Array.isArray(e)?e.map((e=>Ix(e,t,n-t))):Ix(e,t,n-t)}function Uk(e,t){return Gl((()=>null==e?null:Array.isArray(e)?e.map((e=>Uk(e,t))):Ox(e,"int32"===t.dtype?t:Ju(t,"int32"))))}function jk(e,t){const n=[];let r=0,s=null;for(;r<e;)s=r+t,s>=e&&(s=e),n.push([r,s]),r=s;return n}function Gk(e){const t=[];e instanceof sl&&(e=[e]);for(let n=0;n<e.length;++n){const r=e[n];if(1===r.rank)t.push(Nx(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function Hk(e,t){if(null==e)return;const n=[];if(t instanceof sl)n.push(t.id);else if(Array.isArray(t))t.forEach((e=>n.push(e.id)));else if(null!=t)for(const s in t){const e=t[s];n.push(e.id)}const r=[];if(e instanceof sl)-1===n.indexOf(e.id)&&r.push(e);else if(Array.isArray(e))e.forEach((e=>{-1===n.indexOf(e.id)&&r.push(e)}));else if(null!=e)for(const s in e){const t=e[s];-1===n.indexOf(t.id)&&r.push(t)}r.forEach((e=>{e.isDisposed||e.dispose()}))}function qk(e){return Array.isArray(e)}function Kk(e){return!function(e){return e instanceof sl}(e)&&!qk(e)}function Xk(e,t,n){let r,s=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(null==t||0===t.length){if(null!=e){let t=!1;if(qk(e)&&e.length>0)t=!0;else if(Kk(e)){for(const n in e)if(e.hasOwnProperty(n)){t=!0;break}}else t=!0;if(t)throw new Ev(`Error when checking model ${a} expected no data, but got ${e}`)}return[]}if(null==e)return t.map((e=>null));if(Kk(e)){r=[];for(const n of t){if(null==e[n])throw new Ev(`No data provided for "${n}". Need data for each key in: ${t}`);r.push(e[n])}}else if(qk(e)){if(e.length!==t.length)throw new Ev(`Error when checking model ${a}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);r=e}else{if(t.length>1)throw new Ev(`The model ${a} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);r=[e]}if(r=Gk(r),null!=n)for(let i=0;i<t.length;++i){if(null==n[i])continue;const e=r[i];if(e.shape.length!==n[i].length)throw new Ev(`Error when checking ${a}: expected ${t[i]} to have ${n[i].length} dimension(s). but got array with shape ${e.shape}`);for(let t=0;t<n[i].length;++t){if(0===t&&!s)continue;const r=e.shape[t],o=n[i][t];if(null!=o&&o>=0&&r!==o)throw new Ev(`${a} expected a batch of elements where each example has shape [${n[i].slice(1,n[i].length)}] (i.e.,tensor shape [*,${n[i].slice(1,n[i].length)}]) but the ${a} received an input with ${e.shape[0]} examples, each with shape [${e.shape.slice(1,e.shape.length)}] (tensor shape [${e.shape}])`)}}return r}function Qk(e,t,n){let r,s=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(Array.isArray(e)){if(e.length!==t.length)throw new Ev(`Error when checking model ${a}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);r=e}else{if(t.length>1)throw new Ev(`The model expects ${t.length} ${a} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);r=[e]}if(null!=n)for(let i=0;i<t.length;++i){if(null==n[i])continue;const e=r[i];if(e.shape.length!==n[i].length)throw new Ev(`Error when checking ${a}: expected ${t[i]} to have ${n[i].length} dimension(s), but got array with shape ${JSON.stringify(e.shape)}`);for(let r=0;r<n[i].length;++r){if(0===r&&!s)continue;const o=e.shape[r],l=n[i][r];if(null!=l&&l!==o)throw new Ev(`Error when checking ${a}: expected ${t[i]} to have shape ${JSON.stringify(n[i])} but got array with shape ${JSON.stringify(e.shape)}.`)}}}class Yk extends Dk{constructor(e){super(e),this.isTraining=!1}summary(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;if(!this.built)throw new Ev("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");Nk(this,e,t,n)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"===typeof e.optimizer)this.optimizer_=function(e){const t={Adagrad:()=>Bg.adagrad(.01),Adadelta:()=>Bg.adadelta(1,.95,kx()),Adam:()=>Bg.adam(.001,.9,.999,kx()),Adamax:()=>Bg.adamax(.002,.9,.999,kx(),0),RMSProp:()=>Bg.rmsprop(.001,.9,0,kx()),SGD:()=>Bg.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new Ev(`Unknown Optimizer ${e}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof gc))throw new Ev("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"===typeof e.loss||"function"===typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new Ev(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);const n=e.loss;t=n.map((e=>ck(e)))}else{const n=ck(e.loss);this.outputs.forEach((e=>{t.push(n)}))}else{e.loss=e.loss;for(const t in e.loss)if(-1===this.outputNames.indexOf(t))throw new Ev(`Unknown entry in loss dictionary: "${t}". Only expected the following keys: ${this.outputNames}`);for(const n of this.outputNames)null==e.loss[n]&&console.warn(`Output "${n}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${n} during training`),t.push(ck(e.loss[n]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){const e=this.internalOutputShapes[a],t=this.outputNames[a];this.feedOutputNames.push(t),this.feedOutputShapes.push(e),this.feedLossFns.push(this.lossFunctions[a])}const n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],dx("loss",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;const t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}}));const r=function(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>[]));let n;if("string"===typeof e||"function"===typeof e)n=[e];else{if(!Array.isArray(e)&&"object"!==typeof e)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);n=e}if(Array.isArray(n))return t.map((e=>n));{const e=[];for(const r of t){let t=n.hasOwnProperty(r)?n[r]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}(e.metrics,this.outputNames),s=(e,t,n)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([n,e])};dx("metric",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;(t=>{let n,r,a;for(const i of t){if("string"===typeof i&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(i)){const t=this.internalOutputShapes[e];let s;1===t[t.length-1]||this.lossFunctions[e]===ik?-1!==["accuracy","acc"].indexOf(i)?r=hk:-1!==["crossentropy","ce"].indexOf(i)&&(r=fk):this.lossFunctions[e]===ak?-1!==["accuracy","acc"].indexOf(i)?r=mk:-1!==["crossentropy","ce"].indexOf(i)&&(r=yk):-1!==["accuracy","acc"].indexOf(i)?r=dk:-1!==["crossentropy","ce"].indexOf(i)&&(r=gk),-1!==["accuracy","acc"].indexOf(i)?s="acc":-1!==["crossentropy","ce"].indexOf(i)&&(s="ce"),a=r,n=""+s}else{const e=vk(i);a=e,n=""+xk(i)}let t;dx(n,(()=>{t=a})),s(e,n,t)}})(r[e])}})),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=null==n.batchSize?32:n.batchSize;Vk(r);const s=this.standardizeUserDataXY(e,t,!0,r);try{const e=s[0].concat(s[1]);this.makeTestFunction();const t=this.testFunction;return Mv(this.testLoop(t,e,r,n.verbose,n.steps))}finally{Hk(s[0],e),Hk(s[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),async function(e,t,n){const r=null!=(n=n||{}).batches,s=e.testFunction;let a=[];if(n.verbose>0)throw new $v("Verbose mode is not implemented yet.");yr(!r||n.batches>0&&Number.isInteger(n.batches),(()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`));const i=function(e){return"function"===typeof e.next}(t)?t:await t.iterator();let o=0,l=0;for(;!r||l<n.batches;){const t=await i.next();if(a=Gl((()=>{if(t.value){const{xs:n,ys:r}=Lk(e,t.value),i=n.concat(r),u=Gl((()=>s(i)));if(Hl(i),0===l)for(let e=0;e<u.length;++e)a.push(cc(0));const c=i[0].shape[0];for(let e=0;e<u.length;++e){const t=u[e],n=a[e];a[e]=Gl((()=>nc(a[e],ac(c,t)))),l>0&&Hl(n)}Hl(u),o+=c,++l}return a})),t.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<a.length;++u){const e=a[u];a[u]=sc(a[u],o),Hl(e)}return Mv(a)}(this,e,t)}checkNumSamples(e,t,n){let r,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"steps";if(null!=n){if(r=null,null!=t)throw new Ev(`If ${s} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else{if(null==e)throw new Ev(`Either the input data should have a defined shape, or ${s} shoud be specified.`);r=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return r}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new Ev("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(t),r=n?t:[t],s=this.retrieveSymbolicTensors(r),a=new Nw;if(e instanceof sl&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new Ev(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let t=0;t<this.inputs.length;++t)a.add(this.inputs[t],e[t])}else for(const o of this.inputs){const t=e[o.name];if(null==t)throw new Ev(`No value is provided for the model's input ${o.name}`);a.add(o,t)}const i=Tw(s,a);return n?i:i[0]}retrieveSymbolicTensors(e){const t=Ov(null,e.length);let n=e.length;for(const r of this.layers){const s=Array.isArray(r.output)?r.output:[r.output],a=s.map((e=>e.name));for(let r=0;r<e.length;++r){const i=a.indexOf(e[r]);if(-1!==i&&(t[r]=s[i],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw t.forEach(((t,r)=>{null==t&&n.push(e[r])})),new Ev(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)}return t}predictLoop(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:32,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return Gl((()=>{const r=this.checkNumSamples(e);if(n)throw new $v("Verbose predictLoop() is not implemented yet.");const s=jk(r,t),a=this.outputs.map((e=>[]));for(let t=0;t<s.length;++t){const n=Gl((()=>{const n=s[t][0],r=s[t][1],a=Wk(e,n,r),i=[];if(Array.isArray(a))for(let e=0;e<a.length;++e)i.push({key:this.inputs[e],value:a[e]});else i.push({key:this.inputs[0],value:a});const o=new Nw(i);return Tw(this.outputs,o)}));n.forEach(((e,t)=>a[t].push(e)))}return Mv(a.map((e=>Xh(e,0))))}))}predict(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=Gk(e);Qk(n,this.inputNames,this.feedInputShapes,!1);try{const e=null==t.batchSize?32:t.batchSize;return Vk(e),this.predictLoop(n,e)}finally{Hk(n,e)}}predictOnBatch(e){Qk(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t){let n=arguments.length>3?arguments[3]:void 0;if(null==this.optimizer_)throw new Av("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const r=[];for(let s=0;s<this.feedOutputShapes.length;++s){const e=this.feedOutputShapes[s];this.feedLossFns[s]===ak?r.push(e.slice(0,e.length-1).concat([1])):r.push(e)}if(function(e,t){const n=Gv(e.map((e=>e.shape[0])));n.sort();const r=Gv(t.map((e=>e.shape[0])));if(r.sort(),n.length>1)throw new Ev(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map((e=>e.shape)))}`);if(r.length>1)throw new Ev(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map((e=>e.shape)))}`);if(n.length>0&&r.length>0&&!wr(n,r))throw new Ev(`Input Tensors should have the same number of samples as target Tensors. Found ${n[0]} input sample(s) and ${r[0]} target sample(s).`)}(e=Xk(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=Xk(t,this.feedOutputNames,r,!1,"target")),function(e,t,n){const r=[ek,ik,sk];for(let s=0;s<e.length;++s){const a=e[s],i=t[s],o=n[s];if(null!=i){if(i===sk&&1===a.shape[a.shape.length-1])throw new Ev(`You are passing a target array of shape ${a.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(i)){const e=a.shape.slice(1),t=o.slice(1);for(let n=0;n<e.length;++n){const r=e[n],s=t[n];if(null!=s&&r!==s)throw new Ev(`A target Tensor with shape ${a.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=n&&n>0&&e[0].shape[0]%n!==0)throw new Ev(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${n}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,r){let s=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],a=arguments.length>5?arguments[5]:void 0;const[i,o]=this.standardizeUserDataXY(e,t,s,a);if(null!=n)throw new Error("sample weight is not supported yet.");let l=null;if(null!=r){const e=_k(r,this.outputNames);l=[];for(let t=0;t<e.length;++t)l.push(await Fk(o[t],null,e[t]))}return[i,o,l]}testLoop(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,s=arguments.length>4?arguments[4]:void 0;return Gl((()=>{const a=this.checkNumSamples(t,n,s,"steps"),i=[];if(r>0)throw new $v("Verbose mode is not implemented yet.");if(null!=s)throw new $v("steps mode in testLoop() is not implemented yet");{const r=jk(a,n),s=Zf(xx(0,a));for(let n=0;n<r.length;++n){const a=r[n][0],o=r[n][1],l=Ix(s,a,o-a),u=Uk(t,l),c=e(u);if(0===n)for(let e=0;e<c.length;++e)i.push(cc(0));for(let e=0;e<c.length;++e){const t=c[e];i[e]=nc(i[e],ac(o-a,t))}}for(let e=0;e<i.length;++e)i[e]=sc(i[e],a)}return i}))}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){const r=e[n];let s=r;if(Fv(e,r)>1){s+=`_${Fv(e.slice(0,n),r)}`}t.push(s)}return t}makeTrainFunction(){return e=>{const t=[],n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),a=[],i=this.collectedTrainableWeights.map((e=>e.read())),o=this.optimizer_.minimize((()=>{const e=[];for(let t=0;t<this.inputs.length;++t)e.push({key:this.inputs[t],value:n[t]});const i=new Nw(e),o=Tw(this.outputs,i,{training:!0});let l;for(let n=0;n<this.lossFunctions.length;++n){let e=(0,this.lossFunctions[n])(r[n],o[n]);null!=s[n]&&(e=Mk(e,s[n]));const a=Fp(e);t.push(a),l=0===n?e:nc(l,e)}for(let n=0;n<this.metricsTensors.length;++n){let e;if(this.outputs.length>1&&n<this.outputs.length)e=t[n];else{const t=this.metricsTensors[n][0],s=this.metricsTensors[n][1];e=Fp(t(r[s],o[s]))}ql(e),a.push(e)}return l=Fp(l),this.calculateLosses().forEach((e=>{l=nc(l,e)})),l}),!0,i);return[o].concat(a)}}makeTestFunction(){this.testFunction=e=>Gl((()=>{const t=[];let n;const r=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let e=0;e<this.inputs.length;++e)a.push({key:this.inputs[e],value:r[e]});const i=new Nw(a),o=Tw(this.outputs,i);for(let e=0;e<this.lossFunctions.length;++e){const r=this.lossFunctions[e],a=Fp(r(s[e],o[e]));n=0===e?a:nc(n,a),t.push(n)}for(let e=0;e<this.metricsTensors.length;++e){const n=this.metricsTensors[e][0],r=this.metricsTensors[e][1],a=Fp(n(s[r],o[r]));t.push(a)}return t}))}async fit(e,t){let n,r,s,a,i,o,l,u,c,h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;try{const d=null==h.batchSize?32:h.batchSize;Vk(d);const p=!1,f=await this.standardizeUserData(e,t,h.sampleWeight,h.classWeight,p,d);n=f[0],r=f[1],c=f[2];let m,g=!1;if(null!=h.validationData&&h.validationData.length>0){if(g=!0,2!==h.validationData.length)throw 3===h.validationData.length?new $v("validationData including sample weights is not supported yet."):new Ev(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${h.validationData} is invalid.`);i=h.validationData[0],o=h.validationData[1];const e=!0,t=await this.standardizeUserData(i,o,null,null,e,d);l=t[0],u=t[1],m=l.concat(u)}else if(null!=h.validationSplit&&h.validationSplit>0&&h.validationSplit<1){g=!0;const e=Math.floor(n[0].shape[0]*(1-h.validationSplit)),t=n[0].shape[0];l=Wk(n,e,t),s=n,n=Wk(n,0,e),u=Wk(r,e,t),a=r,r=Wk(r,0,e),m=l.concat(u)}else null!=h.validationSteps&&(g=!0);const y=n.concat(r).concat(c);this.checkTrainableWeightsConsistency();const b=this.makeTrainFunction(),v=this.getDedupedMetricsNames();let x,w;g?(this.makeTestFunction(),x=this.testFunction,w=v.slice().concat(v.map((e=>"val_"+e)))):(x=null,m=[],w=v.slice());const k=Xw(h.callbacks,h.yieldEvery);return await this.fitLoop(b,y,v,d,h.epochs,h.verbose,k,x,m,h.shuffle,w,h.initialEpoch,null,null)}finally{this.isTraining=!1,Hk(n,e),Hk(r,t),Hk(s,e),Hk(a,t),Hk(l,i),Hk(u,o),null!=c&&Hl(c)}}async fitLoop(e,t,n,r,s,a,i,o,l,u,c,h,d,p){null==r&&(r=32),null==s&&(s=1),null==u&&(u=!0),null==h&&(h=0);let f=!1;if(null!=o&&null!=l&&(f=!0),null!=p&&(f=!0,null==d))throw new Ev("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const m=this.checkNumSamples(t,r,d,"steps_per_epoch");let g;null!=m&&(g=xx(0,m)),null==a&&(a=1);const{callbackList:y,history:b}=Yw(i,a,s,h,m,d,r,f,c);y.setModel(this),this.history=b,await y.onTrainBegin(),this.stopTraining_=!1;for(let v=h;v<s;++v){await y.onEpochBegin(v);const s={};if(null!=d)throw new $v("stepsPerEpoch mode is not implemented yet.");{if("batch"===u)throw new $v("batch shuffling is not implemneted yet");u&&pr(g);const a=Zf(g),i=jk(m,r);for(let u=0;u<i.length;++u){const c={};if(await y.onBatchBegin(u,c),Gl((()=>{const h=i[u][0],d=i[u][1],p=Ix(a,h,d-h);c.batch=u,c.size=d-h;const m=Uk(t,p),g=e(m);for(let e=0;e<n.length;++e){const t=n[e],r=g[e];c[t]=r,ql(r)}if(u===i.length-1&&f){const e=this.testLoop(o,l,r);for(let t=0;t<n.length;++t){const r=n[t],a=e[t];ql(a),s["val_"+r]=a}}})),await y.onBatchEnd(u,c),Ww(c),this.stopTraining_)break}a.dispose()}if(await y.onEpochEnd(v,s),this.stopTraining_)break}return await y.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return zk(this,e,t)}async trainOnBatch(e,t){const n=await this.standardizeUserData(e,t),r=n[0],s=n[1],a=this.makeTrainFunction()(r.concat(s)),i=[];for(const o of a){const e=await o.data();i.push(e[0])}return Hl(a),Hk(n[0],e),Hk(n[1],t),Mv(i)}getNamedWeights(e){const t=[],n=null!=e&&e.trainableOnly,r=n?this.trainableWeights:this.weights,s=this.getWeights(n);for(let a=0;a<r.length;++a)n&&!r[a].trainable||t.push({name:r[a].originalName,tensor:s[a]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const t=jl().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-jl().numTensors}return e}getLossIdentifiers(){let e;if("string"===typeof this.loss)e=Pv(this.loss);else if(Array.isArray(this.loss)){for(const e of this.loss)if("string"!==typeof e)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map((e=>Pv(e)))}else{const t=Object.keys(this.loss);e={};const n=this.loss;for(const r of t){if("string"!==typeof n[r])throw new Error("Serialization of non-string loss is not supported.");e[r]=Pv(n[r])}}return e}getMetricIdentifiers(){if("string"===typeof this.metrics||"function"===typeof this.metrics)return[Pv(xk(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map((e=>Pv(xk(e))));{const e={};for(const t in this.metrics)e[t]=Pv(xk(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const t=Zw(Ek(e.optimizer_config));let n,r;if("string"===typeof e.loss)n=zv(e.loss);else if(Array.isArray(e.loss))n=e.loss.map((e=>zv(e)));else if(null!=e.loss){n={};for(const t in e.loss)n[t]=zv(e.loss[t])}if(Array.isArray(e.metrics))r=e.metrics.map((e=>zv(e)));else if(null!=e.metrics){r={};for(const t in e.metrics)r[t]=zv(e.metrics[t])}this.compile({loss:n,metrics:r,optimizer:t})}async save(e,t){if("string"===typeof e){const t=yu(e);if(0===t.length)throw new Ev(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new Ev(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new Ev("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const n=await Yl(this.getNamedWeights(t)),r={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:`TensorFlow.js tfjs-layers v${Rk}`,convertedBy:null};if(null!=t&&t.includeOptimizer&&null!=this.optimizer){r.trainingConfig=this.getTrainingConfig();const e="optimizer",{data:t,specs:s}=await Yl(await this.optimizer.getWeights(),e);n.specs.push(...s),n.data=ou([n.data,t])}if(null!=this.userDefinedMetadata){const e=!0;kk(this.userDefinedMetadata,this.name,e),r.userDefinedMetadata=this.userDefinedMetadata}return r.weightData=n.data,r.weightSpecs=n.specs,e.save(r)}setUserDefinedMetadata(e){kk(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}Yk.className="Model",mc(Yk);class Zk extends Yk{}Zk.className="Functional",mc(Zk);class Jk extends Yk{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:tx("sequential_"),null!=e.layers)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some((e=>e<0)))throw new Ev(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof Jk||e instanceof Yk;let n;if(t){if(n=e,1!==n.outputs.length)throw new Ev("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new Ev("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new Ev("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const t=function(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new Ev("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let n=e.dtype;return null==n&&(n="float32"),new Sw({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(t)}if(t)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==e.inboundNodes.length)throw new Ev(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new Ev("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=kw(this.outputs[0])}this.inboundNodes=[],new vw({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Ov(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs[0].shape})}else{const t=e.apply(this.outputs[0]);if(Array.isArray(t))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[t],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if(cw(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Yk({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;this.built||this.build(),super.summary(e,t,n)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new Av("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new Av("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new Av("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new Av("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t){let n,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s={};if(t instanceof Array){if(null==t[0].className||"Merge"===t[0].className)throw new Ev("Legacy serialization format not supported yet.");n=t}else yr(null!=t.layers,(()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")),n=t.layers,delete t.layers,s=t;const a=new e(s);if(!(a instanceof Jk))throw new $v(`Sequential.fromConfig called on non-Sequential input: ${a}`);for(const i of n){const e=Zw(i,void 0,r);r&&e.setFastWeightInitDuringBuild(!0),a.add(e)}return a}set stopTraining(e){if(null==this.model)throw new Ev("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new Ev("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}}Jk.className="Sequential",mc(Jk);class eS extends pc{getConfig(){return{}}}class tS extends eS{apply(e){return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(1!==t)throw new $v(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return Ld(e)}(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:1)}}tS.className="elu",mc(tS);class nS extends eS{apply(e){return $f(e)}}nS.className="selu",mc(nS);class rS extends eS{apply(e){return wf(e)}}rS.className="relu",mc(rS);class sS extends eS{apply(e){return Gl((()=>zp(6,wf(e))))}}sS.className="relu6",mc(sS);class aS extends eS{apply(e){return e}}aS.className="linear",mc(aS);class iS extends eS{apply(e){return Yh(e)}}iS.className="sigmoid",mc(iS);class oS extends eS{apply(e){return function(e){return Gl((()=>{const t=nc(.5,ac(.2,e));return hd(t,0,1)}))}(e)}}oS.className="hardSigmoid",mc(oS);class lS extends eS{apply(e){return wp(e)}}lS.className="softplus",mc(lS);class uS extends eS{apply(e){return function(e){return Gl((()=>sc(e,nc(Sc(e),1))))}(e)}}uS.className="softsign",mc(uS);class cS extends eS{apply(e){return Jh(e)}}cS.className="tanh",mc(cS);class hS extends eS{apply(e){return Bf(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}}hS.className="softmax",mc(hS);class dS extends eS{apply(e){return Sp(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}}dS.className="logSoftmax",mc(dS);class pS extends eS{apply(e){return Gl((()=>Gl((()=>{const t=Math.sqrt(2),n=ac(.5,nc(1,zd(sc(e,t))));return ac(e,n)}))))}}pS.className="gelu",mc(pS);class fS extends eS{apply(e){return Gl((()=>ac(.5,ac(e,nc(1,Jh(ac(ic(sc(2,Math.PI)),nc(e,ac(.044715,xc(e,3))))))))))}}fS.className="gelu_new",mc(fS);class mS extends eS{apply(e){return Gl((()=>ac(e,Jh(wp(e)))))}}mS.className="mish",mc(mS);class gS extends eS{apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return Gl((()=>ac(Yh(ac(e,t)),e)))}}function yS(e){return e.getClassName()}function bS(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Uv(e,fc.getMap().classNameMap,t,"activation")}function vS(e){if(null==e){const e={className:"linear",config:{}};return bS(e)}if("string"===typeof e){const t={};return t.className=e,t.config={},bS(t)}return e instanceof eS?e:bS(e)}function xS(e){if(null!=e&&"object"!==typeof e)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}gS.className="swish",mc(gS);class wS extends pc{}class kS extends wS{constructor(e){super(),xS(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return Gl((()=>{let t=Mp([1]);return this.hasL1&&(t=nc(t,Qd(ac(this.l1,Sc(e))))),this.hasL2&&(t=nc(t,Qd(ac(this.l2,_x(e))))),Hh(t,[])}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}kS.className="L1L2",mc(kS);const SS={l1l2:"L1L2"};function NS(e){return Vv(e)}function IS(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Uv(e,fc.getMap().classNameMap,t,"regularizer")}function CS(e){if(null==e)return null;if("string"===typeof e){return IS({className:e in SS?SS[e]:e,config:{}})}return e instanceof wS?e:IS(e)}class TS extends ww{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,t){e=uw(e);let n=wf(e);return null!=this.maxValue&&(n=hd(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}TS.className="ReLU",mc(TS);class AS extends ww{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=uw(e);return pp(n,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}AS.className="LeakyReLU",mc(AS);class ES extends ww{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=iw(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=CS(e.alphaRegularizer),this.alphaConstraint=Bw(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!==typeof e.sharedAxes)throw new Ev(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){const t=(e=cw(e)).slice(1);if(null!=this.sharedAxes)for(const r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let r=1;r<e.length;++r)n[r]=e[r];this.inputSpec=[new gw({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=uw(e),nf(e,this.alpha.read())}getConfig(){const e={alphaInitializer:aw(this.alphaInitializer),alphaRegularizer:NS(this.alphaRegularizer),alphaConstraint:Pw(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}ES.className="PReLU",mc(ES);class $S extends ww{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new $v(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=uw(e);return Ld(n)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}$S.className="ELU",mc($S);class RS extends ww{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,t){const n=uw(e);return ac(n,Ju(op(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}RS.className="ThresholdedReLU",mc(RS);class DS extends ww{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new hS).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,t){return Gl((()=>{let n=uw(e);const r=t.mask;if(null!=r){const e=ac(wc(Lp(n.shape),Ju(r,n.dtype)),cc(-1e9));n=nc(n,e)}return this.axis instanceof Array?this.axis.length>1?ep(wc(n,Np(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)}))}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function OS(e,t,n){if("number"===typeof e)return Ov(e,t);if(e.length!==t)throw new Ev(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let s=0;s<t;++s){const a=e[s];if((r=a)!==parseInt(r.toString(),10))throw new Ev(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${a}`)}return e;var r}function _S(e,t,n,r){if(null==e)return e;let s;return s="same"===n?e:e-(t+(t-1)*((arguments.length>4&&void 0!==arguments[4]?arguments[4]:1)-1))+1,Math.floor((s+r-1)/r)}function FS(e,t,n,r){if(null==e)return null;if("valid"===r)e=e*t+vx([n-t,0]);else{if("same"!==r)throw new Ev(`Unsupport padding mode: ${r}.`);e*=t}return e}function MS(e,t){return Gl((()=>(lx(t),"channelsFirst"===t?ym(e,[0,2,3,1]):e)))}function LS(e,t){return Gl((()=>(lx(t),"channelsFirst"===t?ym(e,[0,2,3,4,1]):e)))}function PS(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",a=arguments.length>5?arguments[5]:void 0,i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1;return Gl((()=>{if(null==a&&(a="channelsLast"),lx(a),3!==e.shape.length)throw new Ev(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(3!==t.shape.length)throw new Ev(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=n&&1!==n.shape.length)throw new Ev(`The bias for a conv1dWithBias operation should be 1, but is ${n.shape.length} instead`);if("channelsFirst"===a&&(e=ym(e,[0,2,1])),"causal"===s)throw new $v("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=yd(e,t,r,"same"===s?"same":"valid","NWC",i);return null!=n&&(o=Mx(o,n)),o}))}function zS(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",a=arguments.length>5?arguments[5]:void 0,i=arguments.length>6?arguments[6]:void 0,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;return Gl((()=>{if(null==a&&(a="channelsLast"),lx(a),3!==e.rank&&4!==e.rank)throw new Ev(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(3!==t.rank&&4!==t.rank)throw new Ev(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=MS(e,a);if("causal"===s)throw new $v("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=Rm({x:l,filter:t,strides:r,pad:"same"===s?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),"channelsFirst"===a&&(l=ym(l,[0,3,1,2])),l}))}function BS(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1,1],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",a=arguments.length>5?arguments[5]:void 0,i=arguments.length>6?arguments[6]:void 0;return Gl((()=>{if(null==a&&(a="channelsLast"),lx(a),4!==e.rank&&5!==e.rank)throw new Ev(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(4!==t.rank&&5!==t.rank)throw new Ev(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=LS(e,a);if("causal"===s)throw new $v("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=xd(o,t,r,"same"===s?"same":"valid","NDHWC",i),null!=n&&(o=Mx(o,n)),"channelsFirst"===a&&(o=ym(o,[0,4,1,2,3])),o}))}DS.className="Softmax",mc(DS);class VS extends ww{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",VS.verifyArgs(t),this.rank=e,Xv(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new $v(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=OS(t.kernelSize,e,"kernelSize"),this.strides=OS(null==t.strides?1:t.strides,e,"strides"),this.padding=null==t.padding?"valid":t.padding,ux(this.padding),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,lx(this.dataFormat),this.activation=vS(t.activation),this.useBias=null==t.useBias||t.useBias,this.biasInitializer=iw(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Bw(t.biasConstraint),this.biasRegularizer=CS(t.biasRegularizer),this.activityRegularizer=CS(t.activityRegularizer),this.dilationRate=OS(null==t.dilationRate?1:t.dilationRate,e,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new Ev(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new Ev(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new Ev(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(e){if(_v("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!==typeof e.kernelSize&&!Kv(e.kernelSize,"number",1,3))throw new Ev(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:yS(this.activation),useBias:this.useBias,biasInitializer:aw(this.biasInitializer),biasRegularizer:NS(this.biasRegularizer),activityRegularizer:NS(this.activityRegularizer),biasConstraint:Pw(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class WS extends VS{constructor(e,t){super(e,t),this.kernel=null,WS.verifyArgs(t),this.filters=t.filters,Xv(this.filters,"filters"),this.kernelInitializer=iw(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Bw(t.kernelConstraint),this.kernelRegularizer=CS(t.kernelRegularizer)}build(e){e=cw(e);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new Ev(`The channel dimension of the input should be defined. Found ${e[t]}`);const n=e[t],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return Gl((()=>{let t;e=uw(e);const n=null==this.bias?null:this.bias.read(),r=Yv(this.activation.getClassName());if(null!=r&&2===this.rank)t=zS(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(1===this.rank)t=PS(e,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)t=zS(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new $v("convolutions greater than 3D are not implemented yet.");t=BS(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(t=this.activation.apply(t))}return t}))}computeOutputShape(e){e=cw(e);const t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let s=0;s<n.length;++s){const e=_S(n[s],this.kernelSize[s],this.padding,this.strides[s],"number"===typeof this.dilationRate?this.dilationRate:this.dilationRate[s]);t.push(e)}let r=[e[0]];return"channelsLast"===this.dataFormat?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){const e={filters:this.filters,kernelInitializer:aw(this.kernelInitializer),kernelRegularizer:NS(this.kernelRegularizer),kernelConstraint:Pw(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||"number"!==typeof e.filters||e.filters<1)throw new Ev(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class US extends WS{constructor(e){super(2,e),US.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&!Kv(e.kernelSize,"number",1,2))throw new Ev(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}US.className="Conv2D",mc(US);class jS extends WS{constructor(e){super(3,e),jS.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new Ev(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}jS.className="Conv3D",mc(jS);class GS extends US{constructor(e){if(super(e),this.inputSpec=[new gw({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new Ev(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=cw(e)).length)throw new Ev("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new Ev("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new gw({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return Gl((()=>{let t=uw(e);if(4!==t.shape.length)throw new Ev(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape,r=n[0];let s,a;"channelsFirst"===this.dataFormat?(s=2,a=3):(s=1,a=2);const i=n[s],o=n[a],l=this.kernelSize[0],u=this.kernelSize[1],c=this.strides[0],h=this.strides[1],d=[r,FS(i,c,l,this.padding),FS(o,h,u,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=ym(t,[0,2,3,1]));let p=vd(t,this.kernel.read(),d,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(p=ym(p,[0,3,1,2])),null!=this.bias&&(p=Mx(p,this.bias.read(),this.dataFormat)),null!=this.activation&&(p=this.activation.apply(p)),p}))}computeOutputShape(e){const t=(e=cw(e)).slice();let n,r,s;"channelsFirst"===this.dataFormat?(n=1,r=2,s=3):(n=3,r=1,s=2);const a=this.kernelSize[0],i=this.kernelSize[1],o=this.strides[0],l=this.strides[1];return t[n]=this.filters,t[r]=FS(t[r],o,a,this.padding),t[s]=FS(t[s],l,i,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}GS.className="Conv2DTranspose",mc(GS);class HS extends jS{constructor(e){if(super(e),this.inputSpec=[new gw({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new Ev(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=cw(e)).length)throw new Ev("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new Ev("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new gw({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return Gl((()=>{let t=uw(e);if(5!==t.shape.length)throw new Ev(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape,r=n[0];let s,a,i;"channelsFirst"===this.dataFormat?(i=2,s=3,a=4):(i=1,s=2,a=3);const o=n[i],l=n[s],u=n[a],c=this.kernelSize[0],h=this.kernelSize[1],d=this.kernelSize[2],p=this.strides[0],f=this.strides[1],m=this.strides[2],g=[r,FS(o,p,c,this.padding),FS(l,f,h,this.padding),FS(u,m,d,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=ym(t,[0,2,3,4,1]));let y=kd(t,this.kernel.read(),g,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(y=ym(y,[0,4,1,2,3])),null!==this.bias&&(y=Mx(y,this.bias.read(),this.dataFormat)),null!==this.activation&&(y=this.activation.apply(y)),y}))}computeOutputShape(e){const t=(e=cw(e)).slice();let n,r,s,a;"channelsFirst"===this.dataFormat?(n=1,r=2,s=3,a=4):(n=4,r=1,s=2,a=3);const i=this.kernelSize[0],o=this.kernelSize[1],l=this.kernelSize[2],u=this.strides[0],c=this.strides[1],h=this.strides[2];return t[n]=this.filters,t[r]=FS(t[r],u,i,this.padding),t[s]=FS(t[s],c,o,this.padding),t[a]=FS(t[a],h,l,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}HS.className="Conv3DTranspose",mc(HS);class qS extends WS{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new Ev("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new Ev("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new Ev(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=iw(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=CS(t.depthwiseRegularizer),this.depthwiseConstraint=Bw(t.depthwiseConstraint),this.pointwiseInitializer=iw(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=CS(t.pointwiseRegularizer),this.pointwiseConstraint=Bw(t.pointwiseConstraint)}build(e){if((e=cw(e)).length<this.rank+2)throw new Ev(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new Ev(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const n=e[t],r=this.kernelSize.concat([n,this.depthMultiplier]),s=[];for(let i=0;i<this.rank;++i)s.push(1);s.push(n*this.depthMultiplier,this.filters);const a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",s,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):this.bias=null,this.inputSpec=[new gw({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return Gl((()=>{let t;if(e=uw(e),1===this.rank)throw new $v("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=ym(e,[0,2,3,1])),t=Rf(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(t=Mx(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),"channelsFirst"===this.dataFormat&&(t=ym(t,[0,3,1,2])),t}))}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=aw(this.depthwiseInitializer),e.pointwiseInitializer=aw(this.pointwiseInitializer),e.depthwiseRegularizer=NS(this.depthwiseRegularizer),e.pointwiseRegularizer=NS(this.pointwiseRegularizer),e.depthwiseConstraint=Pw(this.depthwiseConstraint),e.pointwiseConstraint=Pw(this.pointwiseConstraint),e}}qS.className="SeparableConv";class KS extends qS{constructor(e){super(2,e)}}KS.className="SeparableConv2D",mc(KS);class XS extends WS{constructor(e){super(1,e),XS.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&!Kv(e.kernelSize,"number",1,1))throw new Ev(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}XS.className="Conv1D",mc(XS);class QS extends ww{constructor(e){super(e),"number"===typeof e.cropping?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"===typeof e.cropping[0]?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return Gl((()=>{if(e=uw(e),"channelsLast"===this.dataFormat){const t=Tx(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Tx(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const t=Tx(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Tx(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}QS.className="Cropping2D",mc(QS);class YS extends ww{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,lx(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,function(e){qv(rx,"InterpolationFormat",e)}(this.interpolation)}computeOutputShape(e){if("channelsFirst"===this.dataFormat){const t=null==e[2]?null:this.size[0]*e[2],n=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,n]}{const t=null==e[1]?null:this.size[0]*e[1],n=null==e[2]?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return Gl((()=>{let t=uw(e);const n=t.shape;if("channelsFirst"===this.dataFormat){t=ym(t,[0,2,3,1]);const e=this.size[0]*n[2],r=this.size[1]*n[3],s="nearest"===this.interpolation?Fg.resizeNearestNeighbor(t,[e,r]):Fg.resizeBilinear(t,[e,r]);return ym(s,[0,3,1,2])}{const e=this.size[0]*n[1],r=this.size[1]*n[2];return"nearest"===this.interpolation?Fg.resizeNearestNeighbor(t,[e,r]):Fg.resizeBilinear(t,[e,r])}}))}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}YS.className="UpSampling2D",mc(YS);class ZS extends VS{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=iw(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Bw(e.depthwiseConstraint),this.depthwiseRegularizer=CS(e.depthwiseRegularizer)}build(e){if((e=cw(e)).length<4)throw new Ev(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new Ev(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Gl((()=>{let t=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[1,1],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"valid",s=arguments.length>4?arguments[4]:void 0,a=arguments.length>5?arguments[5]:void 0;return Gl((()=>{null==s&&(s="channelsLast"),lx(s);let i=MS(e,s);if(4!==e.rank)throw new Ev(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(4!==t.rank)throw new Ev(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=Ed(i,t,n,"same"===r?"same":"valid","NHWC",a),"channelsFirst"===s&&(i=ym(i,[0,3,1,2])),i}))}(e=uw(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(t=Mx(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),t}))}computeOutputShape(e){e=cw(e);const t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,s=_S(t,this.kernelSize[0],this.padding,this.strides[0]),a=_S(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],r,s,a]:[e[0],s,a,r]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=aw(this.depthwiseInitializer),e.depthwiseRegularizer=NS(this.depthwiseRegularizer),e.depthwiseConstraint=Pw(this.depthwiseRegularizer),e}}function JS(e,t,n,r){if(Array.isArray(e)){if(null!=t||null!=n)throw new Ev("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function s(e){return null==e||Array.isArray(e)?e:[e]}return{inputs:e,initialState:t=s(t),constants:n=s(n)}}function eN(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4?arguments[4]:void 0,a=arguments.length>5?arguments[5]:void 0,i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]&&arguments[7];return Gl((()=>{const l=t.shape.length;if(l<3)throw new Ev(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat(xx(2,l));if(t=ym(t,u),null!=a)throw new $v("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=s&&(s=Ju(Ju(s,"bool"),"float32"),s.rank===l-1&&(s=tp(s,-1)),s=ym(s,u)),r&&(t=Sf(t,0),null!=s&&(s=Sf(s,0)));const c=[];let h,d=n;const p=t.shape[0],f=hm(t);let m,g;null!=s&&(m=hm(s));for(let t=0;t<p;++t){const n=f[t],r=Gl((()=>e(n,d)));if(null==s)h=r[0],d=r[1];else{const e=Gl((()=>{const e=m[t],n=wc(qp(e),e),s=nc(ac(r[0],e),ac(d[0],n)),a=d.map(((t,s)=>nc(ac(r[1][s],e),ac(t,n))));return{output:s,newStates:a}}));h=e.output,d=e.newStates}o&&c.push(h)}if(o){g=Kf(c,1)}return[h,g,d]}))}ZS.className="DepthwiseConv2D",mc(ZS);class tN extends ww{constructor(e){let t;if(super(e),null==e.cell)throw new Ev("cell property is missing for the constructor of RNN.");if(t=Array.isArray(e.cell)?new uN({cells:e.cell}):e.cell,null==t.stateSize)throw new Ev("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new gw({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(null==this.states_){return xx(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map((e=>null))}return this.states_}setStates(e){this.states_=e}computeOutputShape(e){ow(e)&&(e=e[0]);let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const n=t[0];let r;if(r=this.returnSequences?[e[0],e[1],n]:[e[0],n],this.returnState){const n=[];for(const r of t)n.push([e[0],r]);return[r].concat(n)}return r}computeMask(e,t){return Gl((()=>{Array.isArray(t)&&(t=t[0]);const e=this.returnSequences?t:null;if(this.returnState){const t=this.states.map((e=>null));return[e].concat(t)}return e}))}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new $v("Constants support is not implemented in RNN yet.");ow(e)&&(e=e[0]);const t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new gw({shape:[t,null,...n]});const r=[e[0]].concat(e.slice(2));let s;if(this.cell.build(r),s=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!wr(this.stateSpec.map((e=>e.shape[e.shape.length-1])),s))throw new Ev(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=s.map((e=>new gw({shape:[null,e]})));this.stateful&&this.resetStates()}resetStates(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];Gl((()=>{if(!this.stateful)throw new Tv("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new Ev("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>Mp([n,e]))):this.states_=[Mp([n,this.cell.stateSize])];else if(null==e)Hl(this.states_),null!=this.keptStates&&(Hl(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>Mp([n,e]))):this.states_[0]=Mp([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new Ev(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===t?this.keptStates.push(this.states_.slice()):Hl(this.states_);for(let t=0;t<this.states_.length;++t){const r=e[t],s=Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize,a=[n,s];if(!wr(r.shape,a))throw new Ev(`State ${t} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${r.shape}`);this.states_[t]=r}}this.states_=this.states_.map((e=>ql(e.clone())))}))}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});const s=JS(e,n,r,this.numConstants);e=s.inputs,n=s.initialState,r=s.constants;let a=[],i=[];if(null!=n){t.initialState=n,a=a.concat(n),this.stateSpec=[];for(const e of n)this.stateSpec.push(new gw({shape:e.shape}));i=i.concat(this.stateSpec)}null!=r&&(t.constants=r,a=a.concat(r),this.numConstants=r.length);if(a[0]instanceof yw){const n=[e].concat(a),r=this.inputSpec.concat(i),s=this.inputSpec;this.inputSpec=r;const o=super.apply(n,t);return this.inputSpec=s,o}return super.apply(e,t)}call(e,t){return Gl((()=>{const n=null==t?null:t.mask,r=null==t?null:t.training;let s=null==t?null:t.initialState;e=uw(e),null==s&&(s=this.stateful?this.states_:this.getInitialState(e));const a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==a)throw new Ev(`RNN Layer has ${a} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const i={training:r},o=eN(((e,t)=>{const n=this.cell.call([e].concat(t),i);return[n[0],n.slice(1)]}),e,s,this.goBackwards,n,null,this.unroll,this.returnSequences),l=o[0],u=o[1],c=o[2];this.stateful&&this.resetStates(c,r);const h=this.returnSequences?u:l;return this.returnState?[h].concat(c):h}))}getInitialState(e){return Gl((()=>{let t=Mp(e.shape);return t=Qd(t,[1,2]),t=Nx(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map((e=>e>1?$x(t,[1,e]):t)):this.cell.stateSize>1?[$x(t,[1,this.cell.stateSize])]:[t]}))}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===tN.className&&(t.cell={className:this.cell.getClassName(),config:n}),Object.assign(Object.assign(Object.assign({},n),e),t)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=Zw(t.cell,n);return new e(Object.assign(t,{cell:r}))}}tN.className="RNN",mc(tN);class nN extends ww{}class rN extends nN{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Xv(this.units,"units"),this.activation=vS(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=iw(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=iw(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=iw(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=CS(e.kernelRegularizer),this.recurrentRegularizer=CS(e.recurrentRegularizer),this.biasRegularizer=CS(e.biasRegularizer),this.kernelConstraint=Bw(e.kernelConstraint),this.recurrentConstraint=Bw(e.recurrentConstraint),this.biasConstraint=Bw(e.biasConstraint),this.dropout=bx([1,vx([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=bx([1,vx([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=cw(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Gl((()=>{if(2!==e.length)throw new Ev(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];const r=null!=t.training&&t.training;let s;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=cN({ones:()=>qp(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=cN({ones:()=>qp(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,i=this.recurrentDropoutMask;s=Dx(null!=a?ac(e,a):e,this.kernel.read()),null!=this.bias&&(s=Mx(s,this.bias.read())),null!=i&&(n=ac(n,i));let o=nc(s,Dx(n,this.recurrentKernel.read()));return null!=this.activation&&(o=this.activation.apply(o)),[o,o]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:yS(this.activation),useBias:this.useBias,kernelInitializer:aw(this.kernelInitializer),recurrentInitializer:aw(this.recurrentInitializer),biasInitializer:aw(this.biasInitializer),kernelRegularizer:NS(this.kernelRegularizer),recurrentRegularizer:NS(this.recurrentRegularizer),biasRegularizer:NS(this.biasRegularizer),activityRegularizer:NS(this.activityRegularizer),kernelConstraint:Pw(this.kernelConstraint),recurrentConstraint:Pw(this.recurrentConstraint),biasConstraint:Pw(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}rN.className="SimpleRNNCell",mc(rN);class sN extends tN{constructor(e){e.cell=new rN(e),super(e)}call(e,t){return Gl((()=>{null!=this.cell.dropoutMask&&(Hl(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Hl(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})}))}static fromConfig(e,t){return new e(t)}}sN.className="SimpleRNN",mc(sN);class aN extends nN{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new Ev("GRUCell does not support reset_after parameter set to true.");this.units=e.units,Xv(this.units,"units"),this.activation=vS(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=vS(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=iw(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=iw(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=iw(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=CS(e.kernelRegularizer),this.recurrentRegularizer=CS(e.recurrentRegularizer),this.biasRegularizer=CS(e.biasRegularizer),this.kernelConstraint=Bw(e.kernelConstraint),this.recurrentConstraint=Bw(e.recurrentConstraint),this.biasConstraint=Bw(e.biasConstraint),this.dropout=bx([1,vx([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=bx([1,vx([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){const t=(e=cw(e))[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Gl((()=>{if(2!==e.length)throw new Ev(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const n=null!=t.training&&t.training;let r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=cN({ones:()=>qp(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=cN({ones:()=>qp(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,a=this.recurrentDropoutMask;let i,o,l;0<this.dropout&&this.dropout<1&&(e=ac(e,s[0]));let u=Dx(e,this.kernel.read());this.useBias&&(u=Mx(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=ac(r,a[0]));const c=this.recurrentKernel.read(),[h,d]=jf(c,[2*this.units,this.units],c.rank-1),p=Dx(r,h),[f,m,g]=jf(u,3,u.rank-1),[y,b]=jf(p,2,p.rank-1);i=this.recurrentActivation.apply(nc(f,y)),o=this.recurrentActivation.apply(nc(m,b));const v=Dx(ac(o,r),d);l=this.activation.apply(nc(g,v));const x=nc(ac(i,r),ac(nc(1,xp(i)),l));return[x,x]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:yS(this.activation),recurrentActivation:yS(this.recurrentActivation),useBias:this.useBias,kernelInitializer:aw(this.kernelInitializer),recurrentInitializer:aw(this.recurrentInitializer),biasInitializer:aw(this.biasInitializer),kernelRegularizer:NS(this.kernelRegularizer),recurrentRegularizer:NS(this.recurrentRegularizer),biasRegularizer:NS(this.biasRegularizer),activityRegularizer:NS(this.activityRegularizer),kernelConstraint:Pw(this.kernelConstraint),recurrentConstraint:Pw(this.recurrentConstraint),biasConstraint:Pw(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}aN.className="GRUCell",mc(aN);class iN extends tN{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new aN(e),super(e)}call(e,t){return Gl((()=>{null!=this.cell.dropoutMask&&(Hl(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Hl(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}iN.className="GRU",mc(iN);class oN extends nN{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Xv(this.units,"units"),this.activation=vS(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=vS(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=iw(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=iw(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=iw(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=CS(e.kernelRegularizer),this.recurrentRegularizer=CS(e.recurrentRegularizer),this.biasRegularizer=CS(e.biasRegularizer),this.kernelConstraint=Bw(e.kernelConstraint),this.recurrentConstraint=Bw(e.recurrentConstraint),this.biasConstraint=Bw(e.biasConstraint),this.dropout=bx([1,vx([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=bx([1,vx([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;const n=(e=cw(e))[e.length-1];let r;if(this.kernel=this.addWeight("kernel",[n,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const e=this.biasInitializer,n=this.units;r=new((t=class extends Vx{apply(t,r){const s=e.apply([n]),a=(new Ux).apply([n]),i=e.apply([2*n]);return Ex(Ex(s,a),i)}}).className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return Gl((()=>{const n=null!=t.training&&t.training;if(3!==e.length)throw new Ev(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1];const s=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=cN({ones:()=>qp(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=cN({ones:()=>qp(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,i=this.recurrentDropoutMask;let o,l,u,c;0<this.dropout&&this.dropout<1&&(e=ac(e,a[0]));let h=Dx(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=ac(r,i[0])),h=nc(h,Dx(r,this.recurrentKernel.read())),this.useBias&&(h=Mx(h,this.bias.read()));const[d,p,f,m]=jf(h,4,h.rank-1);o=this.recurrentActivation.apply(d),l=this.recurrentActivation.apply(p),u=nc(ac(l,s),ac(o,this.activation.apply(f))),c=this.recurrentActivation.apply(m);const g=ac(c,this.activation.apply(u));return[g,g,u]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:yS(this.activation),recurrentActivation:yS(this.recurrentActivation),useBias:this.useBias,kernelInitializer:aw(this.kernelInitializer),recurrentInitializer:aw(this.recurrentInitializer),biasInitializer:aw(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:NS(this.kernelRegularizer),recurrentRegularizer:NS(this.recurrentRegularizer),biasRegularizer:NS(this.biasRegularizer),activityRegularizer:NS(this.activityRegularizer),kernelConstraint:Pw(this.kernelConstraint),recurrentConstraint:Pw(this.recurrentConstraint),biasConstraint:Pw(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}oN.className="LSTMCell",mc(oN);class lN extends tN{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new oN(e),super(e)}call(e,t){return Gl((()=>{null!=this.cell.dropoutMask&&(Hl(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Hl(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}lN.className="LSTM",mc(lN);class uN extends nN{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return Gl((()=>{let n=e.slice(1);const r=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?r.push(n.splice(0,e.stateSize.length)):r.push(n.splice(0,1));r.reverse();const s=[];let a;for(let i=0;i<this.cells.length;++i){const o=this.cells[i];n=r[i],a=0===i?[e[0]].concat(n):[a[0]].concat(n),a=o.call(a,t),s.push(a.slice(1))}n=[];for(const e of s.slice().reverse())n.push(...e);return[a[0]].concat(n)}))}build(e){let t;ow(e)&&(e=e[0]),this.cells.forEach(((n,r)=>{dx(`RNNCell_${r}`,(()=>{n.build(e),t=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,e=[e[0],t]}))})),this.built=!0}getConfig(){const e=super.getConfig(),t={cells:this.cells.map((e=>({className:e.getClassName(),config:e.getConfig()})))};return Object.assign(Object.assign({},e),t)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=[];for(const s of t.cells)r.push(Zw(s,n));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return fw(e)}setWeights(e){const t=[];for(const n of this.cells){const r=n.weights.length,s=e.splice(r);for(let e=0;e<n.weights.length;++e)t.push([n.weights[e],s[e]])}mw(t)}}function cN(e){const{ones:t,rate:n,training:r=!1,count:s=1,dropoutFunc:a}=e,i=()=>null!=a?a(t(),n):Lx(t(),n),o=()=>Px(i,t,r);if(!s||s<=1)return ql(o().clone());return Array(s).fill(void 0).map(o).map((e=>ql(e.clone())))}uN.className="StackedRNNCells",mc(uN);var hN=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"===typeof Object.getOwnPropertySymbols){var s=0;for(r=Object.getOwnPropertySymbols(e);s<r.length;s++)t.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(e,r[s])&&(n[r[s]]=e[r[s]])}return n};class dN extends tN{constructor(e){if(e.unroll)throw new $v("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new $v("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new gw({ndim:5})]}call(e,t){return Gl((()=>{if(null!=this.cell.dropoutMask&&(Hl(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Hl(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new Ev("ConvRNN2D cell does not support constants");const n=null==t?null:t.mask,r=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})}))}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return Gl((()=>{const{stateSize:t}=this.cell,n=e.shape,r=this.computeSingleOutputShape(n),s=Mp([r[0],...r.slice(2)]);return Array.isArray(t)?Array(t.length).fill(s):[s]}))}resetStates(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];Gl((()=>{if(!this.stateful)throw new Tv("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),s=[r[0],...r.slice(2)];if(null==n[0])throw new Ev("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>Mp(s))):this.states_=[Mp(s)];else if(null==e)Hl(this.states_),null!=this.keptStates&&(Hl(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>Mp(s))):this.states_[0]=Mp(s);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new Ev(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):Hl(this.states_);for(let t=0;t<this.states_.length;++t){const n=e[t],r=s;if(!wr(n.shape,r))throw new Ev(`State ${t} is incompatible with layer ${this.name}: expected shape=${r}, received shape=${n.shape}`);this.states_[t]=n}}this.states_=this.states_.map((e=>ql(e.clone())))}))}computeSingleOutputShape(e){const{dataFormat:t,filters:n,kernelSize:r,padding:s,strides:a,dilationRate:i}=this.cell,o="channelsFirst"===t,l=e[o?3:2],u=e[o?4:3],c=_S(l,r[0],s,a[0],i[0]),h=_S(u,r[1],s,a[1],i[1]);return[...e.slice(0,2),...o?[n,c,h]:[c,h,n]]}}dN.className="ConvRNN2D";class pN extends oN{constructor(e){const{filters:t,kernelSize:n,strides:r,padding:s,dataFormat:a,dilationRate:i}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,Xv(this.filters,"filters"),this.kernelSize=OS(n,2,"kernelSize"),this.kernelSize.forEach((e=>Xv(e,"kernelSize"))),this.strides=OS(r||1,2,"strides"),this.strides.forEach((e=>Xv(e,"strides"))),this.padding=s||"valid",ux(this.padding),this.dataFormat=a||"channelsLast",lx(this.dataFormat),this.dilationRate=OS(i||1,2,"dilationRate"),this.dilationRate.forEach((e=>Xv(e,"dilationRate")))}build(e){var t;e=cw(e);const n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new Ev(`The channel dimension of the input should be defined. Found ${e[n]}`);const r=e[n],s=this.kernelSize.concat([r,4*this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const a=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",a,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){const n=this.biasInitializer,r=this.filters;e=new((t=class extends Vx{apply(e,t){return Ax([n.apply([r]),Lp([r]),n.apply([2*r])])}}).className="CustomInit",t)}else e=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return Gl((()=>{if(3!==e.length)throw new Ev(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const n=t.training||!1,r=e[0],s=e[1],a=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=cN({ones:()=>qp(r),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,o=(e,t,n)=>t&&t[n]?ac(t[n],e):e;let l=o(r,i,0),u=o(r,i,1),c=o(r,i,2),h=o(r,i,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=cN({ones:()=>qp(s),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const d=this.recurrentDropoutMask;let p=o(s,d,0),f=o(s,d,1),m=o(s,d,2),g=o(s,d,3);const[y,b,v,x]=jf(this.kernel.read(),4,3),[w,k,S,N]=this.useBias?jf(this.bias.read(),4):[null,null,null,null];l=this.inputConv(l,y,w,this.padding),u=this.inputConv(u,b,k,this.padding),c=this.inputConv(c,v,S,this.padding),h=this.inputConv(h,x,N,this.padding);const[I,C,T,A]=jf(this.recurrentKernel.read(),4,3);p=this.recurrentConv(p,I),f=this.recurrentConv(f,C),m=this.recurrentConv(m,T),g=this.recurrentConv(g,A);const E=this.recurrentActivation.apply(nc(l,p)),$=this.recurrentActivation.apply(nc(u,f)),R=nc(ac($,a),ac(E,this.activation.apply(nc(c,m)))),D=ac(this.recurrentActivation.apply(nc(h,g)),this.activation.apply(R));return[D,D,R]}))}getConfig(){const e=super.getConfig(),{units:t}=e,n=hN(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),r)}inputConv(e,t,n,r){const s=gd(e,t,this.strides,r||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?Mx(s,n,this.dataFormat):s}recurrentConv(e,t){return gd(e,t,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}pN.className="ConvLSTM2DCell",mc(pN);class fN extends dN{constructor(e){const t=new pN(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}fN.className="ConvLSTM2D",mc(fN);class mN extends ww{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const t=e.shape,n=[];for(let r=0;r<this.noiseShape.length;++r)n.push(null==this.noiseShape[r]?t[r]:this.noiseShape[r]);return n}call(e,t){return Gl((()=>{this.invokeCallHook(e,t);const n=uw(e);if(0<this.rate&&this.rate<1){const e=null!=t.training&&t.training,r=this.getNoiseShape(n);return Px((()=>Lx(n,this.rate,r,this.seed)),(()=>n),e)}return e}))}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}mN.className="Dropout",mc(mN);class gN extends mN{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}gN.className="SpatialDropout1D",mc(gN);class yN extends ww{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,Xv(this.units,"units"),this.activation=vS(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=iw(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=iw(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Bw(e.kernelConstraint),this.biasConstraint=Bw(e.biasConstraint),this.kernelRegularizer=CS(e.kernelRegularizer),this.biasRegularizer=CS(e.biasRegularizer),this.activityRegularizer=CS(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const t=(e=cw(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){const t=(e=cw(e)).slice();return t[t.length-1]=this.units,t}call(e,t){return Gl((()=>{this.invokeCallHook(e,t);const n=uw(e),r=Yv(this.activation.getClassName());let s;return null!=r?s=Dx(n,this.kernel.read(),r,this.bias?this.bias.read():null):(s=Dx(n,this.kernel.read()),null!=this.bias&&(s=Mx(s,this.bias.read())),null!=this.activation&&(s=this.activation.apply(s))),s}))}getConfig(){const e={units:this.units,activation:yS(this.activation),useBias:this.useBias,kernelInitializer:aw(this.kernelInitializer),biasInitializer:aw(this.biasInitializer),kernelRegularizer:NS(this.kernelRegularizer),biasRegularizer:NS(this.biasRegularizer),activityRegularizer:NS(this.activityRegularizer),kernelConstraint:Pw(this.kernelConstraint),biasConstraint:Pw(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}yN.className="Dense",mc(yN);class bN extends ww{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=cw(e);for(const t of e.slice(1))if(null==t)throw new Ev(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],yx(e,1)]}call(e,t){return Gl((()=>{this.invokeCallHook(e,t);let n=uw(e);if("channelsFirst"===this.dataFormat&&n.rank>1){const e=[0];for(let t=2;t<n.rank;++t)e.push(t);e.push(1),n=ym(n,e)}return function(e){if(e.rank<=1)throw new Ev(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);const t=[e.shape[0],yx(e.shape,1)];return Hh(e,t)}(n)}))}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}bN.className="Flatten",mc(bN);class vN extends ww{constructor(e){super(e),this.supportsMasking=!0,this.activation=vS(e.activation)}call(e,t){return Gl((()=>{this.invokeCallHook(e,t);const n=uw(e);return this.activation.apply(n)}))}getConfig(){const e={activation:yS(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}vN.className="Activation",mc(vN);class xN extends ww{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return Gl((()=>function(e,t){return Gl((()=>{if(2!==e.shape.length)throw new Ev(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);return $x(Nx(e,1),[1,t,1])}))}(e=uw(e),this.n)))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}xN.className="RepeatVector",mc(xN);class wN extends ww{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,t){const n="Total size of new array must be unchanged.",r=t.slice();let s=1,a=null;for(let o=0;o<r.length;++o){const e=r[o];if(this.isUnknown(e)){if(null!==a)throw new Ev("Can only specifiy one unknown dimension.");a=o}else s*=e}const i=yx(e);if(null!==a){if(0===s||i%s!==0)throw new Ev(n);r[a]=i/s}else if(i!==s)throw new Ev(n);return r}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return Gl((()=>{this.invokeCallHook(e,t);const n=uw(e),r=n.shape,s=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return Hh(n,s)}))}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}wN.className="Reshape",mc(wN);class kN extends ww{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=xx(1,e.dims.length+1);if(!wr(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new gw({ndim:this.dims.length+1})]}computeOutputShape(e){const t=(e=cw(e)).slice();return this.dims.forEach(((n,r)=>{t[r+1]=e[n]})),t}call(e,t){return ym(uw(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}kN.className="Permute",mc(kN);class SN extends ww{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const n=uw(e);return Sh(Gp(n,this.maskValue),-1)}call(e,t){return Gl((()=>{this.invokeCallHook(e,t);const n=uw(e),r=Sh(Gp(n,this.maskValue),-1,!0);return ac(n,Ju(r,n.dtype))}))}}SN.className="Masking",mc(SN);class NN extends ww{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),null==e.inputLength?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(Lv(e.inputLength))}this.inputDim=e.inputDim,Xv(this.inputDim,"inputDim"),this.outputDim=e.outputDim,Xv(this.outputDim,"outputDim"),this.embeddingsInitializer=iw(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=CS(e.embeddingsRegularizer),this.activityRegularizer=CS(e.activityRegularizer),this.embeddingsConstraint=Bw(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return Gl((()=>this.maskZero?(e=uw(e),Gp(e,lc(e))):null))}computeOutputShape(e){if(e=cw(e),null==this.inputLength)return[...e,this.outputDim];const t=Lv(this.inputLength);if(t.length!==e.length-1)throw new Ev(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let r=0;r<t.length;++r){const s=t[r],a=e[r+1];if(null!=s&&null!=a&&s!==a)throw new Ev(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==s&&(t[n]=a),n++}}return[e[0],...t,this.outputDim]}call(e,t){return Gl((()=>{this.invokeCallHook(e,t);let n=uw(e);"int32"!==n.dtype&&(n=Sx(n,"int32"));const r=Ox(this.embeddings.read(),Hh(n,[n.size]));return Hh(r,cw(this.computeOutputShape(n.shape)))}))}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:aw(this.embeddingsInitializer),embeddingsRegularizer:NS(this.embeddingsRegularizer),activityRegularizer:NS(this.activityRegularizer),embeddingsConstraint:Pw(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}NN.className="Embedding",mc(NN);class IN extends ww{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new $v}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;const n=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){const s=e[e.length-t.length+r],a=t[r];if(null==s||null==a||s<0||a<0)n.push(null);else if(1===s)n.push(a);else if(1===a)n.push(s);else{if(s!==a)throw new Ev("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(s)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[cw(e)]),e.length<2)throw new Ev(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const s of e)null!=s&&null!==s[0]&&t.push(s[0]);if(t=Gv(t),t.length>1)throw new Ev(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=null==e[0]?null:e[0].slice(1);for(let s=1;s<e.length;++s){const t=null==e[s]?null:e[s].slice(1);n=this.computeElementwiseOpOutputShape(n,t)}const r=e.map((e=>e.length));-1===e.indexOf(null)&&1===Gv(r).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return Gl((()=>{if(this.reshapeRequired){const t=[],n=e.map((e=>e.rank));if(-1===n.indexOf(null)){const r=vx(n);for(let n of e){const e=n.rank;for(let t=0;t<r-e;++t)n=Nx(n,1);t.push(n)}return this.mergeFunction(t)}{let n=!1;for(const a of e){const e=a.rank;if(null==e){const e=a.shape,r=e[0],s=e.slice(1).concat([r]);let i=Hh(a,[r].concat(yx(e.slice(1))));i=ym(i,[1,0]),i=Hh(i,s),t.push(i),n=!0}else if(e>1){const r=xx(1,e).concat([0]);t.push(ym(a,r)),n=!0}else t.push(a)}let r=this.mergeFunction(t);const s=r.rank;if(n)if(null==s){const e=r.shape,t=e[e.length-1],n=[t].concat(e.slice(0,e.length-1));r=Hh(ym(Hh(r,[-1,t]),[1,0]),n)}else if(s>1){const e=[s-1].concat(xx(0,s-1));r=ym(r,e)}return r}}return this.mergeFunction(e)}))}computeOutputShape(e){let t;t=null==e[0]?null:e[0].slice(1);for(let r=1;r<e.length;++r){const n=null==e[r]?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,n)}let n=[];for(const r of e)null!=r&&null!==r[0]&&n.push(r[0]);return n=Gv(n),t=1===n.length?n.concat(t):[null].concat(t),t}computeMask(e,t){return Gl((()=>{if(null==t)return null;if(!Array.isArray(t))throw new Ev("`mask` should be an Array");if(!Array.isArray(e))throw new Ev("`inputs` should be an Array");if(t.length!==e.length)throw new Ev(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every((e=>null==e)))return null;let n=(t=t.map((e=>null==e?e:tp(e,0))))[0];for(let e=1;e<t.length-1;++e)n=Ip(n,t[e]);return n}))}}class CN extends IN{constructor(e){super(e)}mergeFunction(e){return Gl((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=nc(t,e[n]);return t}))}}CN.className="Add",mc(CN);class TN extends IN{constructor(e){super(e)}mergeFunction(e){return Gl((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=ac(t,e[n]);return t}))}}TN.className="Multiply",mc(TN);class AN extends IN{constructor(e){super(e)}mergeFunction(e){return Gl((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=nc(t,e[n]);return ac(1/e.length,t)}))}}AN.className="Average",mc(AN);class EN extends IN{constructor(e){super(e)}mergeFunction(e){return Gl((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Tc(t,e[n]);return t}))}}EN.className="Maximum",mc(EN);class $N extends IN{constructor(e){super(e)}mergeFunction(e){return Gl((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=zp(t,e[n]);return t}))}}$N.className="Minimum",mc($N);class RN extends IN{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new Ev("A `Concatenate` layer should be called on a list of at least 2 inputs");let t=!0;for(const r of e)if(null!=r){t=!1;break}if(t)return;const n=[];for(let r=0;r<e.length;++r){const t=e[r].slice();t.splice(this.axis,1);let s=!1;for(const e of n)if(wr(e,t)){s=!0;break}s||n.push(t)}if(n.length>1)throw new Ev("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return Gl((()=>Ax(e,this.axis)))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new Ev("A `Concatenate` layer should be called on a list of inputs.");const t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(const s of t.slice(1)){if(null==n[r]||null==s[r]){n[r]=null;break}n[r]+=s[r]}return n}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new Ev("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new Ev("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new Ev(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return Gl((()=>{let n=!0;if(t.forEach((e=>{null==e||(n=!1)})),n)return null;const r=[];for(let a=0;a<e.length;++a)null==t[a]?r.push(Ju(qp(e[a]),"bool")):t[a].rank<e[a].rank?r.push(tp(t[a],-1)):r.push(t[a]);const s=Xh(r,this.axis);return kh(s,-1,!1)}))}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function DN(e,t){for(;e<0;)e+=t;return e}RN.className="Concatenate",mc(RN);class ON extends IN{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){yr(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0],n=e[1];if(t.length>3||n.length>3)throw new $v("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new Ev(`Dimension incompatibility: ${t[r[0]]} !== ${n[r[1]]}`)}mergeFunction(e){if(2!==e.length)throw new Ev(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t,n=e[0],r=e[1];return t=Array.isArray(this.axes)?this.axes.map(((t,n)=>DN(t,e[n].shape.length))):[DN(this.axes,n.shape.length),DN(this.axes,r.shape.length)],this.normalize&&(n=Jw(n,t[0]),r=Jw(r,t[1])),function(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new $v("batchDot is not implemented for tensors of 4D or higher rank yet");if(yr(e.shape.length>=2,(()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`)),yr(e.shape.length>=2,(()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`)),"number"===typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new $v("batchDot is not implemented for complex64-type Tensors yet.");const r=e.shape.length,s=t.shape.length;null==n&&(n=[r-1,s-2]);const a=n;return Gl((()=>{let n,i;if(r>s){n=r-s;const e=[];for(let t=0;t<n;++t)e.push(1);t=Hh(t,t.shape.concat(e))}else if(s>r){n=s-r;const t=[];for(let e=0;e<n;++e)t.push(1);e=Hh(e,e.shape.concat(t))}else n=0;if(2===e.shape.length&&2===t.shape.length)i=a[0]===a[1]?Qd(ac(e,t),a[0]):Qd(ac(ym(e,[1,0]),t),a[1]);else{const n=a[0]!==e.shape.length-1,r=a[1]===t.shape.length-1;i=Qh(e,t,n,r)}if(n>0){let e;e=r>s?r+s-3:r-1;const t=[];for(let r=e;r<e+n;++r)t.push(r);i=qf(i,t)}return 1===i.shape.length&&(i=tp(i,1)),i}))}(n,r,t)}interpretAxes(e,t){let n;return n=Array.isArray(this.axes)?this.axes:[DN(this.axes,e.length),DN(this.axes,t.length)],n}computeOutputShape(e){yr(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new $v("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);const s=t.concat(n);return 1===s.length&&s.push(1),s}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}ON.className="Dot",mc(ON);class _N extends ww{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return Gl((()=>{this.invokeCallHook(e,t);const n=uw(e);return Px((()=>nc(Rx(n.shape,0,this.stddev),n)),(()=>n),t.training||!1)}))}}_N.className="GaussianNoise",mc(_N);class FN extends ww{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Gl((()=>{this.invokeCallHook(e,t);const n=uw(e);if(this.rate>0&&this.rate<1){return Px((()=>{const e=Math.sqrt(this.rate/(1-this.rate));return ac(n,Rx(n.shape,1,e))}),(()=>n),t.training||!1)}return n}))}}FN.className="GaussianDropout",mc(FN);class MN extends ww{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||uw(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Gl((()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(e),r=()=>{const t=uw(e),r=-1.7580993408473766;let s=lp(gf(n),this.rate);s=Sx(s,"float32");const a=((1-this.rate)*(1+this.rate*r**2))**-.5,i=-a*r*this.rate,o=nc(ac(t,s),ac(nc(s,-1),r));return nc(ac(o,a),i)};return Px(r,(()=>uw(e)),t.training||!1)}return e}))}}function LN(e,t,n,r,s){let a,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:.001;if(2===e.rank)a=rd(e,t,n,r,s,i);else if(3===e.rank)a=sd(e,t,n,r,s,i);else{if(4!==e.rank)throw new $v(`batchNormalization is not implemented for array of rank ${e.rank} yet`);a=ad(e,t,n,r,s,i)}return a}function PN(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return wr(r.slice().sort(),xx(0,e.rank-1))?function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return Gl((()=>{const a=Wp(e,r),i=a.mean,o=a.variance;return[LN(e,i,o,n,t,s),i,o]}))}(e,t,n,r,s):function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return Gl((()=>{const a=Wp(e,r),i=a.mean,o=a.variance,l=[];for(const t of xx(0,e.rank))-1!==r.indexOf(t)?l.push(1):l.push(e.shape[t]);const u=Hh(i,l),c=Hh(o,l),h=null==t?null:Hh(t,l),d=null==n?null:Hh(n,l);return[LN(e,u,c,d,h,s),i,o]}))}(e,t,n,r,s)}MN.className="AlphaDropout",mc(MN);class zN extends ww{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=iw(e.betaInitializer||"zeros"),this.gammaInitializer=iw(e.gammaInitializer||"ones"),this.movingMeanInitializer=iw(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=iw(e.movingVarianceInitializer||"ones"),this.betaConstraint=Bw(e.betaConstraint),this.gammaConstraint=Bw(e.gammaConstraint),this.betaRegularizer=CS(e.betaRegularizer),this.gammaRegularizer=CS(e.gammaRegularizer)}build(e){e=cw(e);const t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(null==n)throw new Ev(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new gw({ndim:e.length,axes:{[t]:n}})];const r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return Gl((()=>{const n=null!=t.training&&t.training,r=uw(e),s=r.shape,a=s.length,i=xx(0,a),o=this.axis>=0?this.axis:this.axis+a;i.splice(o,1);const l=Ov(1,a);l[o]=s[o];const u=i.slice();u.sort();const c=!wr(u,xx(0,a).slice(0,a-1));if(!n)return(()=>{if(c){const e=Hh(this.movingMean.read(),l),t=Hh(this.movingVariance.read(),l),n=this.center?Hh(this.beta.read(),l):null,s=this.scale?Hh(this.gamma.read(),l):null;return LN(r,e,t,n,s,this.epsilon)}return LN(r,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[h,d,p]=PN(r,this.gamma.read(),this.beta.read(),i,this.epsilon),f=(e,t,n)=>{Gl((()=>{const r=1-n,s=e.read(),a=ac(wc(s,t),r);e.write(wc(s,a))}))};return(()=>{f(this.movingMean,d,this.momentum),f(this.movingVariance,p,this.momentum)})(),h}))}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:aw(this.betaInitializer),gammaInitializer:aw(this.gammaInitializer),movingMeanInitializer:aw(this.movingMeanInitializer),movingVarianceInitializer:aw(this.movingVarianceInitializer),betaRegularizer:NS(this.betaRegularizer),gammaRegularizer:NS(this.gammaRegularizer),betaConstraint:Pw(this.betaConstraint),gammaConstraint:Pw(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}zN.className="BatchNormalization",mc(zN);class BN extends ww{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"===typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=iw(e.betaInitializer||"zeros"),this.gammaInitializer=iw(e.gammaInitializer||"ones"),this.betaRegularizer=CS(e.betaRegularizer),this.gammaRegularizer=CS(e.gammaRegularizer),this.supportsMasking=!0}build(e){const t=(e=cw(e)).length;"number"===typeof this.axis&&(this.axis=[this.axis]);for(let s=0;s<this.axis.length;++s)this.axis[s]<0&&(this.axis[s]+=t);for(const s of this.axis)if(s<0||s>=t)throw new Error(`Invalid axis: ${s}`);if(this.axis.length!==Gv(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const n=this.axis.map((t=>e[t])),r=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){const n=uw(e),r=n.shape,s=r.length;return Gl((()=>{let{mean:e,variance:t}=Wp(n,this.axis,!0);const a=Ov(1,s);for(const n of this.axis)a[n]=r[n];const i=e=>null!=e&&e.shape.length!==s?Hh(e,a):e;let o=this.scale?i(this.gamma.read()):null,l=this.center?i(this.beta.read()):null;const u=[],c=[];for(let n=0;n<s;++n)-1!==this.axis.indexOf(n)?(u.push(r[n]),c.push(1)):(u.push(1),c.push(r[n]));return e=rp(e,u),t=rp(t,u),null!=o&&(o=rp(o,c)),null!=l&&(l=rp(l,c)),LN(n,e,t,l,o,this.epsilon)}))}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:aw(this.betaInitializer),gammaInitializer:aw(this.gammaInitializer),betaRegularizer:NS(this.betaRegularizer),gammaRegularizer:NS(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}BN.className="LayerNormalization",mc(BN);class VN extends ww{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"===typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new Ev(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if("number"===typeof e.padding[0])t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new Ev(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],2!==e.padding[1].length)throw new Ev(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new gw({ndim:4})]}computeOutputShape(e){let t,n;return e=cw(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])}call(e,t){return Gl((()=>{return t=uw(e),n=this.padding,r=this.dataFormat,Gl((()=>{if(4!==t.rank)throw new Ev(`temporalPadding expects input tensor to be 4-D, but received a ${t.rank}-D tensor.`);if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new Ev("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==r&&(r="channelsLast"),"channelsLast"!==r&&"channelsFirst"!==r)throw new Ev(`Unknown data format: ${r}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let e;return e="channelsFirst"===r?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],Xp(t,e)}));var t,n,r}))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}function WN(e,t,n,r,s,a){return Gl((()=>{let i;lx(s),cx(a),ux(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==a&&(a="max"),e=MS(e,s);const o="same"===r?"same":"valid";return i="max"===a?Dp(e,t,n,o):qh(e,t,n,o),"channelsFirst"===s&&(i=ym(i,[0,3,1,2])),i}))}function UN(e,t,n,r,s,a){return Gl((()=>{let i;lx(s),cx(a),ux(r),null==n&&(n=[1,1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==a&&(a="max"),e=LS(e,s);const o="same"===r?"same":"valid";return i="max"===a?Op(e,t,n,o):Kh(e,t,n,o),"channelsFirst"===s&&(i=ym(i,[0,4,1,2,3])),i}))}VN.className="ZeroPadding2D",mc(VN);class jN extends ww{constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"===typeof e.poolSize)this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!==typeof e.poolSize[0])throw new Ev(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);this.poolSize=e.poolSize}if(Xv(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"===typeof e.strides)this.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!==typeof e.strides[0])throw new Ev(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);this.strides=e.strides}Xv(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,ux(this.padding),this.inputSpec=[new gw({ndim:3})]}computeOutputShape(e){const t=_S((e=cw(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return Gl((()=>{this.invokeCallHook(e,t),e=Nx(uw(e),2);const n=this.poolingFunction(uw(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return qf(n,[2])}))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class GN extends jN{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return lx(s),ux(r),WN(e,t,n,r,s,"max")}}GN.className="MaxPooling1D",mc(GN);class HN extends jN{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return lx(s),ux(r),WN(e,t,n,r,s,"avg")}}HN.className="AveragePooling1D",mc(HN);class qN extends ww{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new Ev(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];Xv(this.poolSize,"poolSize"),Xv(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,lx(this.dataFormat),ux(this.padding),this.inputSpec=[new gw({ndim:4})]}computeOutputShape(e){e=cw(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=_S(t,this.poolSize[0],this.padding,this.strides[0]),n=_S(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return Gl((()=>(this.invokeCallHook(e,t),this.poolingFunction(uw(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class KN extends qN{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return lx(s),ux(r),WN(e,t,n,r,s,"max")}}KN.className="MaxPooling2D",mc(KN);class XN extends qN{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return lx(s),ux(r),WN(e,t,n,r,s,"avg")}}XN.className="AveragePooling2D",mc(XN);class QN extends ww{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new Ev(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];Xv(this.poolSize,"poolSize"),Xv(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,lx(this.dataFormat),ux(this.padding),this.inputSpec=[new gw({ndim:5})]}computeOutputShape(e){e=cw(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[4]:e[3];return t=_S(t,this.poolSize[0],this.padding,this.strides[0]),n=_S(n,this.poolSize[1],this.padding,this.strides[1]),r=_S(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n,r]:[e[0],t,n,r,e[4]]}call(e,t){return Gl((()=>(this.invokeCallHook(e,t),this.poolingFunction(uw(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class YN extends QN{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return lx(s),ux(r),UN(e,t,n,r,s,"max")}}YN.className="MaxPooling3D",mc(YN);class ZN extends QN{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return lx(s),ux(r),UN(e,t,n,r,s,"avg")}}ZN.className="AveragePooling3D",mc(ZN);class JN extends ww{constructor(e){super(e),this.inputSpec=[new gw({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new $v}}class eI extends JN{constructor(e){super(e||{})}call(e,t){return Gl((()=>{const t=uw(e);return Fp(t,1)}))}}eI.className="GlobalAveragePooling1D",mc(eI);class tI extends JN{constructor(e){super(e||{})}call(e,t){return Gl((()=>{const t=uw(e);return Kd(t,1)}))}}tI.className="GlobalMaxPooling1D",mc(tI);class nI extends ww{constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,lx(this.dataFormat),this.inputSpec=[new gw({ndim:4})]}computeOutputShape(e){return"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new $v}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class rI extends nI{call(e,t){return Gl((()=>{const t=uw(e);return"channelsLast"===this.dataFormat?Fp(t,[1,2]):Fp(t,[2,3])}))}}rI.className="GlobalAveragePooling2D",mc(rI);class sI extends nI{call(e,t){return Gl((()=>{const t=uw(e);return"channelsLast"===this.dataFormat?Kd(t,[1,2]):Kd(t,[2,3])}))}}sI.className="GlobalMaxPooling2D",mc(sI);class aI extends ww{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=Zw(t.layer,n);delete t.layer;const s={layer:r};return Object.assign(s,t),new e(s)}}class iI extends aI{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=cw(e)).length<3)throw new Ev(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){const t=[(e=cw(e))[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),r=e[1];return[n[0],r].concat(n.slice(1))}call(e,t){return Gl((()=>eN(((e,n)=>[uw(this.layer.call(e,t)),[]]),e=uw(e),[],!1,null,null,!1,!0)[1]))}}iI.className="TimeDistributed",mc(iI);class oI extends aI{constructor(e){super(e);const t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=Zw(n),t.goBackwards=!0!==t.goBackwards;const r={};if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=Zw(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,function(e){qv(ix,"BidirectionalMergeMode",e)}(this.mergeMode),e.weights)throw new $v("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t,n,r,s=this.forwardLayer.computeOutputShape(e);return Array.isArray(s)&&Array.isArray(s[0])||(s=[s]),this.returnState?(r=s.slice(1),t=s[0]):t=s[0],"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[t].concat(r).concat(r.slice()):Mv(n)}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});const s=JS(e,n,r,this.numConstants);if(e=s.inputs,n=s.initialState,r=s.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(null==n||0===n.length)&&null==r)return super.apply(e,t);const a=[],i=[];if(null!=n){const e=n.length;if(e%2>0)throw new Ev("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,a.push(...n);const r=n.map((e=>new gw({shape:e.shape})));this.forwardLayer.stateSpec=r.slice(0,e/2),this.backwardLayer.stateSpec=r.slice(e/2),i.push(...r)}if(null!=r)throw new $v("Support for constants in Bidirectional layers is not implemented yet.");const o=a[0]instanceof yw;for(const l of a)if(l instanceof yw!==o)throw new Ev("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){const n=[e].concat(a),r=this.inputSpec.concat(i),s=this.inputSpec;this.inputSpec=r;const o=super.apply(n,t);return this.inputSpec=s,o}return super.apply(e,t)}call(e,t){return Gl((()=>{const n=t.initialState;let r,s,a,i;if(null==n)r=this.forwardLayer.call(e,t),s=this.backwardLayer.call(e,t);else{const a=n.slice(0,n.length/2),i=n.slice(n.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:a})),s=this.backwardLayer.call(e,Object.assign(t,{initialState:i}))}return this.returnState&&(Array.isArray(r)&&(a=r.slice(1).concat(s.slice(1))),r=r[0],s=s[0]),this.returnSequences&&(s=Sf(s,1)),"concat"===this.mergeMode?i=Ax([r,s]):"sum"===this.mergeMode?i=nc(r,s):"ave"===this.mergeMode?i=ac(.5,nc(r,s)):"mul"===this.mergeMode?i=ac(r,s):null==this.mergeMode&&(i=[r,s]),this.returnState?null==this.mergeMode?i.concat(a):[i].concat(a):i}))}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){dx(this.forwardLayer.name,(()=>{this.forwardLayer.build(e)})),dx(this.backwardLayer.name,(()=>{this.backwardLayer.build(e)})),this.built=!0}computeMask(e,t){let n;if(Array.isArray(t)&&(t=t[0]),n=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){const e=this.forwardLayer.states.map((e=>null));return Array.isArray(n)?n.concat(e).concat(e):[n].concat(e).concat(e)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const n=Zw(t.layer);if(delete t.layer,null!=t.numConstants)throw new $v("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=t;return r.layer=n,new e(r)}}oI.className="Bidirectional",mc(oI);class lI extends ww{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return Gl((()=>("float32"!==(e=uw(e)).dtype&&(e=Sx(e,"float32")),nc(ac(e,this.scale),this.offset))))}}lI.className="Rescaling",mc(lI);const{resizeBilinear:uI,cropAndResize:cI}=Fg;class hI extends ww{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,r,s,a,i,o){return Gl((()=>{let l,u=!1;const c=[t/a,n/i,(r+t)/a,(s+n)/i],h=[];3===e.rank?(u=!0,l=Kf([e])):l=e;for(let e=0;e<l.shape[0];e++)h.push(c);const d=Bl(h,[h.length,4]),p=bf(0,h.length,1,"int32"),f=cI(l,d,p,[r,s],"nearest");return Sx(u?uw(hm(f)):f,o)}))}upsize(e,t,n,r){return Gl((()=>Sx(uI(e,[t,n]),r)))}call(e,t){return Gl((()=>{const t=uw(e),n=t.dtype,r=t.shape,s=r[r.length-3],a=r[r.length-2];let i=0;s!==this.height&&(i=Math.floor((s-this.height)/2));let o=0;return a!==this.width&&(o=Math.floor((a-this.width)/2),0===o&&(o=1)),i>=0&&o>=0?this.centerCrop(t,i,o,this.height,this.width,s,a,n):this.upsize(e,this.height,this.width,n)}))}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){const t=(e=cw(e)).length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}}hI.className="CenterCrop",mc(hI);class dI extends ww{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return null==(e=cw(e))?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return Gl((()=>{let n;if("int32"!==(e=uw(e)).dtype&&(e=Sx(e,"int32")),"undefined"!==typeof t.countWeights){if("count"!==this.outputMode)throw new Ev(`countWeights is not used when outputMode !== count.\n              Received countWeights=${t.countWeights}`);n=uw(t.countWeights)}const r=Kd(e),s=Xd(e),a=op(this.numTokens,r).bufferSync().get(0),i=lp(s,0).bufferSync().get(0);if(!a||!i)throw new Ev(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return function(e,t,n,r){let s=uw(e);if("int32"!==s.dtype&&(s=Sx(s,"int32")),"int"===t)return s;const a=s.shape;if(0===s.rank&&(s=tp(s,-1)),"oneHot"===t&&1!==s.shape[s.shape.length-1]&&(s=tp(s,-1)),s.rank>2)throw new Ev(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${a} which would result in output rank ${s.rank}.`);const i=["multiHot","oneHot"].includes(t),o=s;let l;if(l=Td(o,"undefined"!==typeof r&&"count"===t?r:[],n,i),"tfIdf"!==t)return l;if(r)return ac(l,r);throw new Ev("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,n)}))}}dI.className="CategoryEncoding",mc(dI);const pI=new Set(["bilinear","nearest"]);class fI extends ww{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!pI.has(e.interpolation))throw new Ev(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(e.cropToAspectRatio)}computeOutputShape(e){const t=(e=cw(e))[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return Gl((()=>{const t=[this.height,this.width];if("bilinear"===this.interpolation)return Fg.resizeBilinear(e,t,!this.cropToAspectRatio);if("nearest"===this.interpolation)return Fg.resizeNearestNeighbor(e,t,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...pI]} are supported`)}))}}fI.className="Resizing",mc(fI);class mI{constructor(e){this.seed=e}next(){if(void 0!==this.seed)return this.seed++}}mI.className="RandomSeed";class gI extends ww{constructor(e){super(e),this.randomGenerator=new mI(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}gI.className="BaseRandomLayer";const yI=new Set(["bilinear","nearest"]);class bI extends gI{constructor(e){super(e);const{factor:t,interpolation:n="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new Ev(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new Ev(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new Ev(`factor cannot have upper bound less than lower bound.\n        Got upper bound: ${this.widthUpper}.\n        Got lower bound: ${this.widthLower}\n      `);if(n){if(!yI.has(n))throw new Ev(`Invalid interpolation parameter: ${n} is not implemented`);this.interpolation=n}}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){const t=(e=cw(e))[2];return[this.imgHeight,-1,t]}call(e,t){return Gl((()=>{const t=uw(e);this.imgHeight=t.shape[t.shape.length-3];const n=t.shape[t.shape.length-2];this.widthFactor=gf([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let r=this.widthFactor.dataSync()[0]*n;r=Math.round(r);const s=[this.imgHeight,r];switch(this.interpolation){case"bilinear":return Fg.resizeBilinear(e,s);case"nearest":return Fg.resizeNearestNeighbor(e,s);default:throw new Error(`Interpolation is ${this.interpolation}\n          but only ${[...yI]} are supported`)}}))}}bI.className="RandomWidth",mc(bI);var vI,xI;Yr().registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"}(vI||(vI={})),function(e){let t;!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(xI||(xI={}));const wI={};function kI(e){return wI[e]}function SI(e,t,n,r,s){const a=t.inputParams[e];if(a&&void 0!==a.inputIndexStart){const e=a.inputIndexStart,i=0===a.inputIndexEnd?void 0:void 0===a.inputIndexEnd?e+1:a.inputIndexEnd,o=e<0?t.inputNames.length+e:e;if("tensor"===a.type)return NI(t.inputNames[o],n,r,s);if("tensors"===a.type){const a=t.inputs.slice(e,i),o=t.inputNames.slice(e,i).filter(((e,t)=>{var n;return"NoOp"!==(null===(n=a[t])||void 0===n?void 0:n.op)}));return o.map((e=>NI(e,n,r,s)))}const l=NI(t.inputNames[o],n,r,s),u=l.dataSync();return"number"===a.type?u[0]:Br(l.shape,u)}const i=t.attrParams[e];return i&&i.value}function NI(e,t,n,r){const[s,a]=AI(e,n);if(null!=r){const e=r.getHashTableHandleByName(s);if(null!=e)return e}const i=n.currentContextIds.find((e=>!!t[TI(s,e)]));return void 0!==i?t[TI(s,i)][a]:void 0}function II(e,t,n){return t[TI(e,n.currentContextId)]}function CI(e,t){const[n,r,s]=AI(e,t);return[TI(n,t&&t.currentContextId),r,s]}function TI(e,t){return t?`${e}-${t}`:e}function AI(e,t){if(""===e)return["",0,void 0];const n=null!=t&&null!=t.parseNodeNameCache;if(n){const n=t.parseNodeNameCache.get(e);if(null!=n)return n}const r=e.split(":");let s;if(1===r.length)s=[e,0,void 0];else{const e=r[0],t=3===r.length?r[1]:void 0;s=[e,Number(r[r.length-1]),t]}return n&&t.parseNodeNameCache.set(e,s),s}function EI(e,t,n){let r=SI("pad",e,t,n);if("explicit"===r){r=SI("explicitPaddings",e,t,n);const s=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)s[e][0]=r[2*e],s[e][1]=r[2*e+1];return s}return r}function $I(e){return e.kept?e:ec(e)}const RI=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],DI=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],OI=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],_I=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],FI=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],MI=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],LI=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],PI=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],zI=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],BI=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],VI=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],WI=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],UI=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],jI=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],GI=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],HI=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],qI=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],KI=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],XI=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];class QI{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[i,o,l,u,c,h,d,p,f,m,g,y,b,v,x,w,k,S,N].map((e=>e.json)));this.opMappers=e.reduce(((e,t)=>(e[t.tfOpName]=t,e)),{})}transformGraph(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=e.node,r=[],s=[],a=[],i=n.reduce(((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?r.push(e[t.name]):"Const"===t.op?s.push(e[t.name]):null!=t.input&&0!==t.input.length||a.push(e[t.name]),e)),{});let o=[];const l=[];let u={},c={};null!=t&&(u=this.mapSignatureEntries(t.inputs),c=this.mapSignatureEntries(t.outputs));const h=Object.keys(i);h.forEach((e=>{const t=i[e];t.inputNames.forEach(((e,n)=>{const[r,,s]=CI(e),a=i[r];if(null!=a.outputs){const e=a.outputs.indexOf(s);if(-1!==e){const s=`${r}:${e}`;t.inputNames[n]=s}}t.inputs.push(a),a.children.push(t)}))})),0===Object.keys(c).length?h.forEach((e=>{const t=i[e];0===t.children.length&&l.push(t)})):Object.keys(c).forEach((e=>{const[t]=CI(e),n=i[t];null!=n&&(n.signatureKey=c[e],l.push(n))})),Object.keys(u).length>0?Object.keys(u).forEach((e=>{const[t]=CI(e),n=i[t];n&&(n.signatureKey=u[e],o.push(n))})):o=r;let d={};null!=e.library&&null!=e.library.function&&(d=e.library.function.reduce(((e,t)=>(e[t.signature.name]=this.mapFunction(t),e)),{}));const p={nodes:i,inputs:o,outputs:l,weights:s,placeholders:r,signature:t,functions:d};return a.length>0&&(p.initNodes=a),p}mapSignatureEntries(e){return Object.keys(e||{}).reduce(((t,n)=>(t[e[n].name]=n,t)),{})}mapNode(e){const t=kI(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});const n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map((e=>e.startsWith("^")?e.slice(1):e)),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return null!=t.inputs&&(n.inputParams=t.inputs.reduce(((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e)),{})),null!=t.attrs&&(n.attrParams=t.attrs.reduce(((t,n)=>{const r=n.type;let s;switch(n.type){case"string":s=ZI(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=ZI(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":s=lC(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=lC(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":s=eC(e.attr,n.tfName,n.defaultValue||0),void 0===s&&n.tfDeprecatedName&&(s=eC(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":s=oC(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=oC(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":s=JI(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=JI(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":s=cC(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=cC(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":s=iC(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=iC(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":s=uC(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=uC(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":s=rC(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=rC(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":s=sC(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=sC(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":s=nC(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=nC(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${n.type} for op: ${e.op}`)}return t[n.name]={value:s,type:r},t}),{})),n}mapFunction(e){const t=e.nodeDef,n=[];let r={};null!=t&&(r=t.reduce(((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&n.push(e[t.name]),e)),{}));const s=[],a=[];e.signature.inputArg.forEach((e=>{const[t]=CI(e.name),n={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:tC(e.type),type:"dtype"}},children:[]};n.signatureKey=e.name,s.push(n),r[t]=n}));Object.keys(r).forEach((e=>{const t=r[e];t.inputNames.forEach(((e,n)=>{const[s,,a]=CI(e),i=r[s];if(null!=i.outputs){const e=i.outputs.indexOf(a);if(-1!==e){const r=`${s}:${e}`;t.inputNames[n]=r}}t.inputs.push(i),i.children.push(t)}))}));const i=e.ret;e.signature.outputArg.forEach((e=>{const[t,n]=CI(i[e.name]),s=r[t];null!=s&&(s.defaultOutput=n,a.push(s))}));const o=this.mapArgsToSignature(e);return{nodes:r,inputs:s,outputs:a,weights:n,placeholders:[],signature:o}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce(((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e)),{}),outputs:e.signature.outputArg.reduce(((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t)),{})}}mapArgToTensorInfo(e,t){let n=e.name;return null!=t&&(n=t[n]),{name:n,dtype:e.type}}}function YI(e,t){const n=Array.isArray(e)?String.fromCharCode.apply(null,e):function(e){const t=Yr().global;if("undefined"!==typeof t.atob)return t.atob(e);if("undefined"!==typeof Buffer)return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(e);return t?n:n.toLowerCase()}function ZI(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=e[t];return null!=s?YI(s.s,r):n}function JI(e,t,n){const r=e[t];return r?r.b:n}function eC(e,t,n){const r=e[t]||{},s=null!=r.i?r.i:null!=r.f?r.f:n;return"number"===typeof s?s:parseInt(s,10)}function tC(e){switch("string"===typeof e&&(e=vI[e]),e){case vI.DT_FLOAT:case vI.DT_HALF:return"float32";case vI.DT_INT32:case vI.DT_INT64:case vI.DT_INT8:case vI.DT_UINT8:return"int32";case vI.DT_BOOL:return"bool";case vI.DT_DOUBLE:return"float32";case vI.DT_STRING:return"string";case vI.DT_COMPLEX64:case vI.DT_COMPLEX128:return"complex64";default:return null}}function nC(e,t,n){const r=e[t];return r&&r.func?r.func.name:n}function rC(e,t,n){const r=e[t];return r&&r.type?tC(r.type):n}function sC(e,t,n){const r=e[t];return r&&r.list&&r.list.type?r.list.type.map((e=>tC(e))):n}function aC(e){if(!e.unknownRank)return null!=e.dim?e.dim.map((e=>"number"===typeof e.size?e.size:parseInt(e.size,10))):[]}function iC(e,t,n){const r=e[t];return r&&r.shape?aC(r.shape):n}function oC(e,t,n){const r=e[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map((e=>"number"===typeof e?e:parseInt(e,10))):n}function lC(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=e[t];return s&&s.list&&s.list.s?s.list.s.map((e=>YI(e,r))):n}function uC(e,t,n){const r=e[t];return r&&r.list&&r.list.shape?r.list.shape.map((e=>aC(e))):n}function cC(e,t,n){const r=e[t];return r&&r.list&&r.list.b?r.list.b:n}class hC{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map((e=>this.getInput(e))),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce(((e,t)=>(e[t]=this.getAttr(t),e)),{}))}getInput(e){return NI(e,this.tensorMap,this.context)}getAttr(e,t){const n=this.node.rawAttrs[e];if(null!=n.tensor)return NI(e,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return eC(this.node.rawAttrs,e,t);if(null!=n.s)return ZI(this.node.rawAttrs,e,t);if(null!=n.b)return JI(this.node.rawAttrs,e,t);if(null!=n.shape)return iC(this.node.rawAttrs,e,t);if(null!=n.type)return rC(this.node.rawAttrs,e,t);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return oC(this.node.rawAttrs,e,t);if(null!=n.list.s)return lC(this.node.rawAttrs,e,t);if(null!=n.list.shape)return uC(this.node.rawAttrs,e,t);if(null!=n.list.b)return cC(this.node.rawAttrs,e,t);if(null!=n.list.type)return sC(this.node.rawAttrs,e,t)}return t}}function dC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";if("number"!==typeof e&&"number"!==typeof t){yr(e.length===t.length,(()=>n+` Shapes ${e} and ${t} must match`));for(let r=0;r<e.length;r++){const s=e[r],a=t[r];yr(s<0||a<0||s===a,(()=>n+` Shapes ${e} and ${t} must match`))}}}function pC(e){return"number"!==typeof e&&!e.some((e=>e<0))}function fC(e,t,n){let r=mC(e,n);const s=!pC(r);if(s&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&t.forEach((e=>{r=mC(e.shape,r)})),!pC(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function mC(e,t){if("number"===typeof e)return t;if("number"===typeof t)return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);const n=[];for(let r=0;r<e.length;++r){const s=e[r],a=t[r];if(s>=0&&a>=0&&s!==a)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[r]=s>=0?s:a}return n}class gC{constructor(e,t,n,r,s,a,i){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=s,this.dynamicSize=a,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=cc(0),ql(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.tensor.id)||t.tensor.dispose()})),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map((e=>this.read(e)))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},\n          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=t.shape),dC(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,ql(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach(((e,n)=>this.write(e,t[n])))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return Bl([],[0].concat(this.elementShape));const n=this.readMany(e);return dC(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),Kf(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(0===this.size())return Bl([],[0].concat(this.elementShape));const t=[];for(let r=0;r<this.size();r++)t.push(r);const n=this.readMany(t);return dC(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),Xh(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,hm(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0;const r=e.map((e=>(n+=e,n)));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const s=0===n?0:t.size/n,a=[];Gl((()=>{t=Hh(t,[1,n,s]);for(let n=0;n<e.length;++n){const i=[0,0===n?0:r[n-1],0],o=[1,e[n],s];a[n]=Hh(Zh(t,i,o),this.elementShape)}return a}));const i=[];for(let o=0;o<e.length;o++)i[o]=o;this.writeMany(i,a)}}class yC{get id(){return this.idTensor.id}constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1;this.tensors=e,this.elementShape=t,this.elementDtype=n,null!=e&&e.forEach((e=>{if(n!==e.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${e.dtype}`);dC(t,e.shape,"TensorList shape mismatch: "),ql(e)})),this.idTensor=cc(0),this.maxNumElements=r,ql(this.idTensor)}copy(){return new yC([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.id)||t.dispose()})),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(-1!==n&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);dC(e,this.elementShape,"TensorList shape mismatch: ");const r=fC(this.elementShape,this.tensors,e);return Gl((()=>{const e=this.tensors.map((e=>Hh(e,r)));return Kf(e,0)}))}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const n=fC(this.elementShape,this.tensors,e),r=this.tensors.pop();return r.kept=!1,dC(r.shape,e,"TensorList shape mismatch: "),Hh(r,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(dC(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");ql(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(-1!==this.maxNumElements&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new yC([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let n=0;n<Math.min(this.tensors.length,e);++n)t.tensors[n]=this.tensors[n];return t}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[e])throw new Error(`element at index ${e} is null.`);dC(this.tensors[e].shape,t,"TensorList shape mismatch: ");const r=fC(this.elementShape,this.tensors,t);return Hh(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);dC(this.elementShape,t.shape,"TensorList shape mismatch: "),ql(t),null!=this.tensors[e]&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);dC(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());const r=fC(this.elementShape,this.tensors,n);return 0===e.length?Bl([],[0].concat(r)):Gl((()=>{const t=e.map((e=>Hh(this.tensors[e],r)));return Kf(t,0)}))}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);dC(this.elementShape,t,"TensorList shape mismatch: ");const n=fC(this.elementShape,this.tensors,t);return 0===this.size()?Bl([],[0].concat(n)):Gl((()=>{const e=this.tensors.map((e=>Hh(e,n)));return Xh(e,0)}))}}const bC=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{const r=SI("thenBranch",e,t,n),s=SI("elseBranch",e,t,n),a=SI("cond",e,t,n),i=SI("args",e,t,n);return(await a.data())[0]?n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[s].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const r=SI("body",e,t,n),s=SI("cond",e,t,n),a=SI("args",e,t,n),i=await n.functionMap[s].executeFunctionAsync(a,n.tensorArrayMap,n.tensorListMap),o=a.map((e=>e.id));let l=await i[0].data();i.forEach((e=>{e.kept||-1!==o.indexOf(e.id)||e.dispose()}));let u=a;for(;l[0];){const e=u;u=await n.functionMap[r].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);const t=u.map((e=>e.id));e.forEach((e=>{e.kept||-1!==o.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}));const a=await n.functionMap[s].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);l=await a[0].data(),a.forEach((e=>{e.kept||-1!==o.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}))}return u}case"LoopCond":return[$I(SI("pred",e,t,n))];case"Switch":{const r=SI("pred",e,t,n);let s=SI("data",e,t,n);return s.kept||(s=$I(s)),(await r.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{const r=e.inputNames.find((e=>void 0!==NI(e,t,n)));if(r){return[$I(NI(r,t,n))]}return}case"Enter":{const r=SI("frameName",e,t,n),s=SI("tensor",e,t,n);return n.enterFrame(r),[$I(s)]}case"Exit":{const r=SI("tensor",e,t,n);return n.exitFrame(),[$I(r)]}case"NextIteration":{const r=SI("tensor",e,t,n);return n.nextIteration(),[$I(r)]}case"TensorArrayV3":{const r=SI("size",e,t,n),s=SI("dtype",e,t,n),a=SI("elementShape",e,t,n),i=SI("dynamicSize",e,t,n),o=SI("clearAfterRead",e,t,n),l=SI("identicalElementShapes",e,t,n),u=SI("name",e,t,n),c=new gC(u,s,r,a,l,i,o);return n.addTensorArray(c),[c.idTensor,cc(1)]}case"TensorArrayWriteV3":{const r=SI("tensorArrayId",e,t,n),s=SI("index",e,t,n),a=SI("tensor",e,t,n),i=n.getTensorArray(r.id);return i.write(s,a),[i.idTensor]}case"TensorArrayReadV3":{const r=SI("tensorArrayId",e,t,n),s=SI("index",e,t,n);return[n.getTensorArray(r.id).read(s)]}case"TensorArrayGatherV3":{const r=SI("tensorArrayId",e,t,n),s=SI("indices",e,t,n),a=SI("dtype",e,t,n);return[n.getTensorArray(r.id).gather(s,a)]}case"TensorArrayScatterV3":{const r=SI("tensorArrayId",e,t,n),s=SI("indices",e,t,n),a=SI("tensor",e,t,n),i=n.getTensorArray(r.id);return i.scatter(s,a),[i.idTensor]}case"TensorArrayConcatV3":{const r=SI("tensorArrayId",e,t,n),s=n.getTensorArray(r.id),a=SI("dtype",e,t,n);return[s.concat(a)]}case"TensorArraySplitV3":{const r=SI("tensorArrayId",e,t,n),s=SI("tensor",e,t,n),a=SI("lengths",e,t,n),i=n.getTensorArray(r.id);return i.split(a,s),[i.idTensor]}case"TensorArraySizeV3":{const r=SI("tensorArrayId",e,t,n);return[cc(n.getTensorArray(r.id).size(),"int32")]}case"TensorArrayCloseV3":{const r=SI("tensorArrayId",e,t,n),s=n.getTensorArray(r.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{const r=SI("tensorListId",e,t,n),s=SI("index",e,t,n),a=SI("tensor",e,t,n),i=n.getTensorList(r.id);return i.setItem(s,a),[i.idTensor]}case"TensorListGetItem":{const r=SI("tensorListId",e,t,n),s=SI("index",e,t,n),a=SI("elementShape",e,t,n),i=SI("elementDType",e,t,n);return[n.getTensorList(r.id).getItem(s,a,i)]}case"TensorListScatterV2":case"TensorListScatter":{const r=SI("indices",e,t,n),s=function(e,t,n,r){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const s=Math.max(...t);if(null!=r&&-1!==r&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);const a=new yC([],n,e.dtype,r),i=hm(e,0);return t.forEach(((e,t)=>{a.setItem(e,i[t])})),a}(SI("tensor",e,t,n),r,SI("elementShape",e,t,n),SI("numElements",e,t,n));return n.addTensorList(s),[s.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=SI("elementShape",e,t,n),s=SI("elementDType",e,t,n);let a;a="TensorListReserve"===e.op?"numElements":"maxNumElements";const i=SI(a,e,t,n),o=function(e,t,n,r){return new yC([],e,t,r)}(r,s,0,"TensorListReserve"===e.op?-1:i);return n.addTensorList(o),[o.idTensor]}case"TensorListGather":{const r=SI("tensorListId",e,t,n),s=SI("indices",e,t,n),a=SI("elementShape",e,t,n),i=SI("elementDType",e,t,n);return[n.getTensorList(r.id).gather(s,i,a)]}case"TensorListStack":{const r=SI("tensorListId",e,t,n),s=SI("elementShape",e,t,n),a=SI("elementDType",e,t,n),i=SI("numElements",e,t,n);return[n.getTensorList(r.id).stack(s,a,i)]}case"TensorListFromTensor":{const r=function(e,t,n){const r=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);dC(e.shape.slice(1),t,"TensorList shape mismatch: ");const s=hm(e);return new yC(s,t,r)}(SI("tensor",e,t,n),SI("elementShape",e,t,n),SI("elementDType",e,t,n));return n.addTensorList(r),[r.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const r=SI("tensorListId",e,t,n),s=n.getTensorList(r.id),a=SI("dtype",e,t,n),i=SI("elementShape",e,t,n);return[s.concat(a,i)]}case"TensorListPushBack":{const r=SI("tensorListId",e,t,n),s=SI("tensor",e,t,n),a=n.getTensorList(r.id);return a.pushBack(s),[a.idTensor]}case"TensorListPopBack":{const r=SI("tensorListId",e,t,n),s=SI("elementShape",e,t,n),a=SI("elementDType",e,t,n);return[n.getTensorList(r.id).popBack(s,a)]}case"TensorListSplit":{const r=SI("tensor",e,t,n),s=SI("elementShape",e,t,n),a=function(e,t,n){let r=0;const s=t.map((e=>(r+=e,r)));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${e.shape}`);const a=mC(e.shape.slice(1),n),i=0===r?0:e.size/r,o=Gl((()=>{const n=[];e=Hh(e,[1,r,i]);for(let r=0;r<t.length;++r){const o=[0,0===r?0:s[r-1],0],l=[1,t[r],i];n[r]=Hh(Zh(e,o,l),a)}return e.dispose(),n})),l=new yC([],n,e.dtype,t.length);for(let u=0;u<o.length;u++)l.setItem(u,o[u]);return l}(r,SI("lengths",e,t,n),s);return n.addTensorList(a),[a.idTensor]}case"TensorListLength":{const r=SI("tensorListId",e,t,n);return[cc(n.getTensorList(r.id).size(),"int32")]}case"TensorListResize":{const r=SI("tensorListId",e,t,n),s=SI("size",e,t,n),a=n.getTensorList(r.id).resize(s);return n.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function vC(e,t,n){const[r,s]=SI("fusedOps",e,t,n),a="biasadd"===r,i=!a,o="prelu"===s,l="fusedbatchnorm"===r,u=SI("numArgs",e,t,n);if(a){if(o&&2!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&a&&1!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=SI("strides",e,t,n),h=EI(e,t,n),d=SI("dataFormat",e,t,n).toUpperCase(),p=SI("dilations",e,t,n);let[f,m]=SI("args",e,t,n);i&&(m=f,f=void 0);return{stride:c,pad:h,dataFormat:d,dilations:p,biasArg:f,preluArg:m,activationFunc:s,leakyreluAlpha:SI("leakyreluAlpha",e,t,n)}}function xC(e,t,n){return{boxes:SI("boxes",e,t,n),scores:SI("scores",e,t,n),maxOutputSize:SI("maxOutputSize",e,t,n),iouThreshold:SI("iouThreshold",e,t,n),scoreThreshold:SI("scoreThreshold",e,t,n),softNmsSigma:SI("softNmsSigma",e,t,n)}}class wC{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=cc(0),this.tensorMap=new Map,ql(this.handle)}clearAndClose(){this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return cc(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),Gl((()=>{const e=hm(t),r=n.length,s=e.length;yr(r===s,(()=>`The number of elements doesn't match, keys has ${r} elements, the values has ${s} elements.`));for(let t=0;t<r;t++){const r=n[t],s=e[t];ql(s),this.tensorMap.set(r,s)}return this.handle}))}async find(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return Gl((()=>{const e=[];for(let r=0;r<n.length;r++){const s=n[r],a=this.findWithDefault(s,t);e.push(a)}return Kf(e)}))}findWithDefault(e,t){const n=this.tensorMap.get(e);return null!=n?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}function kC(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Gl;const a=((e,t,n)=>{switch(e.category){case"arithmetic":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(SI("a",e,t,n),SI("b",e,t,n))];case"AddN":return[r.addN(SI("tensors",e,t,n))];case"FloorMod":case"Mod":return[r.mod(SI("a",e,t,n),SI("b",e,t,n))];case"Mul":return[r.mul(SI("a",e,t,n),SI("b",e,t,n))];case"RealDiv":case"Div":return[r.div(SI("a",e,t,n),SI("b",e,t,n))];case"DivNoNan":return[r.divNoNan(SI("a",e,t,n),SI("b",e,t,n))];case"FloorDiv":return[r.floorDiv(SI("a",e,t,n),SI("b",e,t,n))];case"Sub":return[r.sub(SI("a",e,t,n),SI("b",e,t,n))];case"Minimum":return[r.minimum(SI("a",e,t,n),SI("b",e,t,n))];case"Maximum":return[r.maximum(SI("a",e,t,n),SI("b",e,t,n))];case"Pow":return[r.pow(SI("a",e,t,n),SI("b",e,t,n))];case"SquaredDifference":return[r.squaredDifference(SI("a",e,t,n),SI("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"basic_math":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"Abs":case"ComplexAbs":return[r.abs(SI("x",e,t,n))];case"Acos":return[r.acos(SI("x",e,t,n))];case"Acosh":return[r.acosh(SI("x",e,t,n))];case"Asin":return[r.asin(SI("x",e,t,n))];case"Asinh":return[r.asinh(SI("x",e,t,n))];case"Atan":return[r.atan(SI("x",e,t,n))];case"Atan2":return[r.atan2(SI("x",e,t,n),SI("y",e,t,n))];case"Atanh":return[r.atanh(SI("x",e,t,n))];case"Ceil":return[r.ceil(SI("x",e,t,n))];case"Complex":return[r.complex(SI("real",e,t,n),SI("imag",e,t,n))];case"Cos":return[r.cos(SI("x",e,t,n))];case"Cosh":return[r.cosh(SI("x",e,t,n))];case"Elu":return[r.elu(SI("x",e,t,n))];case"Erf":return[r.erf(SI("x",e,t,n))];case"Exp":return[r.exp(SI("x",e,t,n))];case"Expm1":return[r.expm1(SI("x",e,t,n))];case"Floor":return[r.floor(SI("x",e,t,n))];case"Log":return[r.log(SI("x",e,t,n))];case"Log1p":return[r.log1p(SI("x",e,t,n))];case"Imag":return[r.imag(SI("x",e,t,n))];case"Neg":return[r.neg(SI("x",e,t,n))];case"Reciprocal":return[r.reciprocal(SI("x",e,t,n))];case"Real":return[r.real(SI("x",e,t,n))];case"Relu":return[r.relu(SI("x",e,t,n))];case"Round":return[r.round(SI("x",e,t,n))];case"Selu":return[r.selu(SI("x",e,t,n))];case"Sigmoid":return[r.sigmoid(SI("x",e,t,n))];case"Sin":return[r.sin(SI("x",e,t,n))];case"Sign":return[r.sign(SI("x",e,t,n))];case"Sinh":return[r.sinh(SI("x",e,t,n))];case"Softplus":return[r.softplus(SI("x",e,t,n))];case"Sqrt":return[r.sqrt(SI("x",e,t,n))];case"Square":return[r.square(SI("x",e,t,n))];case"Tanh":return[r.tanh(SI("x",e,t,n))];case"Tan":return[r.tan(SI("x",e,t,n))];case"ClipByValue":return[r.clipByValue(SI("x",e,t,n),SI("clipValueMin",e,t,n),SI("clipValueMax",e,t,n))];case"Relu6":return[r.relu6(SI("x",e,t,n))];case"Rsqrt":return[r.rsqrt(NI(e.inputNames[0],t,n))];case"LeakyRelu":return[r.leakyRelu(SI("x",e,t,n),SI("alpha",e,t,n))];case"Prelu":return[r.prelu(SI("x",e,t,n),SI("alpha",e,t,n))];case"IsNan":return[r.isNaN(NI(e.inputNames[0],t,n))];case"IsInf":return[r.isInf(NI(e.inputNames[0],t,n))];case"IsFinite":return[r.isFinite(NI(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"control":return bC(e,t,n);case"convolution":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"Conv1D":{const s=SI("stride",e,t,n),a=SI("pad",e,t,n),i=SI("dataFormat",e,t,n).toUpperCase(),o=SI("dilation",e,t,n);return[r.conv1d(SI("x",e,t,n),SI("filter",e,t,n),s,a,i,o)]}case"Conv2D":{const s=SI("strides",e,t,n),a=EI(e,t,n),i=SI("dataFormat",e,t,n).toUpperCase(),o=SI("dilations",e,t,n);return[r.conv2d(SI("x",e,t,n),SI("filter",e,t,n),[s[1],s[2]],a,i,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:s,pad:a,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:h}=vC(e,t,n);return[r.fused.conv2d({x:SI("x",e,t,n),filter:SI("filter",e,t,n),strides:[s[1],s[2]],pad:a,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:h})]}case"FusedDepthwiseConv2dNative":{const{stride:s,pad:a,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:h}=vC(e,t,n);return[r.fused.depthwiseConv2d({x:SI("x",e,t,n),filter:SI("filter",e,t,n),strides:[s[1],s[2]],pad:a,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:h})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=SI("outputShape",e,t,n),a=SI("strides",e,t,n),i=EI(e,t,n);return[r.conv2dTranspose(SI("x",e,t,n),SI("filter",e,t,n),s,[a[1],a[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=SI("strides",e,t,n),a=EI(e,t,n),i=SI("dilations",e,t,n),o=SI("dataFormat",e,t,n).toUpperCase();return[r.depthwiseConv2d(SI("input",e,t,n),SI("filter",e,t,n),[s[1],s[2]],a,o,[i[1],i[2]])]}case"Conv3D":{const s=SI("strides",e,t,n),a=SI("pad",e,t,n),i=SI("dataFormat",e,t,n).toUpperCase(),o=SI("dilations",e,t,n);return[r.conv3d(SI("x",e,t,n),SI("filter",e,t,n),[s[1],s[2],s[3]],a,i,[o[1],o[2],o[3]])]}case"AvgPool":{const s=SI("strides",e,t,n),a=SI("pad",e,t,n),i=SI("kernelSize",e,t,n);return[r.avgPool(SI("x",e,t,n),[i[1],i[2]],[s[1],s[2]],a)]}case"MaxPool":{const s=SI("strides",e,t,n),a=SI("pad",e,t,n),i=SI("kernelSize",e,t,n);return[r.maxPool(SI("x",e,t,n),[i[1],i[2]],[s[1],s[2]],a)]}case"MaxPoolWithArgmax":{const s=SI("strides",e,t,n),a=SI("pad",e,t,n),i=SI("kernelSize",e,t,n),o=SI("includeBatchInIndex",e,t,n),{result:l,indexes:u}=r.maxPoolWithArgmax(SI("x",e,t,n),[i[1],i[2]],[s[1],s[2]],a,o);return[l,u]}case"AvgPool3D":{const s=SI("strides",e,t,n),a=SI("pad",e,t,n),i=SI("kernelSize",e,t,n);return[r.avgPool3d(SI("x",e,t,n),[i[1],i[2],i[3]],[s[1],s[2],s[3]],a)]}case"MaxPool3D":{const s=SI("strides",e,t,n),a=SI("pad",e,t,n),i=SI("kernelSize",e,t,n);return[r.maxPool3d(SI("x",e,t,n),[i[1],i[2],i[3]],[s[1],s[2],s[3]],a)]}case"Dilation2D":{const s=SI("strides",e,t,n),a=SI("pad",e,t,n),i=SI("dilations",e,t,n),o=s[1],l=s[2],u=i[1],c=i[2];return[r.dilation2d(SI("x",e,t,n),SI("filter",e,t,n),[o,l],a,[u,c],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"creation":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"Fill":{const s=SI("shape",e,t,n),a=SI("dtype",e,t,n),i=SI("value",e,t,n);return[r.fill(s,i,a)]}case"LinSpace":{const s=SI("start",e,t,n),a=SI("stop",e,t,n),i=SI("num",e,t,n);return[r.linspace(s,a,i)]}case"Multinomial":{const s=SI("logits",e,t,n),a=SI("numSamples",e,t,n),i=SI("seed",e,t,n);return[r.multinomial(s,a,i)]}case"OneHot":{const s=SI("indices",e,t,n),a=SI("depth",e,t,n),i=SI("onValue",e,t,n),o=SI("offValue",e,t,n),l=SI("dtype",e,t,n);return[r.oneHot(s,a,i,o,l)]}case"Ones":return[r.ones(SI("shape",e,t,n),SI("dtype",e,t,n))];case"OnesLike":return[r.onesLike(SI("x",e,t,n))];case"RandomStandardNormal":return[r.randomStandardNormal(SI("shape",e,t,n),SI("dtype",e,t,n),SI("seed",e,t,n))];case"RandomUniform":return[r.randomUniform(SI("shape",e,t,n),SI("minval",e,t,n),SI("maxval",e,t,n),SI("dtype",e,t,n))];case"RandomUniformInt":return[r.randomUniformInt(SI("shape",e,t,n),SI("minval",e,t,n),SI("maxval",e,t,n),SI("seed",e,t,n))];case"Range":{const s=SI("start",e,t,n),a=SI("stop",e,t,n),i=SI("step",e,t,n);return[r.range(s,a,i,SI("dtype",e,t,n))]}case"TruncatedNormal":{const s=SI("shape",e,t,n),a=SI("mean",e,t,n),i=SI("stdDev",e,t,n),o=SI("seed",e,t,n);return[r.truncatedNormal(s,a,i,SI("dtype",e,t,n),o)]}case"Zeros":return[r.zeros(SI("shape",e,t,n),SI("dtype",e,t,n))];case"ZerosLike":return[r.zerosLike(SI("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"dynamic":return async function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:I;switch(e.op){case"NonMaxSuppressionV5":{const{boxes:r,scores:a,maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=xC(e,t,n),c=await s.image.nonMaxSuppressionWithScoreAsync(r,a,i,o,l,u);return[c.selectedIndices,c.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:r,scores:a,maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=xC(e,t,n),u=SI("padToMaxOutputSize",e,t,n),c=await s.image.nonMaxSuppressionPaddedAsync(r,a,i,o,l,u);return[c.selectedIndices,c.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:r,scores:a,maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=xC(e,t,n);return[await s.image.nonMaxSuppressionAsync(r,a,i,o,l)]}case"Where":{const r=s.cast(SI("condition",e,t,n),"bool"),a=[await s.whereAsync(r)];return r.dispose(),a}case"ListDiff":return s.setdiff1dAsync(SI("x",e,t,n),SI("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n);case"evaluation":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"LowerBound":{const s=SI("sortedSequence",e,t,n),a=SI("values",e,t,n);return[r.lowerBound(s,a)]}case"TopKV2":{const s=SI("x",e,t,n),a=SI("k",e,t,n),i=SI("sorted",e,t,n),o=r.topk(s,a,i);return[o.values,o.indices]}case"UpperBound":{const s=SI("sortedSequence",e,t,n),a=SI("values",e,t,n);return[r.upperBound(s,a)]}case"Unique":{const s=SI("x",e,t,n),a=r.unique(s);return[a.values,a.indices]}case"UniqueV2":{const s=SI("x",e,t,n),a=SI("axis",e,t,n),i=r.unique(s,a);return[i.values,i.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"image":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"ResizeBilinear":{const s=SI("images",e,t,n),a=SI("size",e,t,n),i=SI("alignCorners",e,t,n),o=SI("halfPixelCenters",e,t,n);return[r.image.resizeBilinear(s,[a[0],a[1]],i,o)]}case"ResizeNearestNeighbor":{const s=SI("images",e,t,n),a=SI("size",e,t,n),i=SI("alignCorners",e,t,n),o=SI("halfPixelCenters",e,t,n);return[r.image.resizeNearestNeighbor(s,[a[0],a[1]],i,o)]}case"CropAndResize":{const s=SI("image",e,t,n),a=SI("boxes",e,t,n),i=SI("boxInd",e,t,n),o=SI("cropSize",e,t,n),l=SI("method",e,t,n),u=SI("extrapolationValue",e,t,n);return[r.image.cropAndResize(s,a,i,o,l,u)]}case"ImageProjectiveTransformV3":{const s=SI("images",e,t,n),a=SI("transforms",e,t,n),i=SI("outputShape",e,t,n),o=SI("fillValue",e,t,n),l=SI("interpolation",e,t,n),u=SI("fillMode",e,t,n);return[r.image.transform(s,a,l.toLowerCase(),u.toLowerCase(),o,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"graph":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":const s=SI("default",e,t,n);return[NI(e.name,t,n)||s];case"Placeholder":return[NI(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[$I(SI("x",e,t,n))];case"IdentityN":return SI("x",e,t,n).map((e=>$I(e)));case"Shape":return[r.tensor1d(SI("x",e,t,n).shape,"int32")];case"ShapeN":return SI("x",e,t,n).map((e=>r.tensor1d(e.shape)));case"Size":return[r.scalar(SI("x",e,t,n).size,"int32")];case"Rank":return[r.scalar(SI("x",e,t,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const a=SI("x",e,t,n),i=SI("data",e,t,n),o=SI("message",e,t,n),l=SI("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(o);for(let e=0;e<i.length;e++)console.log(Array.prototype.slice.call(i[e].dataSync()).slice(0,l));return[a];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"logical":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"Equal":return[r.equal(SI("a",e,t,n),SI("b",e,t,n))];case"NotEqual":return[r.notEqual(SI("a",e,t,n),SI("b",e,t,n))];case"Greater":return[r.greater(SI("a",e,t,n),SI("b",e,t,n))];case"GreaterEqual":return[r.greaterEqual(SI("a",e,t,n),SI("b",e,t,n))];case"Less":return[r.less(SI("a",e,t,n),SI("b",e,t,n))];case"LessEqual":return[r.lessEqual(SI("a",e,t,n),SI("b",e,t,n))];case"LogicalAnd":return[r.logicalAnd(SI("a",e,t,n),SI("b",e,t,n))];case"LogicalNot":return[r.logicalNot(SI("a",e,t,n))];case"LogicalOr":return[r.logicalOr(SI("a",e,t,n),SI("b",e,t,n))];case"Select":case"SelectV2":return[r.where(SI("condition",e,t,n),SI("a",e,t,n),SI("b",e,t,n))];case"BitwiseAnd":return[r.bitwiseAnd(SI("a",e,t,n),SI("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"matrices":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(SI("a",e,t,n),SI("b",e,t,n),SI("transposeA",e,t,n),SI("transposeB",e,t,n))];case"Einsum":return[r.einsum(SI("equation",e,t,n),...SI("tensors",e,t,n))];case"Transpose":return[r.transpose(SI("x",e,t,n),SI("perm",e,t,n))];case"_FusedMatMul":const[s,a]=SI("fusedOps",e,t,n),i="biasadd"===s,o="prelu"===a,l=SI("numArgs",e,t,n),u=SI("leakyreluAlpha",e,t,n);if(i){if(o&&2!==l)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&1!==l)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[c,h]=SI("args",e,t,n);return[r.fused.matMul({a:SI("a",e,t,n),b:SI("b",e,t,n),transposeA:SI("transposeA",e,t,n),transposeB:SI("transposeB",e,t,n),bias:c,activation:a,preluActivationWeights:h,leakyreluAlpha:u})];case"MatrixBandPart":return[r.linalg.bandPart(SI("a",e,t,n),SI("numLower",e,t,n),SI("numUpper",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"normalization":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"EuclideanNorm":return[r.euclideanNorm(SI("x",e,t,n),SI("axis",e,t,n),SI("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[r.batchNorm(SI("x",e,t,n),SI("mean",e,t,n),SI("variance",e,t,n),SI("offset",e,t,n),SI("scale",e,t,n),SI("epsilon",e,t,n))];case"LRN":return[r.localResponseNormalization(SI("x",e,t,n),SI("radius",e,t,n),SI("bias",e,t,n),SI("alpha",e,t,n),SI("beta",e,t,n))];case"Softmax":return[r.softmax(SI("x",e,t,n))];case"LogSoftmax":return[r.logSoftmax(SI("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"ragged":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"RaggedGather":{const{outputNestedSplits:s,outputDenseValues:a}=r.raggedGather(SI("paramsNestedSplits",e,t,n),SI("paramsDenseValues",e,t,n),SI("indices",e,t,n),SI("outputRaggedRank",e,t,n));return s.concat(a)}case"RaggedRange":{const{rtNestedSplits:s,rtDenseValues:a}=r.raggedRange(SI("starts",e,t,n),SI("limits",e,t,n),SI("splits",e,t,n));return[s,a]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(SI("shape",e,t,n),SI("values",e,t,n),SI("defaultValue",e,t,n),SI("rowPartitionTensors",e,t,n),SI("rowPartitionTypes",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"reduction":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"Max":{const s=SI("axis",e,t,n),a=SI("keepDims",e,t,n);return[r.max(SI("x",e,t,n),s,a)]}case"Mean":{const s=SI("axis",e,t,n),a=SI("keepDims",e,t,n);return[r.mean(SI("x",e,t,n),s,a)]}case"Min":{const s=SI("axis",e,t,n),a=SI("keepDims",e,t,n);return[r.min(SI("x",e,t,n),s,a)]}case"Sum":{const s=SI("axis",e,t,n),a=SI("keepDims",e,t,n);return[r.sum(SI("x",e,t,n),s,a)]}case"All":{const s=SI("axis",e,t,n),a=SI("keepDims",e,t,n);return[r.all(SI("x",e,t,n),s,a)]}case"Any":{const s=SI("axis",e,t,n),a=SI("keepDims",e,t,n);return[r.any(SI("x",e,t,n),s,a)]}case"ArgMax":{const s=SI("axis",e,t,n);return[r.argMax(SI("x",e,t,n),s)]}case"ArgMin":{const s=SI("axis",e,t,n);return[r.argMin(SI("x",e,t,n),s)]}case"Prod":{const s=SI("axis",e,t,n),a=SI("keepDims",e,t,n);return[r.prod(SI("x",e,t,n),s,a)]}case"Cumprod":{const s=SI("axis",e,t,n),a=SI("exclusive",e,t,n),i=SI("reverse",e,t,n);return[r.cumprod(SI("x",e,t,n),s,a,i)]}case"Cumsum":{const s=SI("axis",e,t,n),a=SI("exclusive",e,t,n),i=SI("reverse",e,t,n);return[r.cumsum(SI("x",e,t,n),s,a,i)]}case"Bincount":const s=SI("x",e,t,n),a=SI("weights",e,t,n),i=SI("size",e,t,n);return[r.bincount(s,a,i)];case"DenseBincount":{const s=SI("x",e,t,n),a=SI("weights",e,t,n),i=SI("size",e,t,n),o=SI("binaryOutput",e,t,n);return[r.denseBincount(s,a,i,o)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"slice_join":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"ConcatV2":case"Concat":{const s=SI("n",e,t,n),a=SI("axis",e,t,n);let i=SI("tensors",e,t,n);return i=i.slice(0,s),[r.concat(i,a)]}case"Gather":{const s=SI("x",e,t,n),a=SI("indices",e,t,n);return[r.gather(s,r.cast(a,"int32"),0)]}case"GatherV2":{const s=SI("axis",e,t,n),a=SI("batchDims",e,t,n),i=SI("x",e,t,n),o=SI("indices",e,t,n);return[r.gather(i,r.cast(o,"int32"),s,a)]}case"Reverse":{const s=SI("dims",e,t,n),a=[];for(let e=0;e<s.length;e++)s[e]&&a.push(e);const i=SI("x",e,t,n);return[r.reverse(i,a)]}case"ReverseV2":{const s=SI("axis",e,t,n),a=SI("x",e,t,n);return[r.reverse(a,s)]}case"Slice":{const s=SI("begin",e,t,n),a=SI("size",e,t,n);return[r.slice(SI("x",e,t,n),s,a)]}case"StridedSlice":{const s=SI("begin",e,t,n),a=SI("end",e,t,n),i=SI("strides",e,t,n),o=SI("beginMask",e,t,n),l=SI("endMask",e,t,n),u=SI("ellipsisMask",e,t,n),c=SI("newAxisMask",e,t,n),h=SI("shrinkAxisMask",e,t,n),d=SI("x",e,t,n);return[r.stridedSlice(d,s,a,i,o,l,u,c,h)]}case"Pack":return Gl((()=>{const s=SI("axis",e,t,n),a=SI("tensors",e,t,n),i=a[0].shape,o=r.squeeze(a[0]).shape,l=a.map((e=>{const t=wr(e.shape,i);if(!t&&!wr(r.squeeze(e).shape,o))throw new Error("the input tensors shape does not match");return t?e:r.reshape(e,i)}));return[r.stack(l,s)]}));case"Unpack":{const s=SI("axis",e,t,n),a=SI("tensor",e,t,n);return r.unstack(a,s)}case"Tile":{const s=SI("reps",e,t,n);return[r.tile(SI("x",e,t,n),s)]}case"Split":case"SplitV":{const s=SI("axis",e,t,n),a=SI("numOrSizeSplits",e,t,n),i=SI("x",e,t,n);return r.split(i,a,s)}case"ScatterNd":{const s=SI("indices",e,t,n),a=SI("values",e,t,n),i=SI("shape",e,t,n);return[r.scatterND(s,a,i)]}case"GatherNd":{const s=SI("x",e,t,n),a=SI("indices",e,t,n);return[r.gatherND(s,a)]}case"SparseToDense":{const s=SI("sparseIndices",e,t,n),a=SI("outputShape",e,t,n),i=SI("sparseValues",e,t,n),o=SI("defaultValue",e,t,n);return[r.sparseToDense(s,i,a,i.dtype===o.dtype?o:r.cast(o,i.dtype))]}case"TensorScatterUpdate":{const s=SI("indices",e,t,n),a=SI("values",e,t,n),i=SI("tensor",e,t,n);return[r.tensorScatterUpdate(i,s,a)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"sparse":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"SparseFillEmptyRows":{const{outputIndices:s,outputValues:a,emptyRowIndicator:i,reverseIndexMap:o}=r.sparse.sparseFillEmptyRows(SI("indices",e,t,n),SI("values",e,t,n),SI("denseShape",e,t,n),SI("defaultValue",e,t,n));return[s,a,i,o]}case"SparseReshape":{const{outputIndices:s,outputShape:a}=r.sparse.sparseReshape(SI("inputIndices",e,t,n),SI("inputShape",e,t,n),SI("newShape",e,t,n));return[s,a]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(SI("data",e,t,n),SI("indices",e,t,n),SI("segmentIds",e,t,n))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(SI("data",e,t,n),SI("indices",e,t,n),SI("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"spectral":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"FFT":return[r.fft(SI("x",e,t,n))];case"IFFT":return[r.ifft(SI("x",e,t,n))];case"RFFT":return[r.rfft(SI("x",e,t,n))];case"IRFFT":return[r.irfft(SI("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"string":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(SI("input",e,t,n),SI("pattern",e,t,n),SI("rewrite",e,t,n),SI("replaceGlobal",e,t,n))];case"StringNGrams":{const{nGrams:s,nGramsSplits:a}=r.string.stringNGrams(SI("data",e,t,n),SI("dataSplits",e,t,n),SI("separator",e,t,n),SI("nGramWidths",e,t,n),SI("leftPad",e,t,n),SI("rightPad",e,t,n),SI("padWidth",e,t,n),SI("preserveShortSequences",e,t,n));return[s,a]}case"StringSplit":{const{indices:s,values:a,shape:i}=r.string.stringSplit(SI("input",e,t,n),SI("delimiter",e,t,n),SI("skipEmpty",e,t,n));return[s,a,i]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(SI("input",e,t,n),SI("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"transformation":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"Cast":return[r.cast(SI("x",e,t,n),SI("dtype",e,t,n))];case"ExpandDims":{const s=SI("axis",e,t,n);return[r.expandDims(SI("x",e,t,n),s)]}case"Squeeze":{const s=SI("axis",e,t,n);return[r.squeeze(SI("x",e,t,n),s)]}case"Reshape":return[r.reshape(SI("x",e,t,n),SI("shape",e,t,n))];case"EnsureShape":return[r.ensureShape(SI("x",e,t,n),SI("shape",e,t,n))];case"MirrorPad":return[r.mirrorPad(SI("x",e,t,n),SI("padding",e,t,n),SI("mode",e,t,n))];case"PadV2":case"Pad":return[r.pad(SI("x",e,t,n),SI("padding",e,t,n),SI("constantValue",e,t,n))];case"SpaceToBatchND":{const s=SI("blockShape",e,t,n),a=SI("paddings",e,t,n);return[r.spaceToBatchND(SI("x",e,t,n),s,a)]}case"BatchToSpaceND":{const s=SI("blockShape",e,t,n),a=SI("crops",e,t,n);return[r.batchToSpaceND(SI("x",e,t,n),s,a)]}case"DepthToSpace":{const s=SI("blockSize",e,t,n),a=SI("dataFormat",e,t,n).toUpperCase();return[r.depthToSpace(SI("x",e,t,n),s,a)]}case"BroadcastTo":return[r.broadcastTo(SI("x",e,t,n),SI("shape",e,t,n))];case"BroadcastArgs":return[r.broadcastArgs(SI("s0",e,t,n),SI("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"hash_table":return(async(e,t,n,r)=>{switch(e.op){case"HashTable":case"HashTableV2":{const s=r.getHashTableHandleByName(e.name);if(null!=s)return[s];{const s=SI("keyDType",e,t,n),a=SI("valueDType",e,t,n),i=new wC(s,a);return r.addHashTable(e.name,i),[i.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const s=SI("tableHandle",e,t,n,r),a=SI("keys",e,t,n),i=SI("values",e,t,n),o=r.getHashTableById(s.id);return[await o.import(a,i)]}case"LookupTableFind":case"LookupTableFindV2":{const s=SI("tableHandle",e,t,n,r),a=SI("keys",e,t,n),i=SI("defaultValue",e,t,n),o=r.getHashTableById(s.id);return[await o.find(a,i)]}case"LookupTableSize":case"LookupTableSizeV2":{const s=SI("tableHandle",e,t,n,r);return[r.getHashTableById(s.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n,r);case"custom":const a=kI(e.op);if(a&&a.customExecutor)return a.customExecutor(new hC(e,t,n));throw TypeError(`Custom op ${e.op} is not registered.`);default:throw TypeError(`Unknown op '${e.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return qr(a)?a.then((e=>[].concat(e))):[].concat(a)}class SC{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},s=arguments.length>4?arguments[4]:void 0;this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=r,this.parseNodeNameCache=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map((e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`)).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}function NC(e,t,n,r){const s=new Set,a=[];let i=null,o=null;const l=new Set,u=new Set(Object.keys(e).map((e=>AI(e)[0])));r=r||[];const c=new Set(r.map((e=>AI(e.name)[0]))),h=[...t];for(;h.length>0;){const e=h.pop();($C(e)||RC(e)||DC(e))&&null==i&&(i=e,o=i.children.map((e=>e.name)).filter((e=>s.has(e)))),s.add(e.name),null==n[e.name]&&(u.has(e.name)||c.has(e.name)||(0!==e.inputs.length?e.inputs.forEach((e=>{l.has(e.name)||(l.add(e.name),h.push(e))})):a.push(e.name)))}return{inputs:e,outputs:t,usedNodes:s,missingInputs:a,dynamicNode:i,syncInputs:o}}function IC(e,t){const{usedNodes:n,inputs:r}=t,s=Object.keys(r).map((e=>AI(e)[0])).map((t=>e.nodes[t])),a=e.initNodes||[],i=e=>n.has("string"===typeof e?e:e.name);function o(e){return[...new Map(e.map((e=>[e.name,e]))).values()]}const l=o([...s,...e.weights,...a]).filter(i),u=o([...l,...Object.values(e.nodes)]).filter(i),c=new Map(u.map((e=>[e.name,e]))),h={};for(const m of u){h[m.name]=h[m.name]||0;for(const e of m.children)i(e)||(h[e.name]=Number.POSITIVE_INFINITY),h[e.name]=(h[e.name]||0)+1}const d=Object.entries(h).filter((e=>{let[,t]=e;return 0===t})).map((e=>{let[t]=e;return t})),p=[...d];for(;d.length>0;){const e=d.pop(),t=c.get(e);for(const n of t.children.filter(i))0===--h[n.name]&&(p.push(n.name),d.push(n.name))}const f=function(e,t){const n=new Map(e.map((e=>[e.name,e]))),r=t.map((e=>e.name)),s=new Set(r);for(;r.length>0;){const e=r.pop(),t=n.get(e);for(const a of t.children)n.has(a.name)&&!s.has(a.name)&&(s.add(a.name),r.push(a.name))}const a=e.filter((e=>s.has(e.name)));return a}(p.map((e=>c.get(e))),l);return function(e,t){const n=new Map(e.map(((e,t)=>[e.name,t]))),r=new Set(t.map((e=>e.name))),s=e=>r.has("string"===typeof e?e:e.name),a=new Set(e.map((e=>e.name))),i=e=>a.has("string"===typeof e?e:e.name);for(const o of e){for(const e of o.children.filter(i)){if(!n.has(e.name))throw new CC(`Child ${e.name} of node ${o.name} is unreachable.`);if(n.get(o.name)>n.get(e.name))throw new CC(`Node ${o.name} is scheduled to run after its child ${e.name}.`)}if(!s(o))for(const e of o.inputs){if(!n.has(e.name))throw new CC(`Input ${e.name} of node ${o.name} is unreachable.`);if(n.get(e.name)>n.get(o.name))throw new CC(`Node ${o.name} is scheduled to run before its input ${e.name}.`)}}}(f,l),f}class CC extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}const TC=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),AC=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),EC=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function $C(e){return TC.has(e.op)}function RC(e){return AC.has(e.op)}function DC(e){return EC.has(e.op)}class OC{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map((t=>e[t].map((e=>e.id))));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get outputs(){return this._outputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get inputNodes(){return this._inputs.map((e=>e.signatureKey||e.name))}get outputNodes(){return this._outputs.map((e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t}))}get functions(){return Object.keys(this._functions).reduce(((e,t)=>(e[t]=this._functions[t].signature,e)),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,null!=e.functions&&Object.keys(e.functions).forEach((t=>{this._functionExecutorMap[t]=new OC(e.functions[t],this)}))}getCompilationKey(e,t){const n=e.map((e=>e.name)).sort(),r=t.map((e=>e.name)).sort();return n.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(e,t){const n=NC(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:s,syncInputs:a}=n;if(null!=s)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${a}]`);if(r.length>0){const n=t.map((e=>e.name)),s=Object.keys(e);throw new Error(`Cannot compute the outputs [${n}] from the provided inputs [${s}]. Missing the following inputs: [${r}]`)}const i=IC(this.graph,n),o=function(e){const t=new Map(e.map(((e,t)=>[e.name,t]))),n=Number.MAX_SAFE_INTEGER,r=e.map(((e,t)=>$C(e)?n:t)),s=e=>{const n=r[t.get(e.name)];return null==n?-1:n},a=e.map(((e,t)=>e.children.map(s).reduce(((e,t)=>Math.max(e,t)),r[t]))),i=new Map;for(let o=0;o<e.length;++o){const t=a[o];if(t===n)continue;const r=e[o],s=e[t];i.has(s.name)||i.set(s.name,[]),i.get(s.name).push(r)}return i}(i);return{orderedNodes:i,nodeLiveUntilMap:o}}cloneAndKeepTensor(e){if(null==e)return null;const t=e.clone();return ql(t),t}cloneTensorList(e){if(!e)return null;const t=e.map((e=>this.cloneAndKeepTensor(e)));return t}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map((e=>{let[t,n]=e;return[t,this.cloneTensorList(n)]})))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const r=n.map((e=>this.graph.nodes[AI(e)[0]])),s=t.map((e=>AI(e)[0])),a=new Set(s);let i=s.map((e=>this.graph.nodes[e]));0===i.length&&(i=this._outputs);const o=this.getCompilationKey(r,i);let l=this.compiledMap.get(o);null==l&&(l=this.compile(e,i),this.compiledMap.set(o,l));try{this.keepIntermediateTensors=Yr().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(E9){this.keepIntermediateTensors=!1,console.warn(E9.message)}const u={},c={};return Gl((()=>{const n=new SC(this.weightMap,u,c,this.functionExecutorMap,this.parseNodeNameCache),r=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach((t=>{const[s,a]=AI(t,n),i=[];i[a]=e[t],r[s]=i,this.keepIntermediateTensors&&(this.clonedTensorsMap[s]=this.cloneTensorList(i))}));const s=this.getFrozenTensorIds(r),{orderedNodes:i,nodeLiveUntilMap:o}=l;for(const e of i){if(r[e.name])continue;const t=kC(e,r,n,this._resourceManager);if(qr(t))throw new Error(`The execution of the op '${e.op}' returned a promise. Please use model.executeAsync() instead.`);r[e.name]=t,this.keepIntermediateTensors&&(this.clonedTensorsMap[e.name]=this.cloneTensorList(t)),this.checkTensorForDisposalWithNodeLiveUntilInfo(e,r,n,s,a,o.get(e.name))}return null==this.parent&&n.dispose(s),t.map((e=>NI(e,r,n)))}))}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map((t=>e[t])).map((e=>e.map((e=>e.id)))));return new Set(t)}checkTensorForDisposal(e,t,n,r,s,a,i){if(!$C(t)&&!a.has(e)){for(const r of n[e])null!=r&&(i[r.id]=(i[r.id]||0)+t.children.length);for(const e of t.inputs){if($C(e))continue;const t=II(e.name,n,r);if(null!=t)for(const e of t){if(!e||e.kept||s.has(e.id))continue;const t=i[e.id];1===t?(e.dispose(),delete i[e.id]):null!=t&&i[e.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,n,r,s,a){function i(e){return $C(e)||s.has(e.name)}if(!$C(e)&&null!=a)for(const o of a){if(i(o))continue;const e=II(o.name,t,n);for(const t of e)!t||t.kept||r.has(t.id)||t.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach((e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()})),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};this.disposeIntermediateTensors(),n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=Yr().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(E9){this.keepIntermediateTensors=!1,console.warn(E9.message)}const a=new SC(this.weightMap,r,s,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const i=await this.executeWithControlFlow(e,a,t,n),o=t.map((e=>NI(e,i,a))),l=o.map((e=>e.id)),u=Object.keys(e).map((t=>e[t].id)),c=new Set([...l,...u,...this.weightIds]);return Object.values(i).forEach((e=>{e.forEach((e=>{!e||e.isDisposed||c.has(e.id)||e.dispose()}))})),null==this.parent&&a.dispose(c),o}async executeFunctionAsync(e,t,n){const r=e.reduce(((e,t,n)=>(e[this.inputs[n].name]=t,e)),{});return this._executeAsync(r,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,r){const s=Object.keys(e),a=s.map((e=>this.graph.nodes[AI(e)[0]])),i=n.map((e=>AI(e)[0])),o=new Set(i);let l=i.map((e=>this.graph.nodes[e]));0===l.length&&(l=this._outputs);const{usedNodes:u,missingInputs:c,dynamicNode:h,syncInputs:d}=NC(e,l,this.weightMap,this._initNodes),p=[...a,...this.graph.weights,...this._initNodes||[]].map((e=>({node:e,contexts:t.currentContext}))),f=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{const[n,r]=AI(t),s=[];s[r]=e[t],f[n]=s}));const m={},g=this.getFrozenTensorIds(f),y={};for(;p.length>0;){const e=this.processStack(a,p,t,f,y,g,o,m,u);await Promise.all(e)}null!=h||r||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const b=l.filter((e=>!$C(e)&&!NI(e.name,f,t))).map((e=>e.name));if(b.length>0){let e="";throw null!=h&&(e=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${d}]`),new Error(`Cannot compute the outputs [${b}] from the provided inputs [${s}]. Consider providing the following inputs: [${c}]. ${e}`)}return f}processStack(e,t,n,r,s,a,i,o,l){const u=[];for(;t.length>0;){const e=t.pop();n.currentContext=e.contexts;let c="";if("Enter"===e.node.op&&SI("isConstant",e.node,r,n)&&([c]=CI(e.node.name,n)),null==r[e.node.name]){const h=kC(e.node,r,n,this._resourceManager);c||([c]=CI(e.node.name,n));const d=n.currentContext;qr(h)?u.push(h.then((u=>(r[c]=u,this.keepIntermediateTensors&&(this.clonedTensorsMap[c]=this.cloneTensorList(u)),n.currentContext=d,this.checkTensorForDisposal(c,e.node,r,n,a,i,o),this.processChildNodes(e.node,t,n,r,s,l),u)))):(r[c]=h,this.keepIntermediateTensors&&(this.clonedTensorsMap[c]=this.cloneTensorList(h)),this.checkTensorForDisposal(c,e.node,r,n,a,i,o),this.processChildNodes(e.node,t,n,r,s,l))}else this.processChildNodes(e.node,t,n,r,s,l)}return u}processChildNodes(e,t,n,r,s,a){e.children.forEach((e=>{const[i]=CI(e.name,n);!s[i]&&a.has(e.name)&&("Merge"===e.op?e.inputNames.some((e=>!!NI(e,r,n)))&&(s[i]=!0,t.push({contexts:n.currentContext,node:e})):e.inputNames.every((e=>!!NI(e,r,n)))&&(s[i]=!0,t.push({contexts:n.currentContext,node:e})))}))}dispose(){Object.keys(this.weightMap).forEach((e=>this.weightMap[e].forEach((e=>e.dispose()))))}checkInputShapeAndType(e){Object.keys(e).forEach((t=>{const n=e[t],[r]=AI(t),s=this.graph.nodes[r];if(s.attrParams.shape&&s.attrParams.shape.value){const e=s.attrParams.shape.value,t=e.length===n.shape.length&&n.shape.every(((t,n)=>-1===e[n]||e[n]===t));yr(t,(()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${e}], but was [${n.shape}]`))}s.attrParams.dtype&&s.attrParams.dtype.value&&yr(n.dtype===s.attrParams.dtype.value,(()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${n.dtype}`))}))}mapInputs(e){var t,n;const r={};for(const s in e){const a=null===(n=null===(t=this._signature)||void 0===t?void 0:t.inputs)||void 0===n?void 0:n[s];null!=a?r[a.name]=e[s]:r[s]=e[s]}return r}checkInputs(e){const t=Object.keys(e).filter((e=>{const[t]=AI(e);return null==this.graph.nodes[t]}));if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map((e=>{var t,n;const r=null===(n=null===(t=this._signature)||void 0===t?void 0:t.outputs)||void 0===n?void 0:n[e];return null!=r?r.name:e}),{})}checkOutputs(e){e.forEach((e=>{const[t]=AI(e);if(!this.graph.nodes[t])throw new Error(`The output '${e}' is not found in the graph`)}))}}class _C{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}const FC="?tfjs-format=file",MC="model.json";class LC{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:e;this.modelUrl=t,this.loadOptions=n,this.version="n/a",this.io=r,null==n&&(this.loadOptions={}),this.resourceManager=new _C}findIOHandler(){const e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(0===t.length)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return qr(e)?e.then((e=>null==e.getWeightStream?this.loadSync(e):this.loadStreaming(e))):this.loadSync(e)}loadSync(e){const t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(null==e.getWeightStream)throw new Error("Model artifacts missing streamWeights function");const t=await ru(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;const n=this.artifacts.modelTopology;let r=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){const e=this.artifacts.userDefinedMetadata;null!=e.signature&&(r=e.signature),null!=e.structuredOutputKeys&&(this.structuredOutputKeys=e.structuredOutputKeys)}if(this.signature=r,this.version=`${n.versions.producer}.${n.versions.minConsumer}`,this.executor=new OC(QI.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){const t=QI.Instance.transformGraph(e.modelInitializer);this.initializer=new OC(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if("string"===typeof e){const t=this.io.getSaveHandlers(e);if(0===t.length)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new Error(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t={};return(e instanceof sl?[e]:e).forEach(((e,n)=>t[this.structuredOutputKeys[n]]=e)),t}return e}predict(e,t){const n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){const n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){var t;if(!(e instanceof sl)&&!Array.isArray(e)){const n=null===(t=this.signature)||void 0===t?void 0:t.inputs;if(null!=n)for(const t in n){const r=n[t];null!=r.resourceId&&(e[t]=this.resourceIdToCapturedInput[r.resourceId])}return e}e=Array.isArray(e)?e:[e];const n=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+n!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-n} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce(((t,n)=>{var s,a,i;const o=null===(i=null===(a=null===(s=this.signature)||void 0===s?void 0:s.inputs)||void 0===a?void 0:a[n])||void 0===i?void 0:i.resourceId;return t[n]=null!=o?this.resourceIdToCapturedInput[o]:e[r++],t}),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,n=Object.keys(t);for(let r=0;r<n.length;r++){const s=t[n[r]];this.resourceIdToCapturedInput[s.resourceId]=e[r]}}}execute(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce(((t,n)=>(t[n]=[e[n]],t)),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Hl(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function PC(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:e;if(null==t)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==n&&(n={}),n.fromTFHub&&"string"===typeof t&&(t=function(e){e.endsWith("/")||(e+="/");return`${e}${MC}${FC}`}(t));const s=new LC(t,n,r);return await s.load(),s}function zC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Map,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new Set;if(null==e)return null;if("function"===typeof Blob&&e instanceof Blob)return e.slice();if(r.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);const s=t(e);if(s.recurse&&null!==s.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(s.recurse){if(UC(e)){const s=Array.isArray(e)?[]:{};r.add(e);for(const a in e){const i=zC(e[a],t,n,r);s[a]=i}return r.delete(e),e.__proto__&&(s.__proto__=e.__proto__),s}throw new Error(`Can't recurse into non-iterable type: ${e}`)}return n.set(e,s.value),s.value}function BC(e){return VC(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:WC)}function VC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Set;const r=e[0];if(n.has(r))throw new Error("Circular references are not supported.");const s=t(e);if(s.recurse&&null!==s.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(s.recurse){if(UC(r)){const s=Array.isArray(r)?[]:{};n.add(r);for(const a in r){const r=VC(e.map((e=>e[a])),t,n);s[a]=r}return n.delete(r),s}throw new Error(`Can't recurse into non-iterable type: ${r}`)}return s.value}function WC(e){return null===e?null:UC(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}function UC(e){let t=!1;if(Yr().get("IS_BROWSER"))t=e instanceof TextDecoder;else{const{StringDecoder:r}=n(551);t=e instanceof r}return null!=e&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||"object"===typeof e&&!(e instanceof sl)&&!(e instanceof Promise)&&!t)}function jC(e){return function(e,t){return zC(e,t)}(e,GC)}function GC(e){return e instanceof sl?{value:e.clone(),recurse:!1}:UC(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}class HC{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,null==e)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}}class qC extends HC{constructor(){super(qC.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=2*this.capacity,t=new Array(e),n=this.length();for(let r=0;r<n;r++)t[r]=this.get(this.wrap(this.begin+r));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}function KC(e){return new ZC(e)}function XC(e,t){return new uT(e,t)}qC.INITIAL_CAPACITY=32;class QC{async toArray(){const e=[];let t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){const e=this.prefetch(100),t=[];let n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new aT(this,e)}filter(e){return new rT(this,e)}map(e){return new sT(this,e)}mapAsync(e){return new iT(this,e)}serialMapAsync(e){return new iT(this,e).serial()}flatmap(e){return new lT(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile((e=>!0===e))}rowMajorBatch(e){return new nT(this,e,!(arguments.length>1&&void 0!==arguments[1])||arguments[1])}columnMajorBatch(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:WC;return this.rowMajorBatch(e,t).map((e=>BC(e,n)))}concatenate(e,t){return new uT(new YC([this,e]),t)}take(e){return e<0||null==e?this:new tT(this,e)}skip(e){return e<0||null==e?this:new eT(this,e)}prefetch(e){return new hT(this,e)}shuffle(e,t){return new dT(this,e,t)}serial(){return new JC(this)}}class YC extends QC{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const e=this.items[this.trav];return this.trav++,{value:jC(e),done:!1}}}class ZC extends QC{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(E9){throw E9.message=`Error thrown while iterating through a dataset: ${E9.message}`,E9}}}class JC extends QC{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){return this.upstream.next()}}class eT extends QC{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const e=await this.upstream.next();if(e.done)return e;Hl(e.value)}return this.upstream.next()}}class tT extends QC{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class nT extends QC{constructor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){const e=[];for(;e.length<this.batchSize;){const t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}}class rT extends QC{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;){const e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;Hl(e.value)}}}class sT extends QC{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=vl(e.value),n=this.transform(e.value),r=vl(n);for(const s of t)bl(s,r)||s.dispose();return{value:n,done:!1}}}class aT extends QC{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(E9){if(!this.handler(E9))return{value:null,done:!0}}}}class iT extends QC{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=vl(e.value),n=await this.transform(e.value),r=vl(n);for(const s of t)bl(s,r)||s.dispose();return{value:n,done:!1}}}class oT extends QC{constructor(){super(),this.outputQueue=new qC,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class lT extends oT{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const e=await this.upstream.next();if(e.done)return!1;const t=vl(e.value),n=this.transform(e.value),r=vl(n);this.outputQueue.pushAll(n);for(const s of t)bl(s,r)||s.dispose();return!0}}class uT extends QC{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,null==this.iterator){const e=await this.moreIterators.next();if(e.done)return{value:null,done:!0};this.iterator=e.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}}var cT;!function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"}(cT||(cT={}));class hT extends QC{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new HC(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class dT extends hT{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=uf.alea(n||Vo().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(!t.done)return this.refill(),t;this.upstreamExhausted=!0}return{value:null,done:!0}}}class pT{constructor(){this.size=null}batch(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=this;let r;return yr(e>0,(()=>`batchSize needs to be positive, but it is\n      ${e}`)),r=this.size===1/0||null==this.size?this.size:t?Math.ceil(this.size/e):Math.floor(this.size/e),fT((async()=>(await n.iterator()).columnMajorBatch(e,t,mT)),r)}concatenate(e){const t=this;let n;return n=this.size===1/0||e.size===1/0?1/0:null!=this.size&&null!=e.size?this.size+e.size:null,fT((async()=>(await t.iterator()).concatenate(await e.iterator())),n)}filter(e){const t=this;let n;return n=this.size===1/0?1/0:null,fT((async()=>(await t.iterator()).filter((t=>Gl((()=>e(t)))))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){const t=this;return fT((async()=>(await t.iterator()).map((t=>Gl((()=>e(t)))))),this.size)}mapAsync(e){const t=this;return fT((async()=>(await t.iterator()).mapAsync(e)),this.size)}prefetch(e){if(null==e)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const t=this;return fT((async()=>(await t.iterator()).prefetch(e)),this.size)}repeat(e){const t=this;let n;return n=null!=this.size&&e>0?this.size*e:0===e?0:null!=this.size&&(void 0===e||e<0)?1/0:null,fT((async()=>XC(KC((async()=>({value:await t.iterator(),done:!1}))).take(e))),n)}skip(e){const t=this;let n;return n=null!=this.size&&e>=0&&this.size>=e?this.size-e:null!=this.size&&(this.size<e||void 0===e||e<0)?0:null,fT((async()=>(await t.iterator()).skip(e)),n)}shuffle(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(null==e||e<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const r=this,s=uf.alea(t||Vo().toString());return fT((async()=>{let t=s.int32();return n&&(t+=s.int32()),(await r.iterator()).shuffle(e,t.toString())}),this.size)}take(e){const t=this;let n;return n=null!=this.size&&this.size>e?e:null!=this.size&&this.size<=e?this.size:null,fT((async()=>(await t.iterator()).take(e)),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function fT(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return new class extends pT{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function mT(e){if(null===e)return null;const t=e[0];if(null==(n=t)||function(e){return null===e||"object"!==typeof e&&"function"!==typeof e}(n)||Array.isArray(n)||"object"===typeof n&&n instanceof sl||jo(n)){return{value:function(e){if(0===e.length)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof sl?Kf(e):Bl(e)}(e),recurse:!1}}var n;return{value:null,recurse:!0}}pT.MAX_BUFFER_SIZE=1e4;Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");function gT(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&yr("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the CPU backend.`))}))}const yT=fm;class bT extends hr{nextDataId(){return bT.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new cr(this,Ul())}write(e,t,n){this.firstUse&&(this.firstUse=!1,Yr().get("IS_NODE")&&fo("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:n,refCount:1}),r}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&Or(n[0])){const s=n.map((e=>Wo(e)));r=this.write(s,e,t)}else r=this.write(n,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){if(this.data.has(e)){return this.data.get(e).refCount}return 0}incRef(e){this.data.get(e).refCount++}decRef(e){if(this.data.has(e)){this.data.get(e).refCount--}}move(e,t,n,r,s){this.data.set(e,{values:t,dtype:r,refCount:s})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:n}=this.data.get(e);if("complex64"===t){return py(this.readSync(n.real.dataId),this.readSync(n.imag.dataId))}return function(e,t){if(Array.isArray(e))return e;if("float32"===t)return e instanceof Float32Array?e:new Float32Array(e);if("int32"===t)return e instanceof Int32Array?e:new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>Uo(e)));return Zu(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return Zu(e.shape,e.dtype,t)}makeOutput(e,t,n){return Ul().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=Vo();e();return{kernelMs:Vo()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){gT([e],"where");const t=this.readSync(e.dataId);return yT(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}bT.nextDataId=0;function vT(e){return(t,n,r)=>{const s=$r(n,t.length);for(let a=0;a<t.length;++a)s[a]=e(t[a],r);return s}}function xT(e,t,n){return wT(e,vT(t),n)}function wT(e,t,n){return r=>{let{inputs:s,attrs:a,backend:i}=r;const{x:o}=s;gT(o,e);const l=i,u=l.data.get(o.dataId).values;let c;if("string"===o.dtype){if(!Array.isArray(u))throw new Error("String tensor's value was not an instance of Array");c=qy(u)}else c=u;const h=n||o.dtype,d=t(c,h,a);return l.makeTensorInfo(o.shape,h,d)}}Kl("cpu",(()=>new bT),1);const kT=xT(ea,(e=>e>=0?e:Math.exp(e)-1)),ST={kernelName:ea,backendName:"cpu",kernelFunc:kT};function NT(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const IT={kernelName:ya,backendName:"cpu",kernelFunc:NT};function CT(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:a}=r;gT([s],"leakyRelu");const i=xr(s.shape),o=n.data.get(s.dataId).values,l=Er("float32",i);for(let u=0;u<o.length;u++)l[u]=o[u]<0?a*o[u]:o[u];return n.makeTensorInfo(s.shape,"float32",l)}const TT={kernelName:Sa,backendName:"cpu",kernelFunc:CT};function AT(e){return(t,n,r,s,a)=>{const i=Cc(t,n),o=i.length,l=Pr(i),u=Er(a,xr(i)),c=t.length,h=n.length,d=Pr(t),p=Pr(n),f=Nc(t,i),m=Nc(n,i);if(f.length+m.length===0)for(let g=0;g<u.length;++g)u[g]=e(r[g%r.length],s[g%s.length]);else for(let g=0;g<u.length;++g){const t=Hr(g,o,l),n=t.slice(-c);f.forEach((e=>n[e]=0));const a=Gr(n,c,d),i=t.slice(-h);m.forEach((e=>i[e]=0));const y=Gr(i,h,p);u[g]=e(r[a],s[y])}return[u,i]}}const ET=AT(((e,t)=>e<0?t*e:e));function $T(e){const{inputs:t,backend:n}=e,{x:r,alpha:s}=t;gT([r,s],"prelu");const a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,[o,l]=ET(r.shape,s.shape,a,i,"float32");return n.makeTensorInfo(l,"float32",o)}const RT={kernelName:si,backendName:"cpu",kernelFunc:$T},DT=xT(di,(e=>Math.max(0,e))),OT={kernelName:di,backendName:"cpu",kernelFunc:DT},_T=xT(bi,(e=>Math.min(Math.max(0,e),6))),FT={kernelName:bi,backendName:"cpu",kernelFunc:_T},MT=vT((e=>1/(1+Math.exp(-e)))),LT=xT(Ri,(e=>1/(1+Math.exp(-e)))),PT={kernelName:Ri,backendName:"cpu",kernelFunc:LT};function zT(e,t,n,r,s){if("linear"===n)return NT({inputs:{x:t},backend:e});if("relu"===n)return DT({inputs:{x:t},backend:e});if("elu"===n)return kT({inputs:{x:t},backend:e});if("relu6"===n)return _T({inputs:{x:t},backend:e});if("prelu"===n)return $T({inputs:{x:t,alpha:r},backend:e});if("leakyrelu"===n)return CT({inputs:{x:t},backend:e,attrs:{alpha:s}});if("sigmoid"===n)return LT({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function BT(e){const{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,o=n.makeTensorInfo(r.shape,"complex64");return n.data.get(o.dataId).complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",a),imag:n.makeTensorInfo(s.shape,"float32",i)},o}const VT={kernelName:As,backendName:"cpu",kernelFunc:BT};function WT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"float32";if("complex64"===n){return BT({inputs:{real:WT(e,t,"float32"),imag:WT(e,t,"float32")},backend:e})}const r=Wr(xr(t),n);return e.makeTensorInfo(t,n,r)}function UT(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.real,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}const jT={kernelName:ci,backendName:"cpu",kernelFunc:UT};function GT(e,t,n,r){if("int32"===r){return[t,"int32",Int32Array.from(e)]}if("bool"===r){const r=Bo([0],n),[s,a]=AT(((e,t)=>e!==t?1:0))(t,[],e,r,"bool");return[a,"bool",s]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}function HT(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dtype:a}=r;if("complex64"===a){if("complex64"===s.dtype)return NT({inputs:{x:s},backend:n});const e=WT(n,s.shape,s.dtype),t=HT({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),r=BT({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),r}if("complex64"===s.dtype){const e=UT({inputs:{input:s},backend:n}),t=HT({inputs:{x:e},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(e),t}if(!Rr(s.dtype,a)){const e=NT({inputs:{x:s},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:a}}const i=n.data.get(s.dataId).values,[o,l,u]=GT(i,s.shape,s.dtype,a);return n.makeTensorInfo(o,l,u)}const qT={kernelName:Is,backendName:"cpu",kernelFunc:HT};function KT(e,t,n,r){return null==n?n=>{let{inputs:s,backend:a}=n;const{a:i,b:o}=s,l=a;gT([i,o],e);const u=l.data.get(i.dataId).values,c=l.data.get(o.dataId).values,h="string"===i.dtype?qy(u):u,d="string"===i.dtype?qy(c):c,p=r||i.dtype,[f,m]=t(i.shape,o.shape,h,d,p);return l.makeTensorInfo(m,p,f)}:e=>{let{inputs:s,backend:a}=e;const{a:i,b:o}=s,l=a;if("complex64"===i.dtype||"complex64"===o.dtype){const e=HT({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),t=l.data.get(e.dataId),r=t.complexTensorInfos.real,s=t.complexTensorInfos.imag,a=l.data.get(r.dataId).values,u=l.data.get(s.dataId).values,c=HT({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),h=l.data.get(c.dataId),d=h.complexTensorInfos.real,p=h.complexTensorInfos.imag,f=l.data.get(d.dataId).values,m=l.data.get(p.dataId).values,[g,y,b]=n(i.shape,o.shape,a,u,f,m),v=l.makeTensorInfo(b,"float32",g),x=l.makeTensorInfo(b,"float32",y),w=BT({inputs:{real:v,imag:x},backend:l});return l.disposeIntermediateTensorInfo(e),l.disposeIntermediateTensorInfo(c),l.disposeIntermediateTensorInfo(v),l.disposeIntermediateTensorInfo(x),w}{const e=l.data.get(i.dataId).values,n=l.data.get(o.dataId).values,s=r||i.dtype,[a,u]=t(i.shape,o.shape,e,n,s);return l.makeTensorInfo(u,s,a)}}}function XT(e){return(t,n,r,s,a,i)=>{const o=Cc(t,n),l=xr(o),u=o.length,c=Pr(o),h=Er("float32",l),d=Er("float32",l),p=Nc(t,o),f=Nc(n,o),m=py(r,s),g=py(a,i),y=t.length,b=Pr(t),v=n.length,x=Pr(n);if(p.length+f.length===0)for(let w=0;w<h.length;w++){const t=w%m.length,n=w%g.length,r=e(m[2*t],m[2*t+1],g[2*n],g[2*n+1]);h[w]=r.real,d[w]=r.imag}else for(let w=0;w<h.length;w++){const t=Hr(w,u,c),n=t.slice(-y);p.forEach((e=>n[e]=0));const r=Gr(n,y,b),s=t.slice(-v);f.forEach((e=>s[e]=0));const a=Gr(s,v,x),i=e(m[2*r],m[2*r+1],g[2*a],g[2*a+1]);h[w]=i.real,d[w]=i.imag}return[h,d,o]}}const QT=AT(((e,t)=>e+t)),YT=XT(((e,t,n,r)=>({real:e+n,imag:t+r}))),ZT=KT(as,QT,YT),JT={kernelName:as,backendName:"cpu",kernelFunc:ZT};function eA(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:a}=r,i=xr(s.shape),o=Cr(a,i),l=xr(o);yr(i===l,(()=>`The new shape (${o}) has ${l} elements and the old shape (${s.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`)),n.incRef(s.dataId);const u=n.data.get(s.dataId);if(null!=u.complexTensorInfos){const e=u.complexTensorInfos.real,t=u.complexTensorInfos.imag;e.shape=o,t.shape=o}return{dataId:s.dataId,shape:o,dtype:s.dtype}}const tA={kernelName:pi,backendName:"cpu",kernelFunc:eA};function nA(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:i,transposeB:o}=r;gT([s,a],"matMul");const l=s.shape.length,u=a.shape.length,c=i?s.shape[l-2]:s.shape[l-1],h=o?a.shape[u-1]:a.shape[u-2],d=i?s.shape[l-1]:s.shape[l-2],p=o?a.shape[u-2]:a.shape[u-1],f=s.shape.slice(0,-2),m=a.shape.slice(0,-2),g=xr(f),y=xr(m),b=Cc(s.shape.slice(0,-2),a.shape.slice(0,-2)).concat([d,p]);yr(c===h,(()=>`Error in matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${s.shape} and ${a.shape} and transposeA=${i} and transposeB=${o} must match.`));const v=o?[y,p,h]:[y,h,p],x=eA({inputs:{x:s},backend:n,attrs:{shape:i?[g,c,d]:[g,d,c]}}),w=eA({inputs:{x:a},backend:n,attrs:{shape:v}}),k=i?x.shape[1]:x.shape[2],S=i?x.shape[2]:x.shape[1],N=o?w.shape[1]:w.shape[2],I=Math.max(g,y),C=n.data.get(x.dataId).values,T=n.data.get(w.dataId).values,A=Pr(x.shape),E=Pr(w.shape),[$,R,D]=i?[A[0],1,A[1]]:[A[0],A[1],1],[O,_,F]=o?[1,E[1],E[0]]:[E[1],1,E[0]],M=S*N,L=Zu([I,S,N],x.dtype),P=L.values,z=n.blockSize;for(let B=0;B<I;B++){const e=B%g,t=B%y;for(let n=0;n<S;n+=z){const r=Math.min(n+z,S);for(let s=0;s<N;s+=z){const a=Math.min(s+z,N);for(let i=0;i<k;i+=z){const o=Math.min(i+z,k);for(let l=n;l<r;l++)for(let n=s;n<a;n++){let r=0;for(let s=i;s<o;s++){r+=C[e*$+l*R+s*D]*T[s*O+n*_+t*F]}P[B*M+(l*N+n)]+=r}}}}}return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(w),n.makeTensorInfo(b,L.dtype,L.values)}const rA={kernelName:xs,backendName:"cpu",kernelFunc:nA};const sA={kernelName:co,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=r;let d,p,f;const m=[];d=nA({inputs:{a:s,b:a},attrs:{transposeA:l,transposeB:u},backend:n}),i&&(p=ZT({inputs:{a:d,b:i},backend:n}),m.push(d),d=p),c&&(f=zT(n,d,c,o,h),m.push(d),d=f);for(const g of m)n.disposeIntermediateTensorInfo(g);return d}};function aA(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}const iA={kernelName:ns,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend;gT(t,"abs");let r=new Float32Array(xr(t.shape));return r=aA(n.data.get(t.dataId).values),n.makeOutput(r,t.shape,t.dtype)}},oA=xT(rs,(e=>Math.acos(e))),lA={kernelName:rs,backendName:"cpu",kernelFunc:oA},uA=xT(ss,(e=>Math.acosh(e))),cA={kernelName:ss,backendName:"cpu",kernelFunc:uA};const hA={kernelName:is,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,r=t;gT(t,"addN");const s=r.map((e=>n.data.get(e.dataId).values)),a=Zu(r[0].shape,r[0].dtype),i=a.values;for(let o=0;o<r.length;o++){const e=s[o];for(let t=0;t<i.length;t++)i[t]+=e[t]}return n.makeTensorInfo(a.shape,a.dtype,a.values)}};function dA(e,t,n,r,s){const a=t.length,i=xr(t),o=Pr(t),l=Pr(s),u=Er(n,xr(s));for(let c=0;c<i;++c){const t=Hr(c,a,o),n=new Array(t.length);for(let e=0;e<n.length;e++)n[e]=t[r[e]];u[Gr(n,a,l)]=e[c]}return u}function pA(e){const{inputs:t,attrs:n,backend:r}=e,{x:s}=t,{perm:a}=n;gT(s,"transpose");const i=s.shape.length,o=new Array(i);for(let u=0;u<o.length;u++)o[u]=s.shape[a[u]];const l=dA(r.data.get(s.dataId).values,s.shape,s.dtype,a,o);return{dataId:r.write(l,o,s.dtype),shape:o,dtype:s.dtype}}const fA={kernelName:no,backendName:"cpu",kernelFunc:pA};const mA={kernelName:os,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;gT(s,"all");const o=Tr(a,s.shape);let l=o;const u=Gd(l,s.shape.length);let c=s;null!=u&&(c=pA({inputs:{x:s},backend:n,attrs:{perm:u}}),l=qd(l.length,s.shape.length)),jd("all",l,c.shape.length);const[h,d]=Wd(c.shape,l),p=xr(d),f=Wr(xr(h),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const e=y*p;let t=m[e];for(let n=0;n<p;++n){const r=m[e+n];t=t&&r}f[y]=t}null!=u&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(h,c.dtype,f);if(i){const e=eA({inputs:{x:g},backend:n,attrs:{shape:Ud(h,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}};const gA={kernelName:ls,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;gT(s,"any");const o=Tr(a,s.shape);let l=o;const u=Gd(l,s.shape.length);let c=s;null!=u&&(c=pA({inputs:{x:s},backend:n,attrs:{perm:u}}),l=qd(l.length,s.shape.length)),jd("any",l,c.shape.length);const[h,d]=Wd(c.shape,l),p=xr(d),f=Wr(xr(h),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const e=y*p;let t=m[e];for(let n=0;n<p;++n){const r=m[e+n];t=t||r}f[y]=t}null!=u&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(h,c.dtype,f);if(i){const e=eA({inputs:{x:g},backend:n,attrs:{shape:Ud(h,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}};const yA={kernelName:us,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;gT(s,"argMax");let i=Tr(a,s.shape);const o=Gd(i,s.shape.length);let l=s;const u=[];null!=o&&(l=pA({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=qd(i.length,l.shape.length)),i=[i[0]],jd("argMax",i,l.shape.length);const[c,h]=Wd(l.shape,i),d=Wr(xr(c),"int32"),p=xr(h),f=n.data.get(l.dataId).values;for(let m=0;m<d.length;++m){const e=m*p;let t=f[e],n=0;for(let r=0;r<p;++r){const s=f[e+r];s>t&&(t=s,n=r)}d[m]=n}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(c,"int32",d)}};const bA={kernelName:cs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;gT(s,"argMin");let i=Tr(a,s.shape);const o=Gd(i,s.shape.length);let l=s;const u=[];null!=o&&(l=pA({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=qd(i.length,l.shape.length)),i=[i[0]],jd("argMin",i,l.shape.length);const[c,h]=Wd(l.shape,i),d=Wr(xr(c),"int32"),p=xr(h),f=n.data.get(l.dataId).values;for(let m=0;m<d.length;++m){const e=m*p;let t=f[e],n=0;for(let r=0;r<p;++r){const s=f[e+r];s<t&&(t=s,n=r)}d[m]=n}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(c,"int32",d)}},vA=xT(hs,(e=>Math.asin(e))),xA={kernelName:hs,backendName:"cpu",kernelFunc:vA},wA=xT(ds,(e=>Math.asinh(e))),kA={kernelName:ds,backendName:"cpu",kernelFunc:wA},SA=xT(ps,(e=>Math.atan(e))),NA={kernelName:ps,backendName:"cpu",kernelFunc:SA},IA=AT(((e,t)=>Math.atan2(e,t))),CA=KT(ms,IA),TA={kernelName:ms,backendName:"cpu",kernelFunc:CA},AA=xT(fs,(e=>Math.atanh(e))),EA={kernelName:fs,backendName:"cpu",kernelFunc:AA};function $A(e,t,n,r,s,a){const i=s.strideHeight,o=s.strideWidth,l=s.dilationHeight,u=s.dilationWidth,c=s.effectiveFilterHeight,h=s.effectiveFilterWidth,d=s.padInfo.top,p=s.padInfo.left,f="max"===a?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=Zu(s.outShape,n),g=m.values,y=s.outShape[1]*s.outShape[2]*s.outShape[3],b=s.outShape[2]*s.outShape[3],v=s.outShape[3];for(let x=0;x<s.batchSize;++x){const t=x*y,n=x*r[0];for(let m=0;m<s.inChannels;++m)for(let y=0;y<s.outHeight;++y){const x=y*i-d,w=Math.max(0,x),k=Math.min(s.inHeight,c+x),S=t+y*b;for(let t=0;t<s.outWidth;++t){const i=t*o-p,c=Math.max(0,i),d=Math.min(s.inWidth,h+i);let y=f,b=0,x=0;for(let t=w;t<k;t+=l){const s=n+t*r[1];for(let t=c;t<d;t+=u){const n=e[s+t*r[2]+m];"max"===a&&n>y?y=n:"avg"===a&&(b+=n,x++)}if(isNaN(y))break}g[S+t*v+m]="avg"===a?b/x:y}}}return m}function RA(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]&&arguments[4],a=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const i=Zu(r.outShape,"int32"),o=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,h=r.effectiveFilterHeight,d=r.effectiveFilterWidth,p=r.padInfo.top,f=r.padInfo.left,m=Zu(t,n,e);for(let g=0;g<r.batchSize;++g)for(let e=0;e<r.inChannels;++e)for(let t=0;t<r.outHeight;++t){const n=t*o-p;let y=n;for(;y<0;)y+=u;const b=Math.min(r.inHeight,h+n);for(let o=0;o<r.outWidth;++o){const h=o*l-f;let p=h;for(;p<0;)p+=c;const v=Math.min(r.inWidth,d+h);let x=Number.NEGATIVE_INFINITY,w=-1;for(let t=y;t<b;t+=u){const i=t-n;for(let n=p;n<v;n+=c){const o=n-h,l=m.get(g,t,n,e);l>x&&(x=l,w=s?a?((g*r.inHeight+t)*r.inWidth+n)*r.inChannels+e:(t*r.inWidth+n)*r.inChannels+e:i*d+o)}}i.set(w,g,t,o,e)}}return i}function DA(e,t,n,r,s,a){const i=s.strideDepth,o=s.strideHeight,l=s.strideWidth,u=s.dilationDepth,c=s.dilationHeight,h=s.dilationWidth,d=s.effectiveFilterDepth,p=s.effectiveFilterHeight,f=s.effectiveFilterWidth,m=s.padInfo.front,g=s.padInfo.top,y=s.padInfo.left,b="max"===a?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=Zu(s.outShape,n),x=v.values,w=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],k=s.outShape[2]*s.outShape[3]*s.outShape[4],S=s.outShape[3]*s.outShape[4],N=s.outShape[4];for(let I=0;I<s.batchSize;++I){const t=I*w,n=I*r[0];for(let v=0;v<s.inChannels;++v)for(let w=0;w<s.outDepth;++w){const I=w*i-m;let C=I;for(;C<0;)C+=u;const T=Math.min(s.inDepth,d+I),A=t+w*k;for(let t=0;t<s.outHeight;++t){const i=t*o-g;let d=i;for(;d<0;)d+=c;const m=Math.min(s.inHeight,p+i),w=A+t*S;for(let t=0;t<s.outWidth;++t){const i=t*l-y;let o=i;for(;o<0;)o+=h;const p=Math.min(s.inWidth,f+i),g=w+t*N;let k=b,S=0,I=0;for(let t=C;t<T;t+=u){const s=n+t*r[1];for(let t=d;t<m;t+=c){const n=s+t*r[2];for(let t=o;t<p;t+=h){const s=e[n+t*r[3]+v];if("max"===a&&s>k?k=s:"avg"===a&&(S+=s,I++),isNaN(k))break}if(isNaN(k))break}if(isNaN(k))break}x[g+v]="avg"===a?S/Math.max(I,1):k}}}}return v}const OA={kernelName:gs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;gT(s,"avgPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r;yr(Wh(i,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const u=Dh(s.shape,a,i,1,o,l);let c;if(1===u.filterWidth&&1===u.filterHeight&&wr(u.inShape,u.outShape))c=NT({inputs:{x:s},backend:n});else{const e=n.data.get(s.dataId).values,t=Pr(s.shape),r=$A(e,s.shape,s.dtype,t,u,"avg");c=n.makeTensorInfo(u.outShape,s.dtype,r.values)}return c}};const _A={kernelName:bs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;gT(s,"avgPool3d");const c=Oh(s.shape,a,i,1,o,l,u),h=DA(n.data.get(s.dataId).values,s.shape,s.dtype,Pr(s.shape),c,"avg");return n.makeTensorInfo(h.shape,"float32",h.values)}};const FA={kernelName:vs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;gT([s,a],"avgPool3DGrad");const c=Oh(a.shape,i,o,1,l,u),h=c.strideDepth,d=c.strideHeight,p=c.strideWidth,f=c.filterDepth,m=c.filterHeight,g=c.filterWidth,y=c.dilationDepth,b=c.dilationHeight,v=c.dilationWidth,x=c.effectiveFilterDepth,w=c.effectiveFilterHeight,k=c.effectiveFilterWidth,S=x-1-c.padInfo.front,N=k-1-c.padInfo.left,I=w-1-c.padInfo.top,C=Zu(a.shape,"float32"),T=1/(f*m*g),A=n.bufferSync(s);for(let E=0;E<c.batchSize;++E)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inDepth;++t)for(let n=0;n<c.inHeight;++n)for(let r=0;r<c.inWidth;++r){const s=t-S,a=n-I,i=r-N;let o=0;for(let t=0;t<x;t+=y){const n=(s+t)/h;if(!(n<0||n>=c.outDepth||Math.floor(n)!==n))for(let t=0;t<w;t+=b){const r=(a+t)/d;if(!(r<0||r>=c.outHeight||Math.floor(r)!==r))for(let t=0;t<k;t+=v){const s=(i+t)/p;if(s<0||s>=c.outWidth||Math.floor(s)!==s)continue;o+=A.get(E,n,r,s,e)}}}C.set(o*T,E,t,n,r,e)}return n.makeTensorInfo(C.shape,C.dtype,C.values)}};const MA={kernelName:ys,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a;gT([s,a],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=r,c=Dh(i.shape,o,l,1,u),h=c.strideHeight,d=c.strideWidth,p=c.filterHeight,f=c.filterWidth,m=c.dilationHeight,g=c.dilationWidth,y=c.effectiveFilterHeight,b=c.effectiveFilterWidth,v=b-1-c.padInfo.left,x=y-1-c.padInfo.top,w=Zu(i.shape,"float32"),k=1/(p*f),S=n.data.get(s.dataId).values,N=Zu(s.shape,"float32",S);for(let I=0;I<c.batchSize;++I)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inHeight;++t)for(let n=0;n<c.inWidth;++n){const r=t-x,s=n-v;let a=0;for(let t=0;t<y;t+=m){const n=(r+t)/h;if(!(n<0||n>=c.outHeight||Math.floor(n)!==n))for(let t=0;t<b;t+=g){const r=(s+t)/d;if(r<0||r>=c.outWidth||Math.floor(r)!==r)continue;a+=N.get(I,n,r,e)}}w.set(a*k,I,t,n,e)}return n.makeTensorInfo(w.shape,w.dtype,w.values)}};const LA={kernelName:da,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,scale:a,offset:i,mean:o,variance:l}=t;yr(o.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),yr(null==i||o.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),yr(null==a||o.shape.length===a.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),gT([s,o,l,a,i],"batchNorm");let{varianceEpsilon:u}=r;null==u&&(u=.001);const c=n.data.get(s.dataId).values,h=n.data.get(o.dataId).values,d=n.data.get(l.dataId).values,p=a?n.data.get(a.dataId).values:new Float32Array([1]),f=i?n.data.get(i.dataId).values:new Float32Array([0]),m=new Float32Array(c.length),g=f.length,y=p.length,b=d.length,v=h.length;let x=0,w=0,k=0,S=0;for(let N=0;N<c.length;++N)m[N]=f[x++]+(c[N]-h[w++])*p[k++]/Math.sqrt(d[S++]+u),x>=g&&(x=0),w>=v&&(w=0),k>=y&&(k=0),S>=b&&(S=0);return n.makeTensorInfo(s.shape,s.dtype,m)}};function PA(e,t,n,r,s){const a=fh(r,t,n),i=xr(n),o=Pr(r);if(a){const n=mh(t,o);return"string"===s?e.slice(n,n+i):e.subarray(n,n+i)}const l=Zu(r,s,"string"===s?qy(e):e),u=Zu(n,s);for(let c=0;c<u.size;++c){const e=u.indexToLoc(c),n=e.map(((e,n)=>e+t[n]));u.set(l.get(...n),...e)}return"string"===s?Ky(u.values):u.values}function zA(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,size:i}=r;gT(s,"slice");const[o,l]=gh(s,a,i);nh(s,o,l);const u=PA(n.data.get(s.dataId).values,o,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,u)}const BA={kernelName:Ti,backendName:"cpu",kernelFunc:zA};const VA={kernelName:ws,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:i}=r;gT([s],"batchToSpaceND");const o=a.reduce(((e,t)=>e*t)),l=Jg(s.shape,a,o),u=ey(l.length,a.length),c=ty(s.shape,a,o),h=ny(i,a.length),d=ry(c,i,a.length),p=eA({inputs:{x:s},backend:n,attrs:{shape:l}}),f=pA({inputs:{x:p},backend:n,attrs:{perm:u}}),m=eA({inputs:{x:f},backend:n,attrs:{shape:c}}),g=zA({inputs:{x:m},backend:n,attrs:{begin:h,size:d}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}};function WA(e,t,n,r,s){const a=xr(r),i=Wr(s,n);for(let o=0;o<e.length;o++){const n=e[o];if(n<0)throw new Error("Input x must be non-negative!");n>=s||(i[n]+=a>0?t[o]:1)}return i}function UA(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=e.shape[0],a=e.shape[1],i=Zu([s,n],t.dtype);for(let o=0;o<s;o++)for(let s=0;s<a;s++){const a=e.get(o,s);if(a<0)throw new Error("Input x must be non-negative!");a>=n||(r?i.set(1,o,a):t.size>0?i.set(i.get(o,a)+t.get(o,s),o,a):i.set(i.get(o,a)+1,o,a))}return i}const jA={kernelName:ks,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i}=r,o=WA(n.data.get(s.dataId).values,n.data.get(a.dataId).values,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,o)}},GA=AT(((e,t)=>e&t)),HA=KT(Ss,GA),qA={kernelName:Ss,backendName:"cpu",kernelFunc:HA};const KA={kernelName:Ns,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:r,s1:s}=t,a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,o=Cc(Array.from(a),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},XA=vT((e=>Math.ceil(e))),QA=wT(Cs,XA),YA={kernelName:Cs,backendName:"cpu",kernelFunc:QA},ZA=xT(Ts,((e,t)=>{const n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e})),JA={kernelName:Ts,backendName:"cpu",kernelFunc:ZA},eE={kernelName:Es,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend,r=new Float32Array(xr(t.shape)),s=n.data.get(t.dataId),a=s.complexTensorInfos.real,i=s.complexTensorInfos.imag,o=n.data.get(a.dataId).values,l=n.data.get(i.dataId).values;for(let u=0;u<o.length;u++){const e=o[u],t=l[u];r[u]=Math.hypot(e,t)}return n.makeOutput(r,t.shape,"float32")}};function tE(e,t,n,r){const s=$r(n,xr(t));if(r&&"string"!==n){let t=0;e.forEach((e=>{const n=xr(e.shape);s.set(e.vals,t),t+=n}))}else{let r=0;e.forEach((e=>{const a="string"===n?qy(e.vals):e.vals;let i=0;for(let n=0;n<e.shape[0];++n){const o=n*t[1]+r;for(let t=0;t<e.shape[1];++t)s[o+t]=a[i++]}r+=e.shape[1]}))}return s}function nE(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.imag,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}const rE={kernelName:va,backendName:"cpu",kernelFunc:nE};function sE(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,a=Tr(s,t[0].shape)[0],i=t.map((e=>e.shape));Ug(i,a);let o=jg(t.map((e=>e.shape)),a);if(0===xr(o))return n.makeTensorInfo(o,t[0].dtype,[]);const l=t.filter((e=>xr(e.shape)>0));if(1===l.length)return NT({inputs:{x:l[0]},backend:n});if("complex64"===l[0].dtype){const e=l.map((e=>UT({inputs:{input:e},backend:n}))),t=l.map((e=>nE({inputs:{input:e},backend:n}))),r=sE({inputs:e,backend:n,attrs:{axis:a}}),s=sE({inputs:t,backend:n,attrs:{axis:a}}),i=BT({inputs:{real:r,imag:s},backend:n});return e.forEach((e=>n.disposeIntermediateTensorInfo(e))),t.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),i}const u=l.map((e=>{const t=xr(e.shape.slice(a));return eA({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})})),c=u.map((e=>({vals:n.data.get(e.dataId).values,shape:e.shape})));o=jg(u.map((e=>e.shape)),1);const h=1===u[0].shape[0],d=tE(c,o,t[0].dtype,h),p=jg(l.map((e=>e.shape)),a),f=n.makeTensorInfo(p,t[0].dtype,d);return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}const aE={kernelName:$s,backendName:"cpu",kernelFunc:sE};function iE(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r;gT([s,a],"conv2d");const h=jh(l),d=_h(s.shape,a.shape,i,u,o,c,!1,h),p=d.filterHeight,f=d.filterWidth,m=d.dilationHeight,g=d.dilationWidth,y=d.padInfo.left,b=d.padInfo.top,v="channelsLast"===d.dataFormat,x=new el(d.outShape,s.dtype),w=Pr(s.shape),k=Pr(a.shape),S=w[0],N=v?w[1]:w[2],I=v?w[2]:1,C=v?1:w[1],T=x.strides[0],A=v?x.strides[1]:x.strides[2],E=v?x.strides[2]:1,$=v?1:x.strides[1],R=n.data.get(s.dataId).values,D=n.data.get(a.dataId).values,O=x.values;for(let _=0;_<d.batchSize;++_){const e=_*S,t=_*T;for(let n=0;n<d.outHeight;++n){const r=t+n*A,s=n*d.strideHeight-b;for(let t=0;t<p;++t){const n=s+t*m;if(n<0||n>=d.inHeight)continue;const a=t*k[0],i=e+n*N;for(let e=0;e<d.outWidth;++e){const t=r+e*E,n=e*d.strideWidth-y;for(let e=0;e<f;++e){const r=n+e*g;if(r<0||r>=d.inWidth)continue;const s=i+r*I;let o=a+e*k[1];for(let e=0;e<d.inChannels;++e){const n=R[s+e*C];for(let e=0;e<d.outChannels;++e)O[t+e*$]+=n*D[o+e];o+=d.outChannels}}}}}}return n.makeTensorInfo(x.shape,x.dtype,O)}const oE={kernelName:Rs,backendName:"cpu",kernelFunc:iE};const lE={kernelName:Ds,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r;gT([s,a],"conv2dBackpropFilter");const h=jh(l),d=_h(s.shape,c,i,1,o,u,!1,h),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=d,y="channelsLast"===d.dataFormat,b=new el(d.filterShape,"float32"),v=d.padInfo.left,x=d.padInfo.top,w=n.data.get(s.dataId).values,k=n.data.get(a.dataId).values,S=new el(s.shape,s.dtype,w),N=new el(a.shape,a.dtype,k);for(let I=0;I<m;++I){const e=Math.max(0,Math.ceil((x-I)/p)),t=Math.min(d.outHeight,(d.inHeight+x-I)/p);for(let n=0;n<g;++n){const r=Math.max(0,Math.ceil((v-n)/f)),s=Math.min(d.outWidth,(d.inWidth+v-n)/f);for(let a=0;a<d.inChannels;++a)for(let i=0;i<d.outChannels;++i){let o=0;for(let l=0;l<d.batchSize;++l)for(let u=e;u<t;++u){const e=I+u*p-x;for(let t=r;t<s;++t){const r=n+t*f-v;o+=y?S.get(l,e,r,a)*N.get(l,u,t,i):S.get(l,a,e,r)*N.get(l,i,u,t)}}b.set(o,I,n,a,i)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};const uE={kernelName:Os,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r;gT([s,a],"conv2dBackpropInput");const h=Pr(a.shape),d=Pr(s.shape);let p=jh(u);const f=_h(i,a.shape,o,1,l,c,!1,p),m=new el(f.inShape,"float32"),g=m.values,y=n.data.get(s.dataId).values,b=n.data.get(a.dataId).values,[v,x,w]=h,{batchSize:k,filterHeight:S,filterWidth:N,inChannels:I,inHeight:C,inWidth:T,outChannels:A,outHeight:E,outWidth:$,strideHeight:R,strideWidth:D}=f;p=f.dataFormat;const O=S-1-f.padInfo.top,_=N-1-f.padInfo.left,F="channelsLast"===p,M=m.strides[0],L=F?m.strides[1]:m.strides[2],P=F?m.strides[2]:1,z=F?1:m.strides[1],B=d[0],V=F?d[1]:d[2],W=F?d[2]:1,U=F?1:d[1];for(let j=0;j<k;++j)for(let e=0;e<I;++e)for(let t=0;t<C;++t){const n=t-O,r=Math.max(0,Math.ceil(n/R)),s=Math.min(E,(S+n)/R);for(let a=0;a<T;++a){const i=a-_,o=Math.max(0,Math.ceil(i/D)),l=Math.min($,(N+i)/D);let u=0;for(let t=r;t<s;++t){const r=t*R-n;for(let n=o;n<l;++n){const s=B*j+V*t+W*n,a=v*(S-1-r)+x*(N-1-(n*D-i))+w*e;for(let e=0;e<A;++e){u+=y[s+U*e]*b[a+e]}}}g[M*j+L*t+P*a+z*e]=u}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}};const cE={kernelName:_s,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r;gT([s,a],"conv3d");const u=Fh(s.shape,a.shape,i,l,o),{filterDepth:c,filterHeight:h,filterWidth:d,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=u,y=g.front,b=g.left,v=g.top,x=new el(u.outShape,s.dtype),w=n.data.get(s.dataId).values,k=n.data.get(a.dataId).values,S=x.values,N=Pr(s.shape),I=Pr(a.shape);for(let C=0;C<u.batchSize;++C){const e=C*N[0],t=C*x.strides[0];for(let n=0;n<u.outDepth;++n){const r=t+n*x.strides[1],s=n*u.strideDepth-y;for(let t=0;t<c;++t){const n=s+t*p;if(n<0||n>=u.inDepth)continue;const a=t*I[0],i=e+n*N[1];for(let e=0;e<u.outHeight;++e){const t=r+e*x.strides[2],n=e*u.strideHeight-v;for(let e=0;e<h;++e){const r=n+e*f;if(r<0||r>=u.inHeight)continue;const s=a+e*I[1],o=i+r*N[2];for(let e=0;e<u.outWidth;++e){const n=t+e*u.outChannels,r=e*u.strideWidth-b;for(let e=0;e<d;++e){const t=r+e*m;if(t<0||t>=u.inWidth)continue;const a=s+e*I[2],i=o+t*u.inChannels;let l=a;for(let e=0;e<u.inChannels;++e){const t=w[i+e];for(let e=0;e<u.outChannels;++e)S[n+e]+=t*k[l+e];l+=u.outChannels}}}}}}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}};const hE={kernelName:Fs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,filterShape:l}=r;gT([s,a],"conv3dBackpropFilterV2");const u=Pr(s.shape),c=Pr(a.shape),h=Fh(s.shape,l,i,1,o),d=h.strideDepth,p=h.strideHeight,f=h.strideWidth,m=h.filterDepth,g=h.filterHeight,y=h.filterWidth,b=new el(h.filterShape,"float32"),v=b.values,[x,w,k,S]=b.strides,N=n.data.get(a.dataId).values,[I,C,T,A]=c,E=n.data.get(s.dataId).values,[$,R,D,O]=u,_=h.padInfo.front,F=h.padInfo.left,M=h.padInfo.top;for(let L=0;L<m;++L){const e=Math.max(0,Math.ceil((_-L)/d)),t=Math.min(h.outDepth,(h.inDepth+_-L)/d),n=L*x;for(let r=0;r<g;++r){const s=Math.max(0,Math.ceil((M-r)/p)),a=Math.min(h.outHeight,(h.inHeight+M-r)/p),i=r*w+n;for(let n=0;n<y;++n){const o=Math.max(0,Math.ceil((F-n)/f)),l=Math.min(h.outWidth,(h.inWidth+F-n)/f),u=n*k+i;for(let i=0;i<h.inChannels;++i){const c=i*S+u;for(let u=0;u<h.outChannels;++u){let m=0;for(let c=0;c<h.batchSize;++c){const h=c*$,g=c*I;for(let c=e;c<t;++c){const e=(L+c*d-_)*R+h,t=c*C+g;for(let c=s;c<a;++c){const s=(r+c*p-M)*D+e,a=c*T+t;for(let e=o;e<l;++e){const t=e*A+a;m+=E[(n+e*f-F)*O+s+i]*N[t+u]}}}}v[c+u]=m}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};const dE={kernelName:Ms,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:i,strides:o,inputShape:l}=r;gT([s],"conv3dBackpropInputV2");const u=Pr(s.shape),c=Pr(a.shape),h=Fh(l,a.shape,o,1,i),d=new el(h.inShape,"float32"),p=d.values,[f,m,g,y]=d.strides,b=n.data.get(s.dataId).values,[v,x,w,k]=u,S=n.data.get(a.dataId).values,[N,I,C,T]=c,{batchSize:A,filterDepth:E,filterHeight:$,filterWidth:R,inChannels:D,inDepth:O,inHeight:_,inWidth:F,outChannels:M,outDepth:L,outHeight:P,outWidth:z,strideDepth:B,strideHeight:V,strideWidth:W}=h,U=E-1-h.padInfo.front,j=$-1-h.padInfo.top,G=R-1-h.padInfo.left;for(let H=0;H<A;++H)for(let e=0;e<D;++e)for(let t=0;t<O;++t){const n=t-U,r=Math.max(0,Math.ceil(n/B)),s=Math.min(L,(E+n)/B);for(let a=0;a<_;++a){const i=a-j,o=Math.max(0,Math.ceil(i/V)),l=Math.min(P,($+i)/V);for(let u=0;u<F;++u){const c=u-G,h=Math.max(0,Math.ceil(c/W)),d=Math.min(z,(R+c)/W);let A=0;for(let t=r;t<s;++t){const r=t*B-n;for(let n=o;n<l;++n){const s=n*V-i;for(let a=h;a<d;++a){const i=v*H+x*t+w*n+k*a,o=N*(E-1-r)+I*($-1-s)+C*(R-1-(a*W-c))+T*e;for(let e=0;e<M;++e){A+=b[i+e]*S[o+e]}}}}p[f*H+m*t+g*a+y*u+e]=A}}}return n.makeTensorInfo(d.shape,d.dtype,d.values)}},pE=xT(Ls,(e=>Math.cos(e))),fE={kernelName:Ls,backendName:"cpu",kernelFunc:pE},mE=xT(Ps,(e=>Math.cosh(e))),gE={kernelName:Ps,backendName:"cpu",kernelFunc:mE};const yE={kernelName:Vs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:a,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,[c,h,d,p]=s.shape,f=a.shape[0],[m,g]=o,y=Zu([f,m,g,p],"float32"),b=n.data.get(a.dataId).values,v=n.data.get(i.dataId).values,x=n.data.get(s.dataId).values,w=Pr(s.shape),k=Pr(y.shape);for(let S=0;S<f;S++){const e=4*S,t=b[e],n=b[e+1],r=b[e+2],s=b[e+3],a=v[S];if(a>=c)continue;const i=m>1?(r-t)*(h-1)/(m-1):0,o=g>1?(s-n)*(d-1)/(g-1):0;for(let c=0;c<m;c++){const e=m>1?t*(h-1)+c*i:.5*(t+r)*(h-1);if(e<0||e>h-1)for(let t=0;t<g;t++)for(let e=0;e<p;e++){const n=e+t*k[2]+c*k[1]+S*k[0];y.values[n]=u}else if("bilinear"===l){const t=Math.floor(e),r=Math.ceil(e),i=e-t;for(let e=0;e<g;e++){const l=g>1?n*(d-1)+e*o:.5*(n+s)*(d-1);if(l<0||l>d-1){for(let t=0;t<p;t++){const n=t+e*k[2]+c*k[1]+S*k[0];y.values[n]=u}continue}const h=Math.floor(l),f=Math.ceil(l),m=l-h;for(let n=0;n<p;n++){let s=n+h*w[2]+t*w[1]+a*w[0];const o=x[s];s=n+f*w[2]+t*w[1]+a*w[0];const l=x[s];s=n+h*w[2]+r*w[1]+a*w[0];const u=x[s];s=n+f*w[2]+r*w[1]+a*w[0];const d=o+(l-o)*m,p=u+(x[s]-u)*m;s=n+e*k[2]+c*k[1]+S*k[0],y.values[s]=d+(p-d)*i}}}else for(let t=0;t<g;++t){const r=g>1?n*(d-1)+t*o:.5*(n+s)*(d-1);if(r<0||r>d-1){for(let e=0;e<p;e++){const n=e+t*k[2]+c*k[1]+S*k[0];y.values[n]=u}continue}const i=Math.round(r),l=Math.round(e);for(let e=0;e<p;e++){const n=e+i*w[2]+l*w[1]+a*w[0],r=e+t*k[2]+c*k[1]+S*k[0];y.values[r]=x[n]}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}};const bE={kernelName:zs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;gT(s,"cumprod");const l=Gd([a],s.shape.length);let u=s;null!=l&&(u=pA({inputs:{x:s},backend:n,attrs:{perm:l}}));const c=qd(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const h=pl(u.dtype,"int32"),d=Vr(xr(u.shape),h),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let y=0;y<p.length;y+=f)for(let e=0;e<f;e++){const t=m(y,e);if(0===e)d[t]=i?1:p[t];else{const n=m(y,e-1);d[t]=i?p[n]*d[n]:p[t]*d[n]}}const g=n.makeTensorInfo(u.shape,h,d);if(null!=l){const e=pA({inputs:{x:g},backend:n,attrs:{perm:Hd(l)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),e}return g}};const vE={kernelName:Bs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;gT(s,"cumsum");const l=Gd([a],s.shape.length);let u=s;null!=l&&(u=pA({inputs:{x:s},backend:n,attrs:{perm:l}}));const c=qd(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const h=pl(u.dtype,"int32"),d=Wr(xr(u.shape),h),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let y=0;y<p.length;y+=f)for(let e=0;e<f;e++){const t=m(y,e);if(0===e)d[t]=i?0:p[t];else{const n=m(y,e-1);d[t]=i?p[n]+d[n]:p[t]+d[n]}}const g=n.makeTensorInfo(u.shape,h,d);if(null!=l){const e=pA({inputs:{x:g},backend:n,attrs:{perm:Hd(l)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),e}return g}};const xE={kernelName:Ws,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i,binaryOutput:o}=r;if(1===s.shape.length){const e=WA(n.data.get(s.dataId).values,n.data.get(a.dataId).values,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,e)}if(2===s.shape.length){const e=UA(n.bufferSync(s),n.bufferSync(a),i,o);return n.makeTensorInfo(e.shape,a.dtype,e.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}};const wE={kernelName:Us,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:a,dataFormat:i}=r;yr("NHWC"===i,(()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`));const o=s.shape[0],l=s.shape[1],u=s.shape[2],c=s.shape[3],h=l*a,d=u*a,p=c/(a*a),f=n.data.get(s.dataId).values,m=new Float32Array(o*h*d*p);let g=0;for(let y=0;y<o;++y)for(let e=0;e<h;++e){const t=Math.floor(e/a),n=e%a;for(let e=0;e<d;++e){const r=Math.floor(e/a),s=(n*a+e%a)*p;for(let e=0;e<p;++e){const n=e+s+c*(r+u*(t+l*y));m[g++]=f[n]}}}return n.makeTensorInfo([o,h,d,p],s.dtype,m)}};function kE(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r;gT([s,a],"depthwiseConv2DNative");const c=Pr(s.shape),h=Pr(a.shape);let d=l;null==d&&(d=[1,1]),yr(Wh(i,d),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`));const p=_h(s.shape,a.shape,i,d,o,u,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=p,v=b.left,x=b.top,w=p.outChannels/p.inChannels,k=new el(p.outShape,s.dtype),S=n.data.get(s.dataId).values,N=n.data.get(a.dataId).values,I=k.values;for(let C=0;C<p.batchSize;++C){const e=C*c[0],t=C*k.strides[0];for(let n=0;n<p.outHeight;++n){const r=t+n*k.strides[1],s=n*p.strideHeight-x;for(let t=0;t<f;++t){const n=s+t*g;if(n<0||n>=p.inHeight)continue;const a=t*h[0],i=e+n*c[1];for(let e=0;e<p.outWidth;++e){const t=r+e*k.strides[2],n=e*p.strideWidth-v;for(let e=0;e<m;++e){const r=n+e*y;if(r<0||r>=p.inWidth)continue;const s=a+e*h[1],o=i+r*p.inChannels;let l=t,u=s;for(let e=0;e<p.inChannels;++e){const t=S[o+e];for(let e=0;e<w;++e)I[l+e]+=t*N[u+e];l+=w,u+=w}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}const SE={kernelName:js,backendName:"cpu",kernelFunc:kE};const NE={kernelName:Gs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r;gT([s,a],"depthwiseConv2dNativeBackpropFilter");const h=_h(s.shape,c,i,o,l,u,!0),{strideHeight:d,strideWidth:p,filterHeight:f,filterWidth:m}=h,g=new el(h.filterShape,"float32"),y=h.padInfo.left,b=h.padInfo.top,v=h.outChannels/h.inChannels,x=n.data.get(s.dataId).values,w=new el(s.shape,s.dtype,x),k=n.data.get(a.dataId).values,S=new el(a.shape,a.dtype,k);for(let N=0;N<f;++N){const e=Math.max(0,Math.ceil((b-N)/d)),t=Math.min(h.outHeight,(h.inHeight+b-N)/d);for(let n=0;n<m;++n){const r=Math.max(0,Math.ceil((y-n)/p)),s=Math.min(h.outWidth,(h.inWidth+y-n)/p);for(let a=0;a<h.outChannels;++a){const i=Math.trunc(a/v),o=a%v;let l=0;for(let u=0;u<h.batchSize;++u)for(let o=e;o<t;++o){const e=N+o*d-b;for(let t=r;t<s;++t){const r=n+t*p-y;l+=w.get(u,e,r,i)*S.get(u,o,t,a)}}g.set(l,N,n,i,o)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}};const IE={kernelName:Hs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r;gT([s,a],"depthwiseConv2DNativeBackpropInput");const h=Pr(s.shape),d=Pr(a.shape),p=_h(c,a.shape,i,o,l,u,!0),f=new el(p.inShape,"float32"),m=f.values,[g,y,b]=f.strides,v=n.data.get(s.dataId).values,[x,w,k]=h,S=n.data.get(a.dataId).values,[N,I,C]=d,{batchSize:T,filterHeight:A,filterWidth:E,inChannels:$,inHeight:R,inWidth:D,outChannels:O,outHeight:_,outWidth:F,strideHeight:M,strideWidth:L}=p,P=A-1-p.padInfo.top,z=E-1-p.padInfo.left,B=O/$;for(let V=0;V<T;++V)for(let e=0;e<$;++e)for(let t=0;t<R;++t){const n=t-P,r=Math.max(0,Math.ceil(n/M)),s=Math.min(_,(A+n)/M);for(let a=0;a<D;++a){const i=a-z,o=Math.max(0,Math.ceil(i/L)),l=Math.min(F,(E+i)/L);let u=0;for(let t=r;t<s;++t){const r=t*M-n;for(let n=o;n<l;++n){const s=x*V+w*t+k*n,a=N*(A-1-r)+I*(E-1-(n*L-i))+C*e;for(let t=0;t<B;++t){u+=v[s+(e*B+t)]*S[a+t]}}}m[g*V+y*t+b*a+e]=u}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}};const CE={kernelName:qs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,s=xr(r.shape),a=n.data.get(r.dataId).values,i=Zu([s,s],r.dtype),o=i.values;for(let u=0;u<a.length;u++)o[u*s+u]=a[u];const l=[...r.shape,...r.shape];return n.makeTensorInfo(l,i.dtype,i.values)}},TE={kernelName:Ks,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e;const{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r,u=n,c=u.data.get(s.dataId).values,h=s.shape.length,d=u.data.get(a.dataId).values,p=a.shape.length,{batchSize:f,inHeight:m,inWidth:g,inChannels:y,outHeight:b,outWidth:v,padInfo:x,strideHeight:w,strideWidth:k,filterHeight:S,filterWidth:N,dilationHeight:I,dilationWidth:C,outShape:T}=Rh(s.shape,a.shape,i,o,"NHWC",l),A=xr(T),E=T.length,$=$r(s.dtype,A);for(let R=0;R<f;++R)for(let e=0;e<b;++e){const t=e*w-x.top;for(let n=0;n<v;++n){const r=n*k-x.left;for(let i=0;i<y;++i){let o=Number.MIN_SAFE_INTEGER;for(let e=0;e<S;++e){const n=t+e*I;if(n>=0&&n<m)for(let t=0;t<N;++t){const l=r+t*C;if(l>=0&&l<g){const r=Gr([R,n,l,i],h,Pr(s.shape)),u=Gr([e,t,i],p,Pr(a.shape)),f=c[r]+d[u];f>o&&(o=f)}}}$[Gr([R,e,n,i],E,Pr(T))]=o}}}return{dataId:u.write(Bo($,s.dtype),T,s.dtype),shape:T,dtype:s.dtype}}},AE={kernelName:Qs,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e;const{x:s,filter:a,dy:i}=t,{strides:o,pad:l,dilations:u}=r,c=n,h=Br(s.shape,c.data.get(s.dataId).values),d=Br(a.shape,c.data.get(a.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:v,strideHeight:x,strideWidth:w,filterHeight:k,filterWidth:S,dilationHeight:N,dilationWidth:I,outShape:C}=Rh(s.shape,a.shape,o,l,"NHWC",u);yr(i.rank===C.length,(()=>`Error in ${Qs}, dy must have the same rank as output ${C.length}, but got ${i.rank}`));const T=Br(C,c.data.get(i.dataId).values),A=Ur(a.shape,a.dtype);for(let E=0;E<p;++E)for(let e=0;e<y;++e){const t=e*x-v.top;for(let n=0;n<b;++n){const r=n*w-v.left;for(let s=0;s<g;++s){let a=Number.MIN_SAFE_INTEGER,i=0,o=0;for(let e=0;e<k;++e){const n=t+e*N;if(n>=0&&n<f)for(let t=0;t<S;++t){const l=r+t*I;if(l>=0&&l<m){const r=h[E][n][l][s]+d[e][t][s];r>a&&(a=r,i=e,o=t)}}}A[i][o][s]+=T[E][e][n][s]}}}return{dataId:c.write(Bo(A,s.dtype),a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},EE={kernelName:Xs,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e;const{x:s,filter:a,dy:i}=t,{strides:o,pad:l,dilations:u}=r,c=n,h=Br(s.shape,c.data.get(s.dataId).values),d=Br(a.shape,c.data.get(a.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:v,strideHeight:x,strideWidth:w,filterHeight:k,filterWidth:S,dilationHeight:N,dilationWidth:I,outShape:C}=Rh(s.shape,a.shape,o,l,"NHWC",u);yr(i.rank===C.length,(()=>`Error in ${Xs}, dy must have the same rank as output ${C.length}, but got ${i.rank}`));const T=Br(C,c.data.get(i.dataId).values),A=Ur(s.shape,s.dtype);for(let E=0;E<p;++E)for(let e=0;e<y;++e){const t=e*x-v.top;for(let n=0;n<b;++n){const r=n*w-v.left;for(let s=0;s<g;++s){let a=Number.MIN_SAFE_INTEGER,i=t<0?0:t,o=r<0?0:r;for(let e=0;e<k;++e){const n=t+e*N;if(n>=0&&n<f)for(let t=0;t<S;++t){const l=r+t*I;if(l>=0&&l<m){const r=h[E][n][l][s]+d[e][t][s];r>a&&(a=r,i=n,o=l)}}}A[E][i][o][s]+=T[E][e][n][s]}}}return{dataId:c.write(Bo(A,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};const $E={kernelName:Ys,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:s}=t,{canvas:a,options:i}=r,{contextOptions:o,imageOptions:l}=i||{},u=(null===l||void 0===l?void 0:l.alpha)||1,c=(null===o||void 0===o?void 0:o.contextType)||"2d";if("2d"!==c)throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);const h=a.getContext(c,(null===o||void 0===o?void 0:o.contextAttributes)||{});if(null==h)throw new Error(`Could not get the context with ${c} type.`);const[d,p]=s.shape.slice(0,2),f=2===s.shape.length?1:s.shape[2],m=n.data.get(s.dataId).values,g="float32"===s.dtype?255:1,y=new Uint8ClampedArray(p*d*4);for(let v=0;v<d*p;++v){const e=[0,0,0,255*u];for(let n=0;n<f;n++){const t=m[v*f+n];if("float32"===s.dtype){if(t<0||t>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${t}.`)}else if("int32"===s.dtype&&(t<0||t>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${t}.`);1===f?(e[0]=t*g,e[1]=t*g,e[2]=t*g):e[n]=t*g}const t=4*v;y[t+0]=Math.round(e[0]),y[t+1]=Math.round(e[1]),y[t+2]=Math.round(e[2]),y[t+3]=Math.round(e[3])}a.width=p,a.height=d;const b=new ImageData(y,p,d);return h.putImageData(b,0,0),s}},RE=AT(((e,t)=>e*t)),DE=XT(((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n}))),OE=KT(qa,RE,DE),_E={kernelName:qa,backendName:"cpu",kernelFunc:OE};function FE(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;let o;gT(s,"sum"),o="bool"===s.dtype?HT({inputs:{x:s},backend:n,attrs:{dtype:"int32"}}):NT({inputs:{x:s},backend:n});const l=o.shape.length,u=Tr(a,o.shape),c=Gd(u,l);let h=u,d=o;null!=c&&(d=pA({inputs:{x:o},backend:n,attrs:{perm:c}}),h=qd(h.length,l)),jd("sum",h,d.shape.length);const[p,f]=Wd(d.shape,h);let m=WT(n,p,pl(d.dtype,"int32"));const g=xr(f),y=n.data.get(m.dataId).values,b=n.data.get(d.dataId).values;for(let v=0;v<y.length;++v){const e=v*g;let t=0;for(let n=0;n<g;++n)t+=b[e+n];y[v]=t}if(i){const e=m;m=eA({inputs:{x:m},backend:n,attrs:{shape:Ud(m.shape,u)}}),n.disposeIntermediateTensorInfo(e)}return n.disposeIntermediateTensorInfo(o),null!=c&&n.disposeIntermediateTensorInfo(d),m}const ME={kernelName:_i,backendName:"cpu",kernelFunc:FE};const LE={kernelName:Js,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,a=t,{allDims:i,summedDims:o,idDims:l}=Iy(s,a.length);Ty(i.length,l,a);const{path:u,steps:c}=Ay(o,l),h=c.length;let d=null,p=i.length;const f=[];for(let m=0;m<h;++m){for(const e of c[m]){const{permutationIndices:t,expandDims:r}=Cy(p,l[e]);let s;Ey(t)?s=a[e]:(s=pA({inputs:{x:a[e]},backend:n,attrs:{perm:t}}),f.push(s));const i=s.shape.slice();for(let e=0;e<r.length;++e)i.splice(r[e],0,1);wr(s.shape,i)||(s=eA({inputs:{x:s},backend:n,attrs:{shape:i}}),f.push(s)),null===d?d=s:(d=OE({inputs:{a:s,b:d},backend:n}),f.push(d))}m<h-1&&(u[m]>=0&&(d=FE({inputs:{x:d},backend:n,attrs:{axis:u[m]-(i.length-p),keepDims:!1}}),f.push(d)),p--)}for(const m of f)m!==d&&n.disposeIntermediateTensorInfo(m);return d}};const PE={kernelName:ta,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{dy:r,y:s}=t;gT([r,s],"eluGrad");const a=new Float32Array(xr(s.shape)),i=n.data.get(s.dataId).values,o=n.data.get(r.dataId).values;for(let l=0;l<i.length;++l){const e=i[l];a[l]=e>=0?o[l]:o[l]*(e+1)}return n.makeTensorInfo(s.shape,"float32",a)}},zE=AT(((e,t)=>e===t?1:0)),BE=KT(ra,zE,null,"bool"),VE={kernelName:ra,backendName:"cpu",kernelFunc:BE},WE=oy,UE=ly,jE=uy,GE=cy,HE=hy,qE=dy,KE=xT(na,(e=>{const t=Math.sign(e),n=Math.abs(e),r=1/(1+WE*n);return t*(1-((((qE*r+HE)*r+GE)*r+jE)*r+UE)*r*Math.exp(-n*n))})),XE={kernelName:na,backendName:"cpu",kernelFunc:KE},QE=vT((e=>Math.exp(e))),YE=wT(sa,QE,"float32"),ZE={kernelName:sa,backendName:"cpu",kernelFunc:YE};function JE(e){const{inputs:t,backend:n,attrs:r}=e,{input:s}=t,{dim:a}=r,i=s.shape.length,o=s.shape.slice();let l=a;return a<0&&(yr(-(i+1)<=a,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),l=i+a+1),o.splice(l,0,1),eA({inputs:{x:s},backend:n,attrs:{shape:o}})}const e$={kernelName:aa,backendName:"cpu",kernelFunc:JE},t$=vT((e=>Math.expm1(e))),n$=wT(ia,t$),r$={kernelName:ia,backendName:"cpu",kernelFunc:n$},s$=AT(((e,t)=>e/t)),a$=KT(Zs,s$),i$={kernelName:Zs,backendName:"cpu",kernelFunc:a$},o$=AT(((e,t)=>e-t)),l$=XT(((e,t,n,r)=>({real:e-n,imag:t-r}))),u$=KT(Qi,o$,l$),c$={kernelName:Qi,backendName:"cpu",kernelFunc:u$};function h$(e,t,n){const r=e.shape,s=r[0],a=r[1],i=n.data.get(e.dataId),o=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,u=[s,a],c=xr(u),h=Er("float32",c),d=Er("float32",c);for(let g=0;g<s;g++){const e=zA({inputs:{x:o},backend:n,attrs:{begin:[g,0],size:[1,a]}}),r=zA({inputs:{x:l},backend:n,attrs:{begin:[g,0],size:[1,a]}}),s=BT({inputs:{real:e,imag:r},backend:n}),{real:i,imag:u}=d$(s,t,n),c=py(i,u);for(let t=0;t<a;t++){const e=yy(c,t);h[g*a+t]=e.real,d[g*a+t]=e.imag}n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s)}const p=n.makeTensorInfo(u,"float32",h),f=n.makeTensorInfo(u,"float32",d),m=BT({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}function d$(e,t,n){const r=xr(e.shape),s=n.data.get(e.dataId),a=n.data.get(s.complexTensorInfos.real.dataId).values,i=n.data.get(s.complexTensorInfos.imag.dataId).values;if(function(e){return 0===(e&e-1)}(r)){const s=p$(a,i,r,t,n),o=[e.shape[0],e.shape[1]];if(t){const e=n.makeTensorInfo(o,"float32",s.real),t=n.makeTensorInfo(o,"float32",s.imag),a=n.makeTensorInfo([],"float32",zo(r,"float32")),i=NT({inputs:{x:a},backend:n}),l=i$.kernelFunc({inputs:{a:e,b:a},backend:n}),u=i$.kernelFunc({inputs:{a:t,b:i},backend:n}),c=n.data.get(l.dataId).values,h=n.data.get(u.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),{real:c,imag:h}}return s}{const e=function(e,t,n){const r=new Float32Array(2*t);for(let s=0;s<t;s++){let a=0,i=0;for(let r=0;r<t;r++){const o=xy(s*r,t,n),l=yy(e,r);a+=l.real*o.real-l.imag*o.imag,i+=l.real*o.imag+l.imag*o.real}n&&(a/=t,i/=t),by(r,a,i,s)}return r}(py(a,i),r,t);return fy(e)}}function p$(e,t,n,r,s){if(1===n)return{real:e,imag:t};const a=py(e,t),i=n/2,o=my(a),l=o.real,u=o.imag,c=[l.length],h=s.makeTensorInfo(c,"float32",l),d=s.makeTensorInfo(c,"float32",u),p=BT({inputs:{real:h,imag:d},backend:s}),f=gy(a),m=f.real,g=f.imag,y=[m.length],b=s.makeTensorInfo(y,"float32",m),v=s.makeTensorInfo(y,"float32",g),x=BT({inputs:{real:b,imag:v},backend:s}),w=p$(l,u,i,r,s),k=w.real,S=w.imag,N=[k.length],I=s.makeTensorInfo(N,"float32",k),C=s.makeTensorInfo(N,"float32",S),T=BT({inputs:{real:I,imag:C},backend:s}),A=p$(m,g,i,r,s),E=A.real,$=A.imag,R=[E.length],D=s.makeTensorInfo(R,"float32",E),O=s.makeTensorInfo(R,"float32",$),_=BT({inputs:{real:D,imag:O},backend:s}),F=vy(n,r),M=[F.real.length],L=s.makeTensorInfo(M,"float32",F.real),P=s.makeTensorInfo(M,"float32",F.imag),z=BT({inputs:{real:L,imag:P},backend:s}),B=OE({inputs:{a:z,b:_},backend:s}),V=ZT({inputs:{a:T,b:B},backend:s}),W=u$({inputs:{a:T,b:B},backend:s}),U=UT({inputs:{input:V},backend:s}),j=UT({inputs:{input:W},backend:s}),G=nE({inputs:{input:V},backend:s}),H=nE({inputs:{input:W},backend:s}),q=sE({inputs:[U,j],backend:s,attrs:{axis:0}}),K=sE({inputs:[G,H],backend:s,attrs:{axis:0}}),X=s.data.get(q.dataId).values,Q=s.data.get(K.dataId).values;return s.disposeIntermediateTensorInfo(h),s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(p),s.disposeIntermediateTensorInfo(b),s.disposeIntermediateTensorInfo(v),s.disposeIntermediateTensorInfo(x),s.disposeIntermediateTensorInfo(I),s.disposeIntermediateTensorInfo(C),s.disposeIntermediateTensorInfo(T),s.disposeIntermediateTensorInfo(D),s.disposeIntermediateTensorInfo(O),s.disposeIntermediateTensorInfo(_),s.disposeIntermediateTensorInfo(L),s.disposeIntermediateTensorInfo(P),s.disposeIntermediateTensorInfo(z),s.disposeIntermediateTensorInfo(B),s.disposeIntermediateTensorInfo(V),s.disposeIntermediateTensorInfo(W),s.disposeIntermediateTensorInfo(U),s.disposeIntermediateTensorInfo(G),s.disposeIntermediateTensorInfo(j),s.disposeIntermediateTensorInfo(H),s.disposeIntermediateTensorInfo(q),s.disposeIntermediateTensorInfo(K),{real:X,imag:Q}}const f$={kernelName:oa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t,s=xr(r.shape),a=r.shape[r.shape.length-1],i=eA({inputs:{x:r},backend:n,attrs:{shape:[s/a,a]}}),o=h$(i,!1,n),l=eA({inputs:{x:o},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}};function m$(e){const{backend:t,attrs:n}=e,{shape:r,value:s,dtype:a}=n,i=a||Fr(s),o=$r(i,xr(r));return function(e,t){e.fill(t)}(o,s),t.makeTensorInfo(r,i,o)}const g$={kernelName:la,backendName:"cpu",kernelFunc:m$};const y$={kernelName:ua,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{image:s}=t,a=r,i=Er(s.dtype,xr(s.shape)),[o,l,u,c]=s.shape,h=a.data.get(s.dataId).values;for(let d=0;d<o;d++){const e=d*u*l*c;for(let t=0;t<l;t++){const n=t*(u*c);for(let t=0;t<u;t++){const r=t*c;for(let s=0;s<c;s++){const a=Math.round(u-t-1),o=e+n+r+s;let l=h[o];if(a>=0&&a<u){l=h[e+n+a*c+s]}i[o]=l}}}}return{dataId:a.write(i,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},b$=vT((e=>Math.floor(e))),v$=wT(ca,b$),x$={kernelName:ca,backendName:"cpu",kernelFunc:v$},w$=AT(((e,t)=>Math.floor(e/t))),k$=KT(ha,w$,null,"int32"),S$={kernelName:ha,backendName:"cpu",kernelFunc:k$};const N$={kernelName:ho,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r;let m=iE({inputs:{x:s,filter:a},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d}});if(i){const e=m;if("NCHW"===c&&1===i.shape.length&&1!==i.shape[0]){const e=eA({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});m=ZT({inputs:{a:m,b:e},backend:n}),n.disposeIntermediateTensorInfo(e)}else m=ZT({inputs:{a:m,b:i},backend:n});n.disposeIntermediateTensorInfo(e)}if(p){const e=m;if("NCHW"===c&&"prelu"===p&&1===o.shape.length&&1!==o.shape[0]){const e=eA({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=zT(n,m,p,e,f),n.disposeIntermediateTensorInfo(e)}else m=zT(n,m,p,o,f);n.disposeIntermediateTensorInfo(e)}return m}};const I$={kernelName:po,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r;let m=kE({inputs:{x:s,filter:a},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d}});if(i){const e=m;m=ZT({inputs:{a:m,b:i},backend:n}),n.disposeIntermediateTensorInfo(e)}if(p){const e=m;m=zT(n,m,p,o,f),n.disposeIntermediateTensorInfo(e)}return m}};function C$(e,t,n,r,s,a,i,o,l){const u=Zu([r,a],n);for(let c=0;c<r;c++){const n=[];let r=0;for(let t=0;t<s;t++){const a=e[c*s+t];r+=a*i[t],n.push(a)}if(r<0||r>=l/a)throw new Error(`Invalid indices: ${n} does not index into ${o}`);for(let e=0;e<a;e++)u.values[c*a+e]=t.get(...t.indexToLoc(r*a+e))}return u}const T$={kernelName:fa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:s}=t,a=xr(r.shape),i=s.shape,o=i[i.length-1],[l,u,c,h]=sy(r,s);if(0===u)return n.makeTensorInfo(l,r.dtype,[]);const d=C$(n.data.get(s.dataId).values,n.bufferSync(r),r.dtype,u,o,c,h,r.shape,a);return n.makeTensorInfo(l,r.dtype,d.values)}};function A$(e,t,n){const r=Zu(n,e.dtype);for(let s=0;s<r.size;++s){const n=r.indexToLoc(s).slice(),a=n[0],i=n[2],o=t.locToIndex([a,i]);n[2]=t.values[o];const l=e.locToIndex(n);0<=l&&l<e.values.length&&(r.values[s]=e.values[l])}return r}const E$={kernelName:pa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,indices:a}=t,{axis:i,batchDims:o}=r;gT([s,a],"gatherV2");const l=Tr(i,s.shape)[0],u=n.data.get(a.dataId).values,c=s.shape[l];for(let v=0;v<u.length;++v){const e=u[v];yr(e<=c-1&&e>=0,(()=>`GatherV2: the index value ${e} is not in [0, ${c-1}]`))}let h=o;null==o&&(h=0);const d=xr(a.shape),p=Hy(s,a,l,h),f=eA({inputs:{x:s},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=eA({inputs:{x:a},backend:n,attrs:{shape:[p.batchSize,d/p.batchSize]}}),g=[p.batchSize,p.outerSize,d/p.batchSize,p.sliceSize],y=n.bufferSync(m),b=A$(n.bufferSync(f),y,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(p.outputShape,b.dtype,b.values)}},$$=AT(((e,t)=>e>t?1:0)),R$=KT(ma,$$,null,"bool"),D$={kernelName:ma,backendName:"cpu",kernelFunc:R$},O$=AT(((e,t)=>e>=t?1:0)),_$=KT(ga,O$,null,"bool"),F$={kernelName:ga,backendName:"cpu",kernelFunc:_$};const M$={kernelName:ba,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t,s=xr(r.shape),a=r.shape[r.shape.length-1],i=eA({inputs:{x:r},backend:n,attrs:{shape:[s/a,a]}}),o=h$(i,!0,n),l=eA({inputs:{x:o},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}},L$=xT(xa,(e=>Number.isFinite(e)?1:0),"bool"),P$={kernelName:xa,backendName:"cpu",kernelFunc:L$},z$=xT(wa,(e=>Math.abs(e)===1/0?1:0),"bool"),B$={kernelName:wa,backendName:"cpu",kernelFunc:z$},V$=xT(ka,(e=>Number.isNaN(e)?1:0),"bool"),W$={kernelName:ka,backendName:"cpu",kernelFunc:V$},U$=AT(((e,t)=>e<t?1:0)),j$=KT(Na,U$,null,"bool"),G$={kernelName:Na,backendName:"cpu",kernelFunc:j$},H$=AT(((e,t)=>e<=t?1:0)),q$=KT(Ia,H$,null,"bool"),K$={kernelName:Ia,backendName:"cpu",kernelFunc:q$};function X$(e,t,n){const r=(t-e)/(n-1),s=Wr(n,"float32");s[0]=e;for(let a=1;a<s.length;a++)s[a]=s[a-1]+r;return s}const Q$={kernelName:Ca,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:s,num:a}=n,i=X$(r,s,a);return t.makeTensorInfo([i.length],"float32",i)}},Y$=vT((e=>Math.log(e))),Z$=wT(Ta,Y$),J$={kernelName:Ta,backendName:"cpu",kernelFunc:Z$},eR=xT(Aa,(e=>Math.log1p(e))),tR={kernelName:Aa,backendName:"cpu",kernelFunc:eR},nR=AT(((e,t)=>e&&t)),rR=KT(Ea,nR,null,"bool"),sR={kernelName:Ea,backendName:"cpu",kernelFunc:rR},aR=xT($a,(e=>e?0:1),"bool"),iR={kernelName:$a,backendName:"cpu",kernelFunc:aR},oR=AT(((e,t)=>e||t)),lR=KT(Ra,oR,null,"bool"),uR={kernelName:Ra,backendName:"cpu",kernelFunc:lR};const cR={kernelName:Da,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:i,alpha:o,beta:l}=r;gT(s,"LRN");const u=s.shape[3],c=u-1,h=n.data.get(s.dataId).values,d=xr(s.shape),p=new Float32Array(d);function f(e){const t=e%u;let n=e-t+Math.max(0,t-a);const r=e-t+Math.min(t+a,c);let s=0;for(;n<=r;n++){const e=h[n];s+=e*e}return s}for(let m=0;m<d;m++){const e=f(m),t=h[m]*Math.pow(i+o*e,-l);p[m]=t}return n.makeTensorInfo(s.shape,s.dtype,p)}};const hR={kernelName:Oa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r;gT(i,"LRNGrad");const h=xr(i.shape),d=i.shape[3],p=n.data.get(i.dataId).values,f=n.data.get(s.dataId).values,m=n.data.get(a.dataId).values,g=new Float32Array(h),y=h;for(let b=0;b<y;b++){const e=b%d,t=b-e+Math.max(0,e-o),n=b-e+Math.min(d,e+o+1);let r=0;for(let s=t;s<n;s++)r+=Math.pow(f[s],2);r=u*r+l;for(let s=t;s<n;s++){let e=-2*u*c*f[s]*m[b]/r;b===s&&(e+=Math.pow(r,-c)),e*=p[b],g[s]+=e}}return n.makeTensorInfo(i.shape,s.dtype,g)}};function dR(e,t,n,r){const s=Er(r,xr(n));for(let a=0;a<s.length;++a){const n=a*t;let r=e[n];for(let s=0;s<t;++s){const t=e[n+s];(Number.isNaN(t)||t>r)&&(r=t)}s[a]=r}return s}function pR(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:a,keepDims:i}=r,o=n;let l=s.shape;const u=l.length,c=Tr(a,l);let h=c;const d=Gd(h,u);let p=o.data.get(s.dataId).values;if(null!=d){const e=new Array(u);for(let t=0;t<e.length;t++)e[t]=l[d[t]];p=dA(p,l,s.dtype,d,e),h=qd(h.length,u),l=e}gT(s,"max"),jd("max",h,u);const[f,m]=Wd(l,h),g=dR(p,xr(m),f,s.dtype),y=o.write(g,f,s.dtype);let b=f;if(i){b=Ud(f,c)}return{dataId:y,shape:b,dtype:s.dtype}}const fR={kernelName:_a,backendName:"cpu",kernelFunc:pR},mR=AT(((e,t)=>Math.max(e,t))),gR=KT(Fa,mR),yR={kernelName:Fa,backendName:"cpu",kernelFunc:gR};const bR={kernelName:Ma,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;gT(s,"maxPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r;yr(Wh(i,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const u=Dh(s.shape,a,i,1,o,l);let c;if(1===u.filterWidth&&1===u.filterHeight&&wr(u.inShape,u.outShape))c=NT({inputs:{x:s},backend:n});else{const e=n.data.get(s.dataId).values,t=Pr(s.shape),r=$A(e,s.shape,s.dtype,t,u,"max");c=n.makeTensorInfo(u.outShape,s.dtype,r.values)}return c}};const vR={kernelName:Pa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;gT(s,"maxPool3d");const c=Oh(s.shape,a,i,1,o,l,u),h=DA(n.data.get(s.dataId).values,s.shape,s.dtype,Pr(s.shape),c,"max");return n.makeTensorInfo(h.shape,"float32",h.values)}};const xR={kernelName:za,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;gT([s,a],"maxPool3DGrad");const c=Oh(a.shape,i,o,1,l,u),h=function(e,t){const n=Zu(t.outShape,"int32"),r=t.strideDepth,s=t.strideHeight,a=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,c=t.effectiveFilterHeight,h=t.effectiveFilterWidth,d=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){const b=y*r-d;let v=b;for(;v<0;)v+=i;const x=Math.min(t.inDepth,u+b);for(let r=0;r<t.outHeight;++r){const u=r*s-p;let d=u;for(;d<0;)d+=o;const w=Math.min(t.inHeight,c+u);for(let s=0;s<t.outWidth;++s){const p=s*a-f;let k=p;for(;k<0;)k+=l;const S=Math.min(t.inWidth,h+p);let N=Number.NEGATIVE_INFINITY,I=-1;for(let t=v;t<x;t+=i){const n=t-b;for(let r=d;r<w;r+=o){const s=r-u;for(let a=k;a<S;a+=l){const i=a-p,o=e.get(m,t,r,a,g);o>=N&&(N=o,I=n*c*h+s*c+i)}}}n.set(I,m,y,r,s,g)}}}return n}(n.bufferSync(a),c),d=c.strideDepth,p=c.strideHeight,f=c.strideWidth,m=c.dilationDepth,g=c.dilationHeight,y=c.dilationWidth,b=c.effectiveFilterDepth,v=c.effectiveFilterHeight,x=c.effectiveFilterWidth,w=b-1-c.padInfo.front,k=x-1-c.padInfo.left,S=v-1-c.padInfo.top,N=Zu(a.shape,"float32"),I=n.bufferSync(s);for(let C=0;C<c.batchSize;++C)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inDepth;++t)for(let n=0;n<c.inHeight;++n)for(let r=0;r<c.inWidth;++r){const s=t-w,a=n-S,i=r-k;let o=0;for(let t=0;t<b;t+=m){const n=(s+t)/d;if(!(n<0||n>=c.outDepth||Math.floor(n)!==n))for(let r=0;r<v;r+=g){const s=(a+r)/p;if(!(s<0||s>=c.outHeight||Math.floor(s)!==s))for(let a=0;a<x;a+=y){const l=(i+a)/f;if(l<0||l>=c.outWidth||Math.floor(l)!==l)continue;const u=b*v*x-1-h.get(C,n,s,l,e)===t*v*x+r*x+a?1:0;if(0===u)continue;o+=I.get(C,n,s,l,e)*u}}}N.set(o,C,t,n,r,e)}return n.makeTensorInfo(N.shape,N.dtype,N.values)}};const wR={kernelName:La,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a,output:i}=t,o=a;gT([a,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=r,d=Dh(o.shape,l,u,1,c,h),p=n.data.get(o.dataId).values,f=Zu(d.outShape,o.dtype,RA(p,o.shape,o.dtype,d).values),m=d.strideHeight,g=d.strideWidth,y=d.dilationHeight,b=d.dilationWidth,v=d.effectiveFilterHeight,x=d.effectiveFilterWidth,w=x-1-d.padInfo.left,k=v-1-d.padInfo.top,S=Zu(o.shape,"float32"),N=n.data.get(s.dataId).values,I=Zu(s.shape,"float32",N);for(let C=0;C<d.batchSize;++C)for(let e=0;e<d.inChannels;++e)for(let t=0;t<d.inHeight;++t)for(let n=0;n<d.inWidth;++n){const r=t-k,s=n-w;let a=0;for(let t=0;t<v;t+=y){const n=(r+t)/m;if(!(n<0||n>=d.outHeight||Math.floor(n)!==n))for(let r=0;r<x;r+=b){const i=(s+r)/g;if(i<0||i>=d.outWidth||Math.floor(i)!==i)continue;const o=v*x-1-f.get(C,n,i,e)===t*x+r?1:0;if(0===o)continue;a+=I.get(C,n,i,e)*o}}S.set(a,C,t,n,e)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}};const kR={kernelName:Ba,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{x:s}=t,{filterSize:a,strides:i,pad:o,includeBatchInIndex:l}=n,u=r;gT(s,"MaxPoolWithArgmax");const c=u.data.get(s.dataId).values,h=Dh(s.shape,a,i,[1,1],o),[d,p]=function(e,t,n,r,s){const a=$A(e,0,n,Pr(t),s,"max"),i=RA(e,t,n,s,!0,r);return[a.values,i.values]}(c,s.shape,s.dtype,l,h),f=u.write(d,h.outShape,s.dtype),m=u.write(p,h.outShape,s.dtype);return[{dataId:f,shape:h.outShape,dtype:s.dtype},{dataId:m,shape:h.outShape,dtype:"int32"}]}};const SR={kernelName:Va,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=Tr(a,s.shape),l=xr(Wd(s.shape,o)[1]),u=[],c=n.makeTensorInfo([],"float32",new Float32Array([l]));u.push(c);const h=HT({inputs:{x:s},backend:n,attrs:{dtype:"float32"}});u.push(h);const d=a$({inputs:{a:h,b:c},backend:n});u.push(d);const p=FE({inputs:{x:d},backend:n,attrs:{axis:a,keepDims:i}});return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}};const NR={kernelName:Wa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;gT(s,"min");const o=Tr(a,s.shape);let l=o;const u=Gd(l,s.shape.length);let c=s;null!=u&&(c=pA({inputs:{x:s},backend:n,attrs:{perm:u}}),l=qd(l.length,s.shape.length)),jd("min",l,c.shape.length);const[h,d]=Wd(c.shape,l),p=xr(d),f=Wr(xr(h),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const e=y*p;let t=m[e];for(let n=0;n<p;++n){const r=m[e+n];(Number.isNaN(r)||r<t)&&(t=r)}f[y]=t}null!=u&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(h,c.dtype,f);if(i){const e=eA({inputs:{x:g},backend:n,attrs:{shape:Ud(h,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}},IR=AT(((e,t)=>Math.min(e,t))),CR=KT(Ua,IR),TR={kernelName:Ua,backendName:"cpu",kernelFunc:CR};const AR={kernelName:ja,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,mode:i}=r;gT(s,"mirrorPad");const o=a.map(((e,t)=>e[0]+s.shape[t]+e[1])),l=a.map((e=>e[0])),u=a.map(((e,t)=>e[0]+s.shape[t])),c="reflect"===i?0:1,h=n.data.get(s.dataId).values,d=s.shape.length,p=Pr(s.shape),f=xr(o),m=o.length,g=Pr(o),y=Er(s.dtype,f);for(let b=0;b<f;b++){let e=Hr(b,m,g);for(let n=0;n<m;n++)e[n]<l[n]?e[n]=2*l[n]-e[n]-c:e[n]>=u[n]&&(e[n]=2*(u[n]-1)-e[n]+c);e=e.map(((e,t)=>e-l[t]));const t=Gr(e,d,p);y[b]=h[t]}return{dataId:n.write(y,o,s.dtype),shape:o,dtype:s.dtype}}},ER=AT(((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t})),$R=KT(Ga,ER),RR={kernelName:Ga,backendName:"cpu",kernelFunc:$R};function DR(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:a}=r,i=s.shape.length;let o=a;if(-1===o&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);const l=Tr([o],s.shape),u=pR({inputs:{x:s},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),c=Ud(u.shape,l),h=eA({inputs:{x:u},backend:n,attrs:{shape:c}}),d=u$({inputs:{a:s,b:h},backend:n}),p=YE({inputs:{x:d},backend:n}),f=FE({inputs:{x:p},backend:n,attrs:{axis:l,keepDims:!1}}),m=eA({inputs:{x:f},backend:n,attrs:{shape:c}}),g=a$({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}const OR={kernelName:Li,backendName:"cpu",kernelFunc:DR};const _R={kernelName:Ha,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:i,normalized:o}=r;gT(s,"multinomial");const l=o?s:DR({inputs:{logits:s},backend:n,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],h=n.data.get(l.dataId).values,d=[u,a],p=Wr(xr(d),"int32");for(let f=0;f<u;++f){const e=f*c,t=new Float32Array(c-1);t[0]=h[e];for(let s=1;s<t.length;++s)t[s]=t[s-1]+h[e+s];const n=uf.alea(i.toString()),r=f*a;for(let s=0;s<a;++s){const e=n();p[r+s]=t.length;for(let n=0;n<t.length;n++)if(e<t[n]){p[r+s]=n;break}}}return o||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(d,"int32",p)}};function FR(e,t,n){const r=zo(-1,n);return RE([],t,r,e,n)}const MR={kernelName:Ka,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;gT(r,"neg");const s=n.data.get(r.dataId).values,[a,i]=FR(s,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,a)}},LR=Xm;const PR={kernelName:Qa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r;gT(s,"NonMaxSuppression");const u=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values,{selectedIndices:h}=LR(u,c,i,o,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},zR=Qm;const BR={kernelName:Ya,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r;gT(s,"NonMaxSuppressionPadded");const c=n.data.get(s.dataId).values,h=n.data.get(a.dataId).values,{selectedIndices:d,validOutputs:p}=zR(c,h,i,o,l,u);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},VR=Ym;const WR={kernelName:Za,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r;gT(s,"NonMaxSuppressionWithScore");const c=n.data.get(s.dataId).values,h=n.data.get(a.dataId).values,d=i,p=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=VR(c,h,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}},UR=AT(((e,t)=>e!==t?1:0)),jR=KT(Xa,UR,null,"bool"),GR={kernelName:Xa,backendName:"cpu",kernelFunc:jR};const HR={kernelName:ei,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{dtype:a,depth:i,onValue:o,offValue:l}=r;gT(s,"oneHot");const u=xr(s.shape),c=new Float32Array(u*i);c.fill(l);const h=n.data.get(s.dataId).values;for(let d=0;d<u;++d)h[d]>=0&&h[d]<i&&(c[d*i+h[d]]=o);return n.makeTensorInfo([...s.shape,i],a,c)}};function qR(e){const{inputs:t,backend:n}=e,{x:r}=t;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){const e=UT({inputs:{input:r},backend:n}),t=qR({inputs:{x:e},backend:n}),s=nE({inputs:{input:r},backend:n}),a=qR({inputs:{x:s},backend:n}),i=BT({inputs:{real:t,imag:a},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),i}return m$({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const KR={kernelName:io,backendName:"cpu",kernelFunc:qR};const XR={kernelName:Ja,backendName:"cpu",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:s}=n;if("string"===s.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===s.dtype){const t=UT({inputs:{input:s},backend:r}),n=e({inputs:{x:t},backend:r}),a=nE({inputs:{input:s},backend:r}),i=qR({inputs:{x:a},backend:r}),o=BT({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),o}return m$({backend:r,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}};function QR(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(1===t.length)return JE({inputs:{input:t[0]},backend:n,attrs:{dim:s}});const a=t[0].shape,i=t[0].dtype;t.forEach((e=>{br(a,e.shape,"All tensors passed to stack must have matching shapes"),yr(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const o=[],l=t.map((e=>{const t=JE({inputs:{input:e},backend:n,attrs:{dim:s}});return o.push(t),t})),u=sE({inputs:l,backend:n,attrs:{axis:s}});return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}const YR={kernelName:ti,backendName:"cpu",kernelFunc:QR};const ZR={kernelName:ni,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,constantValue:i}=r;gT(s,"pad");const o=a.map(((e,t)=>e[0]+s.shape[t]+e[1])),l=a.map((e=>e[0])),u=n.data.get(s.dataId).values,c=xr(s.shape),h=s.shape.length,d=Pr(s.shape),p=xr(o),f=o.length,m=Pr(o),g=Er(s.dtype,p);0!==i&&g.fill(i);for(let y=0;y<c;y++){const e=Hr(y,h,d).map(((e,t)=>e+l[t]));g[Gr(e,f,m)]=u[y]}return{dataId:n.write(g,o,s.dtype),shape:o,dtype:s.dtype}}},JR=AT(((e,t)=>Math.pow(e,t))),eD=KT(ri,JR),tD={kernelName:ri,backendName:"cpu",kernelFunc:eD};function nD(e,t,n,r){const[s,a]=Wd(e,r),i=pl(t,"int32"),o=Wr(xr(s),i),l=xr(a);for(let u=0;u<o.length;++u){const e=u*l;let t=1;for(let r=0;r<l;++r)t*=n[e+r];o[u]=t}return{outVals:o,outShape:s,outDtype:i}}const rD={kernelName:ai,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;gT(s,"prod");const o=s.shape.length,l=Tr(a,s.shape),u=Gd(l,o);let c=l,h=s;const d=[];null!=u&&(h=pA({inputs:{x:s},backend:n,attrs:{perm:u}}),d.push(h),c=qd(c.length,o));const p=n.data.get(h.dataId).values,{outVals:f,outShape:m,outDtype:g}=nD(h.shape,h.dtype,p,c);let y=m;return i&&(y=Ud(m,l)),d.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(y,g,f)}};function sD(e,t,n,r){const s=[];let a=0;const i=t.length-1+n.length,o=new Array(i).fill(null).map((()=>[0]));!function(e,t){for(let n=0;n<e.length;++n){const r=e[n],s=n===e.length-1?t:e[n+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>s)throw new Error("Ragged splits must not point past values");for(let e=1;e<r.length;++e)if(r[e-1]>r[e])throw new Error("Ragged splits must be sorted in ascending order")}}(n,r);let l=1;for(let u=0;u<t.length-1;++u){l*=t[u];const e=t[u+1];for(let t=1;t<l+1;++t)o[u].push(t*e)}for(let u=0;u<e.length;++u){let r=e[u],i=e[u]+1;for(let e=0;e<n.length;++e){const s=n[e],a=e+t.length-1;if(a>=0){const e=o[a],t=e[e.length-1]-s[r];for(let n=r;n<i;++n)o[a].push(s[n+1]+t)}r=s[r],i=s[i]}i!==r&&(s.push([r,i]),a+=i-r)}return{outSplits:o,valueSlices:s,numValues:a}}function aD(e,t){const n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function iD(e,t,n,r,s){const a=t.slice();a[0]=s;const i=$r(n,xr(a)),o=e.length;return function(e,t,n,r,s,a){const i=aD(t,2)[1],o=aD(a,2)[1];let l=0;for(const u of n)for(let t=u[0];t<u[1];++t){for(let n=0;n<r;++n)s[l*o+n]=e[t*i+n];++l}}(e,t,r,0===o?0:o/t[0],i,a),[i,a]}function oD(e,t,n,r,s,a,i,o){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function(e,t,n){e.forEach(((e,r)=>{if(e<0||e>=n){const s=Hr(r,t.length,Pr(t)).join(",");throw new Error(`indices[${s}] = ${e} is not in [0, ${n})`)}}))}(a,i,t[0][0]-1),0===r.length)throw new Error("params.rank must be nonzero");const l=r[0],{outSplits:u,valueSlices:c,numValues:h}=sD(a,i,e,l),d=function(e){const t=[];for(let n=0;n<e.length;++n){const r=$r("int32",e[n].length);t.push(r),e[n].forEach(((e,t)=>r[t]=e))}return t}(u),p=iD(n,r,s,c,h);return[d,p[0],p[1]]}const lD={kernelName:ii,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:s,paramsDenseValues:a,indices:i}=t,{outputRaggedRank:o}=r,l=s.map((e=>n.data.get(e.dataId).values)),u=s.map((e=>e.shape)),c=n.data.get(a.dataId).values,h=n.data.get(i.dataId).values,[d,p,f]=oD(l,u,c,a.shape,a.dtype,h,i.shape),m=d.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,a.dtype,p);return m.concat([g])}},uD=2147483647;function cD(e,t,n,r,s,a,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(s.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");const o=0===t.length,l=0===s.length,u=0===i.length,c=[];o||c.push(t[0]),l||c.push(s[0]),u||c.push(i[0]);for(let m=1;m<c.length;++m)if(c[m]!==c[m-1])throw new Error("starts, limits, and deltas must have the same shape");const h=0===c.length?1:c[0],d=$r("int32",h+1);d[0]=0;for(let m=0;m<h;++m){const t=o?e[0]:e[m],n=l?r[0]:r[m],s=u?a[0]:a[m];if(0===s)throw new Error("Requires delta != 0");let i;if(s>0&&n<t||s<0&&n>t)i=0;else if(i=Math.ceil(Math.abs((n-t)/s)),i>uD)throw new Error(`Requires ((limit - start) / delta) <= ${uD}`);d[m+1]=d[m]+i}const p=$r(n,d[h]);let f=0;for(let m=0;m<h;++m){const t=d[m+1]-d[m];let n=o?e[0]:e[m];const r=u?a[0]:a[m];for(let e=0;e<t;++e)p[f++]=n,n+=r}return[d,p]}const hD={kernelName:oi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:r,limits:s,deltas:a}=t,i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,[u,c]=cD(i,r.shape,r.dtype,o,s.shape,l,a.shape);return[n.makeTensorInfo([u.length],"int32",u),n.makeTensorInfo([c.length],r.dtype,c)]}};var dD=Gg;class pD{constructor(e,t,n,r,s,a,i,o,l,u){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=r,this.valuesDType=s,this.defaultValue=a,this.defaultValueShape=i,this.rowPartitionValues=o,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=qg(u),this.raggedRank=Kg(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===dD.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===dD.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case dD.VALUE_ROWIDS:return pD.getMaxWidthValueRowID(t);case dD.ROW_SPLITS:return pD.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${dD[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(0===t||1===t)return 0;let n=0;for(let r=0;r<t-1;++r){const t=e[r+1]-e[r];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){const t=e.length;if(0===t)return 0;let n=0,r=e[0],s=0;for(let a=1;a<t;++a){const t=e[a];t!==r&&(r=t,s=Math.max(a-n,s),n=a)}return Math.max(t-n,s)}tensorShapeFromTensor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return mD(e,n)}calculateOutputSize(e){const t=this.valuesShape;Xg(this.defaultValueShape,t);const n=this.tensorShapeFromTensor(this.shape,this.shapeShape),r=Hg(this.raggedRank,n,t);r[0]<0&&(r[0]=e);for(let s=1;s<=this.raggedRank;++s)r[s]<0&&(r[s]=this.getMaxWidth(s));return r}calculateFirstParentOutputIndex(e,t,n){const r=Math.min(e,n),s=[];let a=0;for(let i=0;i<r;++i,a+=t)s.push(a);for(let i=r;i<e;++i)s.push(-1);return yr(s.length===e,(()=>"Final length of result must be equal to firstDimension.")),s}calculateOutputIndexRowSplit(e,t,n,r){const s=e.length,a=[];for(let i=0;i<s-1;++i){const s=e[i+1]-e[i];let o=Math.min(r,s),l=t[i];-1===l&&(o=0);for(let e=0;e<o;++e)a.push(l),l+=n;for(let e=0;e<s-o;++e)a.push(-1)}if(s>0&&a.length!==e[s-1])throw new Error("Invalid row split size.");return a}calculateOutputIndexValueRowID(e,t,n,r){const s=e.length,a=[];if(0===s)return[];let i=0,o=e[0];if(o>=t.length)throw new Error(`Got currentValueRowId=${o}, which is not less than ${t.length}`);let l=t[o];a.push(l);for(let u=1;u<s;++u){const s=e[u];if(s===o)l>=0&&(++i,i<r?l+=n:l=-1);else{if(i=0,o=s,s>=t.length)throw new Error(`Got nextValueRowId=${s} which is not less than ${t.length}`);l=t[s]}a.push(l)}if(a.length!==e.length)throw new Error("Invalid row ids.");return a}calculateOutputIndex(e,t,n,r){const s=this.getRowPartitionTensor(e),a=this.getRowPartitionTypeByDimension(e);switch(a){case dD.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,t,n,r);case dD.ROW_SPLITS:if(s.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(s,t,n,r);default:throw new Error(`Unsupported partition type: ${dD[a]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case dD.FIRST_DIM_SIZE:return e[0];case dD.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case dD.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${dD[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let a=n.length-2;a>=0;--a)n[a]=n[a+1]*t[a+1];const r=mD(t,!1),s=$r(this.valuesDType,xr(r));if(n[0]*t[0]>0){let a=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let e=1;e<=this.raggedRank;++e){a=this.calculateOutputIndex(e-1,a,n[e],t[e])}this.setOutput(this.raggedRank,a,s,r)}return[r,s]}setOutput(e,t,n,r){if(0===n.length)return;const s=this.values,a=n;let i=r.slice();i=i.slice(e+1);const o=xr(i),l=t.length;let u=this.defaultValue;if(u.length!==o&&1!==u.length){const e=this.defaultValueShape;Gl((()=>{const t=Hh(u,e),n=ud(t,i);u=n.dataSync()}))}let c=0,h=0,d=0;for(let p=0;p<=l;++p){let e=p<l?t[p]:-1;if(e!==d){if(h<d){const e=s.subarray(c*o);fD(a.subarray(h*o),e,(d-h)*o)}if(p>=l){const t=n.length;e=Math.floor(t/o)}if(e>d)if(1===this.defaultValue.length)a.subarray(d*o,e*o).fill(this.defaultValue[0]),d=e;else for(;e>d;){fD(a.slice(d*o),u,o),++d}e<0?(c=p+1,h=d):(c=p,h=d,d=h+1)}else++d}}}function fD(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function mD(e,t){const n=[];for(let r of e){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function gD(e,t,n,r,s,a,i,o,l,u){return new pD(e,t,n,r,s,a,i,o,l,u).compute()}const yD={kernelName:li,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{shape:s,values:a,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values,h=n.data.get(i.dataId).values,d=o.map((e=>n.data.get(e.dataId).values)),p=o.map((e=>e.shape)),[f,m]=gD(u,s.shape,c,a.shape,a.dtype,h,i.shape,d,p,l);return n.makeTensorInfo(f,a.dtype,m)}};function bD(e,t,n,r){if(e===t||e<t&&n<0||t<e&&n>1)return Wr(0,r);const s=Wr(Math.abs(Math.ceil((t-e)/n)),r);t<e&&1===n&&(n=-1),s[0]=e;for(let a=1;a<s.length;a++)s[a]=s[a-1]+n;return s}const vD={kernelName:ui,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:s,dtype:a,step:i}=n,o=bD(r,s,i,a);return t.makeTensorInfo([o.length],a,o)}},xD=xT(hi,(e=>1/e)),wD={kernelName:hi,backendName:"cpu",kernelFunc:xD};const kD={kernelName:gi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r;gT(s,"resizeBilinear");const l=Pr(s.shape),[u,c]=o,[h,d,p,f]=s.shape,m=n.data.get(s.dataId).values,g=new Float32Array(xr([h,u,c,f])),y=[a&&u>1?d-1:d,a&&c>1?p-1:p],b=[a&&u>1?u-1:u,a&&c>1?c-1:c];let v=0;const x=y[0]/b[0],w=y[1]/b[1];for(let k=0;k<h;k++)for(let e=0;e<u;e++){let t;t=i?x*(e+.5)-.5:x*e;const n=Math.max(0,Math.floor(t)),r=t-n,s=Math.min(d-1,Math.ceil(t)),a=k*l[0]+n*l[1],o=k*l[0]+s*l[1];for(let e=0;e<c;e++){let t;t=i?w*(e+.5)-.5:w*e;const n=Math.max(0,Math.floor(t)),s=t-n,u=Math.min(p-1,Math.ceil(t)),c=a+n*l[2],h=o+n*l[2],d=a+u*l[2],y=o+u*l[2];for(let e=0;e<f;e++){const t=m[c+e],n=m[h+e],a=t+(m[d+e]-t)*s,i=a+(n+(m[y+e]-n)*s-a)*r;g[v++]=i}}}return n.makeTensorInfo([h,u,c,f],"float32",g)}};const SD={kernelName:yi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r;gT([a,s],"resizeBilinearGrad");const o=Pr(s.shape),[l,u,c,h]=s.shape,[,d,p]=a.shape,f=new Float32Array(l*u*c*h),m=[i&&d>1?u-1:u,i&&p>1?c-1:c],g=[i&&d>1?d-1:d,i&&p>1?p-1:p],y=m[0]/g[0],b=m[1]/g[1],v=n.data.get(a.dataId).values;let x=0;for(let w=0;w<l;w++){const e=w*o[0];for(let t=0;t<d;t++){const n=t*y,r=Math.floor(n),s=Math.min(Math.ceil(n),u-1),a=e+r*o[1],i=e+s*o[1],l=n-r,d=1-l;for(let e=0;e<p;e++){const t=e*b,n=Math.floor(t),r=Math.min(Math.ceil(t),c-1),s=t-n,u=1-s,p=a+n*o[2],m=a+r*o[2],g=i+n*o[2],y=i+r*o[2],w=d*u,k=d*s,S=l*u,N=l*s;for(let e=0;e<h;e++){const t=v[x++];f[p+e]+=t*w,f[m+e]+=t*k,f[g+e]+=t*S,f[y+e]+=t*N}}}}return n.makeTensorInfo([l,c,u,h],"float32",f)}};const ND={kernelName:fi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r;gT(s,"resizeNearestNeighbor");const l=Pr(s.shape),[u,c]=o,[h,d,p,f]=s.shape,m=n.data.get(s.dataId).values,g=new Float32Array(h*u*c*f),y=[a&&u>1?d-1:d,a&&c>1?p-1:p],b=[a&&u>1?u-1:u,a&&c>1?c-1:c],v=y[0]/b[0],x=y[1]/b[1];let w=0;for(let k=0;k<h;k++){const e=k*l[0];for(let t=0;t<u;t++){const n=i?v*(t+.5):v*t;let r=Math.min(d-1,a?Math.round(n):Math.floor(n));i&&(r=Math.max(0,r));const s=e+r*l[1];for(let e=0;e<c;e++){const t=i?x*(e+.5):x*e;let n=Math.min(p-1,a?Math.round(t):Math.floor(t));i&&(n=Math.max(0,n));const r=s+n*l[2];for(let e=0;e<f;e++){const t=m[r+e];g[w++]=t}}}}return n.makeTensorInfo([h,u,c,f],s.dtype,g)}};const ID={kernelName:mi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r;gT([a,s],"resizeNearestNeighborGrad");const o=Pr(s.shape),l=Pr(a.shape),[u,c,h,d]=s.shape,[,p,f]=a.shape,m=new Float32Array(u*c*h*d),g=n.data.get(a.dataId).values,y=[i&&p>1?c-1:c,i&&f>1?h-1:h],b=[i&&p>1?p-1:p,i&&f>1?f-1:f],v=y[0]/b[0],x=y[1]/b[1],w=1/v,k=1/x,S=2*Math.ceil(w)+2,N=2*Math.ceil(k)+2;for(let I=0;I<u;I++){const e=I*o[0];for(let t=0;t<c;t++){const n=e+t*o[1],r=Math.floor(t*w),s=Math.floor(r-S/2);for(let a=0;a<h;a++){const r=n+a*o[2],u=Math.floor(a*k),y=Math.floor(u-N/2);for(let n=0;n<d;n++){let o=0;for(let r=0;r<S;r++){const u=r+s;if(u<0||u>=p)continue;const d=e+u*l[1],m=u*v;if(t===Math.min(c-1,i?Math.round(m):Math.floor(m)))for(let e=0;e<N;e++){const t=e+y;if(t<0||t>=f)continue;const r=d+t*l[2],s=t*x;a===Math.min(h-1,i?Math.round(s):Math.floor(s))&&(o+=g[r+n])}}m[r+n]=o}}}}return n.makeTensorInfo(s.shape,s.dtype,m)}};const CD={kernelName:vi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r;gT(s,"reverse");const i=s.shape.length,o=Tr(a,s.shape);if(0===i)return NT({inputs:{x:s},backend:n});const l=new el(s.shape,s.dtype),u=n.bufferSync(s);for(let c=0;c<l.size;c++){const e=l.indexToLoc(c),t=e.slice();o.forEach((e=>t[e]=s.shape[e]-1-t[e])),l.set(u.get(...t),...e)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}},TD={kernelName:uo,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{image:s}=t,{radians:a,fillValue:i,center:o}=n,l=r,u=Er(s.dtype,xr(s.shape)),[c,h,d,p]=s.shape,[f,m]=Zg(o,h,d),g=Math.sin(a),y=Math.cos(a),b=l.data.get(s.dataId).values;for(let v=0;v<c;v++){const e=v*d*h*p;for(let t=0;t<h;t++){const n=t*(d*p);for(let r=0;r<d;r++){const s=r*p;for(let a=0;a<p;a++){const o=[c,t,r,a],l=o[2],v=o[1];let x=(l-f)*y-(v-m)*g,w=(l-f)*g+(v-m)*y;x=Math.round(x+f),w=Math.round(w+m);let k=i;if("number"!==typeof i&&(k=3===a?255:i[a]),x>=0&&x<d&&w>=0&&w<h){k=b[e+w*(d*p)+x*p+a]}u[e+n+s+a]=k}}}}return{dataId:l.write(u,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},AD=xT(xi,(e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1})),ED={kernelName:xi,backendName:"cpu",kernelFunc:AD},$D=vT((e=>1/Math.sqrt(e))),RD=wT(wi,$D),DD={kernelName:wi,backendName:"cpu",kernelFunc:RD};function OD(e,t,n,r,s,a,i,o,l,u){const c=[r/s,s],h=e.values,d=t.values;if(0===r)return Zu(n,t.dtype);const p=l instanceof el?l:Zu(c,t.dtype);"string"===typeof l||"number"===typeof l?p.values.fill(l):"boolean"===typeof l&&p.values.fill(+l);for(let f=0;f<a;f++){const e=[];let a=0;for(let t=0;t<i;t++){const n=h[f*i+t];e.push(n),a+=n*o[t]}if(a<0||a>=r/s)throw new Error(`Invalid indices: ${e} does not index into ${n}`);for(let n=0;n<s;n++)u?p.values[a*s+n]+=d[f*s+n]:p.values[a*s+n]=0===t.rank?d[0]:d[f*s+n]}return p}const _D={kernelName:ki,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:a}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=am(0,s,i),d=OD(n.bufferSync(s),n.bufferSync(a),i,h,u,l,o,c,0,!0);return n.makeTensorInfo(i,d.dtype,d.values)}};function FD(e,t){let n=0,r=e.length,s=0;for(;n<r;)s=Math.floor((n+r)/2),e[s]<t?n=s+1:r=s;return r}function MD(e,t){let n=0,r=e.length,s=0;for(;n<r;)s=Math.floor((n+r)/2),e[s]<=t?n=s+1:r=s;return r}const LD={kernelName:Ni,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:s,values:a}=t,{side:i}=r,o=function(e,t,n,r,s,a){const i=$r("int32",n*s);for(let o=0;o<n;++o){const n=e.slice(o*r,(o+1)*r),l=o*s;for(let e=0;e<s;++e)i[l+e]="left"===a?FD(n,t[e+l]):MD(n,t[e+l])}return i}(n.data.get(s.dataId).values,n.data.get(a.dataId).values,s.shape[0],s.shape[1],a.shape[1],i);return n.makeTensorInfo(a.shape,"int32",o)}};const PD={kernelName:Ii,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t;gT([r,s,a],"select");const i=r.shape.length,o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,c=pl(s.dtype,a.dtype),h=Wr(xr(s.shape),c);let d=0;const p=0===i||i>1||1===s.shape.length?1:xr(s.shape.slice(1));for(let f=0;f<o.length;f++)for(let e=0;e<p;e++)1===o[f]?h[d++]=l[f]:h[d++]=u[f];return n.makeTensorInfo(s.shape,c,h)}},zD=ay,BD=iy,VD=xT(Ci,(e=>e>=0?BD*e:zD*(Math.exp(e)-1))),WD={kernelName:Ci,backendName:"cpu",kernelFunc:VD},UD=xT($i,(e=>e<0?-1:e>0?1:0)),jD={kernelName:$i,backendName:"cpu",kernelFunc:UD},GD=xT(Ai,(e=>Math.sin(e))),HD={kernelName:Ai,backendName:"cpu",kernelFunc:GD},qD=xT(Ei,(e=>Math.sinh(e))),KD={kernelName:Ei,backendName:"cpu",kernelFunc:qD},XD=Math.log(1.1920928955078125e-7)+2,QD=xT(Di,(e=>{const t=e>-XD,n=e<XD,r=Math.exp(e);let s;return s=n?r:t?e:Math.log(1+r),s})),YD={kernelName:Di,backendName:"cpu",kernelFunc:QD};const ZD={kernelName:Fi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:i}=r;gT([s],"spaceToBatchND");const o=xr(a),l=[[0,0]];l.push(...i);for(let g=1+a.length;g<s.shape.length;++g)l.push([0,0]);const u=ZR.kernelFunc({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),c=Jg(u.shape,a,o,!1),h=ey(c.length,a.length,!1),d=ty(u.shape,a,o,!1),p=eA({inputs:{x:u},backend:n,attrs:{shape:c}}),f=pA({inputs:{x:p},backend:n,attrs:{perm:h}}),m=eA({inputs:{x:f},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}};function JD(e,t,n,r,s,a,i){const o=t[0],l=a[0],u=new Array(l),c=new Array(o),h=t[1];if(0===l){if(0!==o)throw new Error(Dy(o));return[$r(n,0),[0,h],$r(s,0),u,c]}let d=!0,p=0;const f=new Array(l).fill(0);for(let g=0;g<o;++g){const t=e[g*h];if(t<0)throw new Error(Oy(g,t));if(t>=l)throw new Error(_y(g,t,l));++f[t],d=d&&t>=p,p=t}let m=!0;for(let g=0;g<l;++g){const e=0===f[g];u[g]=e,m=m&&!e,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&d){const t=e,n=r;for(let e=0;e<o;++e)c[e]=e;return[t,[o,h],n,u,c]}{const t=f[l-1],a=$r(n,t*h),d=$r(s,t),p=new Array(l).fill(0);for(let n=0;n<o;++n){const t=e[n*h],s=p[t],i=(0===t?0:f[t-1])+s;p[t]++;for(let r=0;r<h;++r)a[i*h+r]=e[n*h+r];d[i]=r[n],c[n]=i}for(let e=0;e<l;++e){if(0===p[e]){const t=0===e?0:f[e-1];a[t*h+0]=e;for(let e=1;e<h;++e)a[t*h+e]=0;d[t]=i}}return[a,[t,h],d,u,c]}}const eO={kernelName:Pi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:a,defaultValue:i}=t;if(1!==a.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${a.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n        ${s.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,c=n.data.get(i.dataId).values[0],[h,d,p,f,m]=JD(o,r.shape,r.dtype,l,s.dtype,u,c);return[n.makeTensorInfo(d,r.dtype,h),n.makeTensorInfo([d[0]],s.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}};function tO(e,t,n,r,s){const a=xr(r),i=t[0],o=s.length,l=[];let u=1,c=-1;for(let m=0;m<o;++m){const e=s[m];if(-1===e){if(-1!==c)throw new Error(Fy(c,m));c=m,l.push(1)}else{if(e<0)throw new Error(My(m,e));u*=e,l.push(e)}}if(-1!==c){if(u<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const e=Math.trunc(a/u);if(u*e!==a)throw new Error(Py(r,l));l[c]=e}if(xr(l)!==a)throw new Error(zy(r,l));const h=r.length,d=[];if(h>0){d[h-1]=1;for(let e=h-2;e>=0;--e)d[e]=d[e+1]*r[e+1]}const p=[];if(o>0){p[o-1]=1;for(let e=o-2;e>=0;--e)p[e]=p[e+1]*l[e+1]}const f=$r(n,i*o);for(let m=0;m<i;++m){let t=0;for(let n=0;n<h;++n)t+=e[m*h+n]*d[n];for(let e=0;e<o;++e)f[m*o+e]=Math.trunc(t/p[e]),t%=p[e]}return[f,[i,o],l]}const nO={kernelName:zi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:a}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${s.shape}`);if(1!==a.shape.length)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const i=Array.from(n.data.get(s.dataId).values),o=n.data.get(r.dataId).values,l=Array.from(n.data.get(a.dataId).values),[u,c,h]=tO(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([h.length],a.dtype,new Int32Array(h))]}};function rO(e,t,n,r,s){let a=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;const o=r.length,l=[t[0],e.length/t[0]],u=l[1],c=o>0?s[o-1]+1:0;if(c<0)throw new Error("segment ids must be >= 0");const h=t.slice();h[0]=c;const d=h.reduce(((e,t)=>e*t),1),p=$r(n,d);if(0===o)return c>0&&p.fill(i),[p,h];if(c<=0)throw new Error("segment ids must be >= 0");let f=0,m=1,g=0,y=s[f];for(;;){let t=0;if(m<o){if(t=s[m],y===t){++m;continue}if(y>=t)throw new Error("segment ids are not increasing")}if(y<0||y>=c)throw new Error(Wy(y,c));y>g&&p.fill(i,g*u,y*u);for(let n=f;n<m;++n){const t=r[n];if(t<0||t>=l[0])throw new Error(Uy(n,r[n],l[0]));for(let n=0;n<u;n++)p[y*u+n]+=e[t*u+n]}if(a)for(let e=0;e<u;e++)p[y*u+e]/=m-f;if(f=m,++m,g=y+1,y=t,m>o)break}return g<c&&p.fill(i,g*u,c*u),[p,h]}const sO={kernelName:Bi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${s.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${a.shape}`);if(s.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,[u,c]=rO(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}};const aO={kernelName:Vi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${s.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${a.shape}`);if(s.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,[u,c]=rO(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}};const iO={kernelName:Wi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:d}=am(0,s,o),p=!1,f=n.bufferSync(s);let m;switch(a.dtype){case"bool":m=OD(f,n.bufferSync(a),o,d,c,u,l,h,Boolean(n.data.get(i.dataId).values[0]),p);break;case"float32":m=OD(f,n.bufferSync(a),o,d,c,u,l,h,n.data.get(i.dataId).values[0],p);break;case"int32":m=OD(f,n.bufferSync(a),o,d,c,u,l,h,n.data.get(i.dataId).values[0],p);break;case"string":m=OD(f,n.bufferSync(a),o,d,c,u,l,h,Uo(n.data.get(i.dataId).values[0]),p);break;default:throw new Error(`Unsupported type ${a.dtype}`)}return n.makeTensorInfo(o,m.dtype,m.values)}};const oO={kernelName:Mi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:i}=r,o=Tr(i,s.shape)[0],l=Ry(s,a,o),u=new Array(s.shape.length).fill(0),c=s.shape.slice();return l.map((e=>{const t=[...c];t[o]=e;const r=zA({inputs:{x:s},backend:n,attrs:{begin:u,size:t}});return u[o]+=e,r}))}},lO=vT((e=>Math.sqrt(e))),uO=xT(Oi,(e=>Math.sqrt(e))),cO={kernelName:Oi,backendName:"cpu",kernelFunc:uO},hO={kernelName:ji,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n}=e;const{x:r}=t,s=n;gT(r,"square");const a=s.data.get(r.dataId).values,i=new Float32Array(a.length);for(let o=0;o<a.length;++o){const e=a[o];i[o]=e*e}return{dataId:s.write(i,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},dO=AT(((e,t)=>{const n=e-t;return n*n})),pO=KT(Ui,dO),fO={kernelName:Ui,backendName:"cpu",kernelFunc:pO},mO=vT(((e,t)=>{const{pattern:n,replaceGlobal:r,rewrite:s}=t;return e.replace(new RegExp(n,r?"g":""),s)})),gO=wT(Gi,mO),yO={kernelName:Gi,backendName:"cpu",kernelFunc:gO},bO=xT(oo,((e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha})),vO={kernelName:oo,backendName:"cpu",kernelFunc:bO};function xO(e,t,n,r){const s=Zu(e,t.dtype);for(let a=0;a<s.size;a++){const e=s.indexToLoc(a),i=new Array(e.length);for(let t=0;t<i.length;t++)i[t]=e[t]*n[t]+r[t];s.set(t.get(...i),...e)}return s}const wO={kernelName:Hi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=r;gT(s,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:v,strides:x}=yh(s.shape,a,i,o,l,u,c,h,d);let w;if(m)w=eA({inputs:{x:s},backend:n,attrs:{shape:f}});else if(g||y){yr(s.shape.length>=1,(()=>`Input must have rank at least 1, got: ${s.shape.length}`));const e=sh(b,v,x),t=zA({inputs:{x:s},backend:n,attrs:{begin:b,size:e}});w=eA({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{const e=xO(p,n.bufferSync(s),x,b);w=n.makeTensorInfo(f,e.dtype,e.values)}return w}};class kO{constructor(e,t,n,r,s,a){this.separator=Wo(e),this.nGramWidths=t,this.leftPad=Wo(n),this.rightPad=Wo(r),this.padWidth=s,this.preserveShort=a}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,s,a){for(let i=0;i<s;++i){const o=this.getPadWidth(a),l=Math.max(0,o-i),u=Math.max(0,o-(s-(i+1))),c=a-(l+u),h=t+(l>0?0:i-o);let d=0;d+=l*this.leftPad.length;for(let t=0;t<c;++t)d+=e[h+t].length;d+=u*this.rightPad.length;d+=(l+u+c-1)*this.separator.length,n[r+i]=new Uint8Array(d);const p=n[r+i];let f=0;const m=e=>e.forEach((e=>p[f++]=e));for(let e=0;e<l;++e)m(this.leftPad),m(this.separator);for(let t=0;t<c-1;++t)m(e[h+t]),m(this.separator);if(c>0){m(e[h+c-1]);for(let e=0;e<u;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<u-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){const n=e.length,r=t.length;if(r>0){let e=t[0];if(0!==e)throw new Error(`First split value must be 0, got ${e}`);for(let s=1;s<r;++s){let r=t[s]>=e;if(r=r&&t[s]<=n,!r)throw new Error(`Invalid split value ${t[s]}, must be in [${e}, ${n}]`);e=t[s]}if(e!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${e}`)}const s=r-1,a=$r("int32",r);if(0===n||0===r){const e=new Array(n);for(let t=0;t<=s;++t)a[t]=0;return[e,a]}a[0]=0;for(let o=1;o<=s;++o){const e=t[o]-t[o-1];let n=0;this.nGramWidths.forEach((t=>{n+=this.getNumNGrams(e,t)})),this.preserveShort&&e>0&&0===n&&(n=1),a[o]=a[o-1]+n}const i=new Array(a[s]);for(let o=0;o<s;++o){const n=t[o];let r=a[o];if(this.nGramWidths.forEach((s=>{const a=t[o+1]-t[o],l=this.getNumNGrams(a,s);this.createNGrams(e,n,i,r,l,s),r+=l})),this.preserveShort&&r===a[o]){const s=t[o+1]-t[o];if(0===s)continue;const a=s+2*this.padWidth,l=1;this.createNGrams(e,n,i,r,l,a)}}return[i,a]}}function SO(e,t,n,r,s,a,i,o){return new kO(n,r,s,a,i,o).compute(e,t)}const NO={kernelName:qi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:a,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:h}=t,d=n.data.get(c.dataId).values,p=n.data.get(h.dataId).values,[f,m]=SO(d,p,s,a,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}};function IO(e,t,n,r){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)r.push(e.subarray(t,t+1));return}if(1===t.length){const s=t[0];let a=e.indexOf(s);for(;-1!==a;){const t=e.subarray(0,a);n&&0===t.length||r.push(t),a=(e=e.subarray(a+1)).indexOf(s)}return void(n&&0===e.length||r.push(e))}let s=0;for(let a=0;a<e.length+1;a++)if(a===e.length||-1!==t.indexOf(e[a])){const t=e.subarray(s,a);n&&0===t.length||r.push(t),s=a+1}}function CO(e,t,n){const r=e.length,s=[];let a=0,i=0;const o=new Array(r);for(let d=0;d<r;++d){const r=s.length;IO(e[d],t,n,s);const l=s.length-r;o[d]=l,a+=l,i=Math.max(i,l)}const l=$r("int32",2*a),u=new Array(a),c=[r,i];let h=0;for(let d=0;d<r;++d)for(let e=0;e<o[d];++e)l[2*h]=d,l[2*h+1]=e,u[h]=s[h],++h;return[l,u,c]}const TO={kernelName:Ki,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:a,delimiter:i}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(1!==a.shape.length)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=n.data.get(a.dataId).values,l=n.data.get(i.dataId).values[0],[u,c,h]=CO(o,l,s),d=c.length;return[n.makeTensorInfo([d,2],"int32",u),n.makeTensorInfo([d],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(h))]}};function AO(e,t){const n=$r("int32",e.length);for(let r=0;r<e.length;++r)n[r]=Po(e[r]).modulo(t).getLowBitsUnsigned();return n}const EO={kernelName:Xi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:a}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=AO(n.data.get(a.dataId).values,s);return n.makeTensorInfo(a.shape,"int32",i)}},$O=xT(Yi,(e=>Math.tan(e))),RO={kernelName:Yi,backendName:"cpu",kernelFunc:$O},DO=xT(Zi,(e=>Math.tanh(e)));const OO={kernelName:Si,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{tensor:r,indices:s,updates:a}=t,{sliceRank:i,numUpdates:o,sliceSize:l,strides:u,outputSize:c}=am(0,s,r.shape),h=n.bufferSync(s),d=n.bufferSync(a),p=n.bufferSync(r),f=OD(h,d,r.shape,c,l,o,i,u,p,!1);return n.makeTensorInfo(r.shape,f.dtype,f.values)}};function _O(e,t){const n=new Array(e.rank);for(let s=0;s<n.length;s++)n[s]=e.shape[s]*t[s];const r=Zu(n,e.dtype);for(let s=0;s<r.values.length;++s){const t=r.indexToLoc(s),n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=t[r]%e.shape[r];const a=e.locToIndex(n);r.values[s]=e.values[a]}return r}const FO={kernelName:Ji,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:a}=r;gT(s,"tile");const i=_O(n.bufferSync(s),a);return n.makeTensorInfo(i.shape,i.dtype,i.values)}},MO=(e,t)=>{const n=t.value-e.value;return 0===n?e.index-t.index:n};function LO(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:e.length-1;for(;r>n;){if(r-n>600){const s=r-n+1,a=t-n+1,i=Math.log(s),o=.5*Math.exp(2*i/3),l=.5*Math.sqrt(i*o*(s-o)/s)*Math.sign(a-s/2);LO(e,t,Math.max(n,Math.floor(t-a*o/s+l)),Math.min(r,Math.floor(t+(s-a)*o/s+l)))}const s=e[t];let a=n,i=r;for(gr(e,n,t),MO(e[r],s)>0&&gr(e,n,r);a<i;){for(gr(e,a,i),a++,i--;MO(e[a],s)<0;)a+=1;for(;MO(e[i],s)>0;)i-=1}0===MO(e[n],s)?gr(e,n,i):(i+=1,gr(e,i,r)),i<=t&&(n=i+1),t<=i&&(r=i-1)}}function PO(e,t,n,r,s){const a=t[t.length-1],[i,o]=[e.length/a,a],l=Er(n,i*r),u=Er("int32",i*r);for(let h=0;h<i;h++){const t=h*o,n=e.subarray(t,t+o);let a=new Array(n.length);n.forEach(((e,t)=>a[t]={value:e,index:t})),r<a.length&&(LO(a,r),a=a.slice(0,r)),s&&a.sort(MO);const i=h*r,c=l.subarray(i,i+r),d=u.subarray(i,i+r);for(let e=0;e<r;e++)c[e]=a[e].value,d[e]=a[e].index}const c=t.slice();return c[c.length-1]=r,[Zu(c,n,l),Zu(c,"int32",u)]}const zO={kernelName:eo,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:a,sorted:i}=r;gT(s,"topk");const o=n.data.get(s.dataId).values,[l,u]=PO(o,s.shape,s.dtype,a,i);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}};const BO={kernelName:to,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{image:s,transforms:a}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=n,[c,h,d,p]=s.shape,[f,m]=null!=u?u:[h,d],g=[c,f,m,p],y=Pr(s.shape),b=y[0],v=y[1],x=y[2],w=Pr(g),k=w[0],S=w[1],N=w[2],I=Er(s.dtype,xr(g));I.fill(l);const C=r.data.get(s.dataId).values,T=r.data.get(a.dataId).values;for(let A=0;A<c;++A){const e=1===a.shape[0]?T:T.subarray(8*A,8*A+8);for(let t=0;t<f;++t)for(let n=0;n<m;++n)for(let r=0;r<p;++r){let s;const a=e[6]*n+e[7]*t+1;if(0===a)continue;const u=(e[0]*n+e[1]*t+e[2])/a,c=(e[3]*n+e[4]*t+e[5])/a,p=VO(u,d,o),f=VO(c,h,o);switch(i){case"nearest":s=UO(C,h,d,b,v,x,A,f,p,r,l);break;case"bilinear":s=jO(C,h,d,b,v,x,A,f,p,r,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}I[A*k+t*S+n*N+r]=s}return r.makeTensorInfo(g,s.dtype,I)}return{dataId:r.write(I,g,s.dtype),shape:s.shape,dtype:s.dtype}}};function VO(e,t,n){switch(n){case"reflect":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{const e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return fr(0,n,t-1)}(e,t);case"wrap":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=t-1;n+=t*(Math.trunc(-n/e)+1)}else if(n>t-1)if(t<=1)n=0;else{const e=t-1;n-=t*Math.trunc(n/e)}return fr(0,n,t-1)}(e,t);case"nearest":return function(e,t){return fr(0,e,t-1)}(e,t);default:return function(e){return e}(e)}}function WO(e,t,n,r,s,a,i,o,l,u,c){return 0<=o&&o<t&&0<=l&&l<n?e[i*r+o*s+l*a+u]:c}function UO(e,t,n,r,s,a,i,o,l,u,c){return WO(e,t,n,r,s,a,i,Math.round(o),Math.round(l),u,c)}function jO(e,t,n,r,s,a,i,o,l,u,c){const h=Math.floor(o),d=Math.floor(l),p=h+1,f=d+1;return(p-o)*((f-l)*WO(e,t,n,r,s,a,i,h,d,u,c)+(l-d)*WO(e,t,n,r,s,a,i,h,f,u,c))+(o-h)*((f-l)*WO(e,t,n,r,s,a,i,p,d,u,c)+(l-d)*WO(e,t,n,r,s,a,i,p,f,u,c))}function GO(e,t,n,r){const s=Tr(t,n)[0],a=[1,n[0],1];for(let f=0;f<s;f++)a[0]*=n[f];a[1]=n[s];for(let f=s+1;f<n.length;f++)a[2]*=n[f];const i=new Map,o=new Int32Array(n[s]),l=new el(a,r,e),u=[],c=1===a[0]&&1===a[2];for(let f=0;f<n[s];f++){let t;if(c)t=e[f].toString();else{const e=[];for(let t=0;t<a[0];t++)for(let n=0;n<a[2];n++)e.push(l.get(t,f,n));t=e.join(",")}const n=i.get(t);if(null!=n)o[f]=n;else{const e=i.size;i.set(t,e),o[f]=e,u.push(f)}}const h=a.slice();h[1]=i.size;const d=new el(h,r);u.forEach(((e,t)=>{for(let n=0;n<a[0];n++)for(let r=0;r<a[2];r++)d.set(l.get(n,e,r),n,t,r)}));const p=n.slice();return p[s]=h[1],{outputValues:d.values,outputShape:p,indices:o}}const HO={kernelName:ro,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t;gT(a,"unique");const i=r.data.get(a.dataId).values,{outputValues:o,outputShape:l,indices:u}=GO(i,s,a.shape,a.dtype);return[r.makeTensorInfo(l,a.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}};const qO={kernelName:so,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:s}=t;let{axis:a}=r;a<0&&(a+=s.shape.length);const i=s.shape.length,o=s.shape[a],l=new Array(i-1);let u=0;for(let p=0;p<i;p++)p!==a&&(l[u++]=s.shape[p]);const c=new Array(i).fill(0),h=s.shape.slice();h[a]=1;const d=new Array(o);for(let p=0;p<d.length;p++){c[a]=p;const e=zA({inputs:{x:s},backend:n,attrs:{begin:c,size:h}});d[p]=eA({inputs:{x:e},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(e)}return d}};const KO={kernelName:ao,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:a}=t,{numSegments:i}=r;gT(s,"unsortedSegmentSum");const o=[],l=[],u=s.shape.length-a.shape.length;let c=a;for(let d=0;d<u;++d){const e=JE({inputs:{input:c},backend:n,attrs:{dim:d+1}});c=e,l.push(e)}for(let d=0;d<i;++d){const e=zo(d,"int32"),t=n.makeTensorInfo([],"int32",e),r=BE({inputs:{a:t,b:c},backend:n}),a=HT({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),i=OE({inputs:{a:a,b:s},backend:n}),u=FE({inputs:{x:i},backend:n,attrs:{axis:0,keepDims:!1}});o.push(u),l.push(t),l.push(r),l.push(a),l.push(i),l.push(u)}const h=QR({inputs:o,backend:n,attrs:{axis:0}});return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),h}},XO=[sA,iA,lA,cA,JT,hA,mA,gA,yA,bA,xA,kA,NA,TA,EA,OA,_A,FA,MA,rA,LA,VA,jA,qA,KA,qT,YA,JA,VT,eE,aE,oE,lE,uE,cE,hE,dE,fE,gE,yE,bE,vE,xE,wE,SE,NE,IE,CE,TE,AE,EE,$E,LE,ST,PE,VE,XE,ZE,e$,r$,f$,g$,y$,x$,S$,N$,I$,T$,E$,D$,F$,IT,M$,rE,P$,B$,W$,TT,G$,K$,Q$,J$,tR,sR,iR,uR,cR,hR,fR,yR,bR,vR,xR,wR,kR,SR,NR,TR,AR,RR,_R,_E,MR,PR,BR,WR,GR,HR,XR,YR,ZR,tD,RT,rD,lD,hD,yD,vD,jT,i$,wD,OT,FT,tA,kD,SD,ND,ID,CD,TD,ED,DD,_D,LD,PD,WD,PT,jD,HD,KD,BA,OR,YD,ZD,eO,nO,sO,aO,iO,oO,cO,hO,fO,yO,vO,wO,NO,TO,EO,c$,ME,RO,{kernelName:Zi,backendName:"cpu",kernelFunc:DO},OO,FO,zO,BO,fA,HO,qO,KO,KR];for(const n of XO)wo(n);const QO={},YO={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function ZO(e,t){if(!(e in QO)||null!=t){const n=function(e,t){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=null==t?function(e){if(Yr().getBool("IS_SAFARI")||"undefined"===typeof OffscreenCanvas||2!==e){if("undefined"!==typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}return new OffscreenCanvas(300,150)}(e):t;n.addEventListener("webglcontextlost",(t=>{t.preventDefault(),delete QO[e]}),!1),Yr().getBool("SOFTWARE_WEBGL_ENABLED")&&(YO.failIfMajorPerformanceCaveat=!1);if(1===e)return n.getContext("webgl",YO)||n.getContext("experimental-webgl",YO);return n.getContext("webgl2",YO)}(e,t);if(null===n)return console.log("Could not get context for WebGL version",e),null;QO[e]=n}const n=QO[e];return null==n||n.isContextLost()?(delete QO[e],ZO(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),QO[e])}var JO,e_,t_;function n_(e,t){return[t,e]}function r_(e){const t=xr(e);return Sr(Math.ceil(t/4))}function s_(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function a_(e,t){const n=e;let r,s,a,i,o,l,u,c,h,d;return 2===Yr().getNumber("WEBGL_VERSION")?(r=n.R32F,s=n.R16F,a=n.RGBA16F,i=n.RGBA32F,o=n.RED,u=4,c=1,h=n.HALF_FLOAT,d=n.FLOAT,l=n.RGBA8):(r=e.RGBA,s=e.RGBA,a=e.RGBA,i=n.RGBA,o=e.RGBA,u=4,c=4,h=null!=t?t.HALF_FLOAT_OES:null,d=e.FLOAT,l=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:i,textureFormatFloat:o,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:h,textureTypeFloat:d}}function i_(e,t){const n=t();return Yr().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+function(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}(e,t))}(e),n}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(JO||(JO={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(e_||(e_={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(t_||(t_={}));function o_(e){return!!(Yr().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function l_(e,t){return y_(e,(()=>e.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}const u_=/ERROR: [0-9]+:([0-9]+):/g;function c_(e,t){const n=u_.exec(t);if(null==n)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(e);const r=+n[1],s=e.split("\n"),a=s.length.toString().length+2,i=s.map(((e,t)=>Nr((t+1).toString(),a)+e));let o=0;for(let h=0;h<i.length;h++)o=Math.max(i[h].length,o);const l=i.slice(0,r-1),u=i.slice(r-1,r),c=i.slice(r);console.log(l.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${Nr(u[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join("\n"))}function h_(e,t){if(i_(e,(()=>e.validateProgram(t))),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function d_(e,t,n,r,s,a,i){const o=e.getAttribLocation(t,n);return-1!==o&&(i_(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,r))),i_(e,(()=>e.vertexAttribPointer(o,s,e.FLOAT,!1,a,i))),i_(e,(()=>e.enableVertexAttribArray(o))),!0)}function p_(e,t,n,r){i_(e,(()=>function(e,t,n){b_(e,n),i_(e,(()=>e.activeTexture(e.TEXTURE0+n))),i_(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}(e,t,r))),i_(e,(()=>e.uniform1i(n,r)))}function f_(e,t,n){i_(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),i_(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function m_(e,t){i_(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),i_(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function g_(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}(e,t))}function y_(e,t,n){const r=i_(e,(()=>t()));if(null==r)throw new Error(n);return r}function b_(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){throw new Error(`textureUnit must be in ${`[gl.TEXTURE0, gl.TEXTURE${n}]`}.`)}}function v_(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2;return xr(e.slice(0,e.length-t))}function x_(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function w_(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[v_(e),...x_(e)]),t}function k_(e){return e%2===0}function S_(e,t){if(wr(e=e.slice(-2),t=t.slice(-2)))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e[e.length-1],r=t[t.length-1];if(n===r)return!0;if(k_(n)&&k_(r)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&k_(e[0])&&k_(t[0])}let N_,I_;function C_(e,t){return null!=e.getExtension(t)}function T_(e){try{if(null!=ZO(e))return!0}catch(E9){return console.log("Error when getting WebGL context: ",E9),!1}return!1}function A_(e){if(0===e)return!1;const t=ZO(e);if(1!==e){if(C_(t,"EXT_color_buffer_float"))return E_(t);const e="EXT_color_buffer_half_float";if(C_(t,e)){const n=t.getExtension(e);return function(e,t){const n=a_(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r);const s=1,a=1;e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,s,a,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const i=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,i),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);const o=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(i),o}(t,n)}return!1}if(!C_(t,"OES_texture_float"))return!1;if(!C_(t,"WEBGL_color_buffer_float"))return!1;return E_(t)}function E_(e){const t=a_(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),s}function $_(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&yr("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the WebGL backend.`))}))}const R_=Yr();function D_(){let e,t,n,r,s,a,i,o,l,u;return 2===Yr().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",r="in",s="texture",a="outputColor",i="out vec4 outputColor;",o=Yr().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",l="",u="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",r="varying",s="texture2D",a="gl_FragColor",i="",o="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",u="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:s,output:a,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:l,defineRound:u}}function O_(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const r=Pr(t);return r.map(((t,s)=>`${`int ${e[s]} = ${n} / ${t}`}; ${s===r.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * ${t}`:`index -= ${e[s]} * ${t}`};`)).join("")}function __(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const r=Pr(t);return r.map(((t,s)=>`${`int ${e[s]} = ${n} / outShapeStrides[${s}]`}; ${s===r.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * outShapeStrides[${s}]`:`index -= ${e[s]} * outShapeStrides[${s}]`};`)).join("")}function F_(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const r=e.map(((e,t)=>t)),s=function(e,t){const n=e.length,r=e.map((e=>`${t}[${e}]`)),s=new Array(n-1);s[n-2]=r[n-1];for(let a=n-3;a>=0;--a)s[a]=`(${s[a+1]} * ${r[a+1]})`;return s}(r,t);return s.map(((t,r)=>`${`int ${e[r]} = ${n} / ${s[r]}`}; ${r===s.length-1?`int ${e[r+1]} = ${n} - ${e[r]} * ${s[r]}`:`index -= ${e[r]} * ${s[r]}`};`)).join("")}function M_(e){const t=Pr(e).map((e=>e.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}R_.registerFlag("HAS_WEBGL",(()=>R_.getNumber("WEBGL_VERSION")>0)),R_.registerFlag("WEBGL_VERSION",(()=>T_(2)?2:T_(1)?1:0)),R_.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),R_.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===R_.get("WEBGL_VERSION"))),R_.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),R_.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),R_.registerFlag("WEBGL_PACK",(()=>R_.getBool("HAS_WEBGL"))),R_.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>R_.getBool("WEBGL_PACK"))),R_.registerFlag("WEBGL_PACK_CLIP",(()=>R_.getBool("WEBGL_PACK"))),R_.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>R_.getBool("WEBGL_PACK"))),R_.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>R_.getBool("WEBGL_PACK"))),R_.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>R_.getBool("WEBGL_PACK"))),R_.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>R_.getBool("WEBGL_PACK"))),R_.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>R_.getBool("WEBGL_PACK"))),R_.registerFlag("WEBGL_PACK_REDUCE",(()=>R_.getBool("WEBGL_PACK"))),R_.registerFlag("WEBGL_LAZILY_UNPACK",(()=>R_.getBool("WEBGL_PACK"))),R_.registerFlag("WEBGL_CONV_IM2COL",(()=>R_.getBool("WEBGL_PACK"))),R_.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",(()=>R_.getBool("WEBGL_PACK"))),R_.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>function(e){if(null==N_){const t=ZO(e);N_=t.getParameter(t.MAX_TEXTURE_SIZE)}return N_}(R_.getNumber("WEBGL_VERSION")))),R_.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>function(e){if(null==I_){const t=ZO(e);I_=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,I_)}(R_.getNumber("WEBGL_VERSION")))),R_.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const e=R_.getNumber("WEBGL_VERSION");return 0===e?0:function(e){if(0===e)return 0;let t;const n=ZO(e);return t=C_(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:C_(n,"EXT_disjoint_timer_query")?1:0,t}(e)})),R_.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>R_.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Al())),R_.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>function(e){if(0===e)return!1;const t=ZO(e);if(1===e){if(!C_(t,"OES_texture_float"))return!1}else if(!C_(t,"EXT_color_buffer_float"))return!1;return E_(t)}(R_.getNumber("WEBGL_VERSION")))),R_.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!R_.getBool("WEBGL_FORCE_F16_TEXTURES")&&R_.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),R_.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>A_(R_.getNumber("WEBGL_VERSION")))),R_.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>{return 2===(e=R_.getNumber("WEBGL_VERSION"))&&null!=ZO(e).fenceSync;var e})),R_.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>R_.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),R_.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if("number"!==typeof e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)})),R_.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>Al()?1:-1),(e=>{if("number"!==typeof e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)})),R_.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),R_.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),R_.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),R_.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128)),R_.registerFlag("WEBGL_EXP_CONV",(()=>!1)),R_.registerFlag("SOFTWARE_WEBGL_ENABLED",(()=>R_.getBool("IS_TEST"))),R_.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",(()=>1/0)),R_.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",(()=>!1)),R_.registerFlag("WEBGL2_ISNAN_CUSTOM",(()=>!1)),R_.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1));const L_="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:P_}=a;function z_(e,t,n){const r=[];if(e.forEach((e=>{const t=xr(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?r.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(r.push(`uniform sampler2D ${e.name};`),r.push(`uniform int offset${e.name};`)),n.enableShapeUniforms){const{uniformShape:t}=Q_(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:r.push(`uniform int ${e.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${e.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${e.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${e.name}Shape;`)}r.push(`uniform ivec2 ${e.name}TexShape;`)}})),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach((e=>{r.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:""};`)}));const s=r.join("\n"),a=e.map((e=>function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3?arguments[3]:void 0,s="";s+=n?V_(e,r):B_(e,r);const a=e.shapeInfo.logicalShape,i=t.logicalShape;a.length<=i.length&&(s+=n?function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,o=P_(e.shapeInfo.logicalShape,t.logicalShape),l=X_(i),u=i-a;let c;const h=["x","y","z","w","u","v"];c=0===a?"":i<2&&o.length>=1?"coords = 0;":o.map((e=>`coords.${h[e+u]} = 0;`)).join("\n");let d="";d=i<2&&a>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${h[t+u]}`)).join(", ");let p="return outputValue;";const f=1===xr(e.shapeInfo.logicalShape),m=xr(t.logicalShape),g=1===m;if(1!==a||f||g){if(f&&!g)p=1===i?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(o.length){const e=a-2,t=a-1;o.indexOf(e)>-1&&o.indexOf(t)>-1?p="return vec4(outputValue.x);":o.indexOf(e)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(t)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${s}() {\n      ${l} coords = getOutputCoords();\n      ${c}\n      vec4 outputValue = get${r}(${d});\n      ${p}\n    }\n  `}(e,t):function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=t.texShape,i=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===l&&null==e.shapeInfo.flatOffset&&wr(i,a))return`\n      float ${s}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const u=X_(l),c=P_(e.shapeInfo.logicalShape,t.logicalShape),h=l-o;let d;const p=["x","y","z","w","u","v"];d=0===o?"":l<2&&c.length>=1?"coords = 0;":c.map((e=>`coords.${p[e+h]} = 0;`)).join("\n");let f="";f=l<2&&o>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${p[t+h]}`)).join(", ");return`\n    float ${s}() {\n      ${u} coords = getOutputCoords();\n      ${d}\n      return get${r}(${f});\n    }\n  `}(e,t));return s}(e,t,n.packedInputs,n.enableShapeUniforms))).join("\n"),i=t.texShape,o=D_(),l=function(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(o);let u,c,h=function(e){const t=`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${W_}\n    ${U_}\n    ${j_}\n  `;return t}(o);t.isPacked?(u=function(e,t,n){switch(e.length){case 0:return H_();case 1:return function(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(1===r[0])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `;if(1===r[1])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `;if(n)return"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ";return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,t,n);case 2:return function(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(wr(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const s=Math.ceil(e[1]/2);if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ";return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[2]/2),a=s*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${a};\n      index -= b * ${a};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,t,n);default:return function(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[e.length-1]/2),a=s*Math.ceil(e[e.length-2]/2);let i=a,o="",l="b, r, c";for(let u=2;u<e.length-1;u++)i*=e[e.length-u-1],o=`\n      int b${u} = index / ${i};\n      index -= b${u} * ${i};\n    `+o,l=`b${u}, `+l;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${o}\n\n      int b = index / ${a};\n      index -= b * ${a};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec${e.length}(${l});\n    }\n  `}(e,t,n)}}(t.logicalShape,i,n.enableShapeUniforms),c=function(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(o)):(u=function(e,t,n){switch(e.length){case 0:return H_();case 1:return function(e,t,n){if(1===t[0])return n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `;if(1===t[1])return n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `;if(n)return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ";return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t,n);case 2:return function(e,t,n){if(wr(e,t))return n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `;if(1===e[1])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `;if(1===e[0])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `;if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ";return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n){return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${__(["r","c","d"],e)}\n    return ivec3(r, c, d);\n  }\n`}const r=O_(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(e,t,n);case 4:return function(e,t,n){if(n){return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${__(["r","c","d","d2"],e)}\n      return ivec4(r, c, d, d2);\n    }\n  `}const r=O_(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,t,n);case 5:return function(e,t){const n=O_(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,t);case 6:return function(e,t){const n=O_(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}(t.logicalShape,i,n.enableShapeUniforms),c=function(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(o)),n.packedInputs&&(h+=G_);return[h,l,c,s,u,a,n.userCode].join("\n")}function B_(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;const[s,a]=e.shapeInfo.texShape;if(1===s&&1===a)return`\n      float ${r}() {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const i=q_(n);if(t)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `;const[o,l]=e.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${o}, ${l}, ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 1:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${K_(e)}\n      }\n    `;const s=e.shapeInfo.texShape,a=s[0],i=s[1];if(1===i&&1===a)return`\n      float ${r}(int index) {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const o=q_(n);if(1===i)return t?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${a}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(1===a)return t?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(t)return`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `;return`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${a}, ${i}, index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape;if(null!=a&&wr(n,a)){if(t)return`\n      float ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `;const e=a[0];return`\n    float ${s}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${a[1]}.0, ${e}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `}const{newShape:i,keptDims:o}=Ar(n),l=i;if(l.length<n.length){const n=["row","col"];return`\n      ${B_(Y_(e,l),t)}\n      float ${s}(int row, int col) {\n        return ${s}(${Z_(n,o)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${s}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${K_(e)}\n      }\n    `;const u=a[0],c=a[1],h=q_(r);if(1===c)return t?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;if(1===u)return t?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `;if(t)return`\n      float ${s}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${h};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `;return`\n  float ${s}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${h};\n    vec2 uv = uvFromFlat(${u}, ${c}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=n[1]*n[2],i=n[2],{newShape:o,keptDims:l}=Ar(n),u=o;if(u.length<n.length){const n=["row","col","depth"];return`\n        ${B_(Y_(e,u),t)}\n        float ${s}(int row, int col, int depth) {\n          return ${s}(${Z_(n,l)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${a}, ${i}, 1)));\n        ${K_(e)}\n      }\n    `;const c=e.shapeInfo.texShape,h=c[0],d=c[1],p=e.shapeInfo.flatOffset;if(d===a&&null==p)return t?`\n      float ${s}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${s}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${i}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${d}.0, ${h}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(d===i&&null==p)return t?`\n      float ${s}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${h}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const f=q_(r);if(t)return`\n    float ${s}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${f};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `;return`\n      float ${s}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${a} + col * ${i} + depth + ${f};\n        vec2 uv = uvFromFlat(${h}, ${d}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(e,t);case 4:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=n[3],i=n[2]*a,o=n[1]*i,{newShape:l,keptDims:u}=Ar(n);if(l.length<n.length){const n=["row","col","depth","depth2"];return`\n      ${B_(Y_(e,l),t)}\n      float ${s}(int row, int col, int depth, int depth2) {\n        return ${s}(${Z_(n,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${o}, ${i}, ${a}, 1)));\n        ${K_(e)}\n      }\n    `;const c=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,d=h[0],p=h[1],f=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(p===o&&null==c)return t?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        ${f}\n        ${m}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${i}, ${a}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${d}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(p===a&&null==c)return t?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${n[1]*n[2]}, ${n[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${d}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const y=q_(r);if(t)return`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${f}\n      ${m}\n      ${g}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `;return`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} +\n          depth * ${a} + depth2;\n      vec2 uv = uvFromFlat(${d}, ${p}, index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `}(e,t);case 5:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[4],a=t[3]*s,i=t[2]*a,o=t[1]*i,{newShape:l,keptDims:u}=Ar(t);if(l.length<t.length){const t=["row","col","depth","depth2","depth3"];return`\n      ${B_(Y_(e,l))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${Z_(t,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${o}, ${i}, ${a}, ${s})) +\n          depth3;\n        ${K_(e)}\n      }\n    `;const c=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,d=h[0],p=h[1];if(p===o&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${i}, ${a}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(p===s&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const f=q_(n);return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} + depth * ${a} +\n          depth2 * ${s} + depth3 + ${f};\n      vec2 uv = uvFromFlat(${d}, ${p}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 6:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:s,keptDims:a}=Ar(t);if(s.length<t.length){const t=["row","col","depth","depth2","depth3","depth4"];return`\n      ${B_(Y_(e,s))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${Z_(t,a)});\n      }\n    `}const i=t[5],o=t[4]*i,l=t[3]*o,u=t[2]*l,c=t[1]*u;if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${u}, ${l}, ${o})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${i}, 1)));\n        ${K_(e)}\n      }\n    `;const h=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,p=d[0],f=d[1];if(f===c&&null==h)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${u}, ${l}, ${o}, ${i})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(f===i&&null==h)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const m=q_(n);return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${u} + depth * ${l} +\n          depth2 * ${o} + depth3 * ${i} + depth4 + ${m};\n      vec2 uv = uvFromFlat(${p}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function V_(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=D_();return`\n    vec4 ${n}() {\n      return ${r.texture2D}(${t}, halfCR);\n    }\n  `}(e);case 1:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape,a=D_();if(t)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${a.texture2D}(${n}, uv);\n    }\n  `;const i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${i[0]}, ${i[1]}, index);\n      return ${a.texture2D}(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,i=a[0],o=a[1],l=D_();if(null!=a&&wr(n,a))return t?`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `;if(t)return`\n    vec4 ${s}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `;const u=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=Math.ceil(n[1]/2);return`\n    vec4 ${s}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${c}, ${u[0]}, ${u[1]}, row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];if(1===n[0]){const r=[1,2],a=["b","row","col"];return`\n        ${V_(Y_(e,n.slice(1)),t)}\n        vec4 ${s}(int b, int row, int col) {\n          return ${s}(${Z_(a,r)});\n        }\n      `}const o=D_();if(t)return`\n    vec4 ${s}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `;const l=i[0],u=i[1],c=Math.ceil(n[2]/2),h=c*Math.ceil(n[1]/2);return`\n    vec4 ${s}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${u}, ${h}, ${c}, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `}(e,t);default:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=D_();if(t)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${n}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${n}, uv);\n    }\n  `;const a=e.shapeInfo.logicalShape,i=a.length,o=e.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=l[0],c=l[1],h=Math.ceil(a[i-1]/2);let d=h*Math.ceil(a[i-2]/2),p="int b, int row, int col",f=`b * ${d} + (row / 2) * ${h} + (col / 2)`;for(let m=2;m<i-1;m++)p=`int b${m}, `+p,d*=a[i-m-1],f=`b${m} * ${d} + `+f;return`\n    vec4 ${r}(${p}) {\n      int index = ${f};\n      int texR = index / ${c};\n      int texC = index - texR * ${c};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});\n      return ${s.texture2D}(${n}, uv);\n    }\n  `}(e,t)}}const W_="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",U_="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",j_="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",G_="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function H_(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function q_(e){return`offset${e}`}function K_(e){const t=e.name,n=xr(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function X_(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function Q_(e,t,n){const{newShape:r,keptDims:s}=Ar(t),a=t.length,i=e&&3===a&&1===t[0],o=i?t.slice(1):r,l=!e&&a>1&&!wr(t,n)&&r.length<a||i;return{useSqueezeShape:l,uniformShape:l?o:t,keptDims:s}}function Y_(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function Z_(e,t){return t.map((t=>e[t])).join(", ")}function J_(e,t,n,r){const s=n.map(((e,n)=>{const r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(r.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:r}})),a=s.map((e=>e.shapeInfo)),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},o=z_(s,i,t),l=function(e,t){const n=y_(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(i_(e,(()=>e.shaderSource(n,t))),i_(e,(()=>e.compileShader(n))),Yr().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw c_(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(e.gl,o),u=e.createProgram(l);return Yr().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:a,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(u),Object.assign({program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:a,outShapeInfo:i},eF(e,t,u)))}function eF(e,t,n){const r=[],s=[];let a,i,o,l=null,u=null;u=e.getUniformLocation(n,"NAN",!1),1===Yr().getNumber("WEBGL_VERSION")&&(l=e.getUniformLocation(n,"INFINITY",!1));const c=!1;for(const h of t.variableNames){const s={name:h,uniform:e.getUniformLocation(n,h,c),offset:e.getUniformLocation(n,`offset${h}`,c)};t.enableShapeUniforms&&(s.shape=e.getUniformLocation(n,`${h}Shape`,c),s.texShape=e.getUniformLocation(n,`${h}TexShape`,c)),r.push(s)}if(t.enableShapeUniforms&&(a=e.getUniformLocation(n,"outShape",c),o=e.getUniformLocation(n,"outShapeStrides",c),i=e.getUniformLocation(n,"outTexShape",c)),t.customUniforms)for(const h of t.customUniforms)s.push(e.getUniformLocation(n,h.name,c));return{variablesLocations:r,customUniformLocations:s,infLoc:l,nanLoc:u,outShapeLocation:a,outShapeStridesLocation:o,outTexShapeLocation:i}}function tF(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach(((e,n)=>{const r=e.logicalShape,s=t[n],a=s.shape;if(!wr(r,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${a} must match`);if(e.isUniform&&s.isUniform)return;const i=e.texShape,o=s.isUniform?null:s.texData.texShape;if(!wr(i,o))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${o} must match`)}))}function nF(e){return Yr().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}class rF{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=JO.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=D_();this.outputShape=e,this.enableShapeUniforms=nF(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?__(["r","c","d"],e):O_(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${t.output} = result;\n      }\n    `}}class sF{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=JO.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=D_();this.outputShape=e,this.enableShapeUniforms=nF(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?__(["r","c","d"],e):O_(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${t.output} = result;\n      }\n    `}}class aF{constructor(e){this.variableNames=["A"],this.outTexUsage=e_.DOWNLOAD;const t=D_();this.outputShape=e,this.userCode=`\n      ${L_}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}}class iF{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=e_.DOWNLOAD;const t=D_();this.outputShape=e,this.userCode=`\n      ${L_}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}}const oF={R:0,G:1,B:2,A:3};class lF{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"RGBA";this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=D_();this.outputShape=e,this.enableShapeUniforms=nF(this.outputShape.length);let s="result";t&&(s="floor(result * 255. + 0.5)");let a="";for(let i=0;i<n.length;i++){const e=n[i];a+=`\n          if(offset == ${i}) {\n            result = values[${oF[e]}];\n          }`}this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":M_(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${n.length});\n\n        flatIndex = idiv(flatIndex, ${n.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${r.texture2D}(A, uv);\n          ${a}\n        }\n        ${r.output} = vec4(${s}, 0., 0., 0.);\n      }\n    `}}class uF{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=D_();this.outputShape=e,this.enableShapeUniforms=nF(this.outputShape.length);let r="",s="result";t&&(s="floor(result * 255. + 0.5)");for(let a=0;a<=1;a++)for(let t=0;t<=1;t++){const s=2*a+t;r+=`\n          localCoords = coords;\n          if(localCoords[2] + ${t} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {\n          localCoords[2] += ${t};\n          if (localCoords[1] + ${a} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {\n            localCoords[1] += ${a};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${n.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${s}] = values[0];\n            } else if (offset == 1) {\n              result[${s}] = values[1];\n            } else if (offset == 2) {\n              result[${s}] = values[2];\n            } else {\n              result[${s}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":M_(e)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${r}\n\n          ${n.output} = ${s};\n        }\n    `}}function cF(e){const t=D_();return function(e,t){const n=y_(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(i_(e,(()=>e.shaderSource(n,t))),i_(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(e,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}function hF(e){return function(e,t){const n=y_(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return i_(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),i_(e,(()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function dF(e){return function(e,t){const n=y_(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return i_(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n))),i_(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Uint16Array([0,1,2,2,1,3]))}function pF(e,t,n,r,s,a){!function(e,t){const n=Yr().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0)throw new Error(`Requested texture size [${e}x${t}] is invalid.`);if(e>n||t>n)throw new Error(`Requested texture size [${e}x${t}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`)}(t,n);const i=function(e){return y_(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}(e),o=e.TEXTURE_2D;return i_(e,(()=>e.bindTexture(o,i))),i_(e,(()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),i_(e,(()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),i_(e,(()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST))),i_(e,(()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST))),1===Yr().getNumber("WEBGL_VERSION")?i_(e,(()=>e.texImage2D(o,0,r,t,n,0,s,a,null))):i_(e,(()=>e.texStorage2D(o,1,r,t,n))),i_(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),{texture:i,texShape:[n,t]}}function fF(e){return e.internalFormatFloat}function mF(e){return e.internalFormatHalfFloat}function gF(e){return e.downloadTextureFormat}function yF(e){return e.internalFormatPackedFloat}function bF(e){return e.internalFormatPackedHalfFloat}function vF(e,t,n,r,s,a,i,o){const l=e,u=new Float32Array(function(e,t){const[n,r]=s_(e,t);return n*r*4}(a,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}class xF{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=Yr().getNumber("WEBGL_VERSION");if(null!=e?(this.gl=e,function(e,t){QO[e]=t}(t,e)):this.gl=ZO(t),e=this.gl,2===Yr().getNumber("WEBGL_VERSION")){const t=e;this.createVertexArray=()=>i_(t,(()=>t.createVertexArray())),this.bindVertexArray=e=>i_(t,(()=>t.bindVertexArray(e))),this.deleteVertexArray=e=>i_(t,(()=>t.deleteVertexArray(e))),this.getVertexArray=()=>i_(t,(()=>t.getParameter(t.VERTEX_ARRAY_BINDING)))}else if(null!=e){const t=e.getExtension("OES_vertex_array_object");if(null==t)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>i_(e,(()=>t.createVertexArrayOES())),this.bindVertexArray=n=>i_(e,(()=>t.bindVertexArrayOES(n))),this.deleteVertexArray=n=>i_(e,(()=>t.deleteVertexArrayOES(n))),this.getVertexArray=()=>i_(e,(()=>e.getParameter(t.VERTEX_ARRAY_BINDING_OES)))}let n="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===Yr().getNumber("WEBGL_VERSION")){const e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=l_(this.gl,e),C_(this.gl,t))this.textureHalfFloatExtension=l_(this.gl,t);else if(Yr().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),C_(this.gl,r))this.colorBufferHalfFloatExtension=l_(this.gl,r);else if(Yr().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",C_(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!C_(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=hF(this.gl),this.indexBuffer=dF(this.gl),this.framebuffer=function(e){return y_(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=a_(this.gl,this.textureHalfFloatExtension)}get debug(){return Yr().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;i_(e,(()=>e.finish())),i_(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),i_(e,(()=>e.deleteFramebuffer(this.framebuffer))),i_(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),i_(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),i_(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,a]=n_(t,n);return pF(e,s,a,fF(r),r.textureFormatFloat,e.FLOAT)}(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,a]=n_(t,n);return pF(e,s,a,mF(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,a]=n_(t,n);return pF(e,s,a,gF(r),e.RGBA,e.UNSIGNED_BYTE)}(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),function(e,t,n){i_(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),n.data instanceof Uint8Array?2===Yr().getNumber("WEBGL_VERSION")?i_(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data))):i_(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data))):2===Yr().getNumber("WEBGL_VERSION")?i_(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n))):i_(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n))),i_(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),function(e,t,n,r,s,a){let i,o,l;i_(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),s instanceof Uint8Array?(i=new Uint8Array(n*r*4),o=e.UNSIGNED_BYTE,l=e.RGBA):(i=new Float32Array(n*r*4),o=e.FLOAT,l=a.internalFormatPackedFloat),i.set(s),2===Yr().getNumber("WEBGL_VERSION")?i_(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,o,i))):i_(e,(()=>e.texImage2D(e.TEXTURE_2D,0,l,n,r,0,e.RGBA,o,i))),i_(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,a]=s_(t,n);return pF(e,s,a,bF(r),e.RGBA,r.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,a]=s_(t,n);return pF(e,s,a,yF(r),e.RGBA,e.FLOAT)}(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(m_(this.gl,this.framebuffer),this.outputTexture=null),i_(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n,r){const[s,a]=n_(t,n),i=new Uint8Array(t*n*4);return i_(e,(()=>e.readPixels(0,0,s,a,r.downloadTextureFormat,e.UNSIGNED_BYTE,i))),new Float32Array(i.buffer)}(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,r,s,a){return vF(this.gl,e,0,0,0,s,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return function(e,t,n){const r=e,s=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const r=function(e,t,n){const r=e.createBuffer();i_(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,r)));const s=16*t*n;return i_(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,s,e.STREAM_READ))),i_(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),i_(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),r}(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(Yr().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,s=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=r.clientWaitSync(s,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},t=s}else Yr().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,Yr().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n){const r=new Float32Array(t*n*4);return i_(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r))),r}(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();const t=this.gl;null==this.vertexShader&&(this.vertexShader=cF(t));const n=function(e){return y_(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}(t);i_(t,(()=>t.attachShader(n,this.vertexShader))),i_(t,(()=>t.attachShader(n,e))),function(e,t){if(i_(e,(()=>e.linkProgram(t))),!Yr().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(t,n);const r=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&h_(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;i_(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer))),function(e,t,n){i_(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),d_(e,t,"clipSpacePos",n,3,20,0)&&d_(e,t,"uv",n,2,20,12)}(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&(i_(this.gl,(()=>this.gl.deleteProgram(e))),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&h_(this.gl,this.program),i_(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];return this.throwIfDisposed(),n?function(e,t,n){return y_(e,(()=>e.getUniformLocation(t,n)),'uniform "'+n+'" not present in program.')}(this.gl,e,t):function(e,t,n){return e.getUniformLocation(t,n)}(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),i_(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),p_(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[r,s]=s_(t,n);this.setOutputMatrixTextureDriver(e,r,s)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&h_(this.gl,this.program),g_(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}i_(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),i_(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=l_(this.gl,2===Yr().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===Yr().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===Yr().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await Ir((()=>this.disposed||this.isQueryAvailable(e,Yr().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,Yr().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){const e=function(e){let t=0;for(;t<e.length;++t){if(!e[t]())break}return t-1}(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in Yr().platform&&(n=Yr().platform.setTimeoutCustom.bind(Yr().platform)),Ir((()=>(this.pollItems(),0===this.itemsToPoll.length)),(()=>0),null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),f_(this.gl,e,this.framebuffer),this.debug&&g_(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(f_(this.gl,this.outputTexture,this.framebuffer),this.debug&&g_(this.gl)):m_(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const r=this.gl;f_(r,e,this.framebuffer),this.debug&&g_(r),this.outputTexture=e,i_(r,(()=>r.viewport(0,0,t,n))),i_(r,(()=>r.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),i_(this.gl,(()=>this.gl.scissor(e,t,n,r)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{mx:wF,XI:kF,Nk:SF,f6:NF,ct:IF,YG:CF,hH:TF,z3:AF,sG:EF,uM:$F,vS:RF,qB:DF,GG:OF,rq:_F,lg:FF,WR:MF,cu:LF,GE:PF,px:zF,jC:BF,He:VF,hE:WF,BF:UF,Dk:jF,cl:GF,_B:HF,ub:qF,_f:KF,Ku:XF,qy:QF,Zy:YF,bu:ZF,zv:JF,dH:eM,HS:tM,yH:nM,l3:rM,z9:sM,x6:aM,_m:iM,eW:oM,GK:lM,SP:uM,yr:cM,dl:hM,Dw:dM,xT:pM,_X:fM,wz:mM}=C;function gM(e,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>`${e}.${t}`))}function yM(e,t){return 1===t?[e]:gM(e,t)}class bM{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=nF(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=yM("rc",this.rank),t=X_(this.rank),n=this.getOutOfBoundsCondition(e),r=this.getSetup(e),s=this.getOutput(e);this.userCode=`\n        void main() {\n          ${t} rc = getOutputCoords();\n\n          if(${n}) {\n            setOutput(vec4(0));\n          } else {\n            ${r}\n\n            setOutput(vec4(${s}));\n          }\n        }\n      `}}getSourceCoordsArr(e){const t=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let s=`${0===n?"r":"rp1"}, ${0===r?"c":"cp1"}`;for(let t=2;t<this.rank;t++)s=`${e[e.length-1-t]},`+s;t.push(s)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";const t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`\n      int r = ${t[0]};\n      int c = ${t[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${n};\n      bool rEdge = rp1 >= ${r};\n    `}getOutput(e){const t=this.getSourceCoordsArr(e);if(1===this.rank){return`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`}return`getA(${t[0]}),\n            cEdge ? 0. : getA(${t[1]}),\n            rEdge ? 0. : getA(${t[2]}),\n            rEdge || cEdge ? 0. : getA(${t[3]})`}}class vM{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=nF(this.outputShape.length);let n="";for(let a=0;a<4;a++){let e="thisRC = rc;";a%2===1&&(e+="thisRC.z += 1;"),a>1&&(e+="thisRC.y += 1;"),n+=`\n        ${e}\n        ${a>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${a}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${a>0?"}":""}\n      `}var r,s;this.userCode=`\n      ${r=t,s=this.enableShapeUniforms,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${s?F_(["r","c","d"],"inputShape"):O_(["r","c","d"],r)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":M_(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}class xM{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){const r=kM(t,n),s=SM(e,r,n);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);const a=wM(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();const e=this.freeTextures[s].pop();return this.usedTextures[s].push(e),e}let i;return r===t_.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===t_.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===t_.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===t_.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===t_.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[s].push(i),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),i}releaseTexture(e,t,n,r){if(null==this.freeTextures)return;const s=kM(n,r),a=SM(t,s,r);a in this.freeTextures||(this.freeTextures[a]=[]);const i=wM(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,r),o=Yr().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==o&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[a].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;const l=this.usedTextures[a],u=l&&l.indexOf(e);if(null==u||u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[u]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));for(const e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function wM(e,t,n,r,s){const a=function(e,t){switch(e){case t_.PACKED_2X2_FLOAT32:return yF(t);case t_.PACKED_2X2_FLOAT16:return bF(t);case t_.UNPACKED_FLOAT32:return fF(t);case t_.UNPACKED_FLOAT16:return mF(t);case t_.PACKED_4X1_UNSIGNED_BYTE:return gF(t);default:throw new Error(`Unknown physical texture type ${e}`)}}(t,r);let i;if(s){const[t,n]=s_(e[0],e[1]);i=t*n}else{const[t,n]=n_(e[0],e[1]);i=t*n}const o=function(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}(n,a);return i*o}function kM(e,t){if(e===e_.UPLOAD)return t_.PACKED_2X2_FLOAT32;if(e===e_.RENDER||null==e)return function(e){return Yr().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?t_.PACKED_2X2_FLOAT32:t_.UNPACKED_FLOAT32:e?t_.PACKED_2X2_FLOAT16:t_.UNPACKED_FLOAT16}(t);if(e===e_.DOWNLOAD||e===e_.PIXELS)return t_.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function SM(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}class NM{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=nF(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const IM="if (isnan(x)) return x;",CM="return abs(x);";const TM=IM+"\n  return (x < 0.0) ? 0.0 : x;\n",AM=IM+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",EM="return x;";class $M{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=nF(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class RM{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=nF(this.outputShape.length);const t=e.length,n=yM("rc",t),r=X_(t),s=function(e,t){if(1===e)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}(t,n),a=n.slice(-2),i=t<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${s});\n\n        setOutput(getChannel(packedInput, ${i}));\n      }\n    `}}const DM=fm,OM={};const _M=Yr().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class FM extends hr{nextDataId(){return FM.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Yr().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof xF)t=e;else{const n=ZO(Yr().getNumber("WEBGL_VERSION"),e);t=new xF(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const e=ZO(Yr().getNumber("WEBGL_VERSION"));t=new xF(e),this.binaryCache=((n=Yr().getNumber("WEBGL_VERSION"))in OM||(OM[n]={}),OM[n]),this.gpgpuCreatedLocally=!0}var n;this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new xM(this.gpgpu),this.numMBBeforeWarning=null==Yr().global.screen?1024:Yr().global.screen.height*Yr().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new cr(this,Ul())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,r,s,a){const i=this.makeTensorInfo(t,n),o=this.texData.get(i.dataId);o.isPacked=!1,o.texture={texture:e,texShape:[r,s]},o.texShape=[r,s];const l=w_(t),u=new lF(l,!1,a),c=this.runWebGLProgram(u,[i],n,[[r,s]]);return c.shape=t,o.texture=null,this.disposeIntermediateTensorInfo(i),c.dataId}write(e,t,n){if((Yr().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Yr().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:e_.UPLOAD,refCount:1}),r}refCount(e){if(this.texData.has(e)){return this.texData.get(e).refCount}return 0}incRef(e){this.texData.get(e).refCount++}decRef(e){if(this.texData.has(e)){this.texData.get(e).refCount--}}move(e,t,n,r,s){if(Yr().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:r,values:t,usage:e_.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:r,complexTensorInfos:s,slice:a,shape:i,isPacked:o}=t;if(null!=a){let t;t=o?new $M(i,EM):new NM(i,EM);const n=this.runWebGLProgram(t,[{dataId:e,shape:i,dtype:r}],r),s=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),s}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===r)return n;const l=null!=this.activeTimers;let u,c;if(l&&(u=Vo()),"complex64"===r){c=py(this.readSync(s.real.dataId),this.readSync(s.imag.dataId))}else c=this.getValuesFromTexture(e);return l&&(this.downloadWaitMs+=Vo()-u),this.convertAndCacheOnCPU(e,c)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}const t=this.texData.get(e),{values:n,shape:r,slice:s,dtype:a,complexTensorInfos:i,isPacked:o}=t;if(null!=s){let t;t=o?new $M(r,EM):new NM(r,EM);const n=this.runWebGLProgram(t,[{dataId:e,shape:r,dtype:a}],a),s=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),s}if(null!=n)return this.convertAndCacheOnCPU(e);if(Yr().getBool("DEBUG")&&!Yr().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===Yr().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l,u,c=null;if("complex64"!==a&&Yr().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(e);const t=this.texData.get(l.dataId);c=this.gpgpu.createBufferFromTexture(t.texture.texture,...r_(r))}if(this.pendingRead.set(e,[]),"complex64"!==a&&await this.gpgpu.createAndWaitForFence(),"complex64"===a){const e=await Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]);u=py(e[0],e[1])}else if(null==c)u=this.getValuesFromTexture(e);else{const e=xr(r);u=this.gpgpu.downloadFloat32MatrixFromBuffer(c,e)}if(null!=l&&this.disposeIntermediateTensorInfo(l),null!=c){const e=this.gpgpu.gl;i_(e,(()=>e.deleteBuffer(c)))}const h=this.convertAndCacheOnCPU(e,u),d=this.pendingRead.get(e);return this.pendingRead.delete(e),d.forEach((e=>e(h))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Ul().removeDataId(e,this),this.pendingDeletes--),h}readToGPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=this.texData.get(e),{values:r,shape:s,slice:a,dtype:i,isPacked:o,texture:l}=n;if("complex64"===i)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=a){let n;n=o?new $M(s,EM):new NM(s,EM);const r=this.runWebGLProgram(n,[{dataId:e,shape:s,dtype:i}],i),a=this.readToGPU(r,t);return this.disposeIntermediateTensorInfo(r),a}if(null==l)throw null!=r?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const u=this.decode(e,t.customTexShape),c=Ul().makeTensorFromTensorInfo(u),h=this.texData.get(u.dataId);return Object.assign({tensorRef:c},h.texture)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>Uo(e)));return Zu(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return Zu(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!o_(n)){if(Yr().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:r}=this.texData.get(e),s=xr(t);if(Yr().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),r=this.texData.get(n.dataId),a=this.gpgpu.downloadMatrixFromPackedTexture(r.texture.texture,...r_(t)).subarray(0,s);return this.disposeIntermediateTensorInfo(n),a}const a=Yr().getBool("WEBGL_PACK")&&!0===r,i=a?w_(t):t,o=a?new iF(i):new aF(i),l=this.runWebGLProgram(o,[{shape:i,dtype:n,dataId:e}],"float32"),u=this.texData.get(l.dataId),c=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(l),c}timerAvailable(){return Yr().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,n=[];let r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();const s=Go(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),a=Go(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,r&&(this.programTimersStack=null);const i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(Yr().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(s);i.kernelMs=function(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}(e),i.getExtraProfileInfo=()=>e.map(((e,t)=>({name:a[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Yr().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Vo(),endMs:null}}endTimer(e){return Yr().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Vo(),e)}async getQueryTime(e){if(Yr().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:r,usage:s,isPacked:a,slice:i}=this.texData.get(e),o=i&&i.origDataId||e,l=this.dataRefCount.get(o);l>1?this.dataRefCount.set(o,l-1):(this.dataRefCount.delete(o),null!=t&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,s,a)));const u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:_M;return Yr().getBool("WEBGL_CPU_FORWARD")&&e.every((e=>null==this.texData.get(e.dataId).texture&&xr(e.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){fo("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return DM(e.shape,t)}packedUnaryOp(e,t,n){const r=new $M(e.shape,t),s=this.compileAndRun(r,[e],n);return Ul().makeTensorFromTensorInfo(s)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=eM(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(Yr().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,CM,e.dtype);const t=new NM(e.shape,CM),n=this.compileAndRun(t,[e]);return Ul().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&Or(n[0])){const s=n.map((e=>Wo(e)));r=this.write(s,e,t)}else r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){return Ul().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){const t=new RM(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new bM(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[v_(e.shape),...x_(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},s=[v_(t),...x_(t)],a=new vM(s,n),i=[n],o=this.runWebGLProgram(a,[r],e.dtype,i,!0);return{dataId:o.dataId,shape:t,dtype:o.dtype}}decode(e,t){const n=this.texData.get(e),{isPacked:r,shape:s,dtype:a}=n;if(null!=t){yr(xr(s)<=t[0]*t[1]*4,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))}const i=w_(s);let o;o=r?new sF(i):new rF(i);const l=[null!=t?t:r_(i)];return{dtype:a,shape:s,dataId:this.runWebGLProgram(o,[{shape:i,dtype:a,dataId:e}],a,l,!0,t).dataId}}runWebGLProgram(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]&&arguments[4],a=arguments.length>5?arguments[5]:void 0;const i=this.makeTensorInfo(e.outputShape,n),o=this.texData.get(i.dataId);if(e.packedOutput&&(o.isPacked=!0),e.outPackingScheme===JO.DENSE){const t=null!=a?a:r_(e.outputShape);o.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(o.usage=e.outTexUsage),0===xr(i.shape))return o.values=Er(i.dtype,0),i;const l=[],u=t.map((t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&xr(t.shape)<=Yr().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!==!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),l.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!S_(n.shape,t.shape)){const e=t,r=t.shape;t.shape=n.shape,t=this.packedReshape(t,r),l.push(t),n=this.texData.get(t.dataId),e.shape=r}return{shape:t.shape,texData:n,isUniform:!1}}));this.uploadToGPU(i.dataId);const c={shape:i.shape,texData:o,isUniform:!1},h=function(e,t,n){let r="";t.concat(n).forEach((t=>{const s=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){const a=t.texData.texShape,{useSqueezeShape:i,uniformShape:o,keptDims:l}=Q_(e.packedInputs,t.shape,a);let u="",c="",h="";if(1===o.length&&e.packedInputs){const e=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];u=`${e[0]>1}_${e[1]>1}`}else if(2!==o.length||e.packedInputs){if(o.length>2&&!e.packedInputs){const e=Pr(o);h=`${e[0]===a[1]}_${e[e.length-1]===a[1]}`}}else c=`${o[0]>1}_${o[1]>1}`;const d=t.shape.length,p=2===o.length&&wr(t.shape,a),f=1===xr(t.shape),m=Nc(t.shape,n.shape),g=!e.packedInputs&&d===n.shape.length&&wr(a,n.texData.texShape),y=e.packedInputs||o.length>2?"":`${a[0]>1}_${a[1]>1}`;r+=`${d}_${g}_${i?l:""}_${o.length}_${f}_${m}_${p}_${u}_${c}_${h}_${y}_${s}`}else{const e=t.isUniform?"uniform":t.texData.texShape;r+=`${t.shape}_${e}_${s}`}}));const s=e.userCode;let a=e.constructor.name;return a+="_"+r+"_"+s+`${Yr().getNumber("WEBGL_VERSION")}`,a}(e,u,c),d=this.getAndSaveBinary(h,(()=>J_(this.gpgpu,e,u,c))),p=null!=this.activeTimers;let f;p&&(f=this.startTimer()),Yr().get("ENGINE_COMPILE_ONLY")||function(e,t,n,r,s){t.program.enableShapeUniforms||(tF(t.inShapeInfos,n),tF([t.outShapeInfo],[r]));const a=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(a.texture,i[0],i[1]):e.setOutputMatrixTexture(a.texture,i[0],i[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),1===Yr().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN);for(let l=0;l<n.length;++l){const r=n[l],{uniform:s,offset:a,shape:i,texShape:o}=t.variablesLocations[l];if(i){const{uniformShape:n}=Q_(t.program.packedInputs,r.shape,r.texData.texShape);switch(n.length){case 1:e.gl.uniform1iv(i,new Int32Array(n));break;case 2:e.gl.uniform2iv(i,new Int32Array(n));break;case 3:e.gl.uniform3iv(i,new Int32Array(n));break;case 4:e.gl.uniform4iv(i,new Int32Array(n))}}if(o&&e.gl.uniform2i(o,r.texData.texShape[0],r.texData.texShape[1]),null!=s)if(r.isUniform)if(xr(r.shape)<2)e.gl.uniform1f(s,r.uniformValues[0]);else{let t=r.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(s,t)}else null!=r.texData.slice&&null!=a&&e.gl.uniform1i(a,r.texData.slice.flatOffset),e.setInputMatrixTexture(r.texData.texture.texture,s,l)}const o=t.outShapeLocation;if(o)switch(r.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(r.shape))}if(t.outShapeStridesLocation){const n=Pr(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n))}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&s)for(let l=0;l<t.program.customUniforms.length;++l){const n=t.program.customUniforms[l],r=t.customUniformLocations[l],a=s[l];if("float"===n.type)e.gl.uniform1fv(r,a);else if("vec2"===n.type)e.gl.uniform2fv(r,a);else if("vec3"===n.type)e.gl.uniform3fv(r,a);else if("vec4"===n.type)e.gl.uniform4fv(r,a);else if("int"===n.type)e.gl.uniform1iv(r,a);else if("ivec2"===n.type)e.gl.uniform2iv(r,a);else if("ivec3"===n.type)e.gl.uniform3iv(r,a);else{if("ivec4"!==n.type)throw Error(`uniform type ${n.type} is not supported yet.`);e.gl.uniform4iv(r,a)}}e.executeProgram()}(this.gpgpu,d,u,c,r),l.forEach((e=>this.disposeIntermediateTensorInfo(e))),p&&(f=this.endTimer(f),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(f)}));const m=Yr().getNumber("WEBGL_FLUSH_THRESHOLD");if(m>0){const e=Vo();e-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!Yr().getBool("WEBGL_LAZILY_UNPACK")&&o.isPacked&&!1===s){const e=this.unpackTensor(i);return this.disposeIntermediateTensorInfo(i),e}return i}compileAndRun(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];n=n||t[0].dtype;return this.runWebGLProgram(e,t,n,r,s)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){if(!this.disposed){if(!Yr().getBool("IS_TEST")){Object.keys(this.binaryCache).forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}))}this.textureManager.dispose(),null!=this.canvas&&"undefined"!==typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=Gl((()=>{if(!Yr().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=Yr().getBool("DEBUG");Yr().set("DEBUG",!1);const t=this.abs(cc(1e-8)).dataSync()[0];if(Yr().set("DEBUG",e),t>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:r,values:s,texture:a,usage:i,isPacked:o}=t;if(null!=a)return;const l=null!=this.activeTimers;let u;l&&(u=Vo());let c=t.texShape;if(null==c&&(c=function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=Yr().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=Yr().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");if(r===1/0&&Yr().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),t&&(n*=2,r*=2,e=e.map(((t,n)=>n>=e.length-2?mr(e[n]):e[n])),1===e.length&&(e=[2,e[0]])),2!==e.length){const t=Ar(e);e=t.newShape}let s=xr(e),a=null;e.length<=1&&s<=n?a=[1,s]:2===e.length&&e[0]<=n&&e[1]<=n?a=e:3===e.length&&e[0]*e[1]<=n&&e[2]<=n?a=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=n&&e[1]*e[2]<=n?a=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n?a=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(a=[e[0],e[1]*e[2]*e[3]]);const i=null!=a&&Math.max(...a)>r&&Math.min(...a)<=(t?2:1)&&Math.min(...a)>0;if(null==a||i)if(t){const t=v_(e);let n=2,r=2;e.length&&([n,r]=x_(e)),s=t*(n/2)*(r/2),a=Sr(s).map((e=>2*e))}else a=Sr(s);return a}(n,o),t.texShape=c),null!=s){const e=w_(n);let a,i=c[1],h=c[0];const d=s instanceof Uint8Array||s instanceof Uint8ClampedArray;!o&&d||([i,h]=s_(c[0],c[1])),a=o?new uF(e,d):new lF(e,d);const p=d?[h,i]:c,f=this.makeTensorInfo(p,r),m=this.texData.get(f.dataId);m.usage=d?e_.PIXELS:e_.UPLOAD,m.texShape=p,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),i,h,s);const g=[[h,i]],y=!0,b=this.runWebGLProgram(a,[f],r,g,y),v=this.texData.get(b.dataId);t.texShape=v.texShape,t.isPacked=v.isPacked,t.usage=v.usage,Yr().get("ENGINE_COMPILE_ONLY")?this.disposeData(b.dataId):(t.texture=v.texture,t.values=null,this.texData.delete(b.dataId)),this.disposeIntermediateTensorInfo(f),l&&(this.uploadWaitMs+=Vo()-u)}else{const e=this.acquireTexture(c,i,r,o);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:r}=n;return null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error(`Unknown dtype ${t}`)}(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*Dr(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(const[,t]of Object.entries(this.binaryCache)){const n=new Promise((e=>{try{this.checkCompletion_(t),e(!0)}catch(n){throw n}}));e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await Wg(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw c_(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.");throw new Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:n,infLoc:r,nanLoc:s,outShapeLocation:a,outShapeStridesLocation:i,outTexShapeLocation:o}=eF(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=n,e.infLoc=r,e.nanLoc=s,e.outShapeLocation=a,e.outShapeStridesLocation=i,e.outTexShapeLocation=o}}createTensorFromGPUData(e,t,n){e.channels=e.channels||"RGBA";const{texture:r,height:s,width:a,channels:i}=e,o=Ul().backend;if(!o.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const l=o.writeTexture(r,t,n,s,a,i);return Ul().makeTensorFromDataId(l,t,n,o)}}FM.nextDataId=0;El()&&Kl("webgl",(()=>new FM),2);const MM="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class LM{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=Cc(t,n),this.enableShapeUniforms=nF(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}const PM="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class zM{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Cc(t,n);const s=this.outputShape.length;this.enableShapeUniforms=nF(s);let a="";if(r)if(0===s||1===xr(this.outputShape))a="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else{if(a=`\n          ${X_(s)} coords = getOutputCoords();\n        `,1===s)this.enableShapeUniforms?a+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":a+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const e=yM("coords",s);this.enableShapeUniforms?a+=`\n            bool nextRowOutOfBounds =\n              (${e[s-2]} + 1) >= outShape[${s} - 2];\n            bool nextColOutOfBounds =\n              (${e[s-1]} + 1) >= outShape[${s} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:a+=`\n            bool nextRowOutOfBounds =\n              (${e[s-2]} + 1) >= ${this.outputShape[s-2]};\n            bool nextColOutOfBounds =\n              (${e[s-1]} + 1) >= ${this.outputShape[s-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${a}\n\n        setOutput(result);\n      }\n    `}}function BM(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const VM={kernelName:ya,backendName:"webgl",kernelFunc:BM};function WM(e){const{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.makeTensorInfo(r.shape,"complex64"),i=n.texData.get(a.dataId),o=BM({inputs:{x:r},backend:n}),l=BM({inputs:{x:s},backend:n});return i.complexTensorInfos={real:o,imag:l},a}const UM={kernelName:As,backendName:"webgl",kernelFunc:WM},jM="return (a < 0.) ? b * a : a;",GM="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const HM={kernelName:Sa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:a}=r,i=n.makeTensorInfo([],"float32",zo(a,"float32")),o=Yr().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new zM(GM,s.shape,i.shape):new LM(jM,s.shape,i.shape),l=n.runWebGLProgram(o,[s,i],"float32");return n.disposeIntermediateTensorInfo(i),l}},qM="return (a < 0.) ? b * a : a;",KM="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const XM={kernelName:si,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r,alpha:s}=t,a=Yr().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new zM(KM,r.shape,s.shape):new LM(qM,r.shape,s.shape);return n.runWebGLProgram(a,[r,s],"float32")}},QM="if (isnan(x)) return x;";function YM(e){let{opSnippet:t,packedOpSnippet:n,cpuKernelImpl:r,dtype:s}=e;return e=>{let{inputs:a,backend:i}=e;const{x:o}=a,l=i,u=s||o.dtype;if(l.shouldExecuteOnCPU([o])&&null!=r){const e=l.texData.get(o.dataId),t=r(e.values,u);return l.makeTensorInfo(o.shape,u,t)}let c;return c=Yr().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=n?new $M(o.shape,n):new NM(o.shape,t),l.runWebGLProgram(c,[o],u)}}function ZM(e){let{opSnippet:t,packedOpSnippet:n,checkOutOfBounds:r=!1,supportsComplex:s=!1,cpuKernelImpl:a,dtype:i}=e;return e=>{let{inputs:o,backend:l}=e;const{a:u,b:c}=o,h=l;if(s&&"complex64"===u.dtype){const e=h.texData.get(u.dataId),n=h.texData.get(c.dataId),[r,s]=[[e.complexTensorInfos.real,n.complexTensorInfos.real],[e.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((e=>{const[n,r]=e,s={dataId:n.dataId,dtype:n.dtype,shape:u.shape},a={dataId:r.dataId,dtype:r.dtype,shape:c.shape},i=new LM(t,u.shape,c.shape);return h.runWebGLProgram(i,[s,a],pl(n.dtype,r.dtype))})),a=WM({inputs:{real:r,imag:s},backend:h});return h.disposeIntermediateTensorInfo(r),h.disposeIntermediateTensorInfo(s),a}const d=i||pl(u.dtype,c.dtype);if(("string"===u.dtype||"string"===c.dtype||h.shouldExecuteOnCPU([u,c]))&&null!=a){const e=h.texData.get(u.dataId).values,t=h.texData.get(c.dataId).values,n="string"===u.dtype?qy(e):e,r="string"===u.dtype?qy(t):t,[s,i]=a(u.shape,c.shape,n,r,d),o=h.makeTensorInfo(i,d);return h.texData.get(o.dataId).values=s,o}let p;return p=Yr().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=n?new zM(n,u.shape,c.shape,r):new LM(t,u.shape,c.shape),h.runWebGLProgram(p,[u,c],d)}}function JM(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if("linear"===e)return"return x;";if("relu"===e)return t?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":TM;if("elu"===e)return t?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===e)return t?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":AM;if("prelu"===e)return t?KM:qM;if("leakyrelu"===e)return t?GM:jM;if("sigmoid"===e)return"return 1.0 / (1.0 + exp(-1.0 * x));";throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}class eL{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]&&arguments[4],a=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,o=arguments.length>7&&void 0!==arguments[7]&&arguments[7],l=arguments.length>8&&void 0!==arguments[8]&&arguments[8];this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=nF(this.outputShape.length);const u=r?e[1]:e[2],c=Math.ceil(u/2),h=r?"i * 2, rc.y":"rc.y, i * 2",d=s?"rc.z, i * 2":"i * 2, rc.z",p=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",g="";i&&(m=o?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${i}\n        }`:l?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${i}\n        }`:`vec4 activation(vec4 x) {\n          ${i}\n        }`,g="result = activation(result);");const y=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let b="rc.x",v="rc.x";e[0]<t[0]?b=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(v=`imod(rc.x, ${t[0]})`),this.userCode=`\n      ${m}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${c}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${b};\n        int batchB = ${v};\n        for (int i = 0; i < ${c}; i++) {\n          vec4 a = getMatrixA(batchA, ${h});\n          vec4 b = getMatrixB(batchB, ${d});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${p[0]} * ${f[0]});\n          result += (${p[1]} * ${f[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${y}\n\n        ${g}\n\n        setOutput(result);\n      }\n    `}}const tL="return areal * breal - aimag * bimag;",nL="return areal * bimag + aimag * breal;";class rL{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Cc(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const sL="return a * b;";function aL(e){const{inputs:t,backend:n}=e,{a:r,b:s}=t,a=pl(r.dtype,s.dtype);if("complex64"===r.dtype){const e=n.texData.get(r.dataId),t=n.texData.get(s.dataId),a=new rL(tL,r.shape,s.shape),i=new rL(nL,r.shape,s.shape),o=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:r.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:s.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:s.shape}],l=n.runWebGLProgram(a,o,"float32"),u=n.runWebGLProgram(i,o,"float32"),c=WM({inputs:{real:l,imag:u},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),c}if(n.shouldExecuteOnCPU([r,s])){const e=n.texData.get(r.dataId),t=n.texData.get(s.dataId),[i,o]=UF(r.shape,s.shape,e.values,t.values,a),l=n.makeTensorInfo(o,a);return n.texData.get(l.dataId).values=i,l}let i;return i=Yr().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new zM(sL,r.shape,s.shape):new LM(sL,r.shape,s.shape),n.runWebGLProgram(i,[r,s],a)}const iL={kernelName:qa,backendName:"webgl",kernelFunc:aL};function oL(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:a}=r,i=n,o=xr(s.shape),l=Cr(a,o),u=xr(l);yr(o===u,(()=>`The new shape (${l}) has ${u} elements and the old shape (${s.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`));const c=i.texData.get(s.dataId);return!c.isPacked||S_(s.shape,l)||null!==c.texture&&S_(c.shape,l)?(i.incRef(s.dataId),{dataId:s.dataId,shape:l,dtype:s.dtype}):function(e,t,n){const r=[v_(e.shape),...x_(e.shape)],s={dtype:e.dtype,shape:r,dataId:e.dataId},a=[v_(t),...x_(t)],i=new vM(a,r),o=[r],l=n.runWebGLProgram(i,[s],e.dtype,o,!0);return{dataId:l.dataId,shape:t,dtype:l.dtype}}(s,l,i)}const lL={kernelName:pi,backendName:"webgl",kernelFunc:oL};class uL{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:s,outSize:a}=e;this.outputShape=[r,a];const i=4*Math.floor(n/4),o=n%4;let l="sumValue += dot(values, ones);";if(null!=t){const e=1/t;l=`sumValue += dot(values * ${kr(e)?e.toPrecision(2):e}, ones);`}let u="";s%n>0&&(u=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${u}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${i}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${i};\n        if (${1===o}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${l}\n        } else if (${2===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${l}\n        } else if (${3===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}}class cL{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:s,outSize:a}=e;this.outputShape=[r,a];let i="0.0",o="";"prod"===t?i="1.0":"min"===t?(i="1.0 / 1e-20",o="min"):"max"===t&&(i="-1.0 / 1e-20",o="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?l="sumValue":"prod"===t?l="prodValue":"all"===t?l="allValue":"any"===t&&(l="anyValue");const u=4*Math.floor(n/4),c=n%4;let h=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${o}(values, minMaxValue);\n        if (${"min"===t} || ${"max"===t}) {\n          minMaxValue = ${o}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,d="vec4";"all"===t?(i="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",d="bvec4"):"any"===t&&(i="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",d="bvec4");let p="";s%n>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${i};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${i});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${2===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${3===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${h}\n        }\n        setOutput(${l});\n      }\n    `}}function hL(e,t,n,r){const s=function(e){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const n=t.length?t[t.length-1].outSize:e[1],r=Yg(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}(e.shape);let a=e;for(let i=0;i<s.length;i++){const{inSize:o,windowSize:l,outSize:u}=s[i];let c,h;c="mean"===n?0===i?new uL({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},o):new uL({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u}):new cL({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},n),h=a,a=r.runWebGLProgram(c,[a],t),h.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(h)}return a}class dL{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[t[a]];this.outputShape=n,this.rank=n.length;const r=X_(this.rank),s=function(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let s=0;s<e.length;s++)r[e[s]]=n[s];return r.join()}(t);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${s}));\n    }\n    `}}class pL{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let u=0;u<n.length;u++)n[u]=e[t[u]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=X_(this.rank),s=gM("rc",this.rank),a=new Array(this.rank);for(let u=0;u<t.length;u++)a[t[u]]=s[u];const i=`vec2(${a.slice(-2).join()})`,o=`++${s[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${a.join()}), ${i})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${l};\n      if(${o}) {\n        result[1] = ${l};\n      }\n      --${s[this.rank-1]};\n      if(++${s[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${l};\n        if(${o}) {\n          result[3] = ${l};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function fL(e,t,n){const r=Yr().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new pL(e.shape,t):new dL(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function mL(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;return function(e,t,n,r){const s=t,a=e.shape.length,i=Tr(s,e.shape);let o=i;const l=Gd(o,a),u=null!=l;let c=e;u&&(c=fL(e,l,r),o=qd(o.length,a)),jd("sum",o,a);const[h,d]=Wd(c.shape,o);let p=h;n&&(p=Ud(h,i));const f=xr(d),m=oL({inputs:{x:c},attrs:{shape:[xr(e.shape)/f,f]},backend:r}),g=hL(m,fl(e.dtype),"sum",r),y=oL({inputs:{x:g},attrs:{shape:p},backend:r});return r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(g),u&&r.disposeIntermediateTensorInfo(c),y}(s,a,i,n)}const gL={kernelName:_i,backendName:"webgl",kernelFunc:mL};function yL(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{perm:a}=r,i=n,o=s.shape.length,l=new Array(o);for(let c=0;c<l.length;c++)l[c]=s.shape[a[c]];let u;if(i.shouldExecuteOnCPU([s])){const e=i.texData.get(s.dataId).values,t=fM(e,s.shape,s.dtype,a,l);u=i.makeTensorInfo(l,s.dtype);i.texData.get(u.dataId).values=t}else u=fL(s,a,i);return u}const bL={kernelName:no,backendName:"webgl",kernelFunc:yL};function vL(e){let{a:t,b:n,transposeA:r,transposeB:s,backend:a,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:l=0,activation:u=null}=e;const c=t.shape.length,h=n.shape.length,d=r?t.shape[c-2]:t.shape[c-1],p=s?n.shape[h-1]:n.shape[h-2],f=r?t.shape[c-1]:t.shape[c-2],m=s?n.shape[h-2]:n.shape[h-1],g=t.shape.slice(0,-2),y=n.shape.slice(0,-2),b=xr(g),v=xr(y),x=Cc(t.shape.slice(0,-2),n.shape.slice(0,-2)).concat([f,m]);yr(d===p,(()=>`Error in matMul: inner shapes (${d}) and (${p}) of Tensors with shapes ${t.shape} and ${n.shape} and transposeA=${r} and transposeB=${s} must match.`));const w=r?[b,d,f]:[b,f,d],k=s?[v,m,p]:[v,p,m],S=oL({inputs:{x:t},backend:a,attrs:{shape:w}}),N=oL({inputs:{x:n},backend:a,attrs:{shape:k}}),I=[S,N],C=Math.max(b,v),T=r?S.shape[1]:S.shape[2],A=null!=i,E=null!=o,$="leakyrelu"===u,R=null!=u?JM(u,!0):null;let D;if((1===f||1===m)&&T>1e3&&!1===(A||E||$||null!=R)){let e=S,t=N;r&&(e=yL({inputs:{x:S},backend:a,attrs:{perm:[0,2,1]}}),I.push(e)),s&&(t=yL({inputs:{x:N},backend:a,attrs:{perm:[0,2,1]}}),I.push(t));const n=1===m;let i=e;1!==m&&(i=oL({inputs:{x:e},backend:a,attrs:{shape:[C,T,1]}}),I.push(i));const o=1===m?2:1;let l=t;n&&(l=oL({inputs:{x:t},backend:a,attrs:{shape:[C,1,T]}}),I.push(l));const u=aL({inputs:{a:i,b:l},backend:a});D=mL({inputs:{x:u},backend:a,attrs:{axis:o,keepDims:!0}}),I.push(u)}else{const e=pl(t.dtype,n.dtype),u=new eL(w,k,[C,f,m],r,s,A,R,E,$),c=[S,N];if(null!=i&&c.push(i),E&&c.push(o),$){const e=a.makeTensorInfo([],"float32",zo(l,"float32"));c.push(e),I.push(e)}D=a.runWebGLProgram(u,c,e)}const O=oL({inputs:{x:D},backend:a,attrs:{shape:x}});I.push(D);for(const _ of I)a.disposeIntermediateTensorInfo(_);return O}const xL={kernelName:co,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=r;return vL({a:s,b:a,transposeA:l,transposeB:u,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:h,activation:c})}},wL="return abs(x);";const kL={kernelName:ns,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const e=n.texData.get(r.dataId),t=eM(e.values);return n.makeTensorInfo(r.shape,r.dtype,t)}let s;return s=Yr().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new $M(r.shape,wL):new NM(r.shape,wL),n.runWebGLProgram(s,[r],r.dtype)}},SL=YM({opSnippet:IM+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),NL={kernelName:rs,backendName:"webgl",kernelFunc:SL},IL=YM({opSnippet:IM+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),CL={kernelName:ss,backendName:"webgl",kernelFunc:IL},TL="return a + b;",AL=ZM({opSnippet:TL,packedOpSnippet:TL,supportsComplex:!0,cpuKernelImpl:wF}),EL={kernelName:as,backendName:"webgl",kernelFunc:AL};class $L{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`float v${e} = get${e}AtOutCoords();`)}));const r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}}class RL{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)}));const r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}}const DL={kernelName:is,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,s=n;if(1===s.length)return BM({inputs:{x:s[0]},backend:r});if(s.length>Yr().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(s.length/2),n=e({inputs:s.slice(0,t),backend:r}),a=e({inputs:s.slice(t),backend:r});return e({inputs:[n,a],backend:r})}const a=s.map((e=>e.dtype)).reduce(((e,t)=>pl(e,t))),i=s.map((e=>e.shape)),o=Yr().getBool("WEBGL_PACK")?new RL(s[0].shape,i):new $L(s[0].shape,i);return r.runWebGLProgram(o,s,a)}};const OL={kernelName:os,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=Tr(a,s.shape);let u=l;const c=Gd(u,o);let h=s;null!=c&&(h=yL({inputs:{x:s},backend:n,attrs:{perm:c}}),u=qd(u.length,o)),jd("all",u,o);const[d,p]=Wd(h.shape,u),f=oL({inputs:{x:h},backend:n,attrs:{shape:[-1,xr(p)]}}),m=hL(f,f.dtype,"all",n);let g;if(i){g=oL({inputs:{x:m},backend:n,attrs:{shape:Ud(d,l)}})}else g=oL({inputs:{x:m},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(h),g}};const _L={kernelName:ls,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=Tr(a,s.shape);let u=l;const c=Gd(u,o);let h=s;null!=c&&(h=yL({inputs:{x:s},backend:n,attrs:{perm:c}}),u=qd(u.length,o)),jd("any",u,o);const[d,p]=Wd(h.shape,u),f=oL({inputs:{x:h},backend:n,attrs:{shape:[-1,xr(p)]}}),m=hL(f,f.dtype,"any",n);let g;if(i){g=oL({inputs:{x:m},backend:n,attrs:{shape:Ud(d,l)}})}else g=oL({inputs:{x:m},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(h),g}};class FL{constructor(e,t,n){this.variableNames=["A"];const{windowSize:r,batchSize:s,outSize:a}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,a];const i="max"===t?">":"<",o=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${o};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${i} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class ML{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,yr(e.length>2,(()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`));const s=e[e.length-1],a=Math.ceil(s/t);this.outputShape=e.slice(0,-1),a>1&&this.outputShape.push(a),r||this.variableNames.push("bestIndicesA");const i=this.outputShape,o=i.length,l=X_(o),u=yM("coords",o);let c,h;if(1===a){h=o+1;const e=X_(h);c=`\n        ${e} sourceLocR = ${e}(${u.join()}, 0);\n        ++${u[o-1]};\n        ${e} sourceLocG = ${e}(${u.join()}, 0);\n        ++${u[o-2]};\n        ${e} sourceLocA = ${e}(${u.join()}, 0);\n        --${u[o-1]};\n        ${e} sourceLocB = ${e}(${u.join()}, 0);\n        --${u[o-2]};`}else h=o,c=`\n        ${l} sourceLocR = coords;\n        ++${u[o-1]};\n        ${l} sourceLocG = coords;\n        ++${u[o-2]};\n        ${l} sourceLocA = coords;\n        --${u[o-1]};\n        ${l} sourceLocB = coords;\n        --${u[o-2]};`;const d=["x","y","z","w","u","v"].slice(0,h),p="."+d[h-1],f=d.map((e=>"int "+e)),m=yM("sourceLocR",h-1).concat("inIdx.r"),g=yM("sourceLocG",h-1).concat("inIdx.g"),y=yM("sourceLocB",h-1).concat("inIdx.b"),b=yM("sourceLocA",h-1).concat("inIdx.a"),v="max"===n?"greaterThan":"lessThan",x=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${b.join()})));`,w=`vec4(\n            getAChannel(${m.join()}),\n            hasNextCol ? getAChannel(${g.join()}) : 0.,\n            hasNextRow ? getAChannel(${y.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,k=r?"":`\n      float getBestIndicesAChannel(${f.join()}) {\n        return getChannel(getBestIndicesA(${d.join()}),\n                                          vec2(${d.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${f.join()}) {\n        return getChannel(getA(${d.join()}),\n                               vec2(${d.slice(-2).join()}));\n      }\n      ${k}\n      void main() {\n        ${l} coords = getOutputCoords();\n        bool hasNextCol = ${u[o-1]} < ${i[o-1]-1};\n        bool hasNextRow = ${u[o-2]} < ${i[o-2]-1};\n        ${c}\n        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},\n          sourceLocB${p}, sourceLocA${p}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${w};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${x}\n          vec4 candidate = ${w};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${v}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function LL(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,s=t.shape[0],a=t.shape[1];null!=r&&(s=r.shape[0],a=r.shape[1]);const i=Yg(a),o={windowSize:i,inSize:a,batchSize:s,outSize:Math.ceil(a/i)},l=new FL(o,n,null==r),u=[t];null!=r&&u.push(r);const c=e.runWebGLProgram(l,u,"int32");if(1===c.shape[1])return c;const h=LL(e,t,n,c);return e.disposeIntermediateTensorInfo(c),h}function PL(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const s=null!=r?r.shape:t.shape,a=Yg(s[s.length-1]),i=new ML(s,a,n,null==r),o=null==r?[t]:[t,r],l=e.runWebGLProgram(i,o,"int32");if(l.shape.length===t.shape.length){const r=PL(e,t,n,l);return e.disposeIntermediateTensorInfo(l),r}return l}function zL(e,t,n,r){const s=[n];if(jd("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,t.shape.length),!Yr().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const n=[],a=e.texData.get(t.dataId);let i=t;null!==a&&a.isPacked&&(i=e.unpackTensor(t),n.push(i));const[o,l]=Wd(i.shape,s),u=xr(l),c=oL({inputs:{x:i},backend:e,attrs:{shape:[-1,u]}});n.push(c);const h=LL(e,c,r);n.push(h);const d=oL({inputs:{x:h},backend:e,attrs:{shape:o}});return n.forEach((t=>e.disposeIntermediateTensorInfo(t))),d}return PL(e,t,r)}const BL={kernelName:us,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;let i=Tr(a,s.shape);const o=Gd(i,s.shape.length);let l=s;const u=[];null!=o&&(l=yL({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=qd(i.length,l.shape.length)),jd("argMax",[i[0]],l.shape.length);const c=zL(n,l,i[0],"max");return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}};const VL={kernelName:cs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;let i=Tr(a,s.shape);const o=Gd(i,s.shape.length);let l=s;const u=[];null!=o&&(l=yL({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=qd(i.length,l.shape.length)),jd("argMin",[i[0]],l.shape.length);const c=zL(n,l,i[0],"min");return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}},WL=YM({opSnippet:IM+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),UL={kernelName:hs,backendName:"webgl",kernelFunc:WL},jL=YM({opSnippet:IM+"return log(x + sqrt(x * x + 1.0));"}),GL={kernelName:ds,backendName:"webgl",kernelFunc:jL},HL=YM({opSnippet:IM+"\n  return atan(x);\n"}),qL={kernelName:ps,backendName:"webgl",kernelFunc:HL},KL=ZM({opSnippet:MM+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+PM+"\n  return result;\n"}),XL={kernelName:ms,backendName:"webgl",kernelFunc:KL},QL=YM({opSnippet:IM+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),YL={kernelName:fs,backendName:"webgl",kernelFunc:QL};class ZL{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,i=e.strideHeight,o=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===t,m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let y="0.0";if(f||(y="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${i}, ${o});\n        const ivec2 pads = ivec2(${d}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h};\n                wC += ${u}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${t} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?s?m:g:`wR * ${h} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let b=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(b="avgValue / max(count, 1.0)");const v=4*Math.floor(a/4),x=a%4,w=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${i}, ${o});\n      const ivec2 pads = ivec2(${d}, ${p});\n      const float initializationValue = ${y};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${y});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${l}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${v}; wC += 4) {\n            int xC = xCCorner + wC * ${u};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              getValue(batch, xR, xC + 3 * ${u}, d)\n            );\n\n            ${w}\n          }\n\n          int xC = xCCorner + ${v};\n          if (${1===x}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${2===x}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${3===x}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              initializationValue\n            );\n\n            ${w}\n          }\n        }\n        setOutput(${b});\n      }\n    `}}class JL{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,i=e.strideDepth,o=e.strideHeight,l=e.strideWidth,u=e.dilationDepth,c=e.dilationHeight,h=e.dilationWidth,d=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;const b="avg"===t;let v="0.0";if(b||(v="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${i}, ${o}, ${l});\n        const ivec3 pads = ivec3(${m}, ${g}, ${y});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${d};\n              wD += ${u}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${h}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${t} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?s?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${p} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let x=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(x="avgValue / max(count, 1.0)");const w=4*Math.floor(a/4),k=a%4,S=`\n      if (${b}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${i}, ${o}, ${l});\n      const ivec3 pads = ivec3(${m}, ${g}, ${y});\n      const float initializationValue = ${v};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${v});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${u}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${w}; wC += 4) {\n              int xC = xCCorner + wC * ${h};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${h}, ch)\n              );\n\n              ${S}\n            }\n\n            int xC = xCCorner + ${w};\n            if (${1===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${2===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${3===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                initializationValue\n              );\n\n              ${S}\n            }\n          }\n        }\n        setOutput(${x});\n      }\n    `}}const eP={kernelName:gs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;$_(s,"avgPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r;yr(Wh(i,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const u=Dh(s.shape,a,i,1,o,l);if(1===u.filterWidth&&1===u.filterHeight&&wr(u.inShape,u.outShape))return BM({inputs:{x:s},backend:n});const c=new ZL(u,"avg",!1);return n.runWebGLProgram(c,[s],"float32")}};const tP={kernelName:bs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r,c=Oh(s.shape,a,i,[1,1,1],o,l,u),h=new JL(c,"avg",!1);return n.runWebGLProgram(h,[s],"float32")}};class nP{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=o-1-e.padInfo.top,c=l-1-e.padInfo.left,h=1/(t*n);this.userCode=`\n      const ivec2 pads = ivec2(${u}, ${c});\n      const float avgMultiplier = float(${h});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n            wR += ${a}) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${l};\n            wC+= ${i}) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class rP{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterDepth,h=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=c-1-e.padInfo.front,f=h-1-e.padInfo.top,m=d-1-e.padInfo.left,g=1/(t*n*r);this.userCode=`\n      const ivec3 pads = ivec3(${p}, ${f}, ${m});\n      const float avgMultiplier = float(${g});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${c};\n            wD += ${o}) {\n          float dyD = float(dyDCorner + wD) / ${s}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${h};\n              wR += ${l}) {\n            float dyR = float(dyRCorner + wR) / ${a}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${d};\n                wC += ${u}) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const sP={kernelName:vs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,h=Oh(i.shape,o,l,[1,1,1],u,c),d=new rP(h);return n.runWebGLProgram(d,[s],i.dtype)}};const aP={kernelName:ys,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a;$_([s,a],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=r,c=Dh(i.shape,o,l,1,u),h=new nP(c);return n.runWebGLProgram(h,[s],i.dtype)}};const iP={kernelName:xs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:i,transposeB:o}=r;return vL({a:s,b:a,transposeA:i,transposeB:o,backend:n})}};class oP{constructor(e,t,n,r,s,a){this.outputShape=[],this.variableNames=["x","mean","variance"],Cc(e,t),Cc(e,n);let i="0.0";null!=r&&(Cc(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="1.0";null!=s&&(Cc(e,s),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${i};\n        float scale = ${o};\n        float inv = scale * inversesqrt(variance + float(${a}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class lP{constructor(e,t,n,r,s,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Cc(e,t),Cc(e,n);let i="vec4(0.0)";null!=r&&(Cc(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="vec4(1.0)";null!=s&&(Cc(e,s),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${i};\n        vec4 scale = ${o};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${a}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const uP={kernelName:da,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e;const{x:s,mean:a,variance:i,offset:o,scale:l}=t;yr(a.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),yr(null==o||a.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),yr(null==l||a.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:u}=r;null==u&&(u=.001);const c=[s,a,i];let h=null;null!=o&&(h=o.shape,c.push(o));let d=null;null!=l&&(d=l.shape,c.push(l));const p=Yr().getBool("WEBGL_PACK_NORMALIZATION")?new lP(s.shape,a.shape,i.shape,h,d,u):new oP(s.shape,a.shape,i.shape,h,d,u);return n.runWebGLProgram(p,c,c[0].dtype)}};class cP{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=X_(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=function(e){if(1===e)return"sourceLoc";if(e<=6)return hP.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let r;const s=e.map(((e,t)=>`sourceLoc.${hP[t]} = start[${t}] + coords.${hP[t]};`));r=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${s.join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${r}\n        setOutput(getSource(${n}));\n      }\n    `}}const hP=["x","y","z","w","u","v"];class dP{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=X_(this.rank),n=yM("coords",this.rank),r=yM("sourceLoc",this.rank),s=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,a=`getChannel(getSource(${r.join()}), ${s})`,i=`\n      result.x = ${a};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${a};\n        --${r[this.rank-1]};\n      }\n    `,o=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${a};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${a};\n        }\n      }\n    `,l=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map(((e,t)=>`start[${t}]`)).join()});`:e.map(((e,t)=>`${r[t]} = ${n[t]} + start[${t}];`)).join("\n");this.userCode=`\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${l}\n        vec4 result = vec4(0.);\n        ${i}\n        ${o}\n        setOutput(result);\n      }\n    `}}function pP(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,size:i}=r,[o,l]=gh(s,a,i);if(nh(s,o,l),0===xr(l))return n.makeTensorInfo(l,s.dtype,[]);if(n.shouldExecuteOnCPU([s])||"string"===s.dtype){const e=n.texData.get(s.dataId),t=tM(e.values,o,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,t)}const{isPacked:u}=n.texData.get(s.dataId),c=fh(s.shape,o,l);if(u||!c){const e=Yr().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new dP(l):new cP(l),t=[o];return n.runWebGLProgram(e,[s],s.dtype,t)}return n.uploadToGPU(s.dataId),function(e,t,n,r){const s=r.texData.get(e.dataId),a=r.makeTensorInfo(n,e.dtype),i=r.texData.get(a.dataId);Object.assign(i,s),i.refCount=1,i.shape=n,i.dtype=e.dtype;let o=mh(t,Pr(e.shape));s.slice&&(o+=s.slice.flatOffset),i.slice={flatOffset:o,origDataId:s.slice&&s.slice.origDataId||e.dataId};const l=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,l+1),a}(s,o,l,n)}const fP={kernelName:Ti,backendName:"webgl",kernelFunc:pP},mP={kernelName:ws,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:i}=r;yr(s.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const o=a.reduce(((e,t)=>e*t)),l=Jg(s.shape,a,o),u=ey(l.length,a.length),c=ty(s.shape,a,o),h=ny(i,a.length),d=ry(c,i,a.length),p=[],f=oL({inputs:{x:s},backend:n,attrs:{shape:l}}),m=yL({inputs:{x:f},backend:n,attrs:{perm:u}}),g=oL({inputs:{x:m},backend:n,attrs:{shape:c}}),y=pP({inputs:{x:g},backend:n,attrs:{begin:h,size:d}});return p.push(f),p.push(m),p.push(g),p.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}};const gP={kernelName:ks,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i}=r,o=n.readSync(s.dataId),l=n.readSync(a.dataId),u=kF(o,l,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,u)}};const yP={kernelName:Ss,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{a:r,b:s}=t,a=Yr().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=Yr().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([r,s])||1===i){const e=n.texData.get(r.dataId).values,t=n.texData.get(s.dataId).values,[a,i]=NF(r.shape,s.shape,e,t,r.dtype),o=n.makeTensorInfo(i,r.dtype);return n.texData.get(o.dataId).values=a,o}let o;return o=a?new zM("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",r.shape,s.shape,!1):new LM("\n  return float(int(a.r) & int(b.r));\n",r.shape,s.shape),n.runWebGLProgram(o,[r,s],r.dtype)}};const bP={kernelName:Ns,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:r,s1:s}=t,a=n.readSync(r.dataId),i=n.readSync(s.dataId),o=Cc(Array.from(a),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},vP=ZM({opSnippet:"return float(a != b);",cpuKernelImpl:GF,dtype:"bool"}),xP={kernelName:Xa,backendName:"webgl",kernelFunc:vP};function wP(e){const{inputs:t,backend:n}=e,{input:r}=t;return BM({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.real},backend:n})}const kP={kernelName:ci,backendName:"webgl",kernelFunc:wP};const SP={kernelName:Is,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r,attrs:s}=t,{x:a}=n,{dtype:i}=s;if("complex64"===i){if("complex64"===a.dtype)return BM({inputs:{x:a},backend:r});const t=Mp(a.shape),n=e({inputs:{x:a},backend:r,attrs:{dtype:"float32"}}),s=WM({inputs:{real:n,imag:t},backend:r});return t.dispose(),r.disposeIntermediateTensorInfo(n),s}if("complex64"===a.dtype){const t=wP({inputs:{input:a},backend:r}),n=e({inputs:{x:t},backend:r,attrs:{dtype:i}});return r.disposeIntermediateTensorInfo(t),n}if(!Rr(a.dtype,i)){const e=BM({inputs:{x:a},backend:r});return{dataId:e.dataId,shape:e.shape,dtype:i}}if(r.shouldExecuteOnCPU([a])){const e=r.texData.get(a.dataId).values,[t,n,s]=IF(e,a.shape,a.dtype,i);return r.makeTensorInfo(t,n,s)}if("int32"===i)return function(e,t){const n=new NM(e.shape,"return float(int(x));"),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(a,r);if("bool"===i){const e=r.makeTensorInfo([],"bool",Er("bool",1)),t=vP({inputs:{a:a,b:e},backend:r});return r.disposeIntermediateTensorInfo(e),t}throw new Error(`Error in Cast: failed to cast ${a.dtype} to ${i}`)}},NP="return ceil(x);",IP=YM({opSnippet:NP,packedOpSnippet:NP,cpuKernelImpl:CF}),CP={kernelName:Cs,backendName:"webgl",kernelFunc:IP};class TP{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class AP{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const EP={kernelName:Ts,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{clipValueMin:a,clipValueMax:i}=r;let o;o=Yr().getBool("WEBGL_PACK_CLIP")?new AP(s.shape):new TP(s.shape);const l=[[a],[i]];return n.runWebGLProgram(o,[s],s.dtype,l)}};class $P{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function RP(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const DP={kernelName:Es,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,s=n.texData.get(r.dataId),a=new $P(r.shape),i=[RP(r,s.complexTensorInfos.real),RP(r,s.complexTensorInfos.imag)];return n.runWebGLProgram(a,i,i[0].dtype)}};class OP{constructor(e){this.outputShape=[],this.outputShape=jg(e,1),this.variableNames=e.map(((e,t)=>`T${t}`));const t=new Array(e.length-1);t[0]=e[0][1];for(let a=1;a<t.length;a++)t[a]=t[a-1]+e[a][1];const n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let a=1;a<t.length;a++){const e=t[a-1];n.push(`else if (yC < ${t[a]}) setOutput(getT${a}(yR, yC-${e}));`)}const r=t.length,s=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${s}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}class _P{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=jg(e,t);const n=this.outputShape,r=n.length,s=X_(r),a=yM("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map(((e,t)=>`T${t}`));const o=new Array(e.length-1);o[0]=e[0][t];for(let f=1;f<o.length;f++)o[f]=o[f-1]+e[f][t];const l=i[t],u=i.slice(-2),c=i.join();let h=`if (${l} < ${o[0]}) {\n        return getChannel(\n            getT0(${c}), vec2(${u.join()}));\n        }`;for(let f=1;f<o.length;f++){const e=o[f-1];h+=`\n        if (${l} < ${o[f]}  && ${l} >= ${o[f-1]}) {\n          return getChannel(\n            getT${f}(${FP(i,l,e)}),\n            vec2(${FP(u,l,e)}));\n        }`}const d=o.length,p=o[o.length-1];h+=`\n        return getChannel(\n          getT${d}(${FP(i,l,p)}),\n          vec2(${FP(u,l,p)}));`,this.userCode=`\n      float getValue(${i.map((e=>"int "+e))}) {\n        ${h}\n      }\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${a}), 0., 0., 0.);\n\n        ${a[r-1]} = ${a[r-1]} + 1;\n        if (${a[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${a});\n        }\n\n        ${a[r-2]} = ${a[r-2]} + 1;\n        if (${a[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${a});\n        }\n\n        ${a[r-1]} = ${a[r-1]} - 1;\n        if (${a[r-2]} < ${n[r-2]} &&\n            ${a[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${a});\n        }\n        setOutput(result);\n      }\n    `}}function FP(e,t,n){const r=e.indexOf(t),s=e.map(((e,t)=>t===r?`${e} - ${n}`:e));return s.join()}function MP(e){const{inputs:t,backend:n}=e,{input:r}=t;return BM({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.imag},backend:n})}const LP={kernelName:va,backendName:"webgl",kernelFunc:MP};function PP(e,t,n){const r=e[0].dtype;if("complex64"===r){const r=e.map((e=>wP({inputs:{input:e},backend:n}))),s=e.map((e=>MP({inputs:{input:e},backend:n}))),a=PP(r,t,n),i=PP(s,t,n),o=WM({inputs:{real:a,imag:i},backend:n});return r.forEach((e=>n.disposeIntermediateTensorInfo(e))),s.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),o}let s=n.shouldExecuteOnCPU(e);if("string"===r&&(s=!0),s){const s=e.map((e=>{const r=xr(e.shape.slice(t));return oL({inputs:{x:e},backend:n,attrs:{shape:[-1,r]}})})),a=s.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),i=jg(s.map((e=>e.shape)),1),o=1===s[0].shape[0],l=TF(a,i,r,o),u=jg(e.map((e=>e.shape)),t),c=n.makeTensorInfo(u,r,l);return s.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}const a=e.filter((e=>xr(e.shape)>0)),i=Yr().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&a[0].shape.length>1;if(1===a.length){const t=i?new NM(e[0].shape,EM):new $M(e[0].shape,EM);return n.runWebGLProgram(t,e,r)}const o=Yr().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(a.length>o){const e=[];for(let s=0;s<a.length;s+=o){const r=a.slice(s,s+o);e.push(PP(r,t,n))}const r=PP(e,t,n);for(const t of e)n.disposeIntermediateTensorInfo(t);return r}if(i){const e=new _P(a.map((e=>e.shape)),t);return n.runWebGLProgram(e,a,r)}const{tensors2D:l,outShape:u}=function(e,t,n){const r=jg(e.map((e=>e.shape)),t),s=e.map((e=>oL({inputs:{x:e},attrs:{shape:[-1,xr(e.shape.slice(t))]},backend:n})));return{tensors2D:s,outShape:r}}(a,t,n),c=new OP(l.map((e=>e.shape))),h=n.runWebGLProgram(c,l,r);l.forEach((e=>n.disposeIntermediateTensorInfo(e)));const d=oL({inputs:{x:h},attrs:{shape:u},backend:n});return n.disposeIntermediateTensorInfo(h),d}function zP(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,a=Tr(s,t[0].shape)[0],i=t.map((e=>e.shape));Ug(i,a);const o=jg(t.map((e=>e.shape)),a);if(0===xr(o))return n.makeTensorInfo(o,t[0].dtype,[]);const l=t.filter((e=>xr(e.shape)>0));return 1===l.length?BM({inputs:{x:l[0]},backend:n}):PP(l,a,n)}const BP={kernelName:$s,backendName:"webgl",kernelFunc:zP};class VP{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.outputShape=e.outShape;const a=e.padInfo.top,i=e.padInfo.left,o=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,c=e.dilationWidth,h=e.filterHeight,d=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,g=m?1:2,y=m?2:3,b=m?3:1;let v="",x="";n&&(v=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,x="result = activation(result);");const w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${v}\n\n      const ivec2 strides = ivec2(${o}, ${l});\n      const ivec2 pads = ivec2(${a}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${b}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${y}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${h}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${d}; wC++) {\n            int xC = xCCorner + wC * ${c};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${p}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${p}) *\n                    getW(wR, wC, ${p}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${p}, xR, xC) *\n                    getW(wR, wC, ${p}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2),\n                getW(wR, wC, ${p} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1),\n                  getX(batch, xR, xC, ${p} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC),\n                  getX(batch, ${p} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${w}\n        ${x}\n        setOutput(result);\n      }\n    `}}class WP{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.filterDepth,h=e.filterHeight,d=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${s}, ${a}, ${i});\n      const ivec3 pads = ivec3(${t}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${o};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h}; wR++) {\n            int xR = xRCorner + wR * ${l};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class UP{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=nF(this.outputShape.length);const a=e.padInfo.left,i=e.strideWidth,o=e.dilationWidth,l=e.filterHeight,u=e.filterWidth,c=u;let h="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let m=0;m<u;m++)h+=`\n           vec4 xTexelC${2*m};\n           int xTexelC${2*m}Ready;\n           vec4 xTexelC${2*m+1};\n           int xTexelC${2*m+1}Ready;\n           vec4 xC${m};`;h+=`\n     for (int r = 0; r < ${l}; r++) {\n      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {\n       `;for(let m=0;m<u;m++)h+=`\n           xTexelC${2*m} = vec4(0.0);\n           xTexelC${2*m}Ready = 0;\n           xTexelC${2*m+1} = vec4(0.0);\n           xTexelC${2*m+1}Ready = 0;\n           xC${m} = vec4(0.0);`;h+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let m=0;m<(c+1)/2;m++){const t=2*m;if(h+=`\n           xC = xCCorner + ${t*o};\n           `,1===i){if(t<u&&(a%2===1?(h+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n               `,h+=1===o&&t>0?`\n                 xC${t} = vec4(xTexelC${t-2}.zw, xTexelC${t}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${t} = vec4(previous.zw, xTexelC${t}.xy);\n                   } else {\n                     xC${t} = vec4(0.0, 0.0, xTexelC${t}.xy);\n                   }\n                   `):h+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 xC${t} = xTexelC${t};\n                 `,t+1<u)){const e=a%2===0?mr(o):o;o%2===0&&a%2===1||o%2!==0&&a%2!==1?(h+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${e};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                     xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${t+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${t+1}Ready = 1;\n                   }\n                   `,h+=o>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${t+1} = vec4(previous.zw, xTexelC${t+1}.xy);\n                     } else {\n                      xC${t+1} = vec4(0.0, 0.0, xTexelC${t+1}.xy);\n                     }\n                     `:`\n                     xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.xy);\n                     `):h+=1===e?`\n                     xC${t+1} = xTexelC${t};\n                     `:`\n                     xCOffset = xC + ${e};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                       xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${t+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${t+1}Ready = 1;\n                     }\n\n                     xC${t+1} = xTexelC${t+1};\n                     `}}else t<u&&(a%2===1?(h+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${t+1}Ready == 0) {\n                   xTexelC${t+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${t+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${t+1}Ready = 1;\n                 }\n\n                 xC${t} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n               `,t+1<u&&(h+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${t+1} = vec4(xTexelC${t+1}.xy, final.xy);\n                 `)):(h+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                   xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t+1}.zw = vec2(0.);\n                   }\n                   xTexelC${t+1}Ready = 1;\n                 }\n\n                 xC${t} = vec4(\n                   xTexelC${t}.xy, xTexelC${t+1}.xy);\n               `,t+1<u&&(h+=`\n                   xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n                 `)));t<u&&(h+=`\n             wTexel = getW(r, ${t}, d1, d2);\n             dotProd += xC${t}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${e.inChannels}) {\n               dotProd += xC${t}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,t+1<u&&(h+=`\n               wTexel = getW(r, ${t+1}, d1, d2);\n               dotProd += xC${t+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${e.inChannels}) {\n                 dotProd += xC${t+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}h+="\n     }\n   ",h+="\n     }\n   ",h+="\n     }\n   ";let d="",p="";n&&(d=r?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${n}\n         }`:s?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${n}\n         }`:`vec4 activation(vec4 x) {\n           ${n}\n         }`,p="result = activation(result);");const f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${d}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${h}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${f}\n         ${p}\n         setOutput(result);\n       }\n     `}}class jP{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=nF(this.outputShape.length);const{dataFormat:n}=t,r=D_(),s="channelsLast"===n,a=s?1:2,i=s?2:3,o=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let l="";for(let u=0;u<=1;u++)for(let e=0;e<=1;e++)l+=`\n          blockIndex = rc.z + ${e};\n          pos = rc.y + ${u};\n\n          ${o}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${a}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${i}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${s}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*u+e}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*u+e}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${l}\n\n        ${r.output} = result;\n      }\n    `}}function GP(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function HP(e){let{x:t,filter:n,convInfo:r,backend:s,bias:a=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}=e;const u=t.shape,c=s.texData.get(t.dataId),h=r.inChannels,d=u[0]*u[1]*u[2],p=r.outChannels,f="channelsLast"===r.dataFormat,m=!1;let g;const y=[];if(null!=i){const e=GP(i.shape,f);null!=e&&(i=oL({inputs:{x:i},backend:s,attrs:{shape:e}}),y.push(i))}if(null!=a){const e=GP(a.shape,f);null!=e&&(a=oL({inputs:{x:a},backend:s,attrs:{shape:e}}),y.push(a))}if(!((1===d||1===p)&&h>1e3)&&c.isPacked&&f&&null!=c.texture&&u[2]%2!==0&&wr(c.shape.slice(-3),u.slice(-3))){const e=u[0]*u[1]*(u[2]+1),h={dataId:t.dataId,shape:[1,e,r.inChannels],dtype:t.dtype},d=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,yr(S_(c.shape,h.shape),(()=>`packed reshape ${c.shape} to ${h.shape} isn't free`));const p=oL({inputs:{x:n},backend:s,attrs:{shape:[1,r.inChannels,r.outChannels]}});y.push(p);const f=vL({a:h,b:p,backend:s,transposeA:false,transposeB:m,bias:a,activation:l,preluActivationWeights:i,leakyreluAlpha:o}),b=s.texData.get(f.dataId);yr(b.isPacked,(()=>"batchMatMul result is expected to be packed")),c.shape=d,b.shape=r.outShape,g=BM({inputs:{x:f},backend:s}),g.shape=r.outShape,y.push(f)}else{const e=r.outHeight*r.outWidth,u=oL({inputs:{x:t},backend:s,attrs:{shape:f?[r.batchSize,e,r.inChannels]:[r.batchSize,r.inChannels,e]}}),c=oL({inputs:{x:n},backend:s,attrs:{shape:[1,r.inChannels,r.outChannels]}}),h=vL({a:f?u:c,b:f?c:u,transposeA:!f,transposeB:m,backend:s,bias:a,activation:l,preluActivationWeights:i,leakyreluAlpha:o});g=oL({inputs:{x:h},backend:s,attrs:{shape:r.outShape}}),y.push(u),y.push(c),y.push(h)}for(const b of y)s.disposeIntermediateTensorInfo(b);return g}function qP(e){let{x:t,filter:n,convInfo:r,backend:s,bias:a=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}=e;const{filterWidth:u,filterHeight:c,inChannels:h,outWidth:d,outHeight:p,dataFormat:f}=r,m="channelsLast"===f,g=u*c*h,y=p*d,b=[r.batchSize,g,y],v=[];if(null!=i){const e=GP(i.shape,m);null!=e&&(i=oL({inputs:{x:i},backend:s,attrs:{shape:e}}),v.push(i))}if(null!=a){const e=GP(a.shape,m);null!=e&&(a=oL({inputs:{x:a},backend:s,attrs:{shape:e}}),v.push(a))}const x=oL({inputs:{x:n},backend:s,attrs:{shape:[1,g,xr(n.shape)/g]}});v.push(x);const w=new jP(b,r),k=[t.shape,[r.padInfo.top,r.padInfo.left],[r.strideHeight,r.strideWidth],[r.dilationHeight,r.dilationWidth],[r.inChannels],[r.filterWidth*r.inChannels],[r.outWidth]],S=s.runWebGLProgram(w,[t],"float32",k),N=oL({inputs:{x:S},backend:s,attrs:{shape:b}});v.push(S),v.push(N);const I=null!=a,C=null!=i,T="leakyrelu"===l,A=l?JM(l,!0):null,E=new eL(m?N.shape:x.shape,m?x.shape:N.shape,m?[r.batchSize,y,r.outChannels]:[r.batchSize,r.outChannels,y],!0,!1,I,A,C,T),$=m?[N,x]:[x,N];if(a&&$.push(a),C&&$.push(i),T){const e=s.makeTensorInfo([],"float32",zo(o,"float32"));$.push(e),v.push(e)}const R=s.runWebGLProgram(E,$,"float32"),D=oL({inputs:{x:R},backend:s,attrs:{shape:r.outShape}});v.push(R);for(const O of v)s.disposeIntermediateTensorInfo(O);return D}const KP={kernelName:Rs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r,h=jh(l),d=_h(s.shape,a.shape,i,u,o,c,!1,h);let p;if(1!==d.filterHeight||1!==d.filterWidth||1!==d.dilationHeight||1!==d.dilationWidth||1!==d.strideHeight||1!==d.strideWidth||"SAME"!==d.padInfo.type&&"VALID"!==d.padInfo.type)if(d.strideWidth<=2&&"channelsLast"===h&&Yr().getBool("WEBGL_EXP_CONV")){const e=new UP(d),t=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];p=n.runWebGLProgram(e,[s,a],"float32",t)}else if(Yr().getBool("WEBGL_CONV_IM2COL"))p=qP({x:s,filter:a,convInfo:d,backend:n});else{const e=new VP(d);p=n.runWebGLProgram(e,[s,a],"float32")}else p=HP({x:s,filter:a,convInfo:d,backend:n});const f=oL({inputs:{x:p},backend:n,attrs:{shape:d.outShape}});return n.disposeIntermediateTensorInfo(p),f}};class XP{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,s=e.padInfo.left,a="channelsLast"===e.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${s};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              ${a?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);"}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class QP{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a="channelsLast"===e.dataFormat,i=t-1-e.padInfo.top,o=n-1-e.padInfo.left,l=a?1:2,u=a?2:3,c=a?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${c}];\n\n        ivec2 dyCorner = ivec2(coords[${l}], coords[${u}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${a}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class YP{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,s=e.padInfo.front,a=e.padInfo.top,i=e.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${t} - ${s};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${a};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${r} - ${i};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class ZP{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.front,l=n-1-e.padInfo.top,u=r-1-e.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${o}, ${l}, ${u});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${s}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${a}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const JP={kernelName:Ds,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r,h=jh(l),d=_h(s.shape,c,i,1,o,u,!1,h),p=new XP(d);return n.runWebGLProgram(p,[s,a],"float32")}};class ez{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=nF(this.outputShape.length);const t=e.filterHeight,n=e.filterWidth,r=t-1-e.padInfo.top,s=n-1-e.padInfo.left;this.userCode=`\n      const ivec2 pads = ivec2(${r}, ${s});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            int wCPerm = ${n} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `}}const tz={kernelName:Os,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r,h=jh(u),d=_h(i,a.shape,o,1,l,c,!1,h);if(Yr().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===h){const e=[[d.strideHeight,d.strideWidth]],t=new ez(d);return n.runWebGLProgram(t,[s,a],"float32",e)}{const e=new QP(d);return n.runWebGLProgram(e,[s,a],"float32")}}};const nz={kernelName:_s,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r,u=Fh(s.shape,a.shape,i,l,o),c=new WP(u);return n.runWebGLProgram(c,[s,a],"float32")}};const rz={kernelName:Fs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,filterShape:l}=r,u=Fh(s.shape,l,i,1,o),c=new YP(u);return n.runWebGLProgram(c,[s,a],"float32")}};const sz={kernelName:Ms,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:i,strides:o,inputShape:l}=r,u=Fh(l,a.shape,o,1,i),c=new ZP(u);return n.runWebGLProgram(c,[s,a],"float32")}},az=YM({opSnippet:QM+"\n  return cos(x);\n",packedOpSnippet:`\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${PM}\n  return result;\n`}),iz={kernelName:Ls,backendName:"webgl",kernelFunc:az},oz=YM({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),lz={kernelName:Ps,backendName:"webgl",kernelFunc:oz};class uz{constructor(e,t,n,r,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[a,i,o,l]=e,[u]=t,[c,h]=n;this.outputShape=[u,c,h,l];const d="bilinear"===r?1:0,[p,f]=[i-1+".0",o-1+".0"],[m,g,y]=c>1?[""+(i-1)/(c-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[b,v,x]=h>1?[""+(o-1)/(h-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${b});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${a}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${v};\n\n        float in_y = ${y};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${s}));\n          return;\n        }\n        float in_x = ${x};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${s}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${d} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const cz={kernelName:Vs,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:a,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,c=new uz(s.shape,a.shape,o,l,u);return n.runWebGLProgram(c,[s,a,i],"float32")}};var hz;!function(e){e.Prod="*",e.Sum="+"}(hz||(hz={}));class dz{constructor(e,t,n,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const s=this.outputShape.length,a=this.op===hz.Prod?"1.0":"0.0",i=n?a:`getX(${pz(s,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1];let l="",u="";n?(l=r?"end != "+(o-1):"end != 0",u=r?"end + 1":"end - 1"):(l=r?`end + pow2 < ${o}`:"end >= pow2",u=r?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${X_(s)} coords = getOutputCoords();\n        int end = ${fz(s,"coords",this.op)};\n        float val = ${i};\n        int pow2 = int(pow(2.0, index));\n        if (${l}) {\n          int idx = ${u};\n          ${fz(s,"coords",this.op)} = idx;\n          val ${this.op}= getX(${pz(s,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function pz(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function fz(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function mz(e,t,n,r,s,a){const i=t.shape.length,o=Gd([r],i);let l=t;null!=o&&(l=yL({inputs:{x:t},backend:n,attrs:{perm:o}}));const u=qd(1,i)[0];if(u!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);const c=l.shape[u];let h=BM({inputs:{x:l},backend:n});for(let d=0;d<=Math.ceil(Math.log2(c))-1;d++){const t=new dz(e,l.shape,!1,a),r=[[d]],s=h;h=n.runWebGLProgram(t,[h],h.dtype,r),n.disposeIntermediateTensorInfo(s)}if(s){const t=new dz(e,l.shape,s,a),r=h;h=n.runWebGLProgram(t,[h],h.dtype),n.disposeIntermediateTensorInfo(r)}if(null!=o){const e=yL({inputs:{x:h},backend:n,attrs:{perm:Hd(o)}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(l),e}return h}const gz={kernelName:zs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;return mz(hz.Prod,s,n,a,i,o)}};const yz={kernelName:Bs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;return mz(hz.Sum,s,n,a,i,o)}};const bz={kernelName:Ws,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i,binaryOutput:o}=r;if(1===s.shape.length){const e=n.readSync(s.dataId),t=n.readSync(a.dataId),r=kF(e,t,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,r)}if(2===s.shape.length){const e=n.bufferSync(s),t=n.bufferSync(a),r=SF(e,t,i,o);return n.makeTensorInfo(r.shape,a.dtype,r.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}};class vz{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const xz={kernelName:Us,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:a,dataFormat:i}=r,o=s.shape[0],l=("NHWC"===i?s.shape[1]:s.shape[2])*a,u=("NHWC"===i?s.shape[2]:s.shape[3])*a,c=("NHWC"===i?s.shape[3]:s.shape[1])/(a*a),h=new vz("NHWC"===i?[o,l,u,c]:[o,c,l,u],a,i);return n.runWebGLProgram(h,[s],s.dtype)}};class wz{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=nF(this.outputShape.length);const a=e.filterHeight,i=e.filterWidth,o=e.outChannels/e.inChannels;let l="",u="";n&&(l=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,u="result = activation(result);");const c=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${l}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${o};\n        int q = d2 - d1 * ${o};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${a}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${c}\n        ${u}\n        setOutput(result);\n      }\n    `}}class kz{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=nF(this.outputShape.length);const a=e.outChannels/e.inChannels,i=e.padInfo.left,o=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,c=e.filterWidth,h=c;let d="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let g=0;g<c;g++)d+=`\n          vec4 xTexelC${2*g};\n          int xTexelC${2*g}Ready;\n          vec4 xTexelC${2*g+1};\n          int xTexelC${2*g+1}Ready;\n          vec4 xC${g};`;d+=`\n    for (int r = 0; r < ${u}; r++) {\n      `;for(let g=0;g<c;g++)d+=`\n          xTexelC${2*g} = vec4(0.0);\n          xTexelC${2*g}Ready = 0;\n          xTexelC${2*g+1} = vec4(0.0);\n          xTexelC${2*g+1}Ready = 0;\n          xC${g} = vec4(0.0);`;d+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let g=0;g<(h+1)/2;g++){const e=2*g;if(d+=`\n          xC = xCCorner + ${e*l};\n          `,1===o){if(e<c&&(i%2===1?(d+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n              `,d+=1===l&&e>0?`\n                xC${e} = vec4(xTexelC${e-2}.zw, xTexelC${e}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${e} = vec4(previous.zw, xTexelC${e}.xy);\n                  } else {\n                    xC${e} = vec4(0.0, 0.0, xTexelC${e}.xy);\n                  }\n                  `):d+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                xC${e} = xTexelC${e};\n                `,e+1<c)){const t=i%2===0?mr(l):l;l%2===0&&i%2===1||l%2!==0&&i%2!==1?(d+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${t};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                    xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${e+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${e+1}Ready = 1;\n                  }\n                  `,d+=l>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${e+1} = vec4(previous.zw, xTexelC${e+1}.xy);\n                    } else {\n                     xC${e+1} = vec4(0.0, 0.0, xTexelC${e+1}.xy);\n                    }\n                    `:`\n                    xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.xy);\n                    `):d+=1===t?`\n                    xC${e+1} = xTexelC${e};\n                    `:`\n                    xCOffset = xC + ${t};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                      xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${e+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${e+1}Ready = 1;\n                    }\n\n                    xC${e+1} = xTexelC${e+1};\n                    `}}else e<c&&(i%2===1?(d+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${e+1}Ready == 0) {\n                  xTexelC${e+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${e+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${e+1}Ready = 1;\n                }\n\n                xC${e} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n              `,e+1<c&&(d+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${e+1} = vec4(xTexelC${e+1}.xy, final.xy);\n                `)):(d+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                  xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e+1}.zw = vec2(0.);\n                  }\n                  xTexelC${e+1}Ready = 1;\n                }\n\n                xC${e} = vec4(\n                  xTexelC${e}.xy, xTexelC${e+1}.xy);\n              `,e+1<c&&(d+=`\n                  xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n                `)));e<c&&(d+=`\n            wTexel = getW(r, ${e}, d1, q);\n            dotProd += xC${e} * vec4(wTexel.xz, wTexel.xz);\n          `,e+1<c&&(d+=`\n              wTexel = getW(r, ${e+1}, d1, q);\n              dotProd += xC${e+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}d+="\n    }\n  ",d+="\n      }\n    ";let p="",f="";n&&(p=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,f="result = activation(result);");const m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${p}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${a};\n        int q = d2 - d1 * ${a};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${d}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${m}\n        ${f}\n        setOutput(result);\n      }\n    `}}const Sz={kernelName:js,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r;let c=l;null==c&&(c=[1,1]),yr(Wh(i,c),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`));const h=_h(s.shape,a.shape,i,c,o,u,!0);let d;d=Yr().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?new kz(h):new wz(h);const p=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return n.runWebGLProgram(d,[s,a],"float32",p)}};class Nz{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,s=e.padInfo.left,a=e.outChannels/e.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${a} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${s};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Iz{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a=t-1-e.padInfo.top,i=n-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${a}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${o}; dm++) {\n              int d2 = d1 * ${o} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Cz={kernelName:Gs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r,h=_h(s.shape,c,i,o,l,u,!0),d=new Nz(h);return n.runWebGLProgram(d,[s,a],"float32")}};const Tz={kernelName:Hs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r,h=_h(c,a.shape,i,o,l,u,!0),d=new Iz(h);return n.runWebGLProgram(d,[s,a],"float32")}};class Az{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const Ez={kernelName:qs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,s=[...r.shape,...r.shape],a=xr(r.shape),i=oL({inputs:{x:r},backend:n,attrs:{shape:[a]}}),o=new Az(a),l=n.runWebGLProgram(o,[i],i.dtype),u=oL({inputs:{x:l},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),u}};class $z{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:r,strideHeight:s,strideWidth:a,filterHeight:i,filterWidth:o,dilationHeight:l,dilationWidth:u}=e,{top:c,left:h}=r;this.userCode=`\n      const ivec2 strides = ivec2(${s}, ${a});\n      const ivec2 pads = ivec2(${c}, ${h});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${i}; h++) {\n          int hIn = hBeg + h * ${l};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${o}; w++) {\n              int wIn = wBeg + w * ${u};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const Rz={kernelName:Ks,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r,u=Rh(s.shape,a.shape,i,o,"NHWC",l);let c;const h=new $z(u);c=n.runWebGLProgram(h,[s,a],"float32");const d=oL({inputs:{x:c},backend:n,attrs:{shape:u.outShape}});return n.disposeIntermediateTensorInfo(c),d}};const Dz={kernelName:Js,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,a=t,{allDims:i,summedDims:o,idDims:l}=Iy(s,a.length);Ty(i.length,l,a);const{path:u,steps:c}=Ay(o,l),h=c.length;let d=null,p=i.length;const f=[];for(let m=0;m<h;++m){for(const e of c[m]){const{permutationIndices:t,expandDims:r}=Cy(p,l[e]);let s;Ey(t)?s=a[e]:(s=yL({inputs:{x:a[e]},backend:n,attrs:{perm:t}}),f.push(s));const i=s.shape.slice();for(let e=0;e<r.length;++e)i.splice(r[e],0,1);wr(s.shape,i)||(s=oL({inputs:{x:s},backend:n,attrs:{shape:i}}),f.push(s)),null===d?d=s:(d=aL({inputs:{a:s,b:d},backend:n}),f.push(d))}m<h-1&&(u[m]>=0&&(d=mL({inputs:{x:d},backend:n,attrs:{axis:u[m]-(i.length-p),keepDims:!1}}),f.push(d)),p--)}for(const m of f)m!==d&&n.disposeIntermediateTensorInfo(m);return d}},Oz=YM({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),_z={kernelName:ea,backendName:"webgl",kernelFunc:Oz},Fz={kernelName:ta,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:r,y:s}=t,a=Yr().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new zM("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,s.shape):new LM("return (b >= 0.0) ? a : a * (b + 1.0);",r.shape,s.shape);return n.runWebGLProgram(a,[r,s],r.dtype)}},Mz=ZM({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:AF}),Lz={kernelName:ra,backendName:"webgl",kernelFunc:Mz},Pz=YM({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${oy};\n  float a1 = ${ly};\n  float a2 = ${uy};\n  float a3 = ${cy};\n  float a4 = ${hy};\n  float a5 = ${dy};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),zz={kernelName:na,backendName:"webgl",kernelFunc:Pz},Bz=YM({opSnippet:QM+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:EF,dtype:"float32"}),Vz={kernelName:sa,backendName:"webgl",kernelFunc:Bz};function Wz(e){const{inputs:t,attrs:n,backend:r}=e,{dim:s}=n,{input:a}=t,i=a.shape.length,o=a.shape.slice();let l=s;return s<0&&(yr(-(i+1)<=s,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),l=i+s+1),o.splice(l,0,1),oL({inputs:{x:a},backend:r,attrs:{shape:o}})}const Uz={kernelName:aa,backendName:"webgl",kernelFunc:Wz},jz="return exp(x) - 1.0;",Gz=YM({opSnippet:jz,packedOpSnippet:jz,cpuKernelImpl:$F}),Hz={kernelName:ia,backendName:"webgl",kernelFunc:Gz};class qz{constructor(e,t,n){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const s=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=n?`${r}.0`:"1.0";let i;if("real"===e)i="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);i="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${s};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${i}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${a};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function Kz(e,t,n){const r=n.texData.get(e.dataId),s=xr(e.shape),a=e.shape[e.shape.length-1],i=oL({inputs:{x:e},backend:n,attrs:{shape:[s/a,a]}}),o=i.shape,l=new qz("real",o,t),u=new qz("imag",o,t),c=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:o},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:o}],h=n.runWebGLProgram(l,c,"float32"),d=n.runWebGLProgram(u,c,"float32"),p=WM({inputs:{real:h,imag:d},backend:n});n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d);const f=oL({inputs:{x:p},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(p),f}const Xz={kernelName:oa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return Kz(r,!1,n)}};class Qz{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function Yz(e){const{backend:t,attrs:n}=e,{shape:r,value:s}=n;let{dtype:a}=n;if(a=a||Fr(s),"string"===a){const e=$r(a,xr(r));return e.fill(s),t.makeTensorInfo(r,a,e)}{const e=new Qz(r,s),n=[[s]];return t.runWebGLProgram(e,[],a,n)}}const Zz={kernelName:la,backendName:"webgl",kernelFunc:Yz};class Jz{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const eB={kernelName:ua,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n}=e;const{image:r}=t,s=n,a=new Jz(r.shape);return s.runWebGLProgram(a,[r],r.dtype)}},tB="return floor(x);",nB=YM({opSnippet:tB,packedOpSnippet:tB,cpuKernelImpl:RF}),rB={kernelName:ca,backendName:"webgl",kernelFunc:nB},sB=ZM({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),aB={kernelName:ha,backendName:"webgl",kernelFunc:sB};class iB{constructor(e){this.variableNames=["A"];const t=D_(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class oB{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=D_(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}}const lB={kernelName:lo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e;let{pixels:s}=t;const{numChannels:a}=r,i="undefined"!==typeof HTMLVideoElement&&s instanceof HTMLVideoElement,o="undefined"!==typeof HTMLImageElement&&s instanceof HTMLImageElement,[l,u]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],c=[u,l],h=[u,l,a];if(o||i){const e=Yr().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=uB&&e===cB||(cB=e,uB=document.createElement("canvas").getContext("2d",{willReadFrequently:cB})),uB.canvas.width=l,uB.canvas.height=u,uB.drawImage(s,0,0,l,u),s=uB.canvas}const d=n.makeTensorInfo(c,"int32");n.texData.get(d.dataId).usage=e_.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),s);const p=Yr().getBool("WEBGL_PACK")?new oB(h):new iB(h),f=n.runWebGLProgram(p,[d],"int32");return n.disposeData(d.dataId),f}};let uB,cB=Yr().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const hB={kernelName:ho,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r,m=jh(c),g=_h(s.shape,a.shape,l,h,u,d,!1,m);let y;const b=[],v=null!=i,x=null!=o,w="leakyrelu"===p,k=()=>{const e=[s,a],t=(e,t)=>{if("NCHW"===t&&1===e.shape.length&&1!==e.shape[0]){const t=oL({inputs:{x:e},backend:n,attrs:{shape:[e.shape[0],1,1]}});return b.push(t),t}return e};if(v&&e.push(t(i,c)),x&&e.push(t(o,c)),w){const t=n.makeTensorInfo([],"float32",zo(f,"float32"));e.push(t),b.push(t)}return e};if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(g.strideWidth<=2&&"channelsLast"===m&&Yr().getBool("WEBGL_EXP_CONV")){const e=p?JM(p,!0):null,t=new UP(g,v,e,x,w),r=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],s=k();y=n.runWebGLProgram(t,s,"float32",r)}else if(Yr().getBool("WEBGL_CONV_IM2COL"))y=qP({x:s,filter:a,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});else{const e=p?JM(p,!1):null,t=new VP(g,v,e,x,w),r=k();y=n.runWebGLProgram(t,r,"float32")}else y=HP({x:s,filter:a,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});const S=oL({inputs:{x:y},backend:n,attrs:{shape:g.outShape}});return b.push(y),b.forEach((e=>n.disposeIntermediateTensorInfo(e))),S}};const dB={kernelName:po,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:c,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=r,f=[];let m=c;null==m&&(m=[1,1]),yr(Wh(l,m),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`));const g=_h(s.shape,a.shape,l,m,u,h,!0),y=Yr().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,b=d?JM(d,y):null,v=[s,a],x=null!=i,w=null!=o,k="leakyrelu"===d;if(x&&v.push(i),w&&v.push(o),k){const e=n.makeTensorInfo([],"float32",zo(p,"float32"));v.push(e),f.push(e)}let S;S=y?new kz(g,x,b,w,k):new wz(g,x,b,w,k);const N=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],I=n.runWebGLProgram(S,v,"float32",N);return f.forEach((e=>n.disposeIntermediateTensorInfo(e))),I}};class pB{constructor(e,t,n,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;const s=X_(n.length);let a="\n    int index;";for(let i=0;i<this.sliceDim;i++)a+=`\n          index = round(getIndices(coords[0], ${i}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[i]};\n          flattenIndex += index * ${this.strides[i]};`;this.userCode=`\n         void main() {\n          ${s} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${a}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}const fB={kernelName:fa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:s}=t,a=s.shape,i=a[a.length-1],o=xr(r.shape),[l,u,c,h]=sy(r,s),d=oL({inputs:{x:s},backend:n,attrs:{shape:[u,i]}}),p=oL({inputs:{x:r},backend:n,attrs:{shape:[xr(r.shape)/c,c]}});if(n.shouldExecuteOnCPU([r,s])||"string"===r.dtype){const e=n.readSync(s.dataId),t=n.bufferSync(r),a=DF(e,t,r.dtype,u,i,c,h,r.shape,o);return n.makeTensorInfo(l,r.dtype,a.values)}const f=new pB(i,h,[u,c],r.shape),m=n.runWebGLProgram(f,[p,d],p.dtype),g=oL({inputs:{x:m},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),g}};class mB{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=X_(this.rank),r=function(e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let r=0;r<e.length;r++)2===r?n.push("index"):n.push(`${t[r]}`);return n.join()}(e);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${r}));\n      }\n    `}}function gB(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,indices:a}=t,{axis:i,batchDims:o}=r,l=Tr(i,s.shape)[0];if(Yr().get("DEBUG")){const e=n.readSync(a.dataId),t=s.shape[l];for(let n=0;n<e.length;++n){const r=e[n];yr(r<=t-1&&r>=0,(()=>`GatherV2: the index value ${r} is not in [0, ${t-1}]`))}}const u=Hy(s,a,l,o),c=xr(a.shape),h=[],d=oL({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),p=oL({inputs:{x:a},backend:n,attrs:{shape:[u.batchSize,c/u.batchSize]}});h.push(d),h.push(p);const f=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([s,a])||"string"===s.dtype){const e=n.bufferSync(p),t=n.bufferSync(d),r=OF(t,e,f);return h.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(u.outputShape,r.dtype,r.values)}const m=new mB(d.shape,f),g=n.runWebGLProgram(m,[d,p],d.dtype);h.push(g);const y=oL({inputs:{x:g},backend:n,attrs:{shape:u.outputShape}});return h.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}const yB={kernelName:pa,backendName:"webgl",kernelFunc:gB},bB=ZM({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:_F,dtype:"bool"}),vB={kernelName:ma,backendName:"webgl",kernelFunc:bB},xB=ZM({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:FF}),wB={kernelName:ga,backendName:"webgl",kernelFunc:xB};const kB={kernelName:ba,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return Kz(r,!0,n)}},SB=YM({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),NB={kernelName:xa,backendName:"webgl",kernelFunc:SB},IB=YM({opSnippet:"return float(isinf(x));",dtype:"bool"}),CB={kernelName:wa,backendName:"webgl",kernelFunc:IB},TB=YM({opSnippet:"return float(isnan(x));",dtype:"bool"}),AB={kernelName:ka,backendName:"webgl",kernelFunc:TB},EB=ZM({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:MF,dtype:"bool"}),$B={kernelName:Na,backendName:"webgl",kernelFunc:EB},RB=ZM({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:LF,dtype:"bool"}),DB={kernelName:Ia,backendName:"webgl",kernelFunc:RB};const OB={kernelName:Ca,backendName:"webgl",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:s,num:a}=n,i=PF(r,s,a);return t.makeTensorInfo([i.length],"float32",i)}},_B=YM({opSnippet:QM+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:zF}),FB={kernelName:Ta,backendName:"webgl",kernelFunc:_B},MB=YM({opSnippet:QM+"\n  return log(1.0 + x);\n"}),LB={kernelName:Aa,backendName:"webgl",kernelFunc:MB},PB=ZM({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),zB={kernelName:Ea,backendName:"webgl",kernelFunc:PB},BB=YM({opSnippet:"return float(!(x >= 1.0));"}),VB={kernelName:$a,backendName:"webgl",kernelFunc:BB},WB=ZM({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),UB={kernelName:Ra,backendName:"webgl",kernelFunc:WB};class jB{constructor(e,t,n,r,s){this.variableNames=["x"],this.outputShape=[];const a=t,i=e[3]-1;let o;this.outputShape=e;const l=`float(${n}) + float(${r}) * sum`;o=.5===s?`inversesqrt(${l})`:1===s?`1.0/(${l})`:`exp(log(${l}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${a}; j <= ${a}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${i}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${o};\n        setOutput(val);\n      }\n    `}}class GB{constructor(e,t,n,r,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const a=t,i=e[3]-1;let o;this.outputShape=e;const l=`float(${n}) + float(${r}) * sum`;o=.5===s?`inversesqrt(${l})`:1===s?`1.0/(${l})`:`exp(log(${l}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${a};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${a}; j <= ${a}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${o};\n        setOutput(result);\n      }\n    `}}const HB={kernelName:Da,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:i,alpha:o,beta:l}=r,u=Yr().getBool("WEBGL_PACK_NORMALIZATION")?new GB(s.shape,a,i,o,l):new jB(s.shape,a,i,o,l);return n.runWebGLProgram(u,[s],s.dtype)}};class qB{constructor(e,t,n,r,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=s,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${s})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${s});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const KB={kernelName:Oa,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r,h=new qB(s.shape,o,l,u,c);return n.runWebGLProgram(h,[s,a,i],s.dtype)}};function XB(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:a,keepDims:i}=r,o=s.shape.length,l=Tr(a,s.shape);let u=l;const c=Gd(u,o),h=null!=c,d=n.shouldExecuteOnCPU([s]);let p=s;if(h){if(d){const e=n.texData.get(p.dataId).values,t=new Array(o);for(let n=0;n<t.length;n++)t[n]=s.shape[c[n]];const r=fM(e,s.shape,s.dtype,c,t);p=n.makeTensorInfo(t,s.dtype);n.texData.get(p.dataId).values=r}else p=fL(s,c,n);u=qd(u.length,o)}jd("max",u,o);const[f,m]=Wd(p.shape,u);let g,y=f;if(i&&(y=Ud(f,l)),d){const e=n.texData.get(p.dataId).values,t=BF(e,xr(m),y,s.dtype);g=n.makeTensorInfo(y,s.dtype);n.texData.get(g.dataId).values=t}else g=function(e,t,n,r){const s=xr(t),a=oL({inputs:{x:e},attrs:{shape:[xr(e.shape)/s,s]},backend:r}),i=hL(a,e.dtype,"max",r),o=oL({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),o}(p,m,y,n);return h&&n.disposeIntermediateTensorInfo(p),g}const QB={kernelName:_a,backendName:"webgl",kernelFunc:XB},YB=ZM({opSnippet:MM+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+PM+"\n  return result;\n",cpuKernelImpl:VF}),ZB={kernelName:Fa,backendName:"webgl",kernelFunc:YB};const JB={kernelName:Ma,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;$_(s,"maxPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r;yr(Wh(i,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const u=Dh(s.shape,a,i,1,o,l);if(1===u.filterWidth&&1===u.filterHeight&&wr(u.inShape,u.outShape))return BM({inputs:{x:s},backend:n});const c=new ZL(u,"max",!1);return n.runWebGLProgram(c,[s],s.dtype)}};const eV={kernelName:Pa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dataFormat:l,dimRoundingMode:u}=r,c=Oh(s.shape,a,i,[1,1,1],o,u,l),h=new JL(c,"max",!1);return n.runWebGLProgram(h,[s],s.dtype)}};class tV{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,s=e.effectiveFilterHeight,a=e.effectiveFilterWidth,i=s-1-e.padInfo.top,o=a-1-e.padInfo.left,l=s*a-1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${s};\n          wR += ${r}) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${a}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${a} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class nV{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,s=e.dilationDepth,a=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterDepth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,c=o-1-e.padInfo.front,h=l-1-e.padInfo.top,d=u-1-e.padInfo.left,p=o*l*u-1;this.userCode=`\n      const ivec3 pads = ivec3(${c}, ${h}, ${d});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${o};\n           wD += ${s}) {\n          float dyD = float(dyDCorner + wD) / ${t}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${l};\n              wR += ${a}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${u};\n                wC += ${i}) {\n              float dyC = float(dyCCorner + wC) / ${r}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${p} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${l} * ${u} +\n                  wR * ${u} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const rV={kernelName:za,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,h=Oh(i.shape,o,l,[1,1,1],u,c),d=new JL(h,"max",!0),p=n.runWebGLProgram(d,[i],i.dtype),f=new nV(h),m=n.runWebGLProgram(f,[s,p],i.dtype);return n.disposeIntermediateTensorInfo(p),m}};const sV={kernelName:La,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a,output:i}=t,o=a;$_([a,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=r,d=Dh(o.shape,l,u,1,c,h),p=new ZL(d,"max",!0),f=n.runWebGLProgram(p,[o],o.dtype),m=new tV(d),g=n.runWebGLProgram(m,[s,f],o.dtype);return n.disposeIntermediateTensorInfo(f),g}};const aV={kernelName:Ba,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{x:s}=t,{filterSize:a,strides:i,pad:o,includeBatchInIndex:l}=n,u=r;yr(4===s.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`));const c=[1,1];yr(Wh(i,c),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`));const h=Dh(s.shape,a,i,c,o),[d,p]=function(e,t,n,r){let s=new ZL(n,"max",!1);const a=r.runWebGLProgram(s,[e],"float32");return s=new ZL(n,"max",!0,!0,t),[a,r.runWebGLProgram(s,[e],"float32")]}(s,l,h,u);return[d,p]}};const iV={kernelName:Va,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{x:s}=t,{keepDims:a,axis:i}=n,o=r,l=s.shape.length,u=Tr(i,s.shape);let c=u;const h=Gd(c,l),d=null!=h,p=o.shouldExecuteOnCPU([s]),f=[];let m=s;if(d){if(p){const e=o.texData.get(m.dataId).values,t=new Array(l);for(let r=0;r<t.length;r++)t[r]=s.shape[h[r]];const n=fM(e,s.shape,s.dtype,h,t);m=o.makeTensorInfo(t,s.dtype);o.texData.get(m.dataId).values=n}else m=fL(s,h,o);f.push(m),c=qd(c.length,l)}jd("sum",c,l);const[g,y]=Wd(m.shape,c);let b=g;a&&(b=Ud(g,u));const v=function(e,t,n,r){const s=xr(t),a=oL({inputs:{x:e},attrs:{shape:[xr(e.shape)/s,s]},backend:r}),i=hL(a,"float32","mean",r),o=oL({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),o}(m,y,b,o);for(const x of f)o.disposeIntermediateTensorInfo(x);return v}};const oV={kernelName:Wa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=Tr(a,s.shape);let u=l;const c=Gd(u,o);let h=s;null!=c&&(h=yL({inputs:{x:s},backend:n,attrs:{perm:c}}),u=qd(u.length,s.shape.length)),jd("min",u,o);const[d,p]=Wd(h.shape,u),f=oL({inputs:{x:h},backend:n,attrs:{shape:[-1,xr(p)]}}),m=hL(f,f.dtype,"min",n);let g;if(i){g=oL({inputs:{x:m},backend:n,attrs:{shape:Ud(d,l)}})}else g=oL({inputs:{x:m},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(h),g}},lV=ZM({opSnippet:MM+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+PM+"\n  return result;\n",cpuKernelImpl:WF}),uV={kernelName:Ua,backendName:"webgl",kernelFunc:lV};class cV{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,s=X_(r),a=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),l="reflect"===n?0:1;this.userCode=1!==r?`\n      ${s} start = ${s}(${a});\n      ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outC = getOutputCoords();\n        for (int i = 0; i < ${r}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${l};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};\n          }\n        }\n        ${s} coords = outC - start;\n        setOutput(getX(${o}));\n      }\n    `:`\n        int start = ${a};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${l};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${l};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class hV{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,s=X_(r),a=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=yM("rc",r),l=yM("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${l.slice(-2).join()})`,h="reflect"===n?0:1;let d="";if(1===r){const e=`\n        ${s} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${h};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${h};\n        }\n        source -= start;\n      `;d=`\n        ${s} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n      `}else{const e=`\n        ${s} source = rc;\n        ${s} lt = ${s}(lessThan(source, start));\n        ${s} gte = ${s}(greaterThanEqual(source, end));\n        ${s} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${h}) +\n                gte * ((end - 1) * 2 - source + ${h});\n        source -= start;\n      `;d=`\n        ${s} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n        rc = outputLoc;\n        ${o[r-2]} += 1;\n        if(${o[r-2]} < ${this.outputShape[r-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${l.join()}), ${c});\n          ${o[r-1]} += 1;\n          if(${u}) {\n            ${e}\n            result[3] = getChannel(getX(${l.join()}), ${c});\n          }\n        }\n      `}this.userCode=`\n      const ${s} start = ${s}(${a});\n      const ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${d}\n        setOutput(result);\n      }\n    `}}const dV={kernelName:ja,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e;const{x:s}=t,{paddings:a,mode:i}=r,o=Yr().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new hV(s.shape,a,i):new cV(s.shape,a,i);return n.runWebGLProgram(o,[s],s.dtype)}},pV=ZM({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+PM+"\n  return result;\n"}),fV={kernelName:Ga,backendName:"webgl",kernelFunc:pV};class mV{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}}const gV=ZM({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),yV={kernelName:Zs,backendName:"webgl",kernelFunc:gV},bV="return a - b;",vV=ZM({opSnippet:bV,packedOpSnippet:bV,supportsComplex:!0,cpuKernelImpl:hM}),xV={kernelName:Qi,backendName:"webgl",kernelFunc:vV};function wV(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:a}=r,i=Tr([a],s.shape),o=XB({inputs:{x:s},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),l=Ud(o.shape,i),u=oL({inputs:{x:o},backend:n,attrs:{shape:l}}),c=vV({inputs:{a:s,b:u},backend:n}),h=Bz({inputs:{x:c},backend:n}),d=mL({inputs:{x:h},backend:n,attrs:{axis:i,keepDims:!1}}),p=oL({inputs:{x:d},backend:n,attrs:{shape:l}}),f=gV({inputs:{a:h,b:p},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),f}const kV={kernelName:Li,backendName:"webgl",kernelFunc:wV};const SV={kernelName:Ha,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:i,normalized:o}=r,l=o?s:wV({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),u=l.shape[0],c=l.shape[1],h=new mV(u,c,a),d=[[i]],p=n.runWebGLProgram(h,[l],"int32",d);return o||n.disposeIntermediateTensorInfo(l),p}},NV=IM+"\n  return -x;\n";const IV={kernelName:Ka,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){const e=n.texData.get(r.dataId),[t,s]=jF(e.values,r.shape,r.dtype);return n.makeTensorInfo(s,r.dtype,t)}let s;return s=Yr().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new $M(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new NM(r.shape,NV),n.runWebGLProgram(s,[r],r.dtype)}},CV=Xm;const TV={kernelName:Qa,backendName:"webgl",kernelFunc:function(e){fo("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r,u=n.readSync(s.dataId),c=n.readSync(a.dataId),{selectedIndices:h}=CV(u,c,i,o,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},AV=Qm;const EV={kernelName:Ya,backendName:"webgl",kernelFunc:function(e){fo("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r,c=n.readSync(s.dataId),h=n.readSync(a.dataId),{selectedIndices:d,validOutputs:p}=AV(c,h,i,o,l,u);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},$V=Ym;const RV={kernelName:Za,backendName:"webgl",kernelFunc:function(e){fo("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r,c=n.readSync(s.dataId),h=n.readSync(a.dataId),d=i,p=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=$V(c,h,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};class DV{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}const OV={kernelName:ei,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{dtype:a,depth:i,onValue:o,offValue:l}=r,u=xr(s.shape),c=new DV(u,i,o,l),h=oL({inputs:{x:s},backend:n,attrs:{shape:[u]}}),d=n.runWebGLProgram(c,[h],a);n.disposeIntermediateTensorInfo(h);const p=oL({inputs:{x:d},backend:n,attrs:{shape:[...s.shape,i]}});return n.disposeIntermediateTensorInfo(d),p}};function _V(e){const{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){const e=wP({inputs:{input:r},backend:n}),t=_V({inputs:{x:e},backend:n}),s=MP({inputs:{input:r},backend:n}),a=_V({inputs:{x:s},backend:n}),i=WM({inputs:{real:t,imag:a},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),i}return Yz({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}const FV={kernelName:io,backendName:"webgl",kernelFunc:_V};const MV={kernelName:Ja,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:s}=n;if("string"===s.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===s.dtype){const t=wP({inputs:{input:s},backend:r}),n=e({inputs:{x:t},backend:r}),a=MP({inputs:{input:s},backend:r}),i=_V({inputs:{x:a},backend:r}),o=WM({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),o}return Yz({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:r})}};const LV={kernelName:ti,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(1===t.length)return Wz({inputs:{input:t[0]},backend:n,attrs:{dim:s}});const a=t[0].shape,i=t[0].dtype;t.forEach((e=>{br(a,e.shape,"All tensors passed to stack must have matching shapes"),yr(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const o=[],l=t.map((e=>{const t=Wz({inputs:{input:e},backend:n,attrs:{dim:s}});return o.push(t),t})),u=zP({inputs:l,backend:n,attrs:{axis:s}});return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}};class PV{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,s=X_(r),a=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${s} start = ${s}(${a});\n      ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${s} coords = outC - start;\n          setOutput(getX(${o}));\n        }\n      }\n    `:`\n        int start = ${a};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class zV{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,s=X_(r),a=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=yM("rc",r),l=yM("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${l.slice(-2).join()})`,h=[`${s} rc = outputLoc;`,`${o[r-1]} += 1;\n       if(${u}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${o[r-2]} += 1;\n       if(${o[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${o[r-1]} += 1;\n         if(${u}) {`],d=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let f=0,m=1===r?2:4;f<m;f++)p+=`\n        ${h[f]}\n        if (${d}) {\n          result[${f}] = float(value);\n        } else {\n          ${s} source = rc - start;\n          result[${f}] = getChannel(getX(${l.join()}), ${c});\n        }\n      `;p+=1===r?"} ":"}}",this.userCode=`\n      const ${s} start = ${s}(${a});\n      const ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}const BV=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,constantValue:i}=r;if(0===xr(s.shape)){const e=a.map(((e,t)=>e[0]+s.shape[t]+e[1]));return Yz({backend:n,attrs:{shape:e,value:i,dtype:s.dtype}})}const o=Yr().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new zV(s.shape,a,i):new PV(s.shape,a,i),l=[[i]];return n.runWebGLProgram(o,[s],s.dtype,l)},VV={kernelName:ni,backendName:"webgl",kernelFunc:BV},WV=ZM({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+PM+"\n  return result;\n"}),UV={kernelName:ri,backendName:"webgl",kernelFunc:WV};const jV={kernelName:ai,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=[],u=Tr(a,s.shape);let c=u;const h=Gd(c,o);let d,p=s;if(null!=h&&(p=yL({inputs:{x:s},backend:n,attrs:{perm:h}}),c=qd(c.length,o),l.push(p)),jd("prod",c,o),n.shouldExecuteOnCPU([p])){const e=n.texData.get(p.dataId).values,{outVals:t,outShape:r,outDtype:s}=HF(p.shape,p.dtype,e,c);d=n.makeTensorInfo(r,s,t)}else{const[e,t]=Wd(p.shape,c),r=xr(t),a=oL({inputs:{x:p},backend:n,attrs:{shape:[-1,r]}}),i=hL(a,fl(s.dtype),"prod",n);d=oL({inputs:{x:i},backend:n,attrs:{shape:e}}),l.push(a),l.push(i)}if(i){l.push(d);const e=Ud(d.shape,u);d=oL({inputs:{x:d},backend:n,attrs:{shape:e}})}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}};const GV={kernelName:ii,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:s,paramsDenseValues:a,indices:i}=t,{outputRaggedRank:o}=r,l=s.map((e=>n.readSync(e.dataId))),u=s.map((e=>e.shape)),c=n.readSync(a.dataId),h=n.readSync(i.dataId),[d,p,f]=qF(l,u,c,a.shape,a.dtype,h,i.shape,o),m=d.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,a.dtype,p);return m.concat([g])}};const HV={kernelName:oi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:r,limits:s,deltas:a}=t,i=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(a.dataId),[u,c]=KF(i,r.shape,r.dtype,o,s.shape,l,a.shape);return[n.makeTensorInfo([u.length],"int32",u),n.makeTensorInfo([c.length],r.dtype,c)]}};const qV={kernelName:li,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{shape:s,values:a,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.readSync(s.dataId),c=n.readSync(a.dataId),h=n.readSync(i.dataId),d=o.map((e=>n.readSync(e.dataId))),p=o.map((e=>e.shape)),[f,m]=XF(u,s.shape,c,a.shape,a.dtype,h,i.shape,d,p,l);return n.makeTensorInfo(f,a.dtype,m)}},KV=e=>{const{backend:t,attrs:n}=e,{start:r,stop:s,step:a,dtype:i}=n,o=QF(r,s,a,i);return t.makeTensorInfo([o.length],i,o)},XV={kernelName:ui,backendName:"webgl",kernelFunc:KV},QV=YM({opSnippet:"return 1.0 / x;"}),YV={kernelName:hi,backendName:"webgl",kernelFunc:QV},ZV=YM({opSnippet:IM+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),JV={kernelName:di,backendName:"webgl",kernelFunc:ZV},eW=YM({opSnippet:IM+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),tW={kernelName:bi,backendName:"webgl",kernelFunc:eW};class nW{constructor(e,t,n,r,s){this.variableNames=["A"],this.outputShape=[];const[a,i,o,l]=e;this.outputShape=[a,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let h;h=s?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class rW{constructor(e,t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,i,o,l]=e;this.outputShape=[a,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let h;h=s?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]},\n          ${u[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const sW={kernelName:gi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r,[l,u]=o,c=Yr().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new rW(s.shape,l,u,a,i):new nW(s.shape,l,u,a,i);return n.runWebGLProgram(c,[s],"float32")}};class aW{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,s]=t,[,a,i]=e,o=[n&&a>1?r-1:r,n&&i>1?s-1:s],l=[n&&a>1?a-1:a,n&&i>1?i-1:i],u=o[0]/l[0],c=o[1]/l[1],h=1/u,d=1/c,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${a}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const iW={kernelName:yi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=new aW(a.shape,s.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}};class oW{constructor(e,t,n,r,s){this.variableNames=["A"],this.outputShape=[];const[a,i,o,l]=e;this.outputShape=[a,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],h=r?"0.5":"0.0";let d;d=s?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${d};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class lW{constructor(e,t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,i,o,l]=e;this.outputShape=[a,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],h=r?"0.5":"0.0";let d;d=s?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]},\n          ${u[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${d};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const uW={kernelName:fi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r,[l,u]=o,c=Yr().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new lW(s.shape,l,u,a,i):new oW(s.shape,l,u,a,i);return n.runWebGLProgram(c,[s],s.dtype)}};class cW{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,s]=t,[,a,i]=e,o=[n&&a>1?r-1:r,n&&i>1?s-1:s],l=[n&&a>1?a-1:a,n&&i>1?i-1:i],u=o[0]/l[0],c=o[1]/l[1],h=1/u,d=1/c,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${a}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${o[0]}) *\n                (float(dyR) / float(${l[0]}));\n\n            float sourceFracCol =\n                float(${o[1]}) *\n                  (float(dyC) / float(${l[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${s}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const hW={kernelName:mi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=new cW(a.shape,s.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}};class dW{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);const r=e.map(((n,r)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - coords[${n}] - 1`:`coords[${n}]`)(r))).join(","),s=X_(n);this.userCode=`\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `}}class pW{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;const r=yM("rc",n),s=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,a=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,i=X_(n);function o(n){const r=e.map(((r,s)=>function(n,r){return-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - ${r[n]} - 1`:`${r[n]}`}(s,n)));return`getChannel(getX(${r.join(",")}), vec2(${r.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${s}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${i} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(e){return o(e)}(r.slice())};\n          if(${s}){\n            result.g = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",o(e)}(r.slice())};\n          }\n          if(${a}) {\n            result.b = ${function(e){return e[n-2]="("+e[n-2]+" + 1)",o(e)}(r.slice())};\n            if(${s}) {\n              result.a = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",o(e)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const fW={kernelName:vi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r,i=s.shape.length,o=Tr(a,s.shape);if(0===i)return BM({inputs:{x:s},backend:n});const l=Yr().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new pW(s.shape,o):new dW(s.shape,o);return n.runWebGLProgram(l,[s],s.dtype)}};class mW{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=e[1],r=e[2];this.outputShape=e;let s="";s="number"===typeof t?`float outputValue = ${t.toFixed(2)};`:`\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${s}\n          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const gW={kernelName:uo,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{image:s}=t,{radians:a,fillValue:i,center:o}=n,l=r,u=new mW(s.shape,i),[c,h]=Zg(o,s.shape[1],s.shape[2]),d=[[c,h,Math.sin(a),Math.cos(a)]];return l.runWebGLProgram(u,[s],s.dtype,d)}},yW=YM({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),bW={kernelName:xi,backendName:"webgl",kernelFunc:yW},vW=YM({opSnippet:"return inversesqrt(x);",cpuKernelImpl:YF}),xW={kernelName:wi,backendName:"webgl",kernelFunc:vW};class wW{constructor(e,t,n,r,s,a){let i=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;const o=X_(s.length),l=X_(a.length);let u="";1===n?u="i":2===n&&(u="i, j");const c=`getIndices(${u})`;let h="";1===r?h="i":2===r&&(h="i, coords[1]");const d=`getUpdates(${h})`;let p="";i&&(p="coords[0], coords[1]");const f=`getDefaultValue(${p})`,m=t>1?"strides[j]":"strides";this.userCode=`\n        ${o} strides = ${o}(${s});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(${c});\n              flattenedIndex += index * ${m};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${d};\n              found = true;\n            }\n          }\n          setOutput(mix(${f}, sum, float(found)));\n        }\n      `}}class kW{constructor(e,t,n,r,s,a){let i=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a;const o=X_(s.length),l=X_(a.length);let u="";1===n?u="i":2===n&&(u="i, j");const c=`getIndices(${u})`;let h="";1===r?h="i":2===r&&(h="i, coords[1]");const d=`getUpdates(${h})`;let p="";i&&(p="coords[0], coords[1]");const f=`getDefaultValue(${p})`,m=t>1?"strides[j]":"strides",g=t>1?"strides[j + 1]":"strides";this.userCode=`\n        ${o} strides = ${o}(${s});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${e}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${t}; j+=2) {\n              ivec4 index = round(${c});\n              flattenedIndex += index.xz * ${m};\n              if (j + 1 < ${t}) {\n                flattenedIndex += index.yw * ${g};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ${d};\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(${f}, sum, found));\n        }\n      `}}const SW={kernelName:ki,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:a}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=am(0,s,i),d=[h/u,u];if(0===h)return n.makeTensorInfo(i,s.dtype);const p=oL({inputs:{x:s},backend:n,attrs:{shape:[l,o]}}),f=oL({inputs:{x:a},backend:n,attrs:{shape:[l,u]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0]));let g;g=Yr().getBool("WEBGL_PACK")?new kW(l,o,p.shape.length,f.shape.length,c,d):new wW(l,o,p.shape.length,f.shape.length,c,d);const y=n.runWebGLProgram(g,[f,p,m],f.dtype),b=oL({inputs:{x:y},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(m),b}};class NW{constructor(e,t,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];const s=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,a=2===Yr().getNumber("WEBGL_VERSION")?"while (left < right) {":s,i="left"===r?"<":"<=";this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${a}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${i} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}const IW={kernelName:Ni,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:s,values:a}=t,{side:i}=r,o=new NW(s.shape[0],s.shape[1],a.shape[1],i),l=[[s.shape[1]]];return n.runWebGLProgram(o,[s,a],"int32",l)}};class CW{constructor(e,t,n){let r,s;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)s="resRC",r="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[],i=[];for(let r=0;r<t.length;r++)i.push(`${n[r]}`),r<e&&a.push(`${n[r]}`);r=a.join(),s=i.join()}const a=X_(n);this.userCode=`\n      void main() {\n        ${a} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${s}));\n        } else {\n          setOutput(getB(${s}));\n        }\n      }\n    `}}const TW={kernelName:Ii,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t,i=new CW(r.shape.length,s.shape,s.shape.length);return n.runWebGLProgram(i,[r,s,a],pl(s.dtype,a.dtype))}},AW=YM({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${ay};\n  float scale = ${iy};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),EW={kernelName:Ci,backendName:"webgl",kernelFunc:AW},$W=YM({opSnippet:QM+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:JF}),RW={kernelName:Ri,backendName:"webgl",kernelFunc:$W},DW=YM({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),OW={kernelName:$i,backendName:"webgl",kernelFunc:DW},_W=YM({opSnippet:QM+"\n  return sin(x);\n",packedOpSnippet:`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${PM}\n  return result;\n`}),FW={kernelName:Ai,backendName:"webgl",kernelFunc:_W},MW=YM({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),LW={kernelName:Ei,backendName:"webgl",kernelFunc:MW},PW=YM({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),zW={kernelName:Di,backendName:"webgl",kernelFunc:PW},BW={kernelName:Fi,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:i}=r;yr(s.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const o=a.reduce(((e,t)=>e*t)),l=[[0,0]];l.push(...i);for(let y=1+a.length;y<s.shape.length;++y)l.push([0,0]);const u=[],c=BV({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),h=Jg(c.shape,a,o,!1),d=ey(h.length,a.length,!1),p=ty(c.shape,a,o,!1),f=oL({inputs:{x:c},backend:n,attrs:{shape:h}}),m=yL({inputs:{x:f},backend:n,attrs:{perm:d}}),g=oL({inputs:{x:m},backend:n,attrs:{shape:p}});return u.push(c),u.push(f),u.push(m),u.forEach((e=>n.disposeIntermediateTensorInfo(e))),g}};const VW={kernelName:Pi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:a,defaultValue:i}=t;if(1!==a.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${a.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n         ${s.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const o=n.readSync(r.dataId),l=n.readSync(s.dataId),u=n.readSync(a.dataId),c=n.readSync(i.dataId)[0],[h,d,p,f,m]=nM(o,r.shape,r.dtype,l,s.dtype,u,c);return[n.makeTensorInfo(d,r.dtype,h),n.makeTensorInfo([d[0]],s.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}};const WW={kernelName:zi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:a}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(1!==a.shape.length)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const i=Array.from(n.readSync(s.dataId)),o=n.readSync(r.dataId),l=Array.from(n.readSync(a.dataId)),[u,c,h]=rM(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([h.length],a.dtype,new Int32Array(h))]}};const UW={kernelName:Bi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${s.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${a.shape}`);const i=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(a.dataId),[u,c]=sM(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}};const jW={kernelName:Vi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${s.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${a.shape}`);const i=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(a.dataId),[u,c]=sM(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}};const GW={kernelName:Wi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:d}=am(0,s,o),p=!1;if("string"===a.dtype){const e=n.bufferSync(s),t=n.bufferSync(a),r=Uo(n.readSync(i.dataId)[0]),f=ZF(e,t,o,d,c,u,l,h,r,p);return n.makeTensorInfo(o,f.dtype,f.values)}const f=new wW(u,l,s.shape.length,a.shape.length,h,[d,1],p),m=n.runWebGLProgram(f,[a,s,i],a.dtype),g=oL({inputs:{x:m},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(m),g}};const HW={kernelName:Mi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:i}=r,o=Tr(i,s.shape)[0],l=Ry(s,a,o),u=s.shape.length,c=new Array(u).fill(0),h=s.shape.slice();return l.map((e=>{const t=[...h];t[o]=e;const r=pP({inputs:{x:s},backend:n,attrs:{begin:c,size:t}});return c[o]+=e,r}))}},qW="return sqrt(x);",KW=YM({opSnippet:qW,packedOpSnippet:qW,cpuKernelImpl:aM}),XW={kernelName:Oi,backendName:"webgl",kernelFunc:KW},QW={kernelName:ji,backendName:"webgl",kernelFunc:YM({opSnippet:"return x * x;"})},YW="return (a - b) * (a - b);",ZW=ZM({opSnippet:YW,packedOpSnippet:YW}),JW={kernelName:Ui,backendName:"webgl",kernelFunc:ZW};const eU={kernelName:Gi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");const a=qy(n.readSync(s.dataId)),i=iM(a,"string",r);return n.makeTensorInfo(s.shape,"string",i)}};const tU={kernelName:oo,backendName:"webgl",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e;const{x:s}=t,a=IM+`\n    return x > 0.0 ? 1.0 : float(${n.alpha});\n  `,i=new NM(s.shape,a);return r.runWebGLProgram(i,[s],s.dtype)}};class nU{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,s=X_(n.length),a=X_(n.length);let i="";if(1===r)i="coords * strides + begin";else{let e=0;i=n.map(((t,r)=>(e++,1===n.length?`coords * strides[${r}] + begin[${r}]`:`coords[${e-1}] * strides[${r}] + begin[${r}]`))).join(",")}this.userCode=`\n      ${s} begin = ${s}(${e});\n      ${s} strides = ${s}(${t});\n\n      void main() {\n        ${a} coords = getOutputCoords();\n        setOutput(getX(${i}));\n      }\n    `}}const rU={kernelName:Hi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=r,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:v,strides:x}=yh(s.shape,a,i,o,l,u,c,h,d);let w;if(m)w=oL({inputs:{x:s},backend:n,attrs:{shape:f}});else if(g||y){yr(s.shape.length>=1,(()=>`Input must have rank at least 1, got: ${s.shape.length}`));const e=sh(b,v,x),t=pP({inputs:{x:s},backend:n,attrs:{begin:b,size:e}});w=oL({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{if(n.shouldExecuteOnCPU([s])){const e=n.readSync(s.dataId),t=Zu(s.shape,s.dtype,e),r=oM(p,t,x,b);w=n.makeTensorInfo(f,s.dtype,r.values)}else{const e=new nU(b,x,p);w=n.runWebGLProgram(e,[s],s.dtype)}}const k=oL({inputs:{x:w},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(w),k}};const sU={kernelName:qi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:a,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:h}=t,d=n.readSync(c.dataId),p=n.readSync(h.dataId),[f,m]=lM(d,p,s,a,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}};const aU={kernelName:Ki,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:a,delimiter:i}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(1!==a.shape.length)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=n.readSync(a.dataId),l=n.readSync(i.dataId)[0],[u,c,h]=uM(o,l,s),d=c.length;return[n.makeTensorInfo([d,2],"int32",u),n.makeTensorInfo([d],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(h))]}};const iU={kernelName:Xi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:a}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=n.readSync(a.dataId),o=cM(i,s);return n.makeTensorInfo(a.shape,"int32",o)}},oU=YM({opSnippet:"return tan(x);"}),lU={kernelName:Yi,backendName:"webgl",kernelFunc:oU},uU=YM({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),cU={kernelName:Zi,backendName:"webgl",kernelFunc:uU};const hU={kernelName:Si,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{tensor:s,indices:a,updates:i}=t,{}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=am(0,a,s.shape),d=[h/u,u];if(0===h)return n.makeTensorInfo(s.shape,a.dtype);const p=oL({inputs:{x:a},backend:n,attrs:{shape:[l,o]}}),f=oL({inputs:{x:i},backend:n,attrs:{shape:[l,u]}}),m=oL({inputs:{x:s},backend:n,attrs:{shape:d}}),g=new wW(l,o,p.shape.length,f.shape.length,c,d,!1,!0),y=n.runWebGLProgram(g,[f,p,m],m.dtype),b=oL({inputs:{x:y},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),b}};class dU{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[a]*t[a];this.outputShape=n,this.rank=n.length;const r=X_(this.rank),s=function(e){const t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<e.length;s++)r.push(`imod(${n[s]}, ${e[s]})`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${s}));\n      }\n    `}}function pU(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:a}=r;if("string"===s.dtype||s.shape.length>5){const e=n.readSync(s.dataId),t="string"===s.dtype?e.map((e=>Uo(e))):e,r=Zu(s.shape,s.dtype,t),i=dM(r,a);return n.makeTensorInfo(i.shape,i.dtype,i.values)}const i=new dU(s.shape,a);return n.runWebGLProgram(i,[s],s.dtype)}const fU={kernelName:Ji,backendName:"webgl",kernelFunc:pU};class mU{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class gU{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function yU(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function bU(e){let t=1;for(;t<e;)t*=2;return t}const vU={kernelName:eo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:a,sorted:i}=r,o=Yr().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=Yr().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=s.shape,c=u[u.length-1];if(n.shouldExecuteOnCPU([s])||c<o||a>l){const e=n.readSync(s.dataId),[t,r]=pM(e,u,s.dtype,a,i);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(r.shape,r.dtype,r.values)]}if(0===a)return u[u.length-1]=0,[n.makeTensorInfo(u,s.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(1===c)return[s,Yz({attrs:{shape:u,dtype:"int32",value:0},backend:n})];const h=n.texData.get(s.dataId),d=null!==h&&h.isPacked,p=d?n.unpackTensor(s):s,f=xr(u)/c,m=oL({inputs:{x:p},attrs:{shape:[f,c]},backend:n});d&&yU(n,p);const g=bU(a),y=bU(c);let b=null;const v=()=>null===b?[m,m]:[m,b],x=(e,t,r)=>{const s=v(),a=new mU(r),i=[[c],[null===b?1:0],[Number.NEGATIVE_INFINITY],[e],[t]],o=b;b=n.runWebGLProgram(a,s,"int32",i),yU(n,o)};for(let I=1;I<g;I*=2){const e=2*I;for(let t=I;t>=1;t/=2)x(e,t,[f,y])}for(let I=y;I>g;I/=2){const e=v(),t=new gU([f,I/2]),r=[[c],[null===b?1:0],[g]],s=b;b=n.runWebGLProgram(t,e,"int32",r),yU(n,s);const a=g/2,i=2*a;for(let n=a;n>=1;n/=2)x(i,n,b.shape)}let w=b;b=pP({inputs:{x:b},backend:n,attrs:{begin:0,size:[f,a]}}),yU(n,w);let k=gB({inputs:{x:m,indices:b},backend:n,attrs:{axis:1,batchDims:1}});yU(n,m);const S=u.slice(0,-1);S.push(a),w=b,b=oL({inputs:{x:b},attrs:{shape:S},backend:n}),yU(n,w);const N=k;return k=oL({inputs:{x:k},attrs:{shape:S},backend:n}),yU(n,N),[k,b]}};class xU{constructor(e,t,n,r,s,a){this.variableNames=["Image","Transforms"],this.outputShape=a;const i="nearest"===n?1:2;let o;switch(r){case"constant":default:o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${o} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${s});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${s});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${i} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const wU={kernelName:to,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:s,transforms:a}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=r,[c,h,d,p]=s.shape,[f,m]=null!=u?u:[h,d],g=new xU(h,d,i,o,l,[c,f,m,p]);return n.runWebGLProgram(g,[s,a],"float32")}};const kU={kernelName:ro,backendName:"webgl",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t;$_(a,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=r.readSync(a.dataId),{outputValues:o,outputShape:l,indices:u}=mM(i,s,a.shape,a.dtype);return[r.makeTensorInfo(l,a.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}};const SU={kernelName:so,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:s}=t;let{axis:a}=r;a<0&&(a+=s.shape.length);const i=s,o=i.shape.length,l=s.shape[a],u=new Array(o-1);let c=0;for(let m=0;m<o;m++)m!==a&&(u[c++]=i.shape[m]);const h=[],d=new Array(o).fill(0),p=i.shape.slice();p[a]=1;const f=new Array(l);for(let m=0;m<f.length;m++){d[a]=m;const e=pP({inputs:{x:i},backend:n,attrs:{begin:d,size:p}}),t=oL({inputs:{x:e},backend:n,attrs:{shape:u}});f[m]=t,h.push(e)}return h.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}};class NU{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,r=e.batchSize,s=e.inSize,a=e.numSegments,i=a*Math.ceil(s/n);this.outputShape=[r,i];const o=4*Math.floor(n/4),l=n%4,u="\n        sumValue += dot(values, segFilter);\n    ";let c="";s%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `);let h="";s%n>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${h}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${a})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${a})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${1===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${u}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${u}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}const IU={kernelName:ao,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:a}=t,{numSegments:i}=r,o=s.shape.length,l=[];let u=0;const c=Gd([u],o);let h=s;null!=c&&(h=yL({inputs:{x:s},backend:n,attrs:{perm:c}}),l.push(h),u=qd(1,o)[0]);const d=Gy(h.shape,u,i),p=xr([h.shape[u]]),f=oL({inputs:{x:h},backend:n,attrs:{shape:[-1,p]}});l.push(f);const m=fl(s.dtype),g=(e,t,r,s,a)=>{const i=e.shape[0],o=e.shape[1],u=jy(o,a),c=new NU({windowSize:u,inSize:o,batchSize:i,numSegments:a},t),h=n.compileAndRun(c,[e,r],s);if(l.push(h),h.shape[1]===a)return h;const d=KV({backend:n,attrs:{start:0,stop:a,step:1,dtype:"float32"}}),p=pU({inputs:{x:d},backend:n,attrs:{reps:[o/u]}});l.push(d),l.push(p);return g(h,t,p,s,a)},y=oL({inputs:{x:g(f,"unsortedSegmentSum",a,m,i)},backend:n,attrs:{shape:d}});let b=y;if(null!=c){l.push(y);const e=Hd(c);b=yL({inputs:{x:b},backend:n,attrs:{perm:e}})}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),b}},CU=[xL,kL,NL,CL,EL,DL,OL,_L,BL,VL,UL,GL,qL,XL,YL,eP,tP,sP,aP,iP,uP,mP,gP,yP,bP,SP,CP,EP,UM,DP,BP,KP,JP,tz,nz,rz,sz,iz,lz,cz,gz,yz,bz,xz,Sz,Cz,Tz,Ez,Rz,Dz,_z,Fz,Lz,zz,Vz,Uz,Hz,Xz,Zz,eB,rB,aB,lB,hB,dB,fB,yB,vB,wB,VM,kB,LP,NB,CB,AB,HM,$B,DB,OB,FB,LB,zB,VB,UB,HB,KB,QB,ZB,JB,eV,rV,sV,aV,iV,oV,uV,dV,fV,SV,iL,IV,TV,EV,RV,xP,OV,MV,LV,VV,UV,XM,jV,GV,HV,qV,XV,kP,yV,YV,JV,tW,lL,sW,iW,uW,hW,fW,gW,bW,xW,SW,IW,TW,EW,RW,OW,FW,LW,fP,kV,zW,BW,VW,WW,UW,jW,GW,HW,XW,QW,JW,eU,tU,rU,sU,aU,iU,xV,gL,lU,cU,hU,fU,vU,wU,bL,kU,SU,IU,FV];for(const n of CU)wo(n);const TU=128,AU=()=>{const[e,t]=(0,T.useState)(null),[n,r]=(0,T.useState)({}),[s,a]=(0,T.useState)(""),[i,o]=(0,T.useState)(null);(0,T.useEffect)((()=>{(async()=>{try{const e=await PC("/tfjs_model/model.json");console.log("\u2705 Model loaded"),t(e);const n=await fetch("/label_map.json"),s=await n.json();console.log("\u2705 Label map loaded",s),r(s)}catch($9){console.error("\u274c Failed to load model or label map",$9)}})()}),[]);const l=async()=>{if(!e||!s.trim())return;const{input_ids:t,attention_mask:r,token_type_ids:a}=(e=>{const t=e.trim().toLowerCase().split(/\s+/).map((e=>e.length)).slice(0,TU),n=new Array(TU).fill(0),r=new Array(TU).fill(0),s=new Array(TU).fill(0);for(let a=0;a<t.length;a++)n[a]=t[a],r[a]=1;return{input_ids:Bl([n],[1,TU],"int32"),attention_mask:Bl([r],[1,TU],"int32"),token_type_ids:Bl([s],[1,TU],"int32")}})(s);try{const s=await e.executeAsync({input_ids:t,attention_mask:r,token_type_ids:a}),i=Array.isArray(s)?s[0].arraySync()[0]:s.arraySync()[0],l=i.indexOf(Math.max(...i)),u=n[l]||`Class ${l}`;o(u),Hl([t,r,a,s])}catch($9){console.error("\u274c Model execution error:",$9),alert("Model execution failed. See console for details.")}};return(0,tr.jsxs)("div",{className:"p-4 max-w-xl mx-auto",children:[(0,tr.jsx)("h2",{className:"text-xl mb-4",children:"IAB Text Classifier"}),(0,tr.jsx)("input",{type:"text",value:s,onChange:e=>a(e.target.value),onKeyDown:e=>{"Enter"===e.key&&l()},placeholder:"Type some text...",className:"w-full p-2 border border-gray-300 rounded mb-2"}),(0,tr.jsx)("button",{onClick:l,className:"bg-blue-600 text-white px-4 py-2 rounded",children:"Classify"}),i&&(0,tr.jsxs)("div",{className:"mt-4 text-lg",children:[(0,tr.jsx)("strong",{children:"Predicted IAB category:"})," ",i]})]})};const EU=function(){const{t:e}=ln(),[t,n]=(0,T.useState)(!1),[r,s]=(0,T.useState)("w-0");(0,T.useEffect)((()=>{if(t){const e=setTimeout((()=>{s("w-11/12")}),100);return()=>clearTimeout(e)}}),[t]);const[a,i]=(0,T.useState)(!1);return(0,T.useEffect)((()=>{const e=setInterval((()=>{i((e=>!e))}),1e3);return()=>clearInterval(e)}),[]),(0,tr.jsxs)("div",{className:"bg-slate-50 flex flex-col space-y-4 items-center content-start text-center w-full py-12 px-5",children:[(0,tr.jsx)("img",{src:lr,className:"max-w-full transition-transform duration-1000 ease-in-out "+(a?"translate-y-0":"translate-y-1"),alt:"logo"}),(0,tr.jsxs)("div",{className:"min-h-32 flex flex-col space-y-4 items-center content-start",children:[(0,tr.jsx)("p",{className:"font-mono font-semibold text-2xl",children:(0,tr.jsx)(ur,{words:[e("Visualise your internet footprint!")],speed:60,delay:50,disableSpaces:!0,onComplete:()=>n(!0)})}),(0,tr.jsx)("div",{className:`bg-slate-500 h-0.5 transition-all duration-1000 max-w-80 ease-in-out ${r}`}),t&&(0,tr.jsx)("p",{className:"font-mono font-semibold text-base",children:(0,tr.jsx)(ur,{words:["Coming"," soon",".",".","."],speed:40,delay:50,disableSpaces:!0,disableCursor:!0})})]}),(0,tr.jsx)(St,{to:"/datasets",className:"block py-2 px-4 text-lg font-mono font-semibold text-white no-underline hover:text-sky-950 hover:italic",children:"Go to Datasets "}),(0,tr.jsx)(AU,{})]})},$U=()=>(0,tr.jsx)("h1",{children:"About Page"}),RU=(0,T.createContext)(),DU=e=>{let{children:t}=e;const[n,r]=(0,T.useState)(null);return(0,tr.jsx)(RU.Provider,{value:{dataset:n,setDataset:r},children:t})},OU=()=>(0,T.useContext)(RU),_U=(0,T.createContext)({});function FU(e){const t=(0,T.useRef)(null);return null===t.current&&(t.current=e()),t.current}const MU="undefined"!==typeof window,LU=MU?T.useLayoutEffect:T.useEffect,PU=(0,T.createContext)(null);function zU(e){return"object"===typeof e&&null!==e}function BU(e){return zU(e)&&"offsetHeight"in e}const VU=(0,T.createContext)({transformPagePoint:e=>e,isStatic:!1,reducedMotion:"never"});class WU extends T.Component{getSnapshotBeforeUpdate(e){const t=this.props.childRef.current;if(t&&e.isPresent&&!this.props.isPresent){const e=t.offsetParent,n=BU(e)&&e.offsetWidth||0,r=this.props.sizeRef.current;r.height=t.offsetHeight||0,r.width=t.offsetWidth||0,r.top=t.offsetTop,r.left=t.offsetLeft,r.right=n-r.width-r.left}return null}componentDidUpdate(){}render(){return this.props.children}}function UU(e){let{children:t,isPresent:n,anchorX:r,root:s}=e;const a=(0,T.useId)(),i=(0,T.useRef)(null),o=(0,T.useRef)({width:0,height:0,top:0,left:0,right:0}),{nonce:l}=(0,T.useContext)(VU);return(0,T.useInsertionEffect)((()=>{const{width:e,height:t,top:u,left:c,right:h}=o.current;if(n||!i.current||!e||!t)return;const d="left"===r?`left: ${c}`:`right: ${h}`;i.current.dataset.motionPopId=a;const p=document.createElement("style");l&&(p.nonce=l);const f=s??document.head;return f.appendChild(p),p.sheet&&p.sheet.insertRule(`\n          [data-motion-pop-id="${a}"] {\n            position: absolute !important;\n            width: ${e}px !important;\n            height: ${t}px !important;\n            ${d}px !important;\n            top: ${u}px !important;\n          }\n        `),()=>{f.removeChild(p),f.contains(p)&&f.removeChild(p)}}),[n]),(0,tr.jsx)(WU,{isPresent:n,childRef:i,sizeRef:o,children:T.cloneElement(t,{ref:i})})}const jU=e=>{let{children:t,initial:n,isPresent:r,onExitComplete:s,custom:a,presenceAffectsLayout:i,mode:o,anchorX:l,root:u}=e;const c=FU(GU),h=(0,T.useId)();let d=!0,p=(0,T.useMemo)((()=>(d=!1,{id:h,initial:n,isPresent:r,custom:a,onExitComplete:e=>{c.set(e,!0);for(const t of c.values())if(!t)return;s&&s()},register:e=>(c.set(e,!1),()=>c.delete(e))})),[r,c,s]);return i&&d&&(p={...p}),(0,T.useMemo)((()=>{c.forEach(((e,t)=>c.set(t,!1)))}),[r]),T.useEffect((()=>{!r&&!c.size&&s&&s()}),[r]),"popLayout"===o&&(t=(0,tr.jsx)(UU,{isPresent:r,anchorX:l,root:u,children:t})),(0,tr.jsx)(PU.Provider,{value:p,children:t})};function GU(){return new Map}function HU(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];const t=(0,T.useContext)(PU);if(null===t)return[!0,null];const{isPresent:n,onExitComplete:r,register:s}=t,a=(0,T.useId)();(0,T.useEffect)((()=>{if(e)return s(a)}),[e]);const i=(0,T.useCallback)((()=>e&&r&&r(a)),[a,r,e]);return!n&&r?[!1,i]:[!0]}const qU=e=>e.key||"";function KU(e){const t=[];return T.Children.forEach(e,(e=>{(0,T.isValidElement)(e)&&t.push(e)})),t}const XU=e=>{let{children:t,custom:n,initial:r=!0,onExitComplete:s,presenceAffectsLayout:a=!0,mode:i="sync",propagate:o=!1,anchorX:l="left",root:u}=e;const[c,h]=HU(o),d=(0,T.useMemo)((()=>KU(t)),[t]),p=o&&!c?[]:d.map(qU),f=(0,T.useRef)(!0),m=(0,T.useRef)(d),g=FU((()=>new Map)),[y,b]=(0,T.useState)(d),[v,x]=(0,T.useState)(d);LU((()=>{f.current=!1,m.current=d;for(let e=0;e<v.length;e++){const t=qU(v[e]);p.includes(t)?g.delete(t):!0!==g.get(t)&&g.set(t,!1)}}),[v,p.length,p.join("-")]);const w=[];if(d!==y){let e=[...d];for(let t=0;t<v.length;t++){const n=v[t],r=qU(n);p.includes(r)||(e.splice(t,0,n),w.push(n))}return"wait"===i&&w.length&&(e=w),x(KU(e)),b(d),null}const{forceRender:k}=(0,T.useContext)(_U);return(0,tr.jsx)(tr.Fragment,{children:v.map((e=>{const t=qU(e),y=!(o&&!c)&&(d===v||p.includes(t));return(0,tr.jsx)(jU,{isPresent:y,initial:!(f.current&&!r)&&void 0,custom:n,presenceAffectsLayout:a,mode:i,root:u,onExitComplete:y?void 0:()=>{if(!g.has(t))return;g.set(t,!0);let e=!0;g.forEach((t=>{t||(e=!1)})),e&&(k?.(),x(m.current),o&&h?.(),s&&s())},anchorX:l,children:e},t)}))})};function QU(e){if("undefined"===typeof Proxy)return e;const t=new Map;return new Proxy((function(){return e(...arguments)}),{get:(n,r)=>"create"===r?e:(t.has(r)||t.set(r,e(r)),t.get(r))})}function YU(e){return null!==e&&"object"===typeof e&&"function"===typeof e.start}function ZU(e){const t=[{},{}];return e?.values.forEach(((e,n)=>{t[0][n]=e.get(),t[1][n]=e.getVelocity()})),t}function JU(e,t,n,r){if("function"===typeof t){const[s,a]=ZU(r);t=t(void 0!==n?n:e.custom,s,a)}if("string"===typeof t&&(t=e.variants&&e.variants[t]),"function"===typeof t){const[s,a]=ZU(r);t=t(void 0!==n?n:e.custom,s,a)}return t}function ej(e,t,n){const r=e.getProps();return JU(r,t,void 0!==n?n:r.custom,e)}function tj(e,t){return e?.[t]??e?.default??e}const nj=e=>e,rj={},sj=["setup","read","resolveKeyframes","preUpdate","update","preRender","render","postRender"],aj={value:null,addProjectionMetrics:null};function ij(e,t){let n=!1,r=!0;const s={delta:0,timestamp:0,isProcessing:!1},a=()=>n=!0,i=sj.reduce(((e,n)=>(e[n]=function(e,t){let n=new Set,r=new Set,s=!1,a=!1;const i=new WeakSet;let o={delta:0,timestamp:0,isProcessing:!1},l=0;function u(t){i.has(t)&&(c.schedule(t),e()),l++,t(o)}const c={schedule:function(e){const t=arguments.length>2&&void 0!==arguments[2]&&arguments[2]&&s?n:r;return arguments.length>1&&void 0!==arguments[1]&&arguments[1]&&i.add(e),t.has(e)||t.add(e),e},cancel:e=>{r.delete(e),i.delete(e)},process:e=>{o=e,s?a=!0:(s=!0,[n,r]=[r,n],n.forEach(u),t&&aj.value&&aj.value.frameloop[t].push(l),l=0,n.clear(),s=!1,a&&(a=!1,c.process(e)))}};return c}(a,t?n:void 0),e)),{}),{setup:o,read:l,resolveKeyframes:u,preUpdate:c,update:h,preRender:d,render:p,postRender:f}=i,m=()=>{const a=rj.useManualTiming?s.timestamp:performance.now();n=!1,rj.useManualTiming||(s.delta=r?1e3/60:Math.max(Math.min(a-s.timestamp,40),1)),s.timestamp=a,s.isProcessing=!0,o.process(s),l.process(s),u.process(s),c.process(s),h.process(s),d.process(s),p.process(s),f.process(s),s.isProcessing=!1,n&&t&&(r=!1,e(m))},g=sj.reduce(((t,a)=>{const o=i[a];return t[a]=function(t){let a=arguments.length>1&&void 0!==arguments[1]&&arguments[1],i=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return n||(n=!0,r=!0,s.isProcessing||e(m)),o.schedule(t,a,i)},t}),{});return{schedule:g,cancel:e=>{for(let t=0;t<sj.length;t++)i[sj[t]].cancel(e)},state:s,steps:i}}const{schedule:oj,cancel:lj,state:uj,steps:cj}=ij("undefined"!==typeof requestAnimationFrame?requestAnimationFrame:nj,!0),hj=["transformPerspective","x","y","z","translateX","translateY","translateZ","scale","scaleX","scaleY","rotate","rotateX","rotateY","rotateZ","skew","skewX","skewY"],dj=(()=>new Set(hj))(),pj=new Set(["width","height","top","left","right","bottom",...hj]);function fj(e,t){-1===e.indexOf(t)&&e.push(t)}function mj(e,t){const n=e.indexOf(t);n>-1&&e.splice(n,1)}class gj{constructor(){this.subscriptions=[]}add(e){return fj(this.subscriptions,e),()=>mj(this.subscriptions,e)}notify(e,t,n){const r=this.subscriptions.length;if(r)if(1===r)this.subscriptions[0](e,t,n);else for(let s=0;s<r;s++){const r=this.subscriptions[s];r&&r(e,t,n)}}getSize(){return this.subscriptions.length}clear(){this.subscriptions.length=0}}function yj(e,t){return t?e*(1e3/t):0}let bj;function vj(){bj=void 0}const xj={now:()=>(void 0===bj&&xj.set(uj.isProcessing||rj.useManualTiming?uj.timestamp:performance.now()),bj),set:e=>{bj=e,queueMicrotask(vj)}},wj={current:void 0};class kj{constructor(e){var t=this;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.canTrackVelocity=null,this.events={},this.updateAndNotify=function(e){let n=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const r=xj.now();if(t.updatedAt!==r&&t.setPrevFrameValue(),t.prev=t.current,t.setCurrent(e),t.current!==t.prev&&(t.events.change?.notify(t.current),t.dependents))for(const s of t.dependents)s.dirty();n&&t.events.renderRequest?.notify(t.current)},this.hasAnimated=!1,this.setCurrent(e),this.owner=n.owner}setCurrent(e){this.current=e,this.updatedAt=xj.now(),null===this.canTrackVelocity&&void 0!==e&&(this.canTrackVelocity=(e=>!isNaN(parseFloat(e)))(this.current))}setPrevFrameValue(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.current;this.prevFrameValue=e,this.prevUpdatedAt=this.updatedAt}onChange(e){return this.on("change",e)}on(e,t){this.events[e]||(this.events[e]=new gj);const n=this.events[e].add(t);return"change"===e?()=>{n(),oj.read((()=>{this.events.change.getSize()||this.stop()}))}:n}clearListeners(){for(const e in this.events)this.events[e].clear()}attach(e,t){this.passiveEffect=e,this.stopPassiveEffect=t}set(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];t&&this.passiveEffect?this.passiveEffect(e,this.updateAndNotify):this.updateAndNotify(e,t)}setWithVelocity(e,t,n){this.set(t),this.prev=void 0,this.prevFrameValue=e,this.prevUpdatedAt=this.updatedAt-n}jump(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];this.updateAndNotify(e),this.prev=e,this.prevUpdatedAt=this.prevFrameValue=void 0,t&&this.stop(),this.stopPassiveEffect&&this.stopPassiveEffect()}dirty(){this.events.change?.notify(this.current)}addDependent(e){this.dependents||(this.dependents=new Set),this.dependents.add(e)}removeDependent(e){this.dependents&&this.dependents.delete(e)}get(){return wj.current&&wj.current.push(this),this.current}getPrevious(){return this.prev}getVelocity(){const e=xj.now();if(!this.canTrackVelocity||void 0===this.prevFrameValue||e-this.updatedAt>30)return 0;const t=Math.min(this.updatedAt-this.prevUpdatedAt,30);return yj(parseFloat(this.current)-parseFloat(this.prevFrameValue),t)}start(e){return this.stop(),new Promise((t=>{this.hasAnimated=!0,this.animation=e(t),this.events.animationStart&&this.events.animationStart.notify()})).then((()=>{this.events.animationComplete&&this.events.animationComplete.notify(),this.clearAnimation()}))}stop(){this.animation&&(this.animation.stop(),this.events.animationCancel&&this.events.animationCancel.notify()),this.clearAnimation()}isAnimating(){return!!this.animation}clearAnimation(){delete this.animation}destroy(){this.dependents?.clear(),this.events.destroy?.notify(),this.clearListeners(),this.stop(),this.stopPassiveEffect&&this.stopPassiveEffect()}}function Sj(e,t){return new kj(e,t)}const Nj=e=>Array.isArray(e);function Ij(e,t,n){e.hasValue(t)?e.getValue(t).set(n):e.addValue(t,Sj(n))}const Cj=e=>Boolean(e&&e.getVelocity);function Tj(e,t){const n=e.getValue("willChange");if(function(e){return Boolean(Cj(e)&&e.add)}(n))return n.add(t);if(!n&&rj.WillChange){const n=new rj.WillChange("auto");e.addValue("willChange",n),n.add(t)}}const Aj=e=>e.replace(/([a-z])([A-Z])/gu,"$1-$2").toLowerCase(),Ej="data-"+Aj("framerAppearId");function $j(e){return e.props[Ej]}const Rj=(e,t)=>n=>t(e(n)),Dj=function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return t.reduce(Rj)},Oj=(e,t,n)=>n>t?t:n<e?e:n,_j=e=>1e3*e,Fj=e=>e/1e3,Mj={layout:0,mainThread:0,waapi:0};const Lj=e=>t=>"string"===typeof t&&t.startsWith(e),Pj=Lj("--"),zj=Lj("var(--"),Bj=e=>!!zj(e)&&Vj.test(e.split("/*")[0].trim()),Vj=/var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu,Wj={test:e=>"number"===typeof e,parse:parseFloat,transform:e=>e},Uj={...Wj,transform:e=>Oj(0,1,e)},jj={...Wj,default:1},Gj=e=>Math.round(1e5*e)/1e5,Hj=/-?(?:\d+(?:\.\d+)?|\.\d+)/gu;const qj=/^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu,Kj=(e,t)=>n=>Boolean("string"===typeof n&&qj.test(n)&&n.startsWith(e)||t&&!function(e){return null==e}(n)&&Object.prototype.hasOwnProperty.call(n,t)),Xj=(e,t,n)=>r=>{if("string"!==typeof r)return r;const[s,a,i,o]=r.match(Hj);return{[e]:parseFloat(s),[t]:parseFloat(a),[n]:parseFloat(i),alpha:void 0!==o?parseFloat(o):1}},Qj={...Wj,transform:e=>Math.round((e=>Oj(0,255,e))(e))},Yj={test:Kj("rgb","red"),parse:Xj("red","green","blue"),transform:e=>{let{red:t,green:n,blue:r,alpha:s=1}=e;return"rgba("+Qj.transform(t)+", "+Qj.transform(n)+", "+Qj.transform(r)+", "+Gj(Uj.transform(s))+")"}};const Zj={test:Kj("#"),parse:function(e){let t="",n="",r="",s="";return e.length>5?(t=e.substring(1,3),n=e.substring(3,5),r=e.substring(5,7),s=e.substring(7,9)):(t=e.substring(1,2),n=e.substring(2,3),r=e.substring(3,4),s=e.substring(4,5),t+=t,n+=n,r+=r,s+=s),{red:parseInt(t,16),green:parseInt(n,16),blue:parseInt(r,16),alpha:s?parseInt(s,16)/255:1}},transform:Yj.transform},Jj=e=>({test:t=>"string"===typeof t&&t.endsWith(e)&&1===t.split(" ").length,parse:parseFloat,transform:t=>`${t}${e}`}),eG=Jj("deg"),tG=Jj("%"),nG=Jj("px"),rG=Jj("vh"),sG=Jj("vw"),aG=(()=>({...tG,parse:e=>tG.parse(e)/100,transform:e=>tG.transform(100*e)}))(),iG={test:Kj("hsl","hue"),parse:Xj("hue","saturation","lightness"),transform:e=>{let{hue:t,saturation:n,lightness:r,alpha:s=1}=e;return"hsla("+Math.round(t)+", "+tG.transform(Gj(n))+", "+tG.transform(Gj(r))+", "+Gj(Uj.transform(s))+")"}},oG={test:e=>Yj.test(e)||Zj.test(e)||iG.test(e),parse:e=>Yj.test(e)?Yj.parse(e):iG.test(e)?iG.parse(e):Zj.parse(e),transform:e=>"string"===typeof e?e:e.hasOwnProperty("red")?Yj.transform(e):iG.transform(e),getAnimatableNone:e=>{const t=oG.parse(e);return t.alpha=0,oG.transform(t)}},lG=/(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;const uG="number",cG="color",hG=/var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;function dG(e){const t=e.toString(),n=[],r={color:[],number:[],var:[]},s=[];let a=0;const i=t.replace(hG,(e=>(oG.test(e)?(r.color.push(a),s.push(cG),n.push(oG.parse(e))):e.startsWith("var(")?(r.var.push(a),s.push("var"),n.push(e)):(r.number.push(a),s.push(uG),n.push(parseFloat(e))),++a,"${}"))).split("${}");return{values:n,split:i,indexes:r,types:s}}function pG(e){return dG(e).values}function fG(e){const{split:t,types:n}=dG(e),r=t.length;return e=>{let s="";for(let a=0;a<r;a++)if(s+=t[a],void 0!==e[a]){const t=n[a];s+=t===uG?Gj(e[a]):t===cG?oG.transform(e[a]):e[a]}return s}}const mG=e=>"number"===typeof e?0:oG.test(e)?oG.getAnimatableNone(e):e;const gG={test:function(e){return isNaN(e)&&"string"===typeof e&&(e.match(Hj)?.length||0)+(e.match(lG)?.length||0)>0},parse:pG,createTransformer:fG,getAnimatableNone:function(e){const t=pG(e);return fG(e)(t.map(mG))}};function yG(e,t,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?e+6*(t-e)*n:n<.5?t:n<2/3?e+(t-e)*(2/3-n)*6:e}function bG(e,t){return n=>n>0?t:e}const vG=(e,t,n)=>e+(t-e)*n,xG=(e,t,n)=>{const r=e*e,s=n*(t*t-r)+r;return s<0?0:Math.sqrt(s)},wG=[Zj,Yj,iG];function kG(e){const t=(n=e,wG.find((e=>e.test(n))));var n;if(Boolean(t),!Boolean(t))return!1;let r=t.parse(e);return t===iG&&(r=function(e){let{hue:t,saturation:n,lightness:r,alpha:s}=e;t/=360,n/=100,r/=100;let a=0,i=0,o=0;if(n){const e=r<.5?r*(1+n):r+n-r*n,s=2*r-e;a=yG(s,e,t+1/3),i=yG(s,e,t),o=yG(s,e,t-1/3)}else a=i=o=r;return{red:Math.round(255*a),green:Math.round(255*i),blue:Math.round(255*o),alpha:s}}(r)),r}const SG=(e,t)=>{const n=kG(e),r=kG(t);if(!n||!r)return bG(e,t);const s={...n};return e=>(s.red=xG(n.red,r.red,e),s.green=xG(n.green,r.green,e),s.blue=xG(n.blue,r.blue,e),s.alpha=vG(n.alpha,r.alpha,e),Yj.transform(s))},NG=new Set(["none","hidden"]);function IG(e,t){return n=>vG(e,t,n)}function CG(e){return"number"===typeof e?IG:"string"===typeof e?Bj(e)?bG:oG.test(e)?SG:EG:Array.isArray(e)?TG:"object"===typeof e?oG.test(e)?SG:AG:bG}function TG(e,t){const n=[...e],r=n.length,s=e.map(((e,n)=>CG(e)(e,t[n])));return e=>{for(let t=0;t<r;t++)n[t]=s[t](e);return n}}function AG(e,t){const n={...e,...t},r={};for(const s in n)void 0!==e[s]&&void 0!==t[s]&&(r[s]=CG(e[s])(e[s],t[s]));return e=>{for(const t in r)n[t]=r[t](e);return n}}const EG=(e,t)=>{const n=gG.createTransformer(t),r=dG(e),s=dG(t);return r.indexes.var.length===s.indexes.var.length&&r.indexes.color.length===s.indexes.color.length&&r.indexes.number.length>=s.indexes.number.length?NG.has(e)&&!s.values.length||NG.has(t)&&!r.values.length?function(e,t){return NG.has(e)?n=>n<=0?e:t:n=>n>=1?t:e}(e,t):Dj(TG(function(e,t){const n=[],r={color:0,var:0,number:0};for(let s=0;s<t.values.length;s++){const a=t.types[s],i=e.indexes[a][r[a]],o=e.values[i]??0;n[s]=o,r[a]++}return n}(r,s),s.values),n):bG(e,t)};function $G(e,t,n){if("number"===typeof e&&"number"===typeof t&&"number"===typeof n)return vG(e,t,n);return CG(e)(e,t)}const RG=e=>{const t=t=>{let{timestamp:n}=t;return e(n)};return{start:function(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];return oj.update(t,e)},stop:()=>lj(t),now:()=>uj.isProcessing?uj.timestamp:xj.now()}},DG=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:10,r="";const s=Math.max(Math.round(t/n),2);for(let a=0;a<s;a++)r+=Math.round(1e4*e(a/(s-1)))/1e4+", ";return`linear(${r.substring(0,r.length-2)})`},OG=2e4;function _G(e){let t=0;let n=e.next(t);for(;!n.done&&t<OG;)t+=50,n=e.next(t);return t>=OG?1/0:t}function FG(e,t,n){const r=Math.max(t-5,0);return yj(n-e(r),t-r)}const MG={stiffness:100,damping:10,mass:1,velocity:0,duration:800,bounce:.3,visualDuration:.3,restSpeed:{granular:.01,default:2},restDelta:{granular:.005,default:.5},minDuration:.01,maxDuration:10,minDamping:.05,maxDamping:1},LG=.001;function PG(e){let t,n,{duration:r=MG.duration,bounce:s=MG.bounce,velocity:a=MG.velocity,mass:i=MG.mass}=e;_j(MG.maxDuration);let o=1-s;o=Oj(MG.minDamping,MG.maxDamping,o),r=Oj(MG.minDuration,MG.maxDuration,Fj(r)),o<1?(t=e=>{const t=e*o,n=t*r,s=t-a,i=BG(e,o),l=Math.exp(-n);return LG-s/i*l},n=e=>{const n=e*o*r,s=n*a+a,i=Math.pow(o,2)*Math.pow(e,2)*r,l=Math.exp(-n),u=BG(Math.pow(e,2),o);return(-t(e)+LG>0?-1:1)*((s-i)*l)/u}):(t=e=>Math.exp(-e*r)*((e-a)*r+1)-.001,n=e=>Math.exp(-e*r)*(r*r*(a-e)));const l=function(e,t,n){let r=n;for(let s=1;s<zG;s++)r-=e(r)/t(r);return r}(t,n,5/r);if(r=_j(r),isNaN(l))return{stiffness:MG.stiffness,damping:MG.damping,duration:r};{const e=Math.pow(l,2)*i;return{stiffness:e,damping:2*o*Math.sqrt(i*e),duration:r}}}const zG=12;function BG(e,t){return e*Math.sqrt(1-t*t)}const VG=["duration","bounce"],WG=["stiffness","damping","mass"];function UG(e,t){return t.some((t=>void 0!==e[t]))}function jG(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:MG.visualDuration,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:MG.bounce;const n="object"!==typeof e?{visualDuration:e,keyframes:[0,1],bounce:t}:e;let{restSpeed:r,restDelta:s}=n;const a=n.keyframes[0],i=n.keyframes[n.keyframes.length-1],o={done:!1,value:a},{stiffness:l,damping:u,mass:c,duration:h,velocity:d,isResolvedFromDuration:p}=function(e){let t={velocity:MG.velocity,stiffness:MG.stiffness,damping:MG.damping,mass:MG.mass,isResolvedFromDuration:!1,...e};if(!UG(e,WG)&&UG(e,VG))if(e.visualDuration){const n=e.visualDuration,r=2*Math.PI/(1.2*n),s=r*r,a=2*Oj(.05,1,1-(e.bounce||0))*Math.sqrt(s);t={...t,mass:MG.mass,stiffness:s,damping:a}}else{const n=PG(e);t={...t,...n,mass:MG.mass},t.isResolvedFromDuration=!0}return t}({...n,velocity:-Fj(n.velocity||0)}),f=d||0,m=u/(2*Math.sqrt(l*c)),g=i-a,y=Fj(Math.sqrt(l/c)),b=Math.abs(g)<5;let v;if(r||(r=b?MG.restSpeed.granular:MG.restSpeed.default),s||(s=b?MG.restDelta.granular:MG.restDelta.default),m<1){const e=BG(y,m);v=t=>{const n=Math.exp(-m*y*t);return i-n*((f+m*y*g)/e*Math.sin(e*t)+g*Math.cos(e*t))}}else if(1===m)v=e=>i-Math.exp(-y*e)*(g+(f+y*g)*e);else{const e=y*Math.sqrt(m*m-1);v=t=>{const n=Math.exp(-m*y*t),r=Math.min(e*t,300);return i-n*((f+m*y*g)*Math.sinh(r)+e*g*Math.cosh(r))/e}}const x={calculatedDuration:p&&h||null,next:e=>{const t=v(e);if(p)o.done=e>=h;else{let n=0===e?f:0;m<1&&(n=0===e?_j(f):FG(v,e,t));const a=Math.abs(n)<=r,l=Math.abs(i-t)<=s;o.done=a&&l}return o.value=o.done?i:t,o},toString:()=>{const e=Math.min(_G(x),OG),t=DG((t=>x.next(e*t).value),e,30);return e+"ms "+t},toTransition:()=>{}};return x}function GG(e){let{keyframes:t,velocity:n=0,power:r=.8,timeConstant:s=325,bounceDamping:a=10,bounceStiffness:i=500,modifyTarget:o,min:l,max:u,restDelta:c=.5,restSpeed:h}=e;const d=t[0],p={done:!1,value:d},f=e=>void 0===l?u:void 0===u||Math.abs(l-e)<Math.abs(u-e)?l:u;let m=r*n;const g=d+m,y=void 0===o?g:o(g);y!==g&&(m=y-d);const b=e=>-m*Math.exp(-e/s),v=e=>y+b(e),x=e=>{const t=b(e),n=v(e);p.done=Math.abs(t)<=c,p.value=p.done?y:n};let w,k;const S=e=>{var t;(t=p.value,void 0!==l&&t<l||void 0!==u&&t>u)&&(w=e,k=jG({keyframes:[p.value,f(p.value)],velocity:FG(v,e,p.value),damping:a,stiffness:i,restDelta:c,restSpeed:h}))};return S(0),{calculatedDuration:null,next:e=>{let t=!1;return k||void 0!==w||(t=!0,x(e),S(e)),void 0!==w&&e>=w?k.next(e-w):(!t&&x(e),p)}}}jG.applyToOptions=e=>{const t=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:100;const n=(arguments.length>2?arguments[2]:void 0)({...e,keyframes:[0,t]}),r=Math.min(_G(n),OG);return{type:"keyframes",ease:e=>n.next(r*e).value/t,duration:Fj(r)}}(e,100,jG);return e.ease=t.ease,e.duration=_j(t.duration),e.type="keyframes",e};const HG=(e,t,n)=>(((1-3*n+3*t)*e+(3*n-6*t))*e+3*t)*e;function qG(e,t,n,r){if(e===t&&n===r)return nj;const s=t=>function(e,t,n,r,s){let a,i,o=0;do{i=t+(n-t)/2,a=HG(i,r,s)-e,a>0?n=i:t=i}while(Math.abs(a)>1e-7&&++o<12);return i}(t,0,1,e,n);return e=>0===e||1===e?e:HG(s(e),t,r)}const KG=qG(.42,0,1,1),XG=qG(0,0,.58,1),QG=qG(.42,0,.58,1),YG=e=>t=>t<=.5?e(2*t)/2:(2-e(2*(1-t)))/2,ZG=e=>t=>1-e(1-t),JG=qG(.33,1.53,.69,.99),eH=ZG(JG),tH=YG(eH),nH=e=>(e*=2)<1?.5*eH(e):.5*(2-Math.pow(2,-10*(e-1))),rH=e=>1-Math.sin(Math.acos(e)),sH=ZG(rH),aH=YG(rH),iH=e=>Array.isArray(e)&&"number"===typeof e[0],oH={linear:nj,easeIn:KG,easeInOut:QG,easeOut:XG,circIn:rH,circInOut:aH,circOut:sH,backIn:eH,backInOut:tH,backOut:JG,anticipate:nH},lH=e=>{if(iH(e)){e.length;const[t,n,r,s]=e;return qG(t,n,r,s)}return"string"===typeof e?oH[e]:e},uH=(e,t,n)=>{const r=t-e;return 0===r?1:(n-e)/r};function cH(e,t){let{clamp:n=!0,ease:r,mixer:s}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const a=e.length;if(t.length,1===a)return()=>t[0];if(2===a&&t[0]===t[1])return()=>t[1];const i=e[0]===e[1];e[0]>e[a-1]&&(e=[...e].reverse(),t=[...t].reverse());const o=function(e,t,n){const r=[],s=n||rj.mix||$G,a=e.length-1;for(let i=0;i<a;i++){let n=s(e[i],e[i+1]);if(t){const e=Array.isArray(t)?t[i]||nj:t;n=Dj(e,n)}r.push(n)}return r}(t,r,s),l=o.length,u=n=>{if(i&&n<e[0])return t[0];let r=0;if(l>1)for(;r<e.length-2&&!(n<e[r+1]);r++);const s=uH(e[r],e[r+1],n);return o[r](s)};return n?t=>u(Oj(e[0],e[a-1],t)):u}function hH(e){const t=[0];return function(e,t){const n=e[e.length-1];for(let r=1;r<=t;r++){const s=uH(0,t,r);e.push(vG(n,1,s))}}(t,e.length-1),t}function dH(e){let{duration:t=300,keyframes:n,times:r,ease:s="easeInOut"}=e;const a=(e=>Array.isArray(e)&&"number"!==typeof e[0])(s)?s.map(lH):lH(s),i={done:!1,value:n[0]},o=function(e,t){return e.map((e=>e*t))}(r&&r.length===n.length?r:hH(n),t),l=cH(o,n,{ease:Array.isArray(a)?a:(u=n,c=a,u.map((()=>c||QG)).splice(0,u.length-1))});var u,c;return{calculatedDuration:t,next:e=>(i.value=l(e),i.done=e>=t,i)}}const pH=e=>null!==e;function fH(e,t,n){let{repeat:r,repeatType:s="loop"}=t,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;const i=e.filter(pH),o=a<0||r&&"loop"!==s&&r%2===1?0:i.length-1;return o&&void 0!==n?n:i[o]}const mH={decay:GG,inertia:GG,tween:dH,keyframes:dH,spring:jG};function gH(e){"string"===typeof e.type&&(e.type=mH[e.type])}class yH{constructor(){this.updateFinished()}get finished(){return this._finished}updateFinished(){this._finished=new Promise((e=>{this.resolve=e}))}notifyFinished(){this.resolve()}then(e,t){return this.finished.then(e,t)}}const bH=e=>e/100;class vH extends yH{constructor(e){super(),this.state="idle",this.startTime=null,this.isStopped=!1,this.currentTime=0,this.holdTime=null,this.playbackSpeed=1,this.stop=()=>{const{motionValue:e}=this.options;e&&e.updatedAt!==xj.now()&&this.tick(xj.now()),this.isStopped=!0,"idle"!==this.state&&(this.teardown(),this.options.onStop?.())},Mj.mainThread++,this.options=e,this.initAnimation(),this.play(),!1===e.autoplay&&this.pause()}initAnimation(){const{options:e}=this;gH(e);const{type:t=dH,repeat:n=0,repeatDelay:r=0,repeatType:s,velocity:a=0}=e;let{keyframes:i}=e;const o=t||dH;o!==dH&&"number"!==typeof i[0]&&(this.mixKeyframes=Dj(bH,$G(i[0],i[1])),i=[0,100]);const l=o({...e,keyframes:i});"mirror"===s&&(this.mirroredGenerator=o({...e,keyframes:[...i].reverse(),velocity:-a})),null===l.calculatedDuration&&(l.calculatedDuration=_G(l));const{calculatedDuration:u}=l;this.calculatedDuration=u,this.resolvedDuration=u+r,this.totalDuration=this.resolvedDuration*(n+1)-r,this.generator=l}updateTime(e){const t=Math.round(e-this.startTime)*this.playbackSpeed;null!==this.holdTime?this.currentTime=this.holdTime:this.currentTime=t}tick(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const{generator:n,totalDuration:r,mixKeyframes:s,mirroredGenerator:a,resolvedDuration:i,calculatedDuration:o}=this;if(null===this.startTime)return n.next(0);const{delay:l=0,keyframes:u,repeat:c,repeatType:h,repeatDelay:d,type:p,onUpdate:f,finalKeyframe:m}=this.options;this.speed>0?this.startTime=Math.min(this.startTime,e):this.speed<0&&(this.startTime=Math.min(e-r/this.speed,this.startTime)),t?this.currentTime=e:this.updateTime(e);const g=this.currentTime-l*(this.playbackSpeed>=0?1:-1),y=this.playbackSpeed>=0?g<0:g>r;this.currentTime=Math.max(g,0),"finished"===this.state&&null===this.holdTime&&(this.currentTime=r);let b=this.currentTime,v=n;if(c){const e=Math.min(this.currentTime,r)/i;let t=Math.floor(e),n=e%1;!n&&e>=1&&(n=1),1===n&&t--,t=Math.min(t,c+1);Boolean(t%2)&&("reverse"===h?(n=1-n,d&&(n-=d/i)):"mirror"===h&&(v=a)),b=Oj(0,1,n)*i}const x=y?{done:!1,value:u[0]}:v.next(b);s&&(x.value=s(x.value));let{done:w}=x;y||null===o||(w=this.playbackSpeed>=0?this.currentTime>=r:this.currentTime<=0);const k=null===this.holdTime&&("finished"===this.state||"running"===this.state&&w);return k&&p!==GG&&(x.value=fH(u,this.options,m,this.speed)),f&&f(x.value),k&&this.finish(),x}then(e,t){return this.finished.then(e,t)}get duration(){return Fj(this.calculatedDuration)}get time(){return Fj(this.currentTime)}set time(e){e=_j(e),this.currentTime=e,null===this.startTime||null!==this.holdTime||0===this.playbackSpeed?this.holdTime=e:this.driver&&(this.startTime=this.driver.now()-e/this.playbackSpeed),this.driver?.start(!1)}get speed(){return this.playbackSpeed}set speed(e){this.updateTime(xj.now());const t=this.playbackSpeed!==e;this.playbackSpeed=e,t&&(this.time=Fj(this.currentTime))}play(){if(this.isStopped)return;const{driver:e=RG,startTime:t}=this.options;this.driver||(this.driver=e((e=>this.tick(e)))),this.options.onPlay?.();const n=this.driver.now();"finished"===this.state?(this.updateFinished(),this.startTime=n):null!==this.holdTime?this.startTime=n-this.holdTime:this.startTime||(this.startTime=t??n),"finished"===this.state&&this.speed<0&&(this.startTime+=this.calculatedDuration),this.holdTime=null,this.state="running",this.driver.start()}pause(){this.state="paused",this.updateTime(xj.now()),this.holdTime=this.currentTime}complete(){"running"!==this.state&&this.play(),this.state="finished",this.holdTime=null}finish(){this.notifyFinished(),this.teardown(),this.state="finished",this.options.onComplete?.()}cancel(){this.holdTime=null,this.startTime=0,this.tick(0),this.teardown(),this.options.onCancel?.()}teardown(){this.state="idle",this.stopDriver(),this.startTime=this.holdTime=null,Mj.mainThread--}stopDriver(){this.driver&&(this.driver.stop(),this.driver=void 0)}sample(e){return this.startTime=0,this.tick(e,!0)}attachTimeline(e){return this.options.allowFlatten&&(this.options.type="keyframes",this.options.ease="linear",this.initAnimation()),this.driver?.stop(),e.observe(this)}}const xH=e=>180*e/Math.PI,wH=e=>{const t=xH(Math.atan2(e[1],e[0]));return SH(t)},kH={x:4,y:5,translateX:4,translateY:5,scaleX:0,scaleY:3,scale:e=>(Math.abs(e[0])+Math.abs(e[3]))/2,rotate:wH,rotateZ:wH,skewX:e=>xH(Math.atan(e[1])),skewY:e=>xH(Math.atan(e[2])),skew:e=>(Math.abs(e[1])+Math.abs(e[2]))/2},SH=e=>((e%=360)<0&&(e+=360),e),NH=e=>Math.sqrt(e[0]*e[0]+e[1]*e[1]),IH=e=>Math.sqrt(e[4]*e[4]+e[5]*e[5]),CH={x:12,y:13,z:14,translateX:12,translateY:13,translateZ:14,scaleX:NH,scaleY:IH,scale:e=>(NH(e)+IH(e))/2,rotateX:e=>SH(xH(Math.atan2(e[6],e[5]))),rotateY:e=>SH(xH(Math.atan2(-e[2],e[0]))),rotateZ:wH,rotate:wH,skewX:e=>xH(Math.atan(e[4])),skewY:e=>xH(Math.atan(e[1])),skew:e=>(Math.abs(e[1])+Math.abs(e[4]))/2};function TH(e){return e.includes("scale")?1:0}function AH(e,t){if(!e||"none"===e)return TH(t);const n=e.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);let r,s;if(n)r=CH,s=n;else{const t=e.match(/^matrix\(([-\d.e\s,]+)\)$/u);r=kH,s=t}if(!s)return TH(t);const a=r[t],i=s[1].split(",").map(EH);return"function"===typeof a?a(i):i[a]}function EH(e){return parseFloat(e.trim())}const $H=e=>e===Wj||e===nG,RH=new Set(["x","y","z"]),DH=hj.filter((e=>!RH.has(e)));const OH={width:(e,t)=>{let{x:n}=e,{paddingLeft:r="0",paddingRight:s="0"}=t;return n.max-n.min-parseFloat(r)-parseFloat(s)},height:(e,t)=>{let{y:n}=e,{paddingTop:r="0",paddingBottom:s="0"}=t;return n.max-n.min-parseFloat(r)-parseFloat(s)},top:(e,t)=>{let{top:n}=t;return parseFloat(n)},left:(e,t)=>{let{left:n}=t;return parseFloat(n)},bottom:(e,t)=>{let{y:n}=e,{top:r}=t;return parseFloat(r)+(n.max-n.min)},right:(e,t)=>{let{x:n}=e,{left:r}=t;return parseFloat(r)+(n.max-n.min)},x:(e,t)=>{let{transform:n}=t;return AH(n,"x")},y:(e,t)=>{let{transform:n}=t;return AH(n,"y")}};OH.translateX=OH.x,OH.translateY=OH.y;const _H=new Set;let FH=!1,MH=!1,LH=!1;function PH(){if(MH){const e=Array.from(_H).filter((e=>e.needsMeasurement)),t=new Set(e.map((e=>e.element))),n=new Map;t.forEach((e=>{const t=function(e){const t=[];return DH.forEach((n=>{const r=e.getValue(n);void 0!==r&&(t.push([n,r.get()]),r.set(n.startsWith("scale")?1:0))})),t}(e);t.length&&(n.set(e,t),e.render())})),e.forEach((e=>e.measureInitialState())),t.forEach((e=>{e.render();const t=n.get(e);t&&t.forEach((t=>{let[n,r]=t;e.getValue(n)?.set(r)}))})),e.forEach((e=>e.measureEndState())),e.forEach((e=>{void 0!==e.suspendedScrollY&&window.scrollTo(0,e.suspendedScrollY)}))}MH=!1,FH=!1,_H.forEach((e=>e.complete(LH))),_H.clear()}function zH(){_H.forEach((e=>{e.readKeyframes(),e.needsMeasurement&&(MH=!0)}))}class BH{constructor(e,t,n,r,s){let a=arguments.length>5&&void 0!==arguments[5]&&arguments[5];this.state="pending",this.isAsync=!1,this.needsMeasurement=!1,this.unresolvedKeyframes=[...e],this.onComplete=t,this.name=n,this.motionValue=r,this.element=s,this.isAsync=a}scheduleResolve(){this.state="scheduled",this.isAsync?(_H.add(this),FH||(FH=!0,oj.read(zH),oj.resolveKeyframes(PH))):(this.readKeyframes(),this.complete())}readKeyframes(){const{unresolvedKeyframes:e,name:t,element:n,motionValue:r}=this;if(null===e[0]){const s=r?.get(),a=e[e.length-1];if(void 0!==s)e[0]=s;else if(n&&t){const r=n.readValue(t,a);void 0!==r&&null!==r&&(e[0]=r)}void 0===e[0]&&(e[0]=a),r&&void 0===s&&r.set(e[0])}!function(e){for(let t=1;t<e.length;t++)e[t]??(e[t]=e[t-1])}(e)}setFinalKeyframe(){}measureInitialState(){}renderEndStyles(){}measureEndState(){}complete(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.state="complete",this.onComplete(this.unresolvedKeyframes,this.finalKeyframe,e),_H.delete(this)}cancel(){"scheduled"===this.state&&(_H.delete(this),this.state="pending")}resume(){"pending"===this.state&&this.scheduleResolve()}}function VH(e){let t;return()=>(void 0===t&&(t=e()),t)}const WH=VH((()=>void 0!==window.ScrollTimeline)),UH={};function jH(e,t){const n=VH(e);return()=>UH[t]??n()}const GH=jH((()=>{try{document.createElement("div").animate({opacity:0},{easing:"linear(0, 1)"})}catch(E9){return!1}return!0}),"linearEasing"),HH=e=>{let[t,n,r,s]=e;return`cubic-bezier(${t}, ${n}, ${r}, ${s})`},qH={linear:"linear",ease:"ease",easeIn:"ease-in",easeOut:"ease-out",easeInOut:"ease-in-out",circIn:HH([0,.65,.55,1]),circOut:HH([.55,0,1,.45]),backIn:HH([.31,.01,.66,-.59]),backOut:HH([.33,1.53,.69,.99])};function KH(e,t){return e?"function"===typeof e?GH()?DG(e,t):"ease-out":iH(e)?HH(e):Array.isArray(e)?e.map((e=>KH(e,t)||qH.easeOut)):qH[e]:void 0}function XH(e,t,n){let{delay:r=0,duration:s=300,repeat:a=0,repeatType:i="loop",ease:o="easeOut",times:l}=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},u=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0;const c={[t]:n};l&&(c.offset=l);const h=KH(o,s);Array.isArray(h)&&(c.easing=h),aj.value&&Mj.waapi++;const d={delay:r,duration:s,easing:Array.isArray(h)?"linear":h,fill:"both",iterations:a+1,direction:"reverse"===i?"alternate":"normal"};u&&(d.pseudoElement=u);const p=e.animate(c,d);return aj.value&&p.finished.finally((()=>{Mj.waapi--})),p}function QH(e){return"function"===typeof e&&"applyToOptions"in e}class YH extends yH{constructor(e){if(super(),this.finishedTime=null,this.isStopped=!1,!e)return;const{element:t,name:n,keyframes:r,pseudoElement:s,allowFlatten:a=!1,finalKeyframe:i,onComplete:o}=e;this.isPseudoElement=Boolean(s),this.allowFlatten=a,this.options=e,e.type;const l=function(e){let{type:t,...n}=e;return QH(t)&&GH()?t.applyToOptions(n):(n.duration??(n.duration=300),n.ease??(n.ease="easeOut"),n)}(e);this.animation=XH(t,n,r,l,s),!1===l.autoplay&&this.animation.pause(),this.animation.onfinish=()=>{if(this.finishedTime=this.time,!s){const e=fH(r,this.options,i,this.speed);this.updateMotionValue?this.updateMotionValue(e):function(e,t,n){(e=>e.startsWith("--"))(t)?e.style.setProperty(t,n):e.style[t]=n}(t,n,e),this.animation.cancel()}o?.(),this.notifyFinished()}}play(){this.isStopped||(this.animation.play(),"finished"===this.state&&this.updateFinished())}pause(){this.animation.pause()}complete(){this.animation.finish?.()}cancel(){try{this.animation.cancel()}catch(E9){}}stop(){if(this.isStopped)return;this.isStopped=!0;const{state:e}=this;"idle"!==e&&"finished"!==e&&(this.updateMotionValue?this.updateMotionValue():this.commitStyles(),this.isPseudoElement||this.cancel())}commitStyles(){this.isPseudoElement||this.animation.commitStyles?.()}get duration(){const e=this.animation.effect?.getComputedTiming?.().duration||0;return Fj(Number(e))}get time(){return Fj(Number(this.animation.currentTime)||0)}set time(e){this.finishedTime=null,this.animation.currentTime=_j(e)}get speed(){return this.animation.playbackRate}set speed(e){e<0&&(this.finishedTime=null),this.animation.playbackRate=e}get state(){return null!==this.finishedTime?"finished":this.animation.playState}get startTime(){return Number(this.animation.startTime)}set startTime(e){this.animation.startTime=e}attachTimeline(e){let{timeline:t,observe:n}=e;return this.allowFlatten&&this.animation.effect?.updateTiming({easing:"linear"}),this.animation.onfinish=null,t&&WH()?(this.animation.timeline=t,nj):n(this)}}const ZH={anticipate:nH,backInOut:tH,circInOut:aH};function JH(e){"string"===typeof e.ease&&e.ease in ZH&&(e.ease=ZH[e.ease])}class eq extends YH{constructor(e){JH(e),gH(e),super(e),e.startTime&&(this.startTime=e.startTime),this.options=e}updateMotionValue(e){const{motionValue:t,onUpdate:n,onComplete:r,element:s,...a}=this.options;if(!t)return;if(void 0!==e)return void t.set(e);const i=new vH({...a,autoplay:!1}),o=_j(this.finishedTime??this.time);t.setWithVelocity(i.sample(o-10).value,i.sample(o).value,10),i.stop()}}const tq=(e,t)=>"zIndex"!==t&&(!("number"!==typeof e&&!Array.isArray(e))||!("string"!==typeof e||!gG.test(e)&&"0"!==e||e.startsWith("url(")));const nq=new Set(["opacity","clipPath","filter","transform"]),rq=VH((()=>Object.hasOwnProperty.call(Element.prototype,"animate")));class sq extends yH{constructor(e){let{autoplay:t=!0,delay:n=0,type:r="keyframes",repeat:s=0,repeatDelay:a=0,repeatType:i="loop",keyframes:o,name:l,motionValue:u,element:c,...h}=e;super(),this.stop=()=>{this._animation&&(this._animation.stop(),this.stopTimeline?.()),this.keyframeResolver?.cancel()},this.createdAt=xj.now();const d={autoplay:t,delay:n,type:r,repeat:s,repeatDelay:a,repeatType:i,name:l,motionValue:u,element:c,...h},p=c?.KeyframeResolver||BH;this.keyframeResolver=new p(o,((e,t,n)=>this.onKeyframesResolved(e,t,d,!n)),l,u,c),this.keyframeResolver?.scheduleResolve()}onKeyframesResolved(e,t,n,r){this.keyframeResolver=void 0;const{name:s,type:a,velocity:i,delay:o,isHandoff:l,onUpdate:u}=n;this.resolvedAt=xj.now(),function(e,t,n,r){const s=e[0];if(null===s)return!1;if("display"===t||"visibility"===t)return!0;const a=e[e.length-1],i=tq(s,t),o=tq(a,t);return!(!i||!o)&&(function(e){const t=e[0];if(1===e.length)return!0;for(let n=0;n<e.length;n++)if(e[n]!==t)return!0}(e)||("spring"===n||QH(n))&&r)}(e,s,a,i)||(!rj.instantAnimations&&o||u?.(fH(e,n,t)),e[0]=e[e.length-1],n.duration=0,n.repeat=0);const c={startTime:r?this.resolvedAt&&this.resolvedAt-this.createdAt>40?this.resolvedAt:this.createdAt:void 0,finalKeyframe:t,...n,keyframes:e},h=!l&&function(e){const{motionValue:t,name:n,repeatDelay:r,repeatType:s,damping:a,type:i}=e;if(!BU(t?.owner?.current))return!1;const{onUpdate:o,transformTemplate:l}=t.owner.getProps();return rq()&&n&&nq.has(n)&&("transform"!==n||!l)&&!o&&!r&&"mirror"!==s&&0!==a&&"inertia"!==i}(c)?new eq({...c,element:c.motionValue.owner.current}):new vH(c);h.finished.then((()=>this.notifyFinished())).catch(nj),this.pendingTimeline&&(this.stopTimeline=h.attachTimeline(this.pendingTimeline),this.pendingTimeline=void 0),this._animation=h}get finished(){return this._animation?this.animation.finished:this._finished}then(e,t){return this.finished.finally(e).then((()=>{}))}get animation(){return this._animation||(this.keyframeResolver?.resume(),LH=!0,zH(),PH(),LH=!1),this._animation}get duration(){return this.animation.duration}get time(){return this.animation.time}set time(e){this.animation.time=e}get speed(){return this.animation.speed}get state(){return this.animation.state}set speed(e){this.animation.speed=e}get startTime(){return this.animation.startTime}attachTimeline(e){return this._animation?this.stopTimeline=this.animation.attachTimeline(e):this.pendingTimeline=e,()=>this.stop()}play(){this.animation.play()}pause(){this.animation.pause()}complete(){this.animation.complete()}cancel(){this._animation&&this.animation.cancel(),this.keyframeResolver?.cancel()}}const aq=e=>null!==e;const iq={type:"spring",stiffness:500,damping:25,restSpeed:10},oq={type:"keyframes",duration:.8},lq={type:"keyframes",ease:[.25,.1,.35,1],duration:.3},uq=(e,t)=>{let{keyframes:n}=t;return n.length>2?oq:dj.has(e)?e.startsWith("scale")?{type:"spring",stiffness:550,damping:0===n[1]?2*Math.sqrt(550):30,restSpeed:10}:iq:lq};const cq=function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},s=arguments.length>4?arguments[4]:void 0,a=arguments.length>5?arguments[5]:void 0;return i=>{const o=tj(r,e)||{},l=o.delay||r.delay||0;let{elapsed:u=0}=r;u-=_j(l);const c={keyframes:Array.isArray(n)?n:[null,n],ease:"easeOut",velocity:t.getVelocity(),...o,delay:-u,onUpdate:e=>{t.set(e),o.onUpdate&&o.onUpdate(e)},onComplete:()=>{i(),o.onComplete&&o.onComplete()},name:e,motionValue:t,element:a?void 0:s};(function(e){let{when:t,delay:n,delayChildren:r,staggerChildren:s,staggerDirection:a,repeat:i,repeatType:o,repeatDelay:l,from:u,elapsed:c,...h}=e;return!!Object.keys(h).length})(o)||Object.assign(c,uq(e,c)),c.duration&&(c.duration=_j(c.duration)),c.repeatDelay&&(c.repeatDelay=_j(c.repeatDelay)),void 0!==c.from&&(c.keyframes[0]=c.from);let h=!1;if((!1===c.type||0===c.duration&&!c.repeatDelay)&&(c.duration=0,0===c.delay&&(h=!0)),(rj.instantAnimations||rj.skipAnimations)&&(h=!0,c.duration=0,c.delay=0),c.allowFlatten=!o.type&&!o.ease,h&&!a&&void 0!==t.get()){const e=function(e,t,n){let{repeat:r,repeatType:s="loop"}=t;const a=e.filter(aq),i=r&&"loop"!==s&&r%2===1?0:a.length-1;return i&&void 0!==n?n:a[i]}(c.keyframes,o);if(void 0!==e)return void oj.update((()=>{c.onUpdate(e),c.onComplete()}))}return o.isSync?new vH(c):new sq(c)}};function hq(e,t){let{protectedKeys:n,needsAnimating:r}=e;const s=n.hasOwnProperty(t)&&!0!==r[t];return r[t]=!1,s}function dq(e,t){let{delay:n=0,transitionOverride:r,type:s}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},{transition:a=e.getDefaultTransition(),transitionEnd:i,...o}=t;r&&(a=r);const l=[],u=s&&e.animationState&&e.animationState.getState()[s];for(const c in o){const t=e.getValue(c,e.latestValues[c]??null),r=o[c];if(void 0===r||u&&hq(u,c))continue;const s={delay:n,...tj(a||{},c)},i=t.get();if(void 0!==i&&!t.isAnimating&&!Array.isArray(r)&&r===i&&!s.velocity)continue;let h=!1;if(window.MotionHandoffAnimation){const t=$j(e);if(t){const e=window.MotionHandoffAnimation(t,c,oj);null!==e&&(s.startTime=e,h=!0)}}Tj(e,c),t.start(cq(c,t,r,e.shouldReduceMotion&&pj.has(c)?{type:!1}:s,e,h));const d=t.animation;d&&l.push(d)}return i&&Promise.all(l).then((()=>{oj.update((()=>{i&&function(e,t){const n=ej(e,t);let{transitionEnd:r={},transition:s={},...a}=n||{};a={...a,...r};for(const o in a)Ij(e,o,(i=a[o],Nj(i)?i[i.length-1]||0:i));var i}(e,i)}))})),l}function pq(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=ej(e,t,"exit"===n.type?e.presenceContext?.custom:void 0);let{transition:s=e.getDefaultTransition()||{}}=r||{};n.transitionOverride&&(s=n.transitionOverride);const a=r?()=>Promise.all(dq(e,r,n)):()=>Promise.resolve(),i=e.variantChildren&&e.variantChildren.size?function(){let r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const{delayChildren:a=0,staggerChildren:i,staggerDirection:o}=s;return function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,a=arguments.length>5?arguments[5]:void 0;const i=[],o=(e.variantChildren.size-1)*r,l=1===s?function(){return(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0)*r}:function(){return o-(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0)*r};return Array.from(e.variantChildren).sort(fq).forEach(((e,r)=>{e.notify("AnimationStart",t),i.push(pq(e,t,{...a,delay:n+l(r)}).then((()=>e.notify("AnimationComplete",t))))})),Promise.all(i)}(e,t,a+r,i,o,n)}:()=>Promise.resolve(),{when:o}=s;if(o){const[e,t]="beforeChildren"===o?[a,i]:[i,a];return e().then((()=>t()))}return Promise.all([a(),i(n.delay)])}function fq(e,t){return e.sortNodePosition(t)}function mq(e,t){if(!Array.isArray(t))return!1;const n=t.length;if(n!==e.length)return!1;for(let r=0;r<n;r++)if(t[r]!==e[r])return!1;return!0}function gq(e){return"string"===typeof e||Array.isArray(e)}const yq=["animate","whileInView","whileFocus","whileHover","whileTap","whileDrag","exit"],bq=["initial",...yq],vq=bq.length;function xq(e){if(!e)return;if(!e.isControllingVariants){const t=e.parent&&xq(e.parent)||{};return void 0!==e.props.initial&&(t.initial=e.props.initial),t}const t={};for(let n=0;n<vq;n++){const r=bq[n],s=e.props[r];(gq(s)||!1===s)&&(t[r]=s)}return t}const wq=[...yq].reverse(),kq=yq.length;function Sq(e){return t=>Promise.all(t.map((t=>{let{animation:n,options:r}=t;return function(e,t){let n,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(e.notify("AnimationStart",t),Array.isArray(t)){const s=t.map((t=>pq(e,t,r)));n=Promise.all(s)}else if("string"===typeof t)n=pq(e,t,r);else{const s="function"===typeof t?ej(e,t,r.custom):t;n=Promise.all(dq(e,s,r))}return n.then((()=>{e.notify("AnimationComplete",t)}))}(e,n,r)})))}function Nq(e){let t=Sq(e),n=Tq(),r=!0;const s=t=>(n,r)=>{const s=ej(e,r,"exit"===t?e.presenceContext?.custom:void 0);if(s){const{transition:e,transitionEnd:t,...r}=s;n={...n,...r,...t}}return n};function a(a){const{props:i}=e,o=xq(e.parent)||{},l=[],u=new Set;let c={},h=1/0;for(let t=0;t<kq;t++){const d=wq[t],p=n[d],f=void 0!==i[d]?i[d]:o[d],m=gq(f),g=d===a?p.isActive:null;!1===g&&(h=t);let y=f===o[d]&&f!==i[d]&&m;if(y&&r&&e.manuallyAnimateOnMount&&(y=!1),p.protectedKeys={...c},!p.isActive&&null===g||!f&&!p.prevProp||YU(f)||"boolean"===typeof f)continue;const b=Iq(p.prevProp,f);let v=b||d===a&&p.isActive&&!y&&m||t>h&&m,x=!1;const w=Array.isArray(f)?f:[f];let k=w.reduce(s(d),{});!1===g&&(k={});const{prevResolvedValues:S={}}=p,N={...S,...k},I=t=>{v=!0,u.has(t)&&(x=!0,u.delete(t)),p.needsAnimating[t]=!0;const n=e.getValue(t);n&&(n.liveStyle=!1)};for(const e in N){const t=k[e],n=S[e];if(c.hasOwnProperty(e))continue;let r=!1;r=Nj(t)&&Nj(n)?!mq(t,n):t!==n,r?void 0!==t&&null!==t?I(e):u.add(e):void 0!==t&&u.has(e)?I(e):p.protectedKeys[e]=!0}p.prevProp=f,p.prevResolvedValues=k,p.isActive&&(c={...c,...k}),r&&e.blockInitialAnimation&&(v=!1);v&&(!(y&&b)||x)&&l.push(...w.map((e=>({animation:e,options:{type:d}}))))}if(u.size){const t={};if("boolean"!==typeof i.initial){const n=ej(e,Array.isArray(i.initial)?i.initial[0]:i.initial);n&&n.transition&&(t.transition=n.transition)}u.forEach((n=>{const r=e.getBaseTarget(n),s=e.getValue(n);s&&(s.liveStyle=!0),t[n]=r??null})),l.push({animation:t})}let d=Boolean(l.length);return!r||!1!==i.initial&&i.initial!==i.animate||e.manuallyAnimateOnMount||(d=!1),r=!1,d?t(l):Promise.resolve()}return{animateChanges:a,setActive:function(t,r){if(n[t].isActive===r)return Promise.resolve();e.variantChildren?.forEach((e=>e.animationState?.setActive(t,r))),n[t].isActive=r;const s=a(t);for(const e in n)n[e].protectedKeys={};return s},setAnimateFunction:function(n){t=n(e)},getState:()=>n,reset:()=>{n=Tq(),r=!0}}}function Iq(e,t){return"string"===typeof t?t!==e:!!Array.isArray(t)&&!mq(t,e)}function Cq(){return{isActive:arguments.length>0&&void 0!==arguments[0]&&arguments[0],protectedKeys:{},needsAnimating:{},prevResolvedValues:{}}}function Tq(){return{animate:Cq(!0),whileInView:Cq(),whileHover:Cq(),whileTap:Cq(),whileDrag:Cq(),whileFocus:Cq(),exit:Cq()}}class Aq{constructor(e){this.isMounted=!1,this.node=e}update(){}}let Eq=0;const $q={animation:{Feature:class extends Aq{constructor(e){super(e),e.animationState||(e.animationState=Nq(e))}updateAnimationControlsSubscription(){const{animate:e}=this.node.getProps();YU(e)&&(this.unmountControls=e.subscribe(this.node))}mount(){this.updateAnimationControlsSubscription()}update(){const{animate:e}=this.node.getProps(),{animate:t}=this.node.prevProps||{};e!==t&&this.updateAnimationControlsSubscription()}unmount(){this.node.animationState.reset(),this.unmountControls?.()}}},exit:{Feature:class extends Aq{constructor(){super(...arguments),this.id=Eq++}update(){if(!this.node.presenceContext)return;const{isPresent:e,onExitComplete:t}=this.node.presenceContext,{isPresent:n}=this.node.prevPresenceContext||{};if(!this.node.animationState||e===n)return;const r=this.node.animationState.setActive("exit",!e);t&&!e&&r.then((()=>{t(this.id)}))}mount(){const{register:e,onExitComplete:t}=this.node.presenceContext||{};t&&t(this.id),e&&(this.unmount=e(this.id))}unmount(){}}}},Rq={x:!1,y:!1};function Dq(){return Rq.x||Rq.y}function Oq(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{passive:!0};return e.addEventListener(t,n,r),()=>e.removeEventListener(t,n)}const _q=e=>"mouse"===e.pointerType?"number"!==typeof e.button||e.button<=0:!1!==e.isPrimary;function Fq(e){return{point:{x:e.pageX,y:e.pageY}}}function Mq(e,t,n,r){return Oq(e,t,(e=>t=>_q(t)&&e(t,Fq(t)))(n),r)}function Lq(e){let{top:t,left:n,right:r,bottom:s}=e;return{x:{min:n,max:r},y:{min:t,max:s}}}function Pq(e){return e.max-e.min}function zq(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;e.origin=r,e.originPoint=vG(t.min,t.max,e.origin),e.scale=Pq(n)/Pq(t),e.translate=vG(n.min,n.max,e.origin)-e.originPoint,(e.scale>=.9999&&e.scale<=1.0001||isNaN(e.scale))&&(e.scale=1),(e.translate>=-.01&&e.translate<=.01||isNaN(e.translate))&&(e.translate=0)}function Bq(e,t,n,r){zq(e.x,t.x,n.x,r?r.originX:void 0),zq(e.y,t.y,n.y,r?r.originY:void 0)}function Vq(e,t,n){e.min=n.min+t.min,e.max=e.min+Pq(t)}function Wq(e,t,n){e.min=t.min-n.min,e.max=e.min+Pq(t)}function Uq(e,t,n){Wq(e.x,t.x,n.x),Wq(e.y,t.y,n.y)}const jq=()=>({x:{min:0,max:0},y:{min:0,max:0}});function Gq(e){return[e("x"),e("y")]}function Hq(e){return void 0===e||1===e}function qq(e){let{scale:t,scaleX:n,scaleY:r}=e;return!Hq(t)||!Hq(n)||!Hq(r)}function Kq(e){return qq(e)||Xq(e)||e.z||e.rotate||e.rotateX||e.rotateY||e.skewX||e.skewY}function Xq(e){return Qq(e.x)||Qq(e.y)}function Qq(e){return e&&"0%"!==e}function Yq(e,t,n){return n+t*(e-n)}function Zq(e,t,n,r,s){return void 0!==s&&(e=Yq(e,s,r)),Yq(e,n,r)+t}function Jq(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3?arguments[3]:void 0,s=arguments.length>4?arguments[4]:void 0;e.min=Zq(e.min,t,n,r,s),e.max=Zq(e.max,t,n,r,s)}function eK(e,t){let{x:n,y:r}=t;Jq(e.x,n.translate,n.scale,n.originPoint),Jq(e.y,r.translate,r.scale,r.originPoint)}const tK=.999999999999,nK=1.0000000000001;function rK(e,t){e.min=e.min+t,e.max=e.max+t}function sK(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5;Jq(e,t,n,vG(e.min,e.max,s),r)}function aK(e,t){sK(e.x,t.x,t.scaleX,t.scale,t.originX),sK(e.y,t.y,t.scaleY,t.scale,t.originY)}function iK(e,t){return Lq(function(e,t){if(!t)return e;const n=t({x:e.left,y:e.top}),r=t({x:e.right,y:e.bottom});return{top:n.y,left:n.x,bottom:r.y,right:r.x}}(e.getBoundingClientRect(),t))}const oK=e=>{let{current:t}=e;return t?t.ownerDocument.defaultView:null};function lK(e){return e&&"object"===typeof e&&Object.prototype.hasOwnProperty.call(e,"current")}const uK=(e,t)=>Math.abs(e-t);class cK{constructor(e,t){let{transformPagePoint:n,contextWindow:r,dragSnapToOrigin:s=!1}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(this.startEvent=null,this.lastMoveEvent=null,this.lastMoveEventInfo=null,this.handlers={},this.contextWindow=window,this.updatePoint=()=>{if(!this.lastMoveEvent||!this.lastMoveEventInfo)return;const e=pK(this.lastMoveEventInfo,this.history),t=null!==this.startEvent,n=function(e,t){const n=uK(e.x,t.x),r=uK(e.y,t.y);return Math.sqrt(n**2+r**2)}(e.offset,{x:0,y:0})>=3;if(!t&&!n)return;const{point:r}=e,{timestamp:s}=uj;this.history.push({...r,timestamp:s});const{onStart:a,onMove:i}=this.handlers;t||(a&&a(this.lastMoveEvent,e),this.startEvent=this.lastMoveEvent),i&&i(this.lastMoveEvent,e)},this.handlePointerMove=(e,t)=>{this.lastMoveEvent=e,this.lastMoveEventInfo=hK(t,this.transformPagePoint),oj.update(this.updatePoint,!0)},this.handlePointerUp=(e,t)=>{this.end();const{onEnd:n,onSessionEnd:r,resumeAnimation:s}=this.handlers;if(this.dragSnapToOrigin&&s&&s(),!this.lastMoveEvent||!this.lastMoveEventInfo)return;const a=pK("pointercancel"===e.type?this.lastMoveEventInfo:hK(t,this.transformPagePoint),this.history);this.startEvent&&n&&n(e,a),r&&r(e,a)},!_q(e))return;this.dragSnapToOrigin=s,this.handlers=t,this.transformPagePoint=n,this.contextWindow=r||window;const a=hK(Fq(e),this.transformPagePoint),{point:i}=a,{timestamp:o}=uj;this.history=[{...i,timestamp:o}];const{onSessionStart:l}=t;l&&l(e,pK(a,this.history)),this.removeListeners=Dj(Mq(this.contextWindow,"pointermove",this.handlePointerMove),Mq(this.contextWindow,"pointerup",this.handlePointerUp),Mq(this.contextWindow,"pointercancel",this.handlePointerUp))}updateHandlers(e){this.handlers=e}end(){this.removeListeners&&this.removeListeners(),lj(this.updatePoint)}}function hK(e,t){return t?{point:t(e.point)}:e}function dK(e,t){return{x:e.x-t.x,y:e.y-t.y}}function pK(e,t){let{point:n}=e;return{point:n,delta:dK(n,mK(t)),offset:dK(n,fK(t)),velocity:gK(t,.1)}}function fK(e){return e[0]}function mK(e){return e[e.length-1]}function gK(e,t){if(e.length<2)return{x:0,y:0};let n=e.length-1,r=null;const s=mK(e);for(;n>=0&&(r=e[n],!(s.timestamp-r.timestamp>_j(t)));)n--;if(!r)return{x:0,y:0};const a=Fj(s.timestamp-r.timestamp);if(0===a)return{x:0,y:0};const i={x:(s.x-r.x)/a,y:(s.y-r.y)/a};return i.x===1/0&&(i.x=0),i.y===1/0&&(i.y=0),i}function yK(e,t,n){return{min:void 0!==t?e.min+t:void 0,max:void 0!==n?e.max+n-(e.max-e.min):void 0}}function bK(e,t){let n=t.min-e.min,r=t.max-e.max;return t.max-t.min<e.max-e.min&&([n,r]=[r,n]),{min:n,max:r}}const vK=.35;function xK(e,t,n){return{min:wK(e,t),max:wK(e,n)}}function wK(e,t){return"number"===typeof e?e:e[t]||0}const kK=new WeakMap;class SK{constructor(e){this.openDragLock=null,this.isDragging=!1,this.currentDirection=null,this.originPoint={x:0,y:0},this.constraints=!1,this.hasMutatedConstraints=!1,this.elastic={x:{min:0,max:0},y:{min:0,max:0}},this.visualElement=e}start(e){let{snapToCursor:t=!1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{presenceContext:n}=this.visualElement;if(n&&!1===n.isPresent)return;const{dragSnapToOrigin:r}=this.getProps();this.panSession=new cK(e,{onSessionStart:e=>{const{dragSnapToOrigin:n}=this.getProps();n?this.pauseAnimation():this.stopAnimation(),t&&this.snapToCursor(Fq(e).point)},onStart:(e,t)=>{const{drag:n,dragPropagation:r,onDragStart:s}=this.getProps();if(n&&!r&&(this.openDragLock&&this.openDragLock(),this.openDragLock=function(e){return"x"===e||"y"===e?Rq[e]?null:(Rq[e]=!0,()=>{Rq[e]=!1}):Rq.x||Rq.y?null:(Rq.x=Rq.y=!0,()=>{Rq.x=Rq.y=!1})}(n),!this.openDragLock))return;this.isDragging=!0,this.currentDirection=null,this.resolveConstraints(),this.visualElement.projection&&(this.visualElement.projection.isAnimationBlocked=!0,this.visualElement.projection.target=void 0),Gq((e=>{let t=this.getAxisMotionValue(e).get()||0;if(tG.test(t)){const{projection:n}=this.visualElement;if(n&&n.layout){const r=n.layout.layoutBox[e];if(r){t=Pq(r)*(parseFloat(t)/100)}}}this.originPoint[e]=t})),s&&oj.postRender((()=>s(e,t))),Tj(this.visualElement,"transform");const{animationState:a}=this.visualElement;a&&a.setActive("whileDrag",!0)},onMove:(e,t)=>{const{dragPropagation:n,dragDirectionLock:r,onDirectionLock:s,onDrag:a}=this.getProps();if(!n&&!this.openDragLock)return;const{offset:i}=t;if(r&&null===this.currentDirection)return this.currentDirection=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:10,n=null;Math.abs(e.y)>t?n="y":Math.abs(e.x)>t&&(n="x");return n}(i),void(null!==this.currentDirection&&s&&s(this.currentDirection));this.updateAxis("x",t.point,i),this.updateAxis("y",t.point,i),this.visualElement.render(),a&&a(e,t)},onSessionEnd:(e,t)=>this.stop(e,t),resumeAnimation:()=>Gq((e=>"paused"===this.getAnimationState(e)&&this.getAxisMotionValue(e).animation?.play()))},{transformPagePoint:this.visualElement.getTransformPagePoint(),dragSnapToOrigin:r,contextWindow:oK(this.visualElement)})}stop(e,t){const n=this.isDragging;if(this.cancel(),!n)return;const{velocity:r}=t;this.startAnimation(r);const{onDragEnd:s}=this.getProps();s&&oj.postRender((()=>s(e,t)))}cancel(){this.isDragging=!1;const{projection:e,animationState:t}=this.visualElement;e&&(e.isAnimationBlocked=!1),this.panSession&&this.panSession.end(),this.panSession=void 0;const{dragPropagation:n}=this.getProps();!n&&this.openDragLock&&(this.openDragLock(),this.openDragLock=null),t&&t.setActive("whileDrag",!1)}updateAxis(e,t,n){const{drag:r}=this.getProps();if(!n||!NK(e,r,this.currentDirection))return;const s=this.getAxisMotionValue(e);let a=this.originPoint[e]+n[e];this.constraints&&this.constraints[e]&&(a=function(e,t,n){let{min:r,max:s}=t;return void 0!==r&&e<r?e=n?vG(r,e,n.min):Math.max(e,r):void 0!==s&&e>s&&(e=n?vG(s,e,n.max):Math.min(e,s)),e}(a,this.constraints[e],this.elastic[e])),s.set(a)}resolveConstraints(){const{dragConstraints:e,dragElastic:t}=this.getProps(),n=this.visualElement.projection&&!this.visualElement.projection.layout?this.visualElement.projection.measure(!1):this.visualElement.projection?.layout,r=this.constraints;e&&lK(e)?this.constraints||(this.constraints=this.resolveRefConstraints()):this.constraints=!(!e||!n)&&function(e,t){let{top:n,left:r,bottom:s,right:a}=t;return{x:yK(e.x,r,a),y:yK(e.y,n,s)}}(n.layoutBox,e),this.elastic=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:vK;return!1===e?e=0:!0===e&&(e=vK),{x:xK(e,"left","right"),y:xK(e,"top","bottom")}}(t),r!==this.constraints&&n&&this.constraints&&!this.hasMutatedConstraints&&Gq((e=>{!1!==this.constraints&&this.getAxisMotionValue(e)&&(this.constraints[e]=function(e,t){const n={};return void 0!==t.min&&(n.min=t.min-e.min),void 0!==t.max&&(n.max=t.max-e.min),n}(n.layoutBox[e],this.constraints[e]))}))}resolveRefConstraints(){const{dragConstraints:e,onMeasureDragConstraints:t}=this.getProps();if(!e||!lK(e))return!1;const n=e.current,{projection:r}=this.visualElement;if(!r||!r.layout)return!1;const s=function(e,t,n){const r=iK(e,n),{scroll:s}=t;return s&&(rK(r.x,s.offset.x),rK(r.y,s.offset.y)),r}(n,r.root,this.visualElement.getTransformPagePoint());let a=function(e,t){return{x:bK(e.x,t.x),y:bK(e.y,t.y)}}(r.layout.layoutBox,s);if(t){const e=t(function(e){let{x:t,y:n}=e;return{top:n.min,right:t.max,bottom:n.max,left:t.min}}(a));this.hasMutatedConstraints=!!e,e&&(a=Lq(e))}return a}startAnimation(e){const{drag:t,dragMomentum:n,dragElastic:r,dragTransition:s,dragSnapToOrigin:a,onDragTransitionEnd:i}=this.getProps(),o=this.constraints||{},l=Gq((i=>{if(!NK(i,t,this.currentDirection))return;let l=o&&o[i]||{};a&&(l={min:0,max:0});const u=r?200:1e6,c=r?40:1e7,h={type:"inertia",velocity:n?e[i]:0,bounceStiffness:u,bounceDamping:c,timeConstant:750,restDelta:1,restSpeed:10,...s,...l};return this.startAxisValueAnimation(i,h)}));return Promise.all(l).then(i)}startAxisValueAnimation(e,t){const n=this.getAxisMotionValue(e);return Tj(this.visualElement,e),n.start(cq(e,n,0,t,this.visualElement,!1))}stopAnimation(){Gq((e=>this.getAxisMotionValue(e).stop()))}pauseAnimation(){Gq((e=>this.getAxisMotionValue(e).animation?.pause()))}getAnimationState(e){return this.getAxisMotionValue(e).animation?.state}getAxisMotionValue(e){const t=`_drag${e.toUpperCase()}`,n=this.visualElement.getProps(),r=n[t];return r||this.visualElement.getValue(e,(n.initial?n.initial[e]:void 0)||0)}snapToCursor(e){Gq((t=>{const{drag:n}=this.getProps();if(!NK(t,n,this.currentDirection))return;const{projection:r}=this.visualElement,s=this.getAxisMotionValue(t);if(r&&r.layout){const{min:n,max:a}=r.layout.layoutBox[t];s.set(e[t]-vG(n,a,.5))}}))}scalePositionWithinConstraints(){if(!this.visualElement.current)return;const{drag:e,dragConstraints:t}=this.getProps(),{projection:n}=this.visualElement;if(!lK(t)||!n||!this.constraints)return;this.stopAnimation();const r={x:0,y:0};Gq((e=>{const t=this.getAxisMotionValue(e);if(t&&!1!==this.constraints){const n=t.get();r[e]=function(e,t){let n=.5;const r=Pq(e),s=Pq(t);return s>r?n=uH(t.min,t.max-r,e.min):r>s&&(n=uH(e.min,e.max-s,t.min)),Oj(0,1,n)}({min:n,max:n},this.constraints[e])}}));const{transformTemplate:s}=this.visualElement.getProps();this.visualElement.current.style.transform=s?s({},""):"none",n.root&&n.root.updateScroll(),n.updateLayout(),this.resolveConstraints(),Gq((t=>{if(!NK(t,e,null))return;const n=this.getAxisMotionValue(t),{min:s,max:a}=this.constraints[t];n.set(vG(s,a,r[t]))}))}addListeners(){if(!this.visualElement.current)return;kK.set(this.visualElement,this);const e=Mq(this.visualElement.current,"pointerdown",(e=>{const{drag:t,dragListener:n=!0}=this.getProps();t&&n&&this.start(e)})),t=()=>{const{dragConstraints:e}=this.getProps();lK(e)&&e.current&&(this.constraints=this.resolveRefConstraints())},{projection:n}=this.visualElement,r=n.addEventListener("measure",t);n&&!n.layout&&(n.root&&n.root.updateScroll(),n.updateLayout()),oj.read(t);const s=Oq(window,"resize",(()=>this.scalePositionWithinConstraints())),a=n.addEventListener("didUpdate",(e=>{let{delta:t,hasLayoutChanged:n}=e;this.isDragging&&n&&(Gq((e=>{const n=this.getAxisMotionValue(e);n&&(this.originPoint[e]+=t[e].translate,n.set(n.get()+t[e].translate))})),this.visualElement.render())}));return()=>{s(),e(),r(),a&&a()}}getProps(){const e=this.visualElement.getProps(),{drag:t=!1,dragDirectionLock:n=!1,dragPropagation:r=!1,dragConstraints:s=!1,dragElastic:a=vK,dragMomentum:i=!0}=e;return{...e,drag:t,dragDirectionLock:n,dragPropagation:r,dragConstraints:s,dragElastic:a,dragMomentum:i}}}function NK(e,t,n){return(!0===t||t===e)&&(null===n||n===e)}const IK=e=>(t,n)=>{e&&oj.postRender((()=>e(t,n)))};const{schedule:CK,cancel:TK}=ij(queueMicrotask,!1),AK=(0,T.createContext)({}),EK={hasAnimatedSinceResize:!0,hasEverUpdated:!1};function $K(e,t){return t.max===t.min?0:e/(t.max-t.min)*100}const RK={correct:(e,t)=>{if(!t.target)return e;if("string"===typeof e){if(!nG.test(e))return e;e=parseFloat(e)}return`${$K(e,t.target.x)}% ${$K(e,t.target.y)}%`}},DK={correct:(e,t)=>{let{treeScale:n,projectionDelta:r}=t;const s=e,a=gG.parse(e);if(a.length>5)return s;const i=gG.createTransformer(e),o="number"!==typeof a[0]?1:0,l=r.x.scale*n.x,u=r.y.scale*n.y;a[0+o]/=l,a[1+o]/=u;const c=vG(l,u,.5);return"number"===typeof a[2+o]&&(a[2+o]/=c),"number"===typeof a[3+o]&&(a[3+o]/=c),i(a)}},OK={};class _K extends T.Component{componentDidMount(){const{visualElement:e,layoutGroup:t,switchLayoutGroup:n,layoutId:r}=this.props,{projection:s}=e;!function(e){for(const t in e)OK[t]=e[t],Pj(t)&&(OK[t].isCSSVariable=!0)}(MK),s&&(t.group&&t.group.add(s),n&&n.register&&r&&n.register(s),s.root.didUpdate(),s.addEventListener("animationComplete",(()=>{this.safeToRemove()})),s.setOptions({...s.options,onExitComplete:()=>this.safeToRemove()})),EK.hasEverUpdated=!0}getSnapshotBeforeUpdate(e){const{layoutDependency:t,visualElement:n,drag:r,isPresent:s}=this.props,{projection:a}=n;return a?(a.isPresent=s,r||e.layoutDependency!==t||void 0===t||e.isPresent!==s?a.willUpdate():this.safeToRemove(),e.isPresent!==s&&(s?a.promote():a.relegate()||oj.postRender((()=>{const e=a.getStack();e&&e.members.length||this.safeToRemove()}))),null):null}componentDidUpdate(){const{projection:e}=this.props.visualElement;e&&(e.root.didUpdate(),CK.postRender((()=>{!e.currentAnimation&&e.isLead()&&this.safeToRemove()})))}componentWillUnmount(){const{visualElement:e,layoutGroup:t,switchLayoutGroup:n}=this.props,{projection:r}=e;r&&(r.scheduleCheckAfterUnmount(),t&&t.group&&t.group.remove(r),n&&n.deregister&&n.deregister(r))}safeToRemove(){const{safeToRemove:e}=this.props;e&&e()}render(){return null}}function FK(e){const[t,n]=HU(),r=(0,T.useContext)(_U);return(0,tr.jsx)(_K,{...e,layoutGroup:r,switchLayoutGroup:(0,T.useContext)(AK),isPresent:t,safeToRemove:n})}const MK={borderRadius:{...RK,applyTo:["borderTopLeftRadius","borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius"]},borderTopLeftRadius:RK,borderTopRightRadius:RK,borderBottomLeftRadius:RK,borderBottomRightRadius:RK,boxShadow:DK};function LK(e){return zU(e)&&"ownerSVGElement"in e}const PK=(e,t)=>e.depth-t.depth;class zK{constructor(){this.children=[],this.isDirty=!1}add(e){fj(this.children,e),this.isDirty=!0}remove(e){mj(this.children,e),this.isDirty=!0}forEach(e){this.isDirty&&this.children.sort(PK),this.isDirty=!1,this.children.forEach(e)}}function BK(e,t){const n=xj.now(),r=s=>{let{timestamp:a}=s;const i=a-n;i>=t&&(lj(r),e(i-t))};return oj.setup(r,!0),()=>lj(r)}function VK(e){return Cj(e)?e.get():e}const WK=["TopLeft","TopRight","BottomLeft","BottomRight"],UK=WK.length,jK=e=>"string"===typeof e?parseFloat(e):e,GK=e=>"number"===typeof e||nG.test(e);function HK(e,t){return void 0!==e[t]?e[t]:e.borderRadius}const qK=XK(0,.5,sH),KK=XK(.5,.95,nj);function XK(e,t,n){return r=>r<e?0:r>t?1:n(uH(e,t,r))}function QK(e,t){e.min=t.min,e.max=t.max}function YK(e,t){QK(e.x,t.x),QK(e.y,t.y)}function ZK(e,t){e.translate=t.translate,e.scale=t.scale,e.originPoint=t.originPoint,e.origin=t.origin}function JK(e,t,n,r,s){return e=Yq(e-=t,1/n,r),void 0!==s&&(e=Yq(e,1/s,r)),e}function eX(e,t,n,r,s){let[a,i,o]=n;!function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,s=arguments.length>4?arguments[4]:void 0,a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:e,i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:e;tG.test(t)&&(t=parseFloat(t),t=vG(i.min,i.max,t/100)-i.min);if("number"!==typeof t)return;let o=vG(a.min,a.max,r);e===a&&(o-=t),e.min=JK(e.min,t,n,o,s),e.max=JK(e.max,t,n,o,s)}(e,t[a],t[i],t[o],t.scale,r,s)}const tX=["x","scaleX","originX"],nX=["y","scaleY","originY"];function rX(e,t,n,r){eX(e.x,t,tX,n?n.x:void 0,r?r.x:void 0),eX(e.y,t,nX,n?n.y:void 0,r?r.y:void 0)}function sX(e){return 0===e.translate&&1===e.scale}function aX(e){return sX(e.x)&&sX(e.y)}function iX(e,t){return e.min===t.min&&e.max===t.max}function oX(e,t){return Math.round(e.min)===Math.round(t.min)&&Math.round(e.max)===Math.round(t.max)}function lX(e,t){return oX(e.x,t.x)&&oX(e.y,t.y)}function uX(e){return Pq(e.x)/Pq(e.y)}function cX(e,t){return e.translate===t.translate&&e.scale===t.scale&&e.originPoint===t.originPoint}class hX{constructor(){this.members=[]}add(e){fj(this.members,e),e.scheduleRender()}remove(e){if(mj(this.members,e),e===this.prevLead&&(this.prevLead=void 0),e===this.lead){const e=this.members[this.members.length-1];e&&this.promote(e)}}relegate(e){const t=this.members.findIndex((t=>e===t));if(0===t)return!1;let n;for(let r=t;r>=0;r--){const e=this.members[r];if(!1!==e.isPresent){n=e;break}}return!!n&&(this.promote(n),!0)}promote(e,t){const n=this.lead;if(e!==n&&(this.prevLead=n,this.lead=e,e.show(),n)){n.instance&&n.scheduleRender(),e.scheduleRender(),e.resumeFrom=n,t&&(e.resumeFrom.preserveOpacity=!0),n.snapshot&&(e.snapshot=n.snapshot,e.snapshot.latestValues=n.animationValues||n.latestValues),e.root&&e.root.isUpdating&&(e.isLayoutDirty=!0);const{crossfade:r}=e.options;!1===r&&n.hide()}}exitAnimationComplete(){this.members.forEach((e=>{const{options:t,resumingFrom:n}=e;t.onExitComplete&&t.onExitComplete(),n&&n.options.onExitComplete&&n.options.onExitComplete()}))}scheduleRender(){this.members.forEach((e=>{e.instance&&e.scheduleRender(!1)}))}removeLeadSnapshot(){this.lead&&this.lead.snapshot&&(this.lead.snapshot=void 0)}}const dX={nodes:0,calculatedTargetDeltas:0,calculatedProjections:0},pX=["","X","Y","Z"],fX={visibility:"hidden"};let mX=0;function gX(e,t,n,r){const{latestValues:s}=t;s[e]&&(n[e]=s[e],t.setStaticValue(e,0),r&&(r[e]=0))}function yX(e){if(e.hasCheckedOptimisedAppear=!0,e.root===e)return;const{visualElement:t}=e.options;if(!t)return;const n=$j(t);if(window.MotionHasOptimisedAnimation(n,"transform")){const{layout:t,layoutId:r}=e.options;window.MotionCancelOptimisedAnimation(n,"transform",oj,!(t||r))}const{parent:r}=e;r&&!r.hasCheckedOptimisedAppear&&yX(r)}function bX(e){let{attachResizeListener:t,defaultParent:n,measureScroll:r,checkIsScrollRoot:s,resetTransform:a}=e;return class{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:n?.();this.id=mX++,this.animationId=0,this.animationCommitId=0,this.children=new Set,this.options={},this.isTreeAnimating=!1,this.isAnimationBlocked=!1,this.isLayoutDirty=!1,this.isProjectionDirty=!1,this.isSharedProjectionDirty=!1,this.isTransformDirty=!1,this.updateManuallyBlocked=!1,this.updateBlockedByResize=!1,this.isUpdating=!1,this.isSVG=!1,this.needsReset=!1,this.shouldResetTransform=!1,this.hasCheckedOptimisedAppear=!1,this.treeScale={x:1,y:1},this.eventHandlers=new Map,this.hasTreeAnimated=!1,this.updateScheduled=!1,this.scheduleUpdate=()=>this.update(),this.projectionUpdateScheduled=!1,this.checkUpdateFailed=()=>{this.isUpdating&&(this.isUpdating=!1,this.clearAllSnapshots())},this.updateProjection=()=>{this.projectionUpdateScheduled=!1,aj.value&&(dX.nodes=dX.calculatedTargetDeltas=dX.calculatedProjections=0),this.nodes.forEach(wX),this.nodes.forEach(AX),this.nodes.forEach(EX),this.nodes.forEach(kX),aj.addProjectionMetrics&&aj.addProjectionMetrics(dX)},this.resolvedRelativeTargetAt=0,this.hasProjected=!1,this.isVisible=!0,this.animationProgress=0,this.sharedNodes=new Map,this.latestValues=e,this.root=t?t.root||t:this,this.path=t?[...t.path,t]:[],this.parent=t,this.depth=t?t.depth+1:0;for(let n=0;n<this.path.length;n++)this.path[n].shouldResetTransform=!0;this.root===this&&(this.nodes=new zK)}addEventListener(e,t){return this.eventHandlers.has(e)||this.eventHandlers.set(e,new gj),this.eventHandlers.get(e).add(t)}notifyListeners(e){const t=this.eventHandlers.get(e);for(var n=arguments.length,r=new Array(n>1?n-1:0),s=1;s<n;s++)r[s-1]=arguments[s];t&&t.notify(...r)}hasListeners(e){return this.eventHandlers.has(e)}mount(e){if(this.instance)return;var n;this.isSVG=LK(e)&&!(LK(n=e)&&"svg"===n.tagName),this.instance=e;const{layoutId:r,layout:s,visualElement:a}=this.options;if(a&&!a.current&&a.mount(e),this.root.nodes.add(this),this.parent&&this.parent.children.add(this),this.root.hasTreeAnimated&&(s||r)&&(this.isLayoutDirty=!0),t){let n;const r=()=>this.root.updateBlockedByResize=!1;t(e,(()=>{this.root.updateBlockedByResize=!0,n&&n(),n=BK(r,250),EK.hasAnimatedSinceResize&&(EK.hasAnimatedSinceResize=!1,this.nodes.forEach(TX))}))}r&&this.root.registerSharedNode(r,this),!1!==this.options.animate&&a&&(r||s)&&this.addEventListener("didUpdate",(e=>{let{delta:t,hasLayoutChanged:n,hasRelativeLayoutChanged:r,layout:s}=e;if(this.isTreeAnimationBlocked())return this.target=void 0,void(this.relativeTarget=void 0);const i=this.options.transition||a.getDefaultTransition()||FX,{onLayoutAnimationStart:o,onLayoutAnimationComplete:l}=a.getProps(),u=!this.targetLayout||!lX(this.targetLayout,s),c=!n&&r;if(this.options.layoutRoot||this.resumeFrom||c||n&&(u||!this.currentAnimation)){this.resumeFrom&&(this.resumingFrom=this.resumeFrom,this.resumingFrom.resumingFrom=void 0);const e={...tj(i,"layout"),onPlay:o,onComplete:l};(a.shouldReduceMotion||this.options.layoutRoot)&&(e.delay=0,e.type=!1),this.startAnimation(e),this.setAnimationOrigin(t,c)}else n||TX(this),this.isLead()&&this.options.onExitComplete&&this.options.onExitComplete();this.targetLayout=s}))}unmount(){this.options.layoutId&&this.willUpdate(),this.root.nodes.remove(this);const e=this.getStack();e&&e.remove(this),this.parent&&this.parent.children.delete(this),this.instance=void 0,this.eventHandlers.clear(),lj(this.updateProjection)}blockUpdate(){this.updateManuallyBlocked=!0}unblockUpdate(){this.updateManuallyBlocked=!1}isUpdateBlocked(){return this.updateManuallyBlocked||this.updateBlockedByResize}isTreeAnimationBlocked(){return this.isAnimationBlocked||this.parent&&this.parent.isTreeAnimationBlocked()||!1}startUpdate(){this.isUpdateBlocked()||(this.isUpdating=!0,this.nodes&&this.nodes.forEach($X),this.animationId++)}getTransformTemplate(){const{visualElement:e}=this.options;return e&&e.getProps().transformTemplate}willUpdate(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];if(this.root.hasTreeAnimated=!0,this.root.isUpdateBlocked())return void(this.options.onExitComplete&&this.options.onExitComplete());if(window.MotionCancelOptimisedAnimation&&!this.hasCheckedOptimisedAppear&&yX(this),!this.root.isUpdating&&this.root.startUpdate(),this.isLayoutDirty)return;this.isLayoutDirty=!0;for(let s=0;s<this.path.length;s++){const e=this.path[s];e.shouldResetTransform=!0,e.updateScroll("snapshot"),e.options.layoutRoot&&e.willUpdate(!1)}const{layoutId:t,layout:n}=this.options;if(void 0===t&&!n)return;const r=this.getTransformTemplate();this.prevTransformTemplateValue=r?r(this.latestValues,""):void 0,this.updateSnapshot(),e&&this.notifyListeners("willUpdate")}update(){this.updateScheduled=!1;if(this.isUpdateBlocked())return this.unblockUpdate(),this.clearAllSnapshots(),void this.nodes.forEach(NX);if(this.animationId<=this.animationCommitId)return void this.nodes.forEach(IX);this.isUpdating||this.nodes.forEach(IX),this.animationCommitId=this.animationId,this.isUpdating=!1,this.nodes.forEach(CX),this.nodes.forEach(vX),this.nodes.forEach(xX),this.clearAllSnapshots();const e=xj.now();uj.delta=Oj(0,1e3/60,e-uj.timestamp),uj.timestamp=e,uj.isProcessing=!0,cj.update.process(uj),cj.preRender.process(uj),cj.render.process(uj),uj.isProcessing=!1}didUpdate(){this.updateScheduled||(this.updateScheduled=!0,CK.read(this.scheduleUpdate))}clearAllSnapshots(){this.nodes.forEach(SX),this.sharedNodes.forEach(RX)}scheduleUpdateProjection(){this.projectionUpdateScheduled||(this.projectionUpdateScheduled=!0,oj.preRender(this.updateProjection,!1,!0))}scheduleCheckAfterUnmount(){oj.postRender((()=>{this.isLayoutDirty?this.root.didUpdate():this.root.checkUpdateFailed()}))}updateSnapshot(){!this.snapshot&&this.instance&&(this.snapshot=this.measure(),!this.snapshot||Pq(this.snapshot.measuredBox.x)||Pq(this.snapshot.measuredBox.y)||(this.snapshot=void 0))}updateLayout(){if(!this.instance)return;if(this.updateScroll(),(!this.options.alwaysMeasureLayout||!this.isLead())&&!this.isLayoutDirty)return;if(this.resumeFrom&&!this.resumeFrom.instance)for(let n=0;n<this.path.length;n++){this.path[n].updateScroll()}const e=this.layout;this.layout=this.measure(!1),this.layoutCorrected={x:{min:0,max:0},y:{min:0,max:0}},this.isLayoutDirty=!1,this.projectionDelta=void 0,this.notifyListeners("measure",this.layout.layoutBox);const{visualElement:t}=this.options;t&&t.notify("LayoutMeasure",this.layout.layoutBox,e?e.layoutBox:void 0)}updateScroll(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"measure",t=Boolean(this.options.layoutScroll&&this.instance);if(this.scroll&&this.scroll.animationId===this.root.animationId&&this.scroll.phase===e&&(t=!1),t&&this.instance){const t=s(this.instance);this.scroll={animationId:this.root.animationId,phase:e,isRoot:t,offset:r(this.instance),wasRoot:this.scroll?this.scroll.isRoot:t}}}resetTransform(){if(!a)return;const e=this.isLayoutDirty||this.shouldResetTransform||this.options.alwaysMeasureLayout,t=this.projectionDelta&&!aX(this.projectionDelta),n=this.getTransformTemplate(),r=n?n(this.latestValues,""):void 0,s=r!==this.prevTransformTemplateValue;e&&this.instance&&(t||Kq(this.latestValues)||s)&&(a(this.instance,r),this.shouldResetTransform=!1,this.scheduleRender())}measure(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];const t=this.measurePageBox();let n=this.removeElementScroll(t);var r;return e&&(n=this.removeTransform(n)),PX((r=n).x),PX(r.y),{animationId:this.root.animationId,measuredBox:t,layoutBox:n,latestValues:{},source:this.id}}measurePageBox(){const{visualElement:e}=this.options;if(!e)return{x:{min:0,max:0},y:{min:0,max:0}};const t=e.measureViewportBox();if(!(this.scroll?.wasRoot||this.path.some(BX))){const{scroll:e}=this.root;e&&(rK(t.x,e.offset.x),rK(t.y,e.offset.y))}return t}removeElementScroll(e){const t={x:{min:0,max:0},y:{min:0,max:0}};if(YK(t,e),this.scroll?.wasRoot)return t;for(let n=0;n<this.path.length;n++){const r=this.path[n],{scroll:s,options:a}=r;r!==this.root&&s&&a.layoutScroll&&(s.wasRoot&&YK(t,e),rK(t.x,s.offset.x),rK(t.y,s.offset.y))}return t}applyTransform(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const n={x:{min:0,max:0},y:{min:0,max:0}};YK(n,e);for(let r=0;r<this.path.length;r++){const e=this.path[r];!t&&e.options.layoutScroll&&e.scroll&&e!==e.root&&aK(n,{x:-e.scroll.offset.x,y:-e.scroll.offset.y}),Kq(e.latestValues)&&aK(n,e.latestValues)}return Kq(this.latestValues)&&aK(n,this.latestValues),n}removeTransform(e){const t={x:{min:0,max:0},y:{min:0,max:0}};YK(t,e);for(let n=0;n<this.path.length;n++){const e=this.path[n];if(!e.instance)continue;if(!Kq(e.latestValues))continue;qq(e.latestValues)&&e.updateSnapshot();const r={x:{min:0,max:0},y:{min:0,max:0}};YK(r,e.measurePageBox()),rX(t,e.latestValues,e.snapshot?e.snapshot.layoutBox:void 0,r)}return Kq(this.latestValues)&&rX(t,this.latestValues),t}setTargetDelta(e){this.targetDelta=e,this.root.scheduleUpdateProjection(),this.isProjectionDirty=!0}setOptions(e){this.options={...this.options,...e,crossfade:void 0===e.crossfade||e.crossfade}}clearMeasurements(){this.scroll=void 0,this.layout=void 0,this.snapshot=void 0,this.prevTransformTemplateValue=void 0,this.targetDelta=void 0,this.target=void 0,this.isLayoutDirty=!1}forceRelativeParentToResolveTarget(){this.relativeParent&&this.relativeParent.resolvedRelativeTargetAt!==uj.timestamp&&this.relativeParent.resolveTargetDelta(!0)}resolveTargetDelta(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const t=this.getLead();this.isProjectionDirty||(this.isProjectionDirty=t.isProjectionDirty),this.isTransformDirty||(this.isTransformDirty=t.isTransformDirty),this.isSharedProjectionDirty||(this.isSharedProjectionDirty=t.isSharedProjectionDirty);const n=Boolean(this.resumingFrom)||this!==t;if(!(e||n&&this.isSharedProjectionDirty||this.isProjectionDirty||this.parent?.isProjectionDirty||this.attemptToResolveRelativeTarget||this.root.updateBlockedByResize))return;const{layout:r,layoutId:s}=this.options;if(this.layout&&(r||s)){if(this.resolvedRelativeTargetAt=uj.timestamp,!this.targetDelta&&!this.relativeTarget){const e=this.getClosestProjectingParent();e&&e.layout&&1!==this.animationProgress?(this.relativeParent=e,this.forceRelativeParentToResolveTarget(),this.relativeTarget={x:{min:0,max:0},y:{min:0,max:0}},this.relativeTargetOrigin={x:{min:0,max:0},y:{min:0,max:0}},Uq(this.relativeTargetOrigin,this.layout.layoutBox,e.layout.layoutBox),YK(this.relativeTarget,this.relativeTargetOrigin)):this.relativeParent=this.relativeTarget=void 0}if(this.relativeTarget||this.targetDelta){var a,i,o;if(this.target||(this.target={x:{min:0,max:0},y:{min:0,max:0}},this.targetWithTransforms={x:{min:0,max:0},y:{min:0,max:0}}),this.relativeTarget&&this.relativeTargetOrigin&&this.relativeParent&&this.relativeParent.target?(this.forceRelativeParentToResolveTarget(),a=this.target,i=this.relativeTarget,o=this.relativeParent.target,Vq(a.x,i.x,o.x),Vq(a.y,i.y,o.y)):this.targetDelta?(Boolean(this.resumingFrom)?this.target=this.applyTransform(this.layout.layoutBox):YK(this.target,this.layout.layoutBox),eK(this.target,this.targetDelta)):YK(this.target,this.layout.layoutBox),this.attemptToResolveRelativeTarget){this.attemptToResolveRelativeTarget=!1;const e=this.getClosestProjectingParent();e&&Boolean(e.resumingFrom)===Boolean(this.resumingFrom)&&!e.options.layoutScroll&&e.target&&1!==this.animationProgress?(this.relativeParent=e,this.forceRelativeParentToResolveTarget(),this.relativeTarget={x:{min:0,max:0},y:{min:0,max:0}},this.relativeTargetOrigin={x:{min:0,max:0},y:{min:0,max:0}},Uq(this.relativeTargetOrigin,this.target,e.target),YK(this.relativeTarget,this.relativeTargetOrigin)):this.relativeParent=this.relativeTarget=void 0}aj.value&&dX.calculatedTargetDeltas++}}}getClosestProjectingParent(){if(this.parent&&!qq(this.parent.latestValues)&&!Xq(this.parent.latestValues))return this.parent.isProjecting()?this.parent:this.parent.getClosestProjectingParent()}isProjecting(){return Boolean((this.relativeTarget||this.targetDelta||this.options.layoutRoot)&&this.layout)}calcProjection(){const e=this.getLead(),t=Boolean(this.resumingFrom)||this!==e;let n=!0;if((this.isProjectionDirty||this.parent?.isProjectionDirty)&&(n=!1),t&&(this.isSharedProjectionDirty||this.isTransformDirty)&&(n=!1),this.resolvedRelativeTargetAt===uj.timestamp&&(n=!1),n)return;const{layout:r,layoutId:s}=this.options;if(this.isTreeAnimating=Boolean(this.parent&&this.parent.isTreeAnimating||this.currentAnimation||this.pendingAnimation),this.isTreeAnimating||(this.targetDelta=this.relativeTarget=void 0),!this.layout||!r&&!s)return;YK(this.layoutCorrected,this.layout.layoutBox);const a=this.treeScale.x,i=this.treeScale.y;!function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=n.length;if(!s)return;let a,i;t.x=t.y=1;for(let o=0;o<s;o++){a=n[o],i=a.projectionDelta;const{visualElement:s}=a.options;s&&s.props.style&&"contents"===s.props.style.display||(r&&a.options.layoutScroll&&a.scroll&&a!==a.root&&aK(e,{x:-a.scroll.offset.x,y:-a.scroll.offset.y}),i&&(t.x*=i.x.scale,t.y*=i.y.scale,eK(e,i)),r&&Kq(a.latestValues)&&aK(e,a.latestValues))}t.x<nK&&t.x>tK&&(t.x=1),t.y<nK&&t.y>tK&&(t.y=1)}(this.layoutCorrected,this.treeScale,this.path,t),!e.layout||e.target||1===this.treeScale.x&&1===this.treeScale.y||(e.target=e.layout.layoutBox,e.targetWithTransforms={x:{min:0,max:0},y:{min:0,max:0}});const{target:o}=e;o?(this.projectionDelta&&this.prevProjectionDelta?(ZK(this.prevProjectionDelta.x,this.projectionDelta.x),ZK(this.prevProjectionDelta.y,this.projectionDelta.y)):this.createProjectionDeltas(),Bq(this.projectionDelta,this.layoutCorrected,o,this.latestValues),this.treeScale.x===a&&this.treeScale.y===i&&cX(this.projectionDelta.x,this.prevProjectionDelta.x)&&cX(this.projectionDelta.y,this.prevProjectionDelta.y)||(this.hasProjected=!0,this.scheduleRender(),this.notifyListeners("projectionUpdate",o)),aj.value&&dX.calculatedProjections++):this.prevProjectionDelta&&(this.createProjectionDeltas(),this.scheduleRender())}hide(){this.isVisible=!1}show(){this.isVisible=!0}scheduleRender(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];if(this.options.visualElement?.scheduleRender(),e){const e=this.getStack();e&&e.scheduleRender()}this.resumingFrom&&!this.resumingFrom.instance&&(this.resumingFrom=void 0)}createProjectionDeltas(){this.prevProjectionDelta={x:{translate:0,scale:1,origin:0,originPoint:0},y:{translate:0,scale:1,origin:0,originPoint:0}},this.projectionDelta={x:{translate:0,scale:1,origin:0,originPoint:0},y:{translate:0,scale:1,origin:0,originPoint:0}},this.projectionDeltaWithTransform={x:{translate:0,scale:1,origin:0,originPoint:0},y:{translate:0,scale:1,origin:0,originPoint:0}}}setAnimationOrigin(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const n=this.snapshot,r=n?n.latestValues:{},s={...this.latestValues},a={x:{translate:0,scale:1,origin:0,originPoint:0},y:{translate:0,scale:1,origin:0,originPoint:0}};this.relativeParent&&this.relativeParent.options.layoutRoot||(this.relativeTarget=this.relativeTargetOrigin=void 0),this.attemptToResolveRelativeTarget=!t;const i={x:{min:0,max:0},y:{min:0,max:0}},o=(n?n.source:void 0)!==(this.layout?this.layout.source:void 0),l=this.getStack(),u=!l||l.members.length<=1,c=Boolean(o&&!u&&!0===this.options.crossfade&&!this.path.some(_X));let h;this.animationProgress=0,this.mixTargetDelta=t=>{const n=t/1e3;DX(a.x,e.x,n),DX(a.y,e.y,n),this.setTargetDelta(a),this.relativeTarget&&this.relativeTargetOrigin&&this.layout&&this.relativeParent&&this.relativeParent.layout&&(Uq(i,this.layout.layoutBox,this.relativeParent.layout.layoutBox),function(e,t,n,r){OX(e.x,t.x,n.x,r),OX(e.y,t.y,n.y,r)}(this.relativeTarget,this.relativeTargetOrigin,i,n),h&&function(e,t){return iX(e.x,t.x)&&iX(e.y,t.y)}(this.relativeTarget,h)&&(this.isProjectionDirty=!1),h||(h={x:{min:0,max:0},y:{min:0,max:0}}),YK(h,this.relativeTarget)),o&&(this.animationValues=s,function(e,t,n,r,s,a){s?(e.opacity=vG(0,n.opacity??1,qK(r)),e.opacityExit=vG(t.opacity??1,0,KK(r))):a&&(e.opacity=vG(t.opacity??1,n.opacity??1,r));for(let i=0;i<UK;i++){const s=`border${WK[i]}Radius`;let a=HK(t,s),o=HK(n,s);void 0===a&&void 0===o||(a||(a=0),o||(o=0),0===a||0===o||GK(a)===GK(o)?(e[s]=Math.max(vG(jK(a),jK(o),r),0),(tG.test(o)||tG.test(a))&&(e[s]+="%")):e[s]=o)}(t.rotate||n.rotate)&&(e.rotate=vG(t.rotate||0,n.rotate||0,r))}(s,r,this.latestValues,n,c,u)),this.root.scheduleUpdateProjection(),this.scheduleRender(),this.animationProgress=n},this.mixTargetDelta(this.options.layoutRoot?1e3:0)}startAnimation(e){this.notifyListeners("animationStart"),this.currentAnimation?.stop(),this.resumingFrom?.currentAnimation?.stop(),this.pendingAnimation&&(lj(this.pendingAnimation),this.pendingAnimation=void 0),this.pendingAnimation=oj.update((()=>{EK.hasAnimatedSinceResize=!0,Mj.layout++,this.motionValue||(this.motionValue=Sj(0)),this.currentAnimation=function(e,t,n){const r=Cj(e)?e:Sj(e);return r.start(cq("",r,t,n)),r.animation}(this.motionValue,[0,1e3],{...e,velocity:0,isSync:!0,onUpdate:t=>{this.mixTargetDelta(t),e.onUpdate&&e.onUpdate(t)},onStop:()=>{Mj.layout--},onComplete:()=>{Mj.layout--,e.onComplete&&e.onComplete(),this.completeAnimation()}}),this.resumingFrom&&(this.resumingFrom.currentAnimation=this.currentAnimation),this.pendingAnimation=void 0}))}completeAnimation(){this.resumingFrom&&(this.resumingFrom.currentAnimation=void 0,this.resumingFrom.preserveOpacity=void 0);const e=this.getStack();e&&e.exitAnimationComplete(),this.resumingFrom=this.currentAnimation=this.animationValues=void 0,this.notifyListeners("animationComplete")}finishAnimation(){this.currentAnimation&&(this.mixTargetDelta&&this.mixTargetDelta(1e3),this.currentAnimation.stop()),this.completeAnimation()}applyTransformsToTarget(){const e=this.getLead();let{targetWithTransforms:t,target:n,layout:r,latestValues:s}=e;if(t&&n&&r){if(this!==e&&this.layout&&r&&zX(this.options.animationType,this.layout.layoutBox,r.layoutBox)){n=this.target||{x:{min:0,max:0},y:{min:0,max:0}};const t=Pq(this.layout.layoutBox.x);n.x.min=e.target.x.min,n.x.max=n.x.min+t;const r=Pq(this.layout.layoutBox.y);n.y.min=e.target.y.min,n.y.max=n.y.min+r}YK(t,n),aK(t,s),Bq(this.projectionDeltaWithTransform,this.layoutCorrected,t,s)}}registerSharedNode(e,t){this.sharedNodes.has(e)||this.sharedNodes.set(e,new hX);this.sharedNodes.get(e).add(t);const n=t.options.initialPromotionConfig;t.promote({transition:n?n.transition:void 0,preserveFollowOpacity:n&&n.shouldPreserveFollowOpacity?n.shouldPreserveFollowOpacity(t):void 0})}isLead(){const e=this.getStack();return!e||e.lead===this}getLead(){const{layoutId:e}=this.options;return e&&this.getStack()?.lead||this}getPrevLead(){const{layoutId:e}=this.options;return e?this.getStack()?.prevLead:void 0}getStack(){const{layoutId:e}=this.options;if(e)return this.root.sharedNodes.get(e)}promote(){let{needsReset:e,transition:t,preserveFollowOpacity:n}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const r=this.getStack();r&&r.promote(this,n),e&&(this.projectionDelta=void 0,this.needsReset=!0),t&&this.setOptions({transition:t})}relegate(){const e=this.getStack();return!!e&&e.relegate(this)}resetSkewAndRotation(){const{visualElement:e}=this.options;if(!e)return;let t=!1;const{latestValues:n}=e;if((n.z||n.rotate||n.rotateX||n.rotateY||n.rotateZ||n.skewX||n.skewY)&&(t=!0),!t)return;const r={};n.z&&gX("z",e,r,this.animationValues);for(let s=0;s<pX.length;s++)gX(`rotate${pX[s]}`,e,r,this.animationValues),gX(`skew${pX[s]}`,e,r,this.animationValues);e.render();for(const s in r)e.setStaticValue(s,r[s]),this.animationValues&&(this.animationValues[s]=r[s]);e.scheduleRender()}getProjectionStyles(e){if(!this.instance||this.isSVG)return;if(!this.isVisible)return fX;const t={visibility:""},n=this.getTransformTemplate();if(this.needsReset)return this.needsReset=!1,t.opacity="",t.pointerEvents=VK(e?.pointerEvents)||"",t.transform=n?n(this.latestValues,""):"none",t;const r=this.getLead();if(!this.projectionDelta||!this.layout||!r.target){const t={};return this.options.layoutId&&(t.opacity=void 0!==this.latestValues.opacity?this.latestValues.opacity:1,t.pointerEvents=VK(e?.pointerEvents)||""),this.hasProjected&&!Kq(this.latestValues)&&(t.transform=n?n({},""):"none",this.hasProjected=!1),t}const s=r.animationValues||r.latestValues;this.applyTransformsToTarget(),t.transform=function(e,t,n){let r="";const s=e.x.translate/t.x,a=e.y.translate/t.y,i=n?.z||0;if((s||a||i)&&(r=`translate3d(${s}px, ${a}px, ${i}px) `),1===t.x&&1===t.y||(r+=`scale(${1/t.x}, ${1/t.y}) `),n){const{transformPerspective:e,rotate:t,rotateX:s,rotateY:a,skewX:i,skewY:o}=n;e&&(r=`perspective(${e}px) ${r}`),t&&(r+=`rotate(${t}deg) `),s&&(r+=`rotateX(${s}deg) `),a&&(r+=`rotateY(${a}deg) `),i&&(r+=`skewX(${i}deg) `),o&&(r+=`skewY(${o}deg) `)}const o=e.x.scale*t.x,l=e.y.scale*t.y;return 1===o&&1===l||(r+=`scale(${o}, ${l})`),r||"none"}(this.projectionDeltaWithTransform,this.treeScale,s),n&&(t.transform=n(s,t.transform));const{x:a,y:i}=this.projectionDelta;t.transformOrigin=`${100*a.origin}% ${100*i.origin}% 0`,r.animationValues?t.opacity=r===this?s.opacity??this.latestValues.opacity??1:this.preserveOpacity?this.latestValues.opacity:s.opacityExit:t.opacity=r===this?void 0!==s.opacity?s.opacity:"":void 0!==s.opacityExit?s.opacityExit:0;for(const o in OK){if(void 0===s[o])continue;const{correct:e,applyTo:n,isCSSVariable:a}=OK[o],i="none"===t.transform?s[o]:e(s[o],r);if(n){const e=n.length;for(let r=0;r<e;r++)t[n[r]]=i}else a?this.options.visualElement.renderState.vars[o]=i:t[o]=i}return this.options.layoutId&&(t.pointerEvents=r===this?VK(e?.pointerEvents)||"":"none"),t}clearSnapshot(){this.resumeFrom=this.snapshot=void 0}resetTree(){this.root.nodes.forEach((e=>e.currentAnimation?.stop())),this.root.nodes.forEach(NX),this.root.sharedNodes.clear()}}}function vX(e){e.updateLayout()}function xX(e){const t=e.resumeFrom?.snapshot||e.snapshot;if(e.isLead()&&e.layout&&t&&e.hasListeners("didUpdate")){const{layoutBox:n,measuredBox:r}=e.layout,{animationType:s}=e.options,a=t.source!==e.layout.source;"size"===s?Gq((e=>{const r=a?t.measuredBox[e]:t.layoutBox[e],s=Pq(r);r.min=n[e].min,r.max=r.min+s})):zX(s,t.layoutBox,n)&&Gq((r=>{const s=a?t.measuredBox[r]:t.layoutBox[r],i=Pq(n[r]);s.max=s.min+i,e.relativeTarget&&!e.currentAnimation&&(e.isProjectionDirty=!0,e.relativeTarget[r].max=e.relativeTarget[r].min+i)}));const i={x:{translate:0,scale:1,origin:0,originPoint:0},y:{translate:0,scale:1,origin:0,originPoint:0}};Bq(i,n,t.layoutBox);const o={x:{translate:0,scale:1,origin:0,originPoint:0},y:{translate:0,scale:1,origin:0,originPoint:0}};a?Bq(o,e.applyTransform(r,!0),t.measuredBox):Bq(o,n,t.layoutBox);const l=!aX(i);let u=!1;if(!e.resumeFrom){const r=e.getClosestProjectingParent();if(r&&!r.resumeFrom){const{snapshot:s,layout:a}=r;if(s&&a){const i={x:{min:0,max:0},y:{min:0,max:0}};Uq(i,t.layoutBox,s.layoutBox);const o={x:{min:0,max:0},y:{min:0,max:0}};Uq(o,n,a.layoutBox),lX(i,o)||(u=!0),r.options.layoutRoot&&(e.relativeTarget=o,e.relativeTargetOrigin=i,e.relativeParent=r)}}}e.notifyListeners("didUpdate",{layout:n,snapshot:t,delta:o,layoutDelta:i,hasLayoutChanged:l,hasRelativeLayoutChanged:u})}else if(e.isLead()){const{onExitComplete:t}=e.options;t&&t()}e.options.transition=void 0}function wX(e){aj.value&&dX.nodes++,e.parent&&(e.isProjecting()||(e.isProjectionDirty=e.parent.isProjectionDirty),e.isSharedProjectionDirty||(e.isSharedProjectionDirty=Boolean(e.isProjectionDirty||e.parent.isProjectionDirty||e.parent.isSharedProjectionDirty)),e.isTransformDirty||(e.isTransformDirty=e.parent.isTransformDirty))}function kX(e){e.isProjectionDirty=e.isSharedProjectionDirty=e.isTransformDirty=!1}function SX(e){e.clearSnapshot()}function NX(e){e.clearMeasurements()}function IX(e){e.isLayoutDirty=!1}function CX(e){const{visualElement:t}=e.options;t&&t.getProps().onBeforeLayoutMeasure&&t.notify("BeforeLayoutMeasure"),e.resetTransform()}function TX(e){e.finishAnimation(),e.targetDelta=e.relativeTarget=e.target=void 0,e.isProjectionDirty=!0}function AX(e){e.resolveTargetDelta()}function EX(e){e.calcProjection()}function $X(e){e.resetSkewAndRotation()}function RX(e){e.removeLeadSnapshot()}function DX(e,t,n){e.translate=vG(t.translate,0,n),e.scale=vG(t.scale,1,n),e.origin=t.origin,e.originPoint=t.originPoint}function OX(e,t,n,r){e.min=vG(t.min,n.min,r),e.max=vG(t.max,n.max,r)}function _X(e){return e.animationValues&&void 0!==e.animationValues.opacityExit}const FX={duration:.45,ease:[.4,0,.1,1]},MX=e=>"undefined"!==typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().includes(e),LX=MX("applewebkit/")&&!MX("chrome/")?Math.round:nj;function PX(e){e.min=LX(e.min),e.max=LX(e.max)}function zX(e,t,n){return"position"===e||"preserve-aspect"===e&&!function(e,t,n){return Math.abs(e-t)<=n}(uX(t),uX(n),.2)}function BX(e){return e!==e.root&&e.scroll?.wasRoot}const VX=bX({attachResizeListener:(e,t)=>Oq(e,"resize",t),measureScroll:()=>({x:document.documentElement.scrollLeft||document.body.scrollLeft,y:document.documentElement.scrollTop||document.body.scrollTop}),checkIsScrollRoot:()=>!0}),WX={current:void 0},UX=bX({measureScroll:e=>({x:e.scrollLeft,y:e.scrollTop}),defaultParent:()=>{if(!WX.current){const e=new VX({});e.mount(window),e.setOptions({layoutScroll:!0}),WX.current=e}return WX.current},resetTransform:(e,t)=>{e.style.transform=void 0!==t?t:"none"},checkIsScrollRoot:e=>Boolean("fixed"===window.getComputedStyle(e).position)}),jX={pan:{Feature:class extends Aq{constructor(){super(...arguments),this.removePointerDownListener=nj}onPointerDown(e){this.session=new cK(e,this.createPanHandlers(),{transformPagePoint:this.node.getTransformPagePoint(),contextWindow:oK(this.node)})}createPanHandlers(){const{onPanSessionStart:e,onPanStart:t,onPan:n,onPanEnd:r}=this.node.getProps();return{onSessionStart:IK(e),onStart:IK(t),onMove:n,onEnd:(e,t)=>{delete this.session,r&&oj.postRender((()=>r(e,t)))}}}mount(){this.removePointerDownListener=Mq(this.node.current,"pointerdown",(e=>this.onPointerDown(e)))}update(){this.session&&this.session.updateHandlers(this.createPanHandlers())}unmount(){this.removePointerDownListener(),this.session&&this.session.end()}}},drag:{Feature:class extends Aq{constructor(e){super(e),this.removeGroupControls=nj,this.removeListeners=nj,this.controls=new SK(e)}mount(){const{dragControls:e}=this.node.getProps();e&&(this.removeGroupControls=e.subscribe(this.controls)),this.removeListeners=this.controls.addListeners()||nj}unmount(){this.removeGroupControls(),this.removeListeners()}},ProjectionNode:UX,MeasureLayout:FK}};function GX(e,t){const n=function(e,t,n){if(e instanceof EventTarget)return[e];if("string"===typeof e){let r=document;t&&(r=t.current);const s=n?.[e]??r.querySelectorAll(e);return s?Array.from(s):[]}return Array.from(e)}(e),r=new AbortController;return[n,{passive:!0,...t,signal:r.signal},()=>r.abort()]}function HX(e){return!("touch"===e.pointerType||Dq())}function qX(e,t,n){const{props:r}=e;e.animationState&&r.whileHover&&e.animationState.setActive("whileHover","Start"===n);const s=r["onHover"+n];s&&oj.postRender((()=>s(t,Fq(t))))}const KX=(e,t)=>!!t&&(e===t||KX(e,t.parentElement)),XX=new Set(["BUTTON","INPUT","SELECT","TEXTAREA","A"]);const QX=new WeakSet;function YX(e){return t=>{"Enter"===t.key&&e(t)}}function ZX(e,t){e.dispatchEvent(new PointerEvent("pointer"+t,{isPrimary:!0,bubbles:!0}))}function JX(e){return _q(e)&&!Dq()}function eQ(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const[r,s,a]=GX(e,n),i=e=>{const r=e.currentTarget;if(!JX(e))return;QX.add(r);const a=t(r,e),i=(e,t)=>{window.removeEventListener("pointerup",o),window.removeEventListener("pointercancel",l),QX.has(r)&&QX.delete(r),JX(e)&&"function"===typeof a&&a(e,{success:t})},o=e=>{i(e,r===window||r===document||n.useGlobalTarget||KX(r,e.target))},l=e=>{i(e,!1)};window.addEventListener("pointerup",o,s),window.addEventListener("pointercancel",l,s)};return r.forEach((e=>{var t;(n.useGlobalTarget?window:e).addEventListener("pointerdown",i,s),BU(e)&&(e.addEventListener("focus",(e=>((e,t)=>{const n=e.currentTarget;if(!n)return;const r=YX((()=>{if(QX.has(n))return;ZX(n,"down");const e=YX((()=>{ZX(n,"up")}));n.addEventListener("keyup",e,t),n.addEventListener("blur",(()=>ZX(n,"cancel")),t)}));n.addEventListener("keydown",r,t),n.addEventListener("blur",(()=>n.removeEventListener("keydown",r)),t)})(e,s))),t=e,XX.has(t.tagName)||-1!==t.tabIndex||e.hasAttribute("tabindex")||(e.tabIndex=0))})),a}function tQ(e,t,n){const{props:r}=e;if(e.current instanceof HTMLButtonElement&&e.current.disabled)return;e.animationState&&r.whileTap&&e.animationState.setActive("whileTap","Start"===n);const s=r["onTap"+("End"===n?"":n)];s&&oj.postRender((()=>s(t,Fq(t))))}const nQ=new WeakMap,rQ=new WeakMap,sQ=e=>{const t=nQ.get(e.target);t&&t(e)},aQ=e=>{e.forEach(sQ)};function iQ(e,t,n){const r=function(e){let{root:t,...n}=e;const r=t||document;rQ.has(r)||rQ.set(r,{});const s=rQ.get(r),a=JSON.stringify(n);return s[a]||(s[a]=new IntersectionObserver(aQ,{root:t,...n})),s[a]}(t);return nQ.set(e,n),r.observe(e),()=>{nQ.delete(e),r.unobserve(e)}}const oQ={some:0,all:1};const lQ={inView:{Feature:class extends Aq{constructor(){super(...arguments),this.hasEnteredView=!1,this.isInView=!1}startObserver(){this.unmount();const{viewport:e={}}=this.node.getProps(),{root:t,margin:n,amount:r="some",once:s}=e,a={root:t?t.current:void 0,rootMargin:n,threshold:"number"===typeof r?r:oQ[r]};return iQ(this.node.current,a,(e=>{const{isIntersecting:t}=e;if(this.isInView===t)return;if(this.isInView=t,s&&!t&&this.hasEnteredView)return;t&&(this.hasEnteredView=!0),this.node.animationState&&this.node.animationState.setActive("whileInView",t);const{onViewportEnter:n,onViewportLeave:r}=this.node.getProps(),a=t?n:r;a&&a(e)}))}mount(){this.startObserver()}update(){if("undefined"===typeof IntersectionObserver)return;const{props:e,prevProps:t}=this.node,n=["amount","margin","root"].some(function(e){let{viewport:t={}}=e,{viewport:n={}}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return e=>t[e]!==n[e]}(e,t));n&&this.startObserver()}unmount(){}}},tap:{Feature:class extends Aq{mount(){const{current:e}=this.node;e&&(this.unmount=eQ(e,((e,t)=>(tQ(this.node,t,"Start"),(e,t)=>{let{success:n}=t;return tQ(this.node,e,n?"End":"Cancel")})),{useGlobalTarget:this.node.props.globalTapTarget}))}unmount(){}}},focus:{Feature:class extends Aq{constructor(){super(...arguments),this.isActive=!1}onFocus(){let e=!1;try{e=this.node.current.matches(":focus-visible")}catch(E9){e=!0}e&&this.node.animationState&&(this.node.animationState.setActive("whileFocus",!0),this.isActive=!0)}onBlur(){this.isActive&&this.node.animationState&&(this.node.animationState.setActive("whileFocus",!1),this.isActive=!1)}mount(){this.unmount=Dj(Oq(this.node.current,"focus",(()=>this.onFocus())),Oq(this.node.current,"blur",(()=>this.onBlur())))}unmount(){}}},hover:{Feature:class extends Aq{mount(){const{current:e}=this.node;e&&(this.unmount=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const[r,s,a]=GX(e,n),i=e=>{if(!HX(e))return;const{target:n}=e,r=t(n,e);if("function"!==typeof r||!n)return;const a=e=>{HX(e)&&(r(e),n.removeEventListener("pointerleave",a))};n.addEventListener("pointerleave",a,s)};return r.forEach((e=>{e.addEventListener("pointerenter",i,s)})),a}(e,((e,t)=>(qX(this.node,t,"Start"),e=>qX(this.node,e,"End")))))}unmount(){}}}},uQ={layout:{ProjectionNode:UX,MeasureLayout:FK}},cQ=(0,T.createContext)({strict:!1}),hQ=(0,T.createContext)({});function dQ(e){return YU(e.animate)||bq.some((t=>gq(e[t])))}function pQ(e){return Boolean(dQ(e)||e.variants)}function fQ(e){const{initial:t,animate:n}=function(e,t){if(dQ(e)){const{initial:t,animate:n}=e;return{initial:!1===t||gq(t)?t:void 0,animate:gq(n)?n:void 0}}return!1!==e.inherit?t:{}}(e,(0,T.useContext)(hQ));return(0,T.useMemo)((()=>({initial:t,animate:n})),[mQ(t),mQ(n)])}function mQ(e){return Array.isArray(e)?e.join(" "):e}const gQ={animation:["animate","variants","whileHover","whileTap","exit","whileInView","whileFocus","whileDrag"],exit:["exit"],drag:["drag","dragControls"],focus:["whileFocus"],hover:["whileHover","onHoverStart","onHoverEnd"],tap:["whileTap","onTap","onTapStart","onTapCancel"],pan:["onPan","onPanStart","onPanSessionStart","onPanEnd"],inView:["whileInView","onViewportEnter","onViewportLeave"],layout:["layout","layoutId"]},yQ={};for(const n in gQ)yQ[n]={isEnabled:e=>gQ[n].some((t=>!!e[t]))};const bQ=Symbol.for("motionComponentSymbol");function vQ(e,t,n){return(0,T.useCallback)((r=>{r&&e.onMount&&e.onMount(r),t&&(r?t.mount(r):t.unmount()),n&&("function"===typeof n?n(r):lK(n)&&(n.current=r))}),[t])}function xQ(e,t,n,r,s){const{visualElement:a}=(0,T.useContext)(hQ),i=(0,T.useContext)(cQ),o=(0,T.useContext)(PU),l=(0,T.useContext)(VU).reducedMotion,u=(0,T.useRef)(null);r=r||i.renderer,!u.current&&r&&(u.current=r(e,{visualState:t,parent:a,props:n,presenceContext:o,blockInitialAnimation:!!o&&!1===o.initial,reducedMotionConfig:l}));const c=u.current,h=(0,T.useContext)(AK);!c||c.projection||!s||"html"!==c.type&&"svg"!==c.type||function(e,t,n,r){const{layoutId:s,layout:a,drag:i,dragConstraints:o,layoutScroll:l,layoutRoot:u,layoutCrossfade:c}=t;e.projection=new n(e.latestValues,t["data-framer-portal-id"]?void 0:wQ(e.parent)),e.projection.setOptions({layoutId:s,layout:a,alwaysMeasureLayout:Boolean(i)||o&&lK(o),visualElement:e,animationType:"string"===typeof a?a:"both",initialPromotionConfig:r,crossfade:c,layoutScroll:l,layoutRoot:u})}(u.current,n,s,h);const d=(0,T.useRef)(!1);(0,T.useInsertionEffect)((()=>{c&&d.current&&c.update(n,o)}));const p=n[Ej],f=(0,T.useRef)(Boolean(p)&&!window.MotionHandoffIsComplete?.(p)&&window.MotionHasOptimisedAnimation?.(p));return LU((()=>{c&&(d.current=!0,window.MotionIsMounted=!0,c.updateFeatures(),CK.render(c.render),f.current&&c.animationState&&c.animationState.animateChanges())})),(0,T.useEffect)((()=>{c&&(!f.current&&c.animationState&&c.animationState.animateChanges(),f.current&&(queueMicrotask((()=>{window.MotionHandoffMarkAsComplete?.(p)})),f.current=!1))})),c}function wQ(e){if(e)return!1!==e.options.allowProjection?e.projection:wQ(e.parent)}function kQ(e){let{preloadedFeatures:t,createVisualElement:n,useRender:r,useVisualState:s,Component:a}=e;function i(e,t){let i;const o={...(0,T.useContext)(VU),...e,layoutId:SQ(e)},{isStatic:l}=o,u=fQ(e),c=s(e,l);if(!l&&MU){!function(){(0,T.useContext)(cQ).strict;0}();const e=function(e){const{drag:t,layout:n}=yQ;if(!t&&!n)return{};const r={...t,...n};return{MeasureLayout:t?.isEnabled(e)||n?.isEnabled(e)?r.MeasureLayout:void 0,ProjectionNode:r.ProjectionNode}}(o);i=e.MeasureLayout,u.visualElement=xQ(a,c,o,n,e.ProjectionNode)}return(0,tr.jsxs)(hQ.Provider,{value:u,children:[i&&u.visualElement?(0,tr.jsx)(i,{visualElement:u.visualElement,...o}):null,r(a,e,vQ(c,u.visualElement,t),c,l,u.visualElement)]})}t&&function(e){for(const t in e)yQ[t]={...yQ[t],...e[t]}}(t),i.displayName=`motion.${"string"===typeof a?a:`create(${a.displayName??a.name??""})`}`;const o=(0,T.forwardRef)(i);return o[bQ]=a,o}function SQ(e){let{layoutId:t}=e;const n=(0,T.useContext)(_U).id;return n&&void 0!==t?n+"-"+t:t}function NQ(e,t){let{layout:n,layoutId:r}=t;return dj.has(e)||e.startsWith("origin")||(n||void 0!==r)&&(!!OK[e]||"opacity"===e)}const IQ=(e,t)=>t&&"number"===typeof e?t.transform(e):e,CQ={...Wj,transform:Math.round},TQ={borderWidth:nG,borderTopWidth:nG,borderRightWidth:nG,borderBottomWidth:nG,borderLeftWidth:nG,borderRadius:nG,radius:nG,borderTopLeftRadius:nG,borderTopRightRadius:nG,borderBottomRightRadius:nG,borderBottomLeftRadius:nG,width:nG,maxWidth:nG,height:nG,maxHeight:nG,top:nG,right:nG,bottom:nG,left:nG,padding:nG,paddingTop:nG,paddingRight:nG,paddingBottom:nG,paddingLeft:nG,margin:nG,marginTop:nG,marginRight:nG,marginBottom:nG,marginLeft:nG,backgroundPositionX:nG,backgroundPositionY:nG,...{rotate:eG,rotateX:eG,rotateY:eG,rotateZ:eG,scale:jj,scaleX:jj,scaleY:jj,scaleZ:jj,skew:eG,skewX:eG,skewY:eG,distance:nG,translateX:nG,translateY:nG,translateZ:nG,x:nG,y:nG,z:nG,perspective:nG,transformPerspective:nG,opacity:Uj,originX:aG,originY:aG,originZ:nG},zIndex:CQ,fillOpacity:Uj,strokeOpacity:Uj,numOctaves:CQ},AQ={x:"translateX",y:"translateY",z:"translateZ",transformPerspective:"perspective"},EQ=hj.length;function $Q(e,t,n){const{style:r,vars:s,transformOrigin:a}=e;let i=!1,o=!1;for(const l in t){const e=t[l];if(dj.has(l))i=!0;else if(Pj(l))s[l]=e;else{const t=IQ(e,TQ[l]);l.startsWith("origin")?(o=!0,a[l]=t):r[l]=t}}if(t.transform||(i||n?r.transform=function(e,t,n){let r="",s=!0;for(let a=0;a<EQ;a++){const i=hj[a],o=e[i];if(void 0===o)continue;let l=!0;if(l="number"===typeof o?o===(i.startsWith("scale")?1:0):0===parseFloat(o),!l||n){const e=IQ(o,TQ[i]);l||(s=!1,r+=`${AQ[i]||i}(${e}) `),n&&(t[i]=e)}}return r=r.trim(),n?r=n(t,s?"":r):s&&(r="none"),r}(t,e.transform,n):r.transform&&(r.transform="none")),o){const{originX:e="50%",originY:t="50%",originZ:n=0}=a;r.transformOrigin=`${e} ${t} ${n}`}}const RQ=()=>({style:{},transform:{},transformOrigin:{},vars:{}});function DQ(e,t,n){for(const r in t)Cj(t[r])||NQ(r,n)||(e[r]=t[r])}function OQ(e,t){const n={};return DQ(n,e.style||{},e),Object.assign(n,function(e,t){let{transformTemplate:n}=e;return(0,T.useMemo)((()=>{const e={style:{},transform:{},transformOrigin:{},vars:{}};return $Q(e,t,n),Object.assign({},e.vars,e.style)}),[t])}(e,t)),n}function _Q(e,t){const n={},r=OQ(e,t);return e.drag&&!1!==e.dragListener&&(n.draggable=!1,r.userSelect=r.WebkitUserSelect=r.WebkitTouchCallout="none",r.touchAction=!0===e.drag?"none":"pan-"+("x"===e.drag?"y":"x")),void 0===e.tabIndex&&(e.onTap||e.onTapStart||e.whileTap)&&(n.tabIndex=0),n.style=r,n}const FQ={offset:"stroke-dashoffset",array:"stroke-dasharray"},MQ={offset:"strokeDashoffset",array:"strokeDasharray"};function LQ(e,t,n,r,s){let{attrX:a,attrY:i,attrScale:o,pathLength:l,pathSpacing:u=1,pathOffset:c=0,...h}=t;if($Q(e,h,r),n)return void(e.style.viewBox&&(e.attrs.viewBox=e.style.viewBox));e.attrs=e.style,e.style={};const{attrs:d,style:p}=e;d.transform&&(p.transform=d.transform,delete d.transform),(p.transform||d.transformOrigin)&&(p.transformOrigin=d.transformOrigin??"50% 50%",delete d.transformOrigin),p.transform&&(p.transformBox=s?.transformBox??"fill-box",delete d.transformBox),void 0!==a&&(d.x=a),void 0!==i&&(d.y=i),void 0!==o&&(d.scale=o),void 0!==l&&function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,s=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];e.pathLength=1;const a=s?FQ:MQ;e[a.offset]=nG.transform(-r);const i=nG.transform(t),o=nG.transform(n);e[a.array]=`${i} ${o}`}(d,l,u,c,!1)}const PQ=()=>({style:{},transform:{},transformOrigin:{},vars:{},attrs:{}}),zQ=e=>"string"===typeof e&&"svg"===e.toLowerCase();function BQ(e,t,n,r){const s=(0,T.useMemo)((()=>{const n={style:{},transform:{},transformOrigin:{},vars:{},attrs:{}};return LQ(n,t,zQ(r),e.transformTemplate,e.style),{...n.attrs,style:{...n.style}}}),[t]);if(e.style){const t={};DQ(t,e.style,e),s.style={...t,...s.style}}return s}const VQ=new Set(["animate","exit","variants","initial","style","values","variants","transition","transformTemplate","custom","inherit","onBeforeLayoutMeasure","onAnimationStart","onAnimationComplete","onUpdate","onDragStart","onDrag","onDragEnd","onMeasureDragConstraints","onDirectionLock","onDragTransitionEnd","_dragX","_dragY","onHoverStart","onHoverEnd","onViewportEnter","onViewportLeave","globalTapTarget","ignoreStrict","viewport"]);function WQ(e){return e.startsWith("while")||e.startsWith("drag")&&"draggable"!==e||e.startsWith("layout")||e.startsWith("onTap")||e.startsWith("onPan")||e.startsWith("onLayout")||VQ.has(e)}let UQ=e=>!WQ(e);try{"function"===typeof(jQ=require("@emotion/is-prop-valid").default)&&(UQ=e=>e.startsWith("on")?!WQ(e):jQ(e))}catch{}var jQ;const GQ=["animate","circle","defs","desc","ellipse","g","image","line","filter","marker","mask","metadata","path","pattern","polygon","polyline","rect","stop","switch","symbol","svg","text","tspan","use","view"];function HQ(e){return"string"===typeof e&&!e.includes("-")&&!!(GQ.indexOf(e)>-1||/[A-Z]/u.test(e))}function qQ(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return(t,n,r,s,a)=>{let{latestValues:i}=s;const o=(HQ(t)?BQ:_Q)(n,i,a,t),l=function(e,t,n){const r={};for(const s in e)"values"===s&&"object"===typeof e.values||(UQ(s)||!0===n&&WQ(s)||!t&&!WQ(s)||e.draggable&&s.startsWith("onDrag"))&&(r[s]=e[s]);return r}(n,"string"===typeof t,e),u=t!==T.Fragment?{...l,...o,ref:r}:{},{children:c}=n,h=(0,T.useMemo)((()=>Cj(c)?c.get():c),[c]);return(0,T.createElement)(t,{...u,children:h})}}const KQ=e=>(t,n)=>{const r=(0,T.useContext)(hQ),s=(0,T.useContext)(PU),a=()=>function(e,t,n,r){let{scrapeMotionValuesFromProps:s,createRenderState:a}=e;return{latestValues:XQ(t,n,r,s),renderState:a()}}(e,t,r,s);return n?a():FU(a)};function XQ(e,t,n,r){const s={},a=r(e,{});for(const d in a)s[d]=VK(a[d]);let{initial:i,animate:o}=e;const l=dQ(e),u=pQ(e);t&&u&&!l&&!1!==e.inherit&&(void 0===i&&(i=t.initial),void 0===o&&(o=t.animate));let c=!!n&&!1===n.initial;c=c||!1===i;const h=c?o:i;if(h&&"boolean"!==typeof h&&!YU(h)){const t=Array.isArray(h)?h:[h];for(let n=0;n<t.length;n++){const r=JU(e,t[n]);if(r){const{transitionEnd:e,transition:t,...n}=r;for(const r in n){let e=n[r];if(Array.isArray(e)){e=e[c?e.length-1:0]}null!==e&&(s[r]=e)}for(const r in e)s[r]=e[r]}}}return s}function QQ(e,t,n){const{style:r}=e,s={};for(const a in r)(Cj(r[a])||t.style&&Cj(t.style[a])||NQ(a,e)||void 0!==n?.getValue(a)?.liveStyle)&&(s[a]=r[a]);return s}const YQ={useVisualState:KQ({scrapeMotionValuesFromProps:QQ,createRenderState:RQ})};function ZQ(e,t,n){const r=QQ(e,t,n);for(const s in e)if(Cj(e[s])||Cj(t[s])){r[-1!==hj.indexOf(s)?"attr"+s.charAt(0).toUpperCase()+s.substring(1):s]=e[s]}return r}const JQ={useVisualState:KQ({scrapeMotionValuesFromProps:ZQ,createRenderState:PQ})};function eY(e,t){return function(n){let{forwardMotionProps:r}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{forwardMotionProps:!1};return kQ({...HQ(n)?JQ:YQ,preloadedFeatures:e,useRender:qQ(r),createVisualElement:t,Component:n})}}const tY=e=>t=>t.test(e),nY=[Wj,nG,tG,eG,sG,rG,{test:e=>"auto"===e,parse:e=>e}],rY=e=>nY.find(tY(e)),sY=e=>/^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e),aY=/^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;function iY(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;const[r,s]=function(e){const t=aY.exec(e);if(!t)return[,];const[,n,r,s]=t;return[`--${n??r}`,s]}(e);if(!r)return;const a=window.getComputedStyle(t).getPropertyValue(r);if(a){const e=a.trim();return sY(e)?parseFloat(e):e}return Bj(s)?iY(s,t,n+1):s}const oY=e=>/^0[^.\s]+$/u.test(e);function lY(e){return"number"===typeof e?0===e:null===e||("none"===e||"0"===e||oY(e))}const uY=new Set(["brightness","contrast","saturate","opacity"]);function cY(e){const[t,n]=e.slice(0,-1).split("(");if("drop-shadow"===t)return e;const[r]=n.match(Hj)||[];if(!r)return e;const s=n.replace(r,"");let a=uY.has(t)?1:0;return r!==n&&(a*=100),t+"("+a+s+")"}const hY=/\b([a-z-]*)\(.*?\)/gu,dY={...gG,getAnimatableNone:e=>{const t=e.match(hY);return t?t.map(cY).join(" "):e}},pY={...TQ,color:oG,backgroundColor:oG,outlineColor:oG,fill:oG,stroke:oG,borderColor:oG,borderTopColor:oG,borderRightColor:oG,borderBottomColor:oG,borderLeftColor:oG,filter:dY,WebkitFilter:dY},fY=e=>pY[e];function mY(e,t){let n=fY(e);return n!==dY&&(n=gG),n.getAnimatableNone?n.getAnimatableNone(t):void 0}const gY=new Set(["auto","none","0"]);class yY extends BH{constructor(e,t,n,r,s){super(e,t,n,r,s,!0)}readKeyframes(){const{unresolvedKeyframes:e,element:t,name:n}=this;if(!t||!t.current)return;super.readKeyframes();for(let o=0;o<e.length;o++){let n=e[o];if("string"===typeof n&&(n=n.trim(),Bj(n))){const r=iY(n,t.current);void 0!==r&&(e[o]=r),o===e.length-1&&(this.finalKeyframe=n)}}if(this.resolveNoneKeyframes(),!pj.has(n)||2!==e.length)return;const[r,s]=e,a=rY(r),i=rY(s);if(a!==i)if($H(a)&&$H(i))for(let o=0;o<e.length;o++){const t=e[o];"string"===typeof t&&(e[o]=parseFloat(t))}else OH[n]&&(this.needsMeasurement=!0)}resolveNoneKeyframes(){const{unresolvedKeyframes:e,name:t}=this,n=[];for(let r=0;r<e.length;r++)(null===e[r]||lY(e[r]))&&n.push(r);n.length&&function(e,t,n){let r,s=0;for(;s<e.length&&!r;){const t=e[s];"string"===typeof t&&!gY.has(t)&&dG(t).values.length&&(r=e[s]),s++}if(r&&n)for(const a of t)e[a]=mY(n,r)}(e,n,t)}measureInitialState(){const{element:e,unresolvedKeyframes:t,name:n}=this;if(!e||!e.current)return;"height"===n&&(this.suspendedScrollY=window.pageYOffset),this.measuredOrigin=OH[n](e.measureViewportBox(),window.getComputedStyle(e.current)),t[0]=this.measuredOrigin;const r=t[t.length-1];void 0!==r&&e.getValue(n,r).jump(r,!1)}measureEndState(){const{element:e,name:t,unresolvedKeyframes:n}=this;if(!e||!e.current)return;const r=e.getValue(t);r&&r.jump(this.measuredOrigin,!1);const s=n.length-1,a=n[s];n[s]=OH[t](e.measureViewportBox(),window.getComputedStyle(e.current)),null!==a&&void 0===this.finalKeyframe&&(this.finalKeyframe=a),this.removedTransforms?.length&&this.removedTransforms.forEach((t=>{let[n,r]=t;e.getValue(n).set(r)})),this.resolveNoneKeyframes()}}const bY=[...nY,oG,gG],vY={current:null},xY={current:!1};const wY=new WeakMap;const kY=["AnimationStart","AnimationComplete","Update","BeforeLayoutMeasure","LayoutMeasure","LayoutAnimationStart","LayoutAnimationComplete"];class SY{scrapeMotionValuesFromProps(e,t,n){return{}}constructor(e){let{parent:t,props:n,presenceContext:r,reducedMotionConfig:s,blockInitialAnimation:a,visualState:i}=e,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.current=null,this.children=new Set,this.isVariantNode=!1,this.isControllingVariants=!1,this.shouldReduceMotion=null,this.values=new Map,this.KeyframeResolver=BH,this.features={},this.valueSubscriptions=new Map,this.prevMotionValues={},this.events={},this.propEventSubscriptions={},this.notifyUpdate=()=>this.notify("Update",this.latestValues),this.render=()=>{this.current&&(this.triggerBuild(),this.renderInstance(this.current,this.renderState,this.props.style,this.projection))},this.renderScheduledAt=0,this.scheduleRender=()=>{const e=xj.now();this.renderScheduledAt<e&&(this.renderScheduledAt=e,oj.render(this.render,!1,!0))};const{latestValues:l,renderState:u}=i;this.latestValues=l,this.baseTarget={...l},this.initialValues=n.initial?{...l}:{},this.renderState=u,this.parent=t,this.props=n,this.presenceContext=r,this.depth=t?t.depth+1:0,this.reducedMotionConfig=s,this.options=o,this.blockInitialAnimation=Boolean(a),this.isControllingVariants=dQ(n),this.isVariantNode=pQ(n),this.isVariantNode&&(this.variantChildren=new Set),this.manuallyAnimateOnMount=Boolean(t&&t.current);const{willChange:c,...h}=this.scrapeMotionValuesFromProps(n,{},this);for(const d in h){const e=h[d];void 0!==l[d]&&Cj(e)&&e.set(l[d],!1)}}mount(e){this.current=e,wY.set(e,this),this.projection&&!this.projection.instance&&this.projection.mount(e),this.parent&&this.isVariantNode&&!this.isControllingVariants&&(this.removeFromVariantTree=this.parent.addVariantChild(this)),this.values.forEach(((e,t)=>this.bindToMotionValue(t,e))),xY.current||function(){if(xY.current=!0,MU)if(window.matchMedia){const e=window.matchMedia("(prefers-reduced-motion)"),t=()=>vY.current=e.matches;e.addListener(t),t()}else vY.current=!1}(),this.shouldReduceMotion="never"!==this.reducedMotionConfig&&("always"===this.reducedMotionConfig||vY.current),this.parent&&this.parent.children.add(this),this.update(this.props,this.presenceContext)}unmount(){this.projection&&this.projection.unmount(),lj(this.notifyUpdate),lj(this.render),this.valueSubscriptions.forEach((e=>e())),this.valueSubscriptions.clear(),this.removeFromVariantTree&&this.removeFromVariantTree(),this.parent&&this.parent.children.delete(this);for(const e in this.events)this.events[e].clear();for(const e in this.features){const t=this.features[e];t&&(t.unmount(),t.isMounted=!1)}this.current=null}bindToMotionValue(e,t){this.valueSubscriptions.has(e)&&this.valueSubscriptions.get(e)();const n=dj.has(e);n&&this.onBindTransform&&this.onBindTransform();const r=t.on("change",(t=>{this.latestValues[e]=t,this.props.onUpdate&&oj.preRender(this.notifyUpdate),n&&this.projection&&(this.projection.isTransformDirty=!0)})),s=t.on("renderRequest",this.scheduleRender);let a;window.MotionCheckAppearSync&&(a=window.MotionCheckAppearSync(this,e,t)),this.valueSubscriptions.set(e,(()=>{r(),s(),a&&a(),t.owner&&t.stop()}))}sortNodePosition(e){return this.current&&this.sortInstanceNodePosition&&this.type===e.type?this.sortInstanceNodePosition(this.current,e.current):0}updateFeatures(){let e="animation";for(e in yQ){const t=yQ[e];if(!t)continue;const{isEnabled:n,Feature:r}=t;if(!this.features[e]&&r&&n(this.props)&&(this.features[e]=new r(this)),this.features[e]){const t=this.features[e];t.isMounted?t.update():(t.mount(),t.isMounted=!0)}}}triggerBuild(){this.build(this.renderState,this.latestValues,this.props)}measureViewportBox(){return this.current?this.measureInstanceViewportBox(this.current,this.props):{x:{min:0,max:0},y:{min:0,max:0}}}getStaticValue(e){return this.latestValues[e]}setStaticValue(e,t){this.latestValues[e]=t}update(e,t){(e.transformTemplate||this.props.transformTemplate)&&this.scheduleRender(),this.prevProps=this.props,this.props=e,this.prevPresenceContext=this.presenceContext,this.presenceContext=t;for(let n=0;n<kY.length;n++){const t=kY[n];this.propEventSubscriptions[t]&&(this.propEventSubscriptions[t](),delete this.propEventSubscriptions[t]);const r=e["on"+t];r&&(this.propEventSubscriptions[t]=this.on(t,r))}this.prevMotionValues=function(e,t,n){for(const r in t){const s=t[r],a=n[r];if(Cj(s))e.addValue(r,s);else if(Cj(a))e.addValue(r,Sj(s,{owner:e}));else if(a!==s)if(e.hasValue(r)){const t=e.getValue(r);!0===t.liveStyle?t.jump(s):t.hasAnimated||t.set(s)}else{const t=e.getStaticValue(r);e.addValue(r,Sj(void 0!==t?t:s,{owner:e}))}}for(const r in n)void 0===t[r]&&e.removeValue(r);return t}(this,this.scrapeMotionValuesFromProps(e,this.prevProps,this),this.prevMotionValues),this.handleChildMotionValue&&this.handleChildMotionValue()}getProps(){return this.props}getVariant(e){return this.props.variants?this.props.variants[e]:void 0}getDefaultTransition(){return this.props.transition}getTransformPagePoint(){return this.props.transformPagePoint}getClosestVariantNode(){return this.isVariantNode?this:this.parent?this.parent.getClosestVariantNode():void 0}addVariantChild(e){const t=this.getClosestVariantNode();if(t)return t.variantChildren&&t.variantChildren.add(e),()=>t.variantChildren.delete(e)}addValue(e,t){const n=this.values.get(e);t!==n&&(n&&this.removeValue(e),this.bindToMotionValue(e,t),this.values.set(e,t),this.latestValues[e]=t.get())}removeValue(e){this.values.delete(e);const t=this.valueSubscriptions.get(e);t&&(t(),this.valueSubscriptions.delete(e)),delete this.latestValues[e],this.removeValueFromRenderState(e,this.renderState)}hasValue(e){return this.values.has(e)}getValue(e,t){if(this.props.values&&this.props.values[e])return this.props.values[e];let n=this.values.get(e);return void 0===n&&void 0!==t&&(n=Sj(null===t?void 0:t,{owner:this}),this.addValue(e,n)),n}readValue(e,t){let n=void 0===this.latestValues[e]&&this.current?this.getBaseTargetFromProps(this.props,e)??this.readValueFromInstance(this.current,e,this.options):this.latestValues[e];var r;return void 0!==n&&null!==n&&("string"===typeof n&&(sY(n)||oY(n))?n=parseFloat(n):(r=n,!bY.find(tY(r))&&gG.test(t)&&(n=mY(e,t))),this.setBaseTarget(e,Cj(n)?n.get():n)),Cj(n)?n.get():n}setBaseTarget(e,t){this.baseTarget[e]=t}getBaseTarget(e){const{initial:t}=this.props;let n;if("string"===typeof t||"object"===typeof t){const r=JU(this.props,t,this.presenceContext?.custom);r&&(n=r[e])}if(t&&void 0!==n)return n;const r=this.getBaseTargetFromProps(this.props,e);return void 0===r||Cj(r)?void 0!==this.initialValues[e]&&void 0===n?void 0:this.baseTarget[e]:r}on(e,t){return this.events[e]||(this.events[e]=new gj),this.events[e].add(t)}notify(e){if(this.events[e]){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];this.events[e].notify(...n)}}}class NY extends SY{constructor(){super(...arguments),this.KeyframeResolver=yY}sortInstanceNodePosition(e,t){return 2&e.compareDocumentPosition(t)?1:-1}getBaseTargetFromProps(e,t){return e.style?e.style[t]:void 0}removeValueFromRenderState(e,t){let{vars:n,style:r}=t;delete n[e],delete r[e]}handleChildMotionValue(){this.childSubscription&&(this.childSubscription(),delete this.childSubscription);const{children:e}=this.props;Cj(e)&&(this.childSubscription=e.on("change",(e=>{this.current&&(this.current.textContent=`${e}`)})))}}function IY(e,t,n,r){let{style:s,vars:a}=t;Object.assign(e.style,s,r&&r.getProjectionStyles(n));for(const i in a)e.style.setProperty(i,a[i])}class CY extends NY{constructor(){super(...arguments),this.type="html",this.renderInstance=IY}readValueFromInstance(e,t){if(dj.has(t))return this.projection?.isProjecting?TH(t):((e,t)=>{const{transform:n="none"}=getComputedStyle(e);return AH(n,t)})(e,t);{const r=(n=e,window.getComputedStyle(n)),s=(Pj(t)?r.getPropertyValue(t):r[t])||0;return"string"===typeof s?s.trim():s}var n}measureInstanceViewportBox(e,t){let{transformPagePoint:n}=t;return iK(e,n)}build(e,t,n){$Q(e,t,n.transformTemplate)}scrapeMotionValuesFromProps(e,t,n){return QQ(e,t,n)}}const TY=new Set(["baseFrequency","diffuseConstant","kernelMatrix","kernelUnitLength","keySplines","keyTimes","limitingConeAngle","markerHeight","markerWidth","numOctaves","targetX","targetY","surfaceScale","specularConstant","specularExponent","stdDeviation","tableValues","viewBox","gradientTransform","pathLength","startOffset","textLength","lengthAdjust"]);class AY extends NY{constructor(){super(...arguments),this.type="svg",this.isSVGTag=!1,this.measureInstanceViewportBox=jq}getBaseTargetFromProps(e,t){return e[t]}readValueFromInstance(e,t){if(dj.has(t)){const e=fY(t);return e&&e.default||0}return t=TY.has(t)?t:Aj(t),e.getAttribute(t)}scrapeMotionValuesFromProps(e,t,n){return ZQ(e,t,n)}build(e,t,n){LQ(e,t,this.isSVGTag,n.transformTemplate,n.style)}renderInstance(e,t,n,r){!function(e,t,n,r){IY(e,t,void 0,r);for(const s in t.attrs)e.setAttribute(TY.has(s)?s:Aj(s),t.attrs[s])}(e,t,0,r)}mount(e){this.isSVGTag=zQ(e.tagName),super.mount(e)}}const EY=QU(eY({...$q,...lQ,...jX,...uQ},((e,t)=>HQ(e)?new AY(t):new CY(t,{allowProjection:e!==T.Fragment})))),$Y=(e,t)=>t.some((t=>e instanceof t));let RY,DY;const OY=new WeakMap,_Y=new WeakMap,FY=new WeakMap;let MY={get(e,t,n){if(e instanceof IDBTransaction){if("done"===t)return OY.get(e);if("store"===t)return n.objectStoreNames[1]?void 0:n.objectStore(n.objectStoreNames[0])}return BY(e[t])},set:(e,t,n)=>(e[t]=n,!0),has:(e,t)=>e instanceof IDBTransaction&&("done"===t||"store"===t)||t in e};function LY(e){MY=e(MY)}function PY(e){return(DY||(DY=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])).includes(e)?function(){for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];return e.apply(VY(this),n),BY(this.request)}:function(){for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];return BY(e.apply(VY(this),n))}}function zY(e){return"function"===typeof e?PY(e):(e instanceof IDBTransaction&&function(e){if(OY.has(e))return;const t=new Promise(((t,n)=>{const r=()=>{e.removeEventListener("complete",s),e.removeEventListener("error",a),e.removeEventListener("abort",a)},s=()=>{t(),r()},a=()=>{n(e.error||new DOMException("AbortError","AbortError")),r()};e.addEventListener("complete",s),e.addEventListener("error",a),e.addEventListener("abort",a)}));OY.set(e,t)}(e),$Y(e,RY||(RY=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction]))?new Proxy(e,MY):e)}function BY(e){if(e instanceof IDBRequest)return function(e){const t=new Promise(((t,n)=>{const r=()=>{e.removeEventListener("success",s),e.removeEventListener("error",a)},s=()=>{t(BY(e.result)),r()},a=()=>{n(e.error),r()};e.addEventListener("success",s),e.addEventListener("error",a)}));return FY.set(t,e),t}(e);if(_Y.has(e))return _Y.get(e);const t=zY(e);return t!==e&&(_Y.set(e,t),FY.set(t,e)),t}const VY=e=>FY.get(e);const WY=["get","getKey","getAll","getAllKeys","count"],UY=["put","add","delete","clear"],jY=new Map;function GY(e,t){if(!(e instanceof IDBDatabase)||t in e||"string"!==typeof t)return;if(jY.get(t))return jY.get(t);const n=t.replace(/FromIndex$/,""),r=t!==n,s=UY.includes(n);if(!(n in(r?IDBIndex:IDBObjectStore).prototype)||!s&&!WY.includes(n))return;const a=async function(e){const t=this.transaction(e,s?"readwrite":"readonly");let a=t.store;for(var i=arguments.length,o=new Array(i>1?i-1:0),l=1;l<i;l++)o[l-1]=arguments[l];return r&&(a=a.index(o.shift())),(await Promise.all([a[n](...o),s&&t.done]))[0]};return jY.set(t,a),a}LY((e=>({...e,get:(t,n,r)=>GY(t,n)||e.get(t,n,r),has:(t,n)=>!!GY(t,n)||e.has(t,n)})));const HY=["continue","continuePrimaryKey","advance"],qY={},KY=new WeakMap,XY=new WeakMap,QY={get(e,t){if(!HY.includes(t))return e[t];let n=qY[t];return n||(n=qY[t]=function(){KY.set(this,XY.get(this)[t](...arguments))}),n}};async function*YY(){let e=this;if(e instanceof IDBCursor||(e=await e.openCursor(...arguments)),!e)return;const t=new Proxy(e,QY);for(XY.set(t,e),FY.set(t,VY(e));e;)yield t,e=await(KY.get(t)||e.continue()),KY.delete(t)}function ZY(e,t){return t===Symbol.asyncIterator&&$Y(e,[IDBIndex,IDBObjectStore,IDBCursor])||"iterate"===t&&$Y(e,[IDBIndex,IDBObjectStore])}LY((e=>({...e,get:(t,n,r)=>ZY(t,n)?YY:e.get(t,n,r),has:(t,n)=>ZY(t,n)||e.has(t,n)})));const JY="GoogleActivityApp",eZ="searchResults";async function tZ(){return function(e,t){let{blocked:n,upgrade:r,blocking:s,terminated:a}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=indexedDB.open(e,t),o=BY(i);return r&&i.addEventListener("upgradeneeded",(e=>{r(BY(i.result),e.oldVersion,e.newVersion,BY(i.transaction),e)})),n&&i.addEventListener("blocked",(e=>n(e.oldVersion,e.newVersion,e))),o.then((e=>{a&&e.addEventListener("close",(()=>a())),s&&e.addEventListener("versionchange",(e=>s(e.oldVersion,e.newVersion,e)))})).catch((()=>{})),o}(JY,3,{upgrade(e){e.objectStoreNames.contains(eZ)||e.createObjectStore(eZ,{keyPath:"id",autoIncrement:!0}),e.objectStoreNames.contains("savedDatasets")||e.createObjectStore("savedDatasets",{keyPath:"id"})}})}async function nZ(){try{return await tZ()}catch($9){if(console.warn("Initial DB open failed. Attempting recovery...",$9),"NotFoundError"===$9.name||"VersionError"===$9.name||"InvalidStateError"===$9.name)return await function(e){let{blocked:t}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=indexedDB.deleteDatabase(e);return t&&n.addEventListener("blocked",(e=>t(e.oldVersion,e))),BY(n).then((()=>{}))}(JY),await tZ();throw $9}}const rZ=eZ,sZ=[{id:"1",name:"Arts, Culture & Entertainment",color:"#ff4b5c"},{id:"2",name:"News, Politics & Society",color:"#f15bb5"},{id:"3",name:"Technology & Science",color:"#3cba54"},{id:"4",name:"Health & Wellness",color:"#4ade80"},{id:"5",name:"Food, Drink & Lifestyle",color:"#ff6f61"},{id:"6",name:"Business & Finance",color:"#ffbe0b"},{id:"7",name:"Travel & Transportation",color:"#8ecae6"},{id:"8",name:"Education & Learning",color:"#5bc0eb"},{id:"9",name:"Family & Relationships",color:"#9d4edd"},{id:"10",name:"Shopping",color:"#ffb703"},{id:"11",name:"Sports",color:"#8338ec"},{id:"12",name:"Uncategorized",color:"#aaaaaa"}];class aZ extends Error{}class iZ extends aZ{constructor(e){super(`Invalid DateTime: ${e.toMessage()}`)}}class oZ extends aZ{constructor(e){super(`Invalid Interval: ${e.toMessage()}`)}}class lZ extends aZ{constructor(e){super(`Invalid Duration: ${e.toMessage()}`)}}class uZ extends aZ{}class cZ extends aZ{constructor(e){super(`Invalid unit ${e}`)}}class hZ extends aZ{}class dZ extends aZ{constructor(){super("Zone is an abstract class")}}const pZ="numeric",fZ="short",mZ="long",gZ={year:pZ,month:pZ,day:pZ},yZ={year:pZ,month:fZ,day:pZ},bZ={year:pZ,month:fZ,day:pZ,weekday:fZ},vZ={year:pZ,month:mZ,day:pZ},xZ={year:pZ,month:mZ,day:pZ,weekday:mZ},wZ={hour:pZ,minute:pZ},kZ={hour:pZ,minute:pZ,second:pZ},SZ={hour:pZ,minute:pZ,second:pZ,timeZoneName:fZ},NZ={hour:pZ,minute:pZ,second:pZ,timeZoneName:mZ},IZ={hour:pZ,minute:pZ,hourCycle:"h23"},CZ={hour:pZ,minute:pZ,second:pZ,hourCycle:"h23"},TZ={hour:pZ,minute:pZ,second:pZ,hourCycle:"h23",timeZoneName:fZ},AZ={hour:pZ,minute:pZ,second:pZ,hourCycle:"h23",timeZoneName:mZ},EZ={year:pZ,month:pZ,day:pZ,hour:pZ,minute:pZ},$Z={year:pZ,month:pZ,day:pZ,hour:pZ,minute:pZ,second:pZ},RZ={year:pZ,month:fZ,day:pZ,hour:pZ,minute:pZ},DZ={year:pZ,month:fZ,day:pZ,hour:pZ,minute:pZ,second:pZ},OZ={year:pZ,month:fZ,day:pZ,weekday:fZ,hour:pZ,minute:pZ},_Z={year:pZ,month:mZ,day:pZ,hour:pZ,minute:pZ,timeZoneName:fZ},FZ={year:pZ,month:mZ,day:pZ,hour:pZ,minute:pZ,second:pZ,timeZoneName:fZ},MZ={year:pZ,month:mZ,day:pZ,weekday:mZ,hour:pZ,minute:pZ,timeZoneName:mZ},LZ={year:pZ,month:mZ,day:pZ,weekday:mZ,hour:pZ,minute:pZ,second:pZ,timeZoneName:mZ};class PZ{get type(){throw new dZ}get name(){throw new dZ}get ianaName(){return this.name}get isUniversal(){throw new dZ}offsetName(e,t){throw new dZ}formatOffset(e,t){throw new dZ}offset(e){throw new dZ}equals(e){throw new dZ}get isValid(){throw new dZ}}let zZ=null;class BZ extends PZ{static get instance(){return null===zZ&&(zZ=new BZ),zZ}get type(){return"system"}get name(){return(new Intl.DateTimeFormat).resolvedOptions().timeZone}get isUniversal(){return!1}offsetName(e,t){let{format:n,locale:r}=t;return i0(e,n,r)}formatOffset(e,t){return c0(this.offset(e),t)}offset(e){return-new Date(e).getTimezoneOffset()}equals(e){return"system"===e.type}get isValid(){return!0}}const VZ=new Map;const WZ={year:0,month:1,day:2,era:3,hour:4,minute:5,second:6};const UZ=new Map;class jZ extends PZ{static create(e){let t=UZ.get(e);return void 0===t&&UZ.set(e,t=new jZ(e)),t}static resetCache(){UZ.clear(),VZ.clear()}static isValidSpecifier(e){return this.isValidZone(e)}static isValidZone(e){if(!e)return!1;try{return new Intl.DateTimeFormat("en-US",{timeZone:e}).format(),!0}catch(E9){return!1}}constructor(e){super(),this.zoneName=e,this.valid=jZ.isValidZone(e)}get type(){return"iana"}get name(){return this.zoneName}get isUniversal(){return!1}offsetName(e,t){let{format:n,locale:r}=t;return i0(e,n,r,this.name)}formatOffset(e,t){return c0(this.offset(e),t)}offset(e){if(!this.valid)return NaN;const t=new Date(e);if(isNaN(t))return NaN;const n=function(e){let t=VZ.get(e);return void 0===t&&(t=new Intl.DateTimeFormat("en-US",{hour12:!1,timeZone:e,year:"numeric",month:"2-digit",day:"2-digit",hour:"2-digit",minute:"2-digit",second:"2-digit",era:"short"}),VZ.set(e,t)),t}(this.name);let[r,s,a,i,o,l,u]=n.formatToParts?function(e,t){const n=e.formatToParts(t),r=[];for(let s=0;s<n.length;s++){const{type:e,value:t}=n[s],a=WZ[e];"era"===e?r[a]=t:zJ(a)||(r[a]=parseInt(t,10))}return r}(n,t):function(e,t){const n=e.format(t).replace(/\u200E/g,""),r=/(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(n),[,s,a,i,o,l,u,c]=r;return[i,s,a,o,l,u,c]}(n,t);"BC"===i&&(r=1-Math.abs(r));let c=+t;const h=c%1e3;return c-=h>=0?h:1e3+h,(n0({year:r,month:s,day:a,hour:24===o?0:o,minute:l,second:u,millisecond:0})-c)/6e4}equals(e){return"iana"===e.type&&e.name===this.name}get isValid(){return this.valid}}let GZ={};const HZ=new Map;function qZ(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=JSON.stringify([e,t]);let r=HZ.get(n);return void 0===r&&(r=new Intl.DateTimeFormat(e,t),HZ.set(n,r)),r}const KZ=new Map;const XZ=new Map;let QZ=null;const YZ=new Map;function ZZ(e){let t=YZ.get(e);return void 0===t&&(t=new Intl.DateTimeFormat(e).resolvedOptions(),YZ.set(e,t)),t}const JZ=new Map;function eJ(e,t,n,r){const s=e.listingMode();return"error"===s?null:"en"===s?n(t):r(t)}class tJ{constructor(e,t,n){this.padTo=n.padTo||0,this.floor=n.floor||!1;const{padTo:r,floor:s,...a}=n;if(!t||Object.keys(a).length>0){const t={useGrouping:!1,...n};n.padTo>0&&(t.minimumIntegerDigits=n.padTo),this.inf=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=JSON.stringify([e,t]);let r=KZ.get(n);return void 0===r&&(r=new Intl.NumberFormat(e,t),KZ.set(n,r)),r}(e,t)}}format(e){if(this.inf){const t=this.floor?Math.floor(e):e;return this.inf.format(t)}return KJ(this.floor?Math.floor(e):ZJ(e,3),this.padTo)}}class nJ{constructor(e,t,n){let r;if(this.opts=n,this.originalZone=void 0,this.opts.timeZone)this.dt=e;else if("fixed"===e.zone.type){const t=e.offset/60*-1,n=t>=0?`Etc/GMT+${t}`:`Etc/GMT${t}`;0!==e.offset&&jZ.create(n).valid?(r=n,this.dt=e):(r="UTC",this.dt=0===e.offset?e:e.setZone("UTC").plus({minutes:e.offset}),this.originalZone=e.zone)}else"system"===e.zone.type?this.dt=e:"iana"===e.zone.type?(this.dt=e,r=e.zone.name):(r="UTC",this.dt=e.setZone("UTC").plus({minutes:e.offset}),this.originalZone=e.zone);const s={...this.opts};s.timeZone=s.timeZone||r,this.dtf=qZ(t,s)}format(){return this.originalZone?this.formatToParts().map((e=>{let{value:t}=e;return t})).join(""):this.dtf.format(this.dt.toJSDate())}formatToParts(){const e=this.dtf.formatToParts(this.dt.toJSDate());return this.originalZone?e.map((e=>{if("timeZoneName"===e.type){const t=this.originalZone.offsetName(this.dt.ts,{locale:this.dt.locale,format:this.opts.timeZoneName});return{...e,value:t}}return e})):e}resolvedOptions(){return this.dtf.resolvedOptions()}}class rJ{constructor(e,t,n){this.opts={style:"long",...n},!t&&WJ()&&(this.rtf=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{base:n,...r}=t,s=JSON.stringify([e,r]);let a=XZ.get(s);return void 0===a&&(a=new Intl.RelativeTimeFormat(e,t),XZ.set(s,a)),a}(e,n))}format(e,t){return this.rtf?this.rtf.format(e,t):function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"always",r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s={years:["year","yr."],quarters:["quarter","qtr."],months:["month","mo."],weeks:["week","wk."],days:["day","day","days"],hours:["hour","hr."],minutes:["minute","min."],seconds:["second","sec."]},a=-1===["hours","minutes","seconds"].indexOf(e);if("auto"===n&&a){const n="days"===e;switch(t){case 1:return n?"tomorrow":`next ${s[e][0]}`;case-1:return n?"yesterday":`last ${s[e][0]}`;case 0:return n?"today":`this ${s[e][0]}`}}const i=Object.is(t,-0)||t<0,o=Math.abs(t),l=1===o,u=s[e],c=r?l?u[1]:u[2]||u[1]:l?s[e][0]:e;return i?`${o} ${c} ago`:`in ${o} ${c}`}(t,e,this.opts.numeric,"long"!==this.opts.style)}formatToParts(e,t){return this.rtf?this.rtf.formatToParts(e,t):[]}}const sJ={firstDay:1,minimalDays:4,weekend:[6,7]};class aJ{static fromOpts(e){return aJ.create(e.locale,e.numberingSystem,e.outputCalendar,e.weekSettings,e.defaultToEN)}static create(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];const a=e||SJ.defaultLocale,i=a||(s?"en-US":QZ||(QZ=(new Intl.DateTimeFormat).resolvedOptions().locale,QZ)),o=t||SJ.defaultNumberingSystem,l=n||SJ.defaultOutputCalendar,u=HJ(r)||SJ.defaultWeekSettings;return new aJ(i,o,l,u,a)}static resetCache(){QZ=null,HZ.clear(),KZ.clear(),XZ.clear(),YZ.clear(),JZ.clear()}static fromObject(){let{locale:e,numberingSystem:t,outputCalendar:n,weekSettings:r}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return aJ.create(e,t,n,r)}constructor(e,t,n,r,s){const[a,i,o]=function(e){const t=e.indexOf("-x-");-1!==t&&(e=e.substring(0,t));const n=e.indexOf("-u-");if(-1===n)return[e];{let t,r;try{t=qZ(e).resolvedOptions(),r=e}catch(E9){const a=e.substring(0,n);t=qZ(a).resolvedOptions(),r=a}const{numberingSystem:s,calendar:a}=t;return[r,s,a]}}(e);this.locale=a,this.numberingSystem=t||i||null,this.outputCalendar=n||o||null,this.weekSettings=r,this.intl=function(e,t,n){return n||t?(e.includes("-u-")||(e+="-u"),n&&(e+=`-ca-${n}`),t&&(e+=`-nu-${t}`),e):e}(this.locale,this.numberingSystem,this.outputCalendar),this.weekdaysCache={format:{},standalone:{}},this.monthsCache={format:{},standalone:{}},this.meridiemCache=null,this.eraCache={},this.specifiedLocale=s,this.fastNumbersCached=null}get fastNumbers(){var e;return null==this.fastNumbersCached&&(this.fastNumbersCached=(!(e=this).numberingSystem||"latn"===e.numberingSystem)&&("latn"===e.numberingSystem||!e.locale||e.locale.startsWith("en")||"latn"===ZZ(e.locale).numberingSystem)),this.fastNumbersCached}listingMode(){const e=this.isEnglish(),t=(null===this.numberingSystem||"latn"===this.numberingSystem)&&(null===this.outputCalendar||"gregory"===this.outputCalendar);return e&&t?"en":"intl"}clone(e){return e&&0!==Object.getOwnPropertyNames(e).length?aJ.create(e.locale||this.specifiedLocale,e.numberingSystem||this.numberingSystem,e.outputCalendar||this.outputCalendar,HJ(e.weekSettings)||this.weekSettings,e.defaultToEN||!1):this}redefaultToEN(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return this.clone({...e,defaultToEN:!0})}redefaultToSystem(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return this.clone({...e,defaultToEN:!1})}months(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return eJ(this,e,m0,(()=>{const n=t?{month:e,day:"numeric"}:{month:e},r=t?"format":"standalone";return this.monthsCache[r][e]||(this.monthsCache[r][e]=function(e){const t=[];for(let n=1;n<=12;n++){const r=v2.utc(2009,n,1);t.push(e(r))}return t}((e=>this.extract(e,n,"month")))),this.monthsCache[r][e]}))}weekdays(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return eJ(this,e,v0,(()=>{const n=t?{weekday:e,year:"numeric",month:"long",day:"numeric"}:{weekday:e},r=t?"format":"standalone";return this.weekdaysCache[r][e]||(this.weekdaysCache[r][e]=function(e){const t=[];for(let n=1;n<=7;n++){const r=v2.utc(2016,11,13+n);t.push(e(r))}return t}((e=>this.extract(e,n,"weekday")))),this.weekdaysCache[r][e]}))}meridiems(){return eJ(this,void 0,(()=>x0),(()=>{if(!this.meridiemCache){const e={hour:"numeric",hourCycle:"h12"};this.meridiemCache=[v2.utc(2016,11,13,9),v2.utc(2016,11,13,19)].map((t=>this.extract(t,e,"dayperiod")))}return this.meridiemCache}))}eras(e){return eJ(this,e,N0,(()=>{const t={era:e};return this.eraCache[e]||(this.eraCache[e]=[v2.utc(-40,1,1),v2.utc(2017,1,1)].map((e=>this.extract(e,t,"era")))),this.eraCache[e]}))}extract(e,t,n){const r=this.dtFormatter(e,t).formatToParts().find((e=>e.type.toLowerCase()===n));return r?r.value:null}numberFormatter(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return new tJ(this.intl,e.forceSimple||this.fastNumbers,e)}dtFormatter(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return new nJ(e,this.intl,t)}relFormatter(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return new rJ(this.intl,this.isEnglish(),e)}listFormatter(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=JSON.stringify([e,t]);let r=GZ[n];return r||(r=new Intl.ListFormat(e,t),GZ[n]=r),r}(this.intl,e)}isEnglish(){return"en"===this.locale||"en-us"===this.locale.toLowerCase()||ZZ(this.intl).locale.startsWith("en-us")}getWeekSettings(){return this.weekSettings?this.weekSettings:UJ()?function(e){let t=JZ.get(e);if(!t){const n=new Intl.Locale(e);t="getWeekInfo"in n?n.getWeekInfo():n.weekInfo,"minimalDays"in t||(t={...sJ,...t}),JZ.set(e,t)}return t}(this.locale):sJ}getStartOfWeek(){return this.getWeekSettings().firstDay}getMinDaysInFirstWeek(){return this.getWeekSettings().minimalDays}getWeekendDays(){return this.getWeekSettings().weekend}equals(e){return this.locale===e.locale&&this.numberingSystem===e.numberingSystem&&this.outputCalendar===e.outputCalendar}toString(){return`Locale(${this.locale}, ${this.numberingSystem}, ${this.outputCalendar})`}}let iJ=null;class oJ extends PZ{static get utcInstance(){return null===iJ&&(iJ=new oJ(0)),iJ}static instance(e){return 0===e?oJ.utcInstance:new oJ(e)}static parseSpecifier(e){if(e){const t=e.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);if(t)return new oJ(o0(t[1],t[2]))}return null}constructor(e){super(),this.fixed=e}get type(){return"fixed"}get name(){return 0===this.fixed?"UTC":`UTC${c0(this.fixed,"narrow")}`}get ianaName(){return 0===this.fixed?"Etc/UTC":`Etc/GMT${c0(-this.fixed,"narrow")}`}offsetName(){return this.name}formatOffset(e,t){return c0(this.fixed,t)}get isUniversal(){return!0}offset(){return this.fixed}equals(e){return"fixed"===e.type&&e.fixed===this.fixed}get isValid(){return!0}}class lJ extends PZ{constructor(e){super(),this.zoneName=e}get type(){return"invalid"}get name(){return this.zoneName}get isUniversal(){return!1}offsetName(){return null}formatOffset(){return""}offset(){return NaN}equals(){return!1}get isValid(){return!1}}function uJ(e,t){if(zJ(e)||null===e)return t;if(e instanceof PZ)return e;if("string"===typeof e){const n=e.toLowerCase();return"default"===n?t:"local"===n||"system"===n?BZ.instance:"utc"===n||"gmt"===n?oJ.utcInstance:oJ.parseSpecifier(n)||jZ.create(e)}return BJ(e)?oJ.instance(e):"object"===typeof e&&"offset"in e&&"function"===typeof e.offset?e:new lJ(e)}const cJ={arab:"[\u0660-\u0669]",arabext:"[\u06f0-\u06f9]",bali:"[\u1b50-\u1b59]",beng:"[\u09e6-\u09ef]",deva:"[\u0966-\u096f]",fullwide:"[\uff10-\uff19]",gujr:"[\u0ae6-\u0aef]",hanidec:"[\u3007|\u4e00|\u4e8c|\u4e09|\u56db|\u4e94|\u516d|\u4e03|\u516b|\u4e5d]",khmr:"[\u17e0-\u17e9]",knda:"[\u0ce6-\u0cef]",laoo:"[\u0ed0-\u0ed9]",limb:"[\u1946-\u194f]",mlym:"[\u0d66-\u0d6f]",mong:"[\u1810-\u1819]",mymr:"[\u1040-\u1049]",orya:"[\u0b66-\u0b6f]",tamldec:"[\u0be6-\u0bef]",telu:"[\u0c66-\u0c6f]",thai:"[\u0e50-\u0e59]",tibt:"[\u0f20-\u0f29]",latn:"\\d"},hJ={arab:[1632,1641],arabext:[1776,1785],bali:[6992,7001],beng:[2534,2543],deva:[2406,2415],fullwide:[65296,65303],gujr:[2790,2799],khmr:[6112,6121],knda:[3302,3311],laoo:[3792,3801],limb:[6470,6479],mlym:[3430,3439],mong:[6160,6169],mymr:[4160,4169],orya:[2918,2927],tamldec:[3046,3055],telu:[3174,3183],thai:[3664,3673],tibt:[3872,3881]},dJ=cJ.hanidec.replace(/[\[|\]]/g,"").split("");const pJ=new Map;function fJ(e){let{numberingSystem:t}=e,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"";const r=t||"latn";let s=pJ.get(r);void 0===s&&(s=new Map,pJ.set(r,s));let a=s.get(n);return void 0===a&&(a=new RegExp(`${cJ[r]}${n}`),s.set(n,a)),a}let mJ,gJ=()=>Date.now(),yJ="system",bJ=null,vJ=null,xJ=null,wJ=60,kJ=null;class SJ{static get now(){return gJ}static set now(e){gJ=e}static set defaultZone(e){yJ=e}static get defaultZone(){return uJ(yJ,BZ.instance)}static get defaultLocale(){return bJ}static set defaultLocale(e){bJ=e}static get defaultNumberingSystem(){return vJ}static set defaultNumberingSystem(e){vJ=e}static get defaultOutputCalendar(){return xJ}static set defaultOutputCalendar(e){xJ=e}static get defaultWeekSettings(){return kJ}static set defaultWeekSettings(e){kJ=HJ(e)}static get twoDigitCutoffYear(){return wJ}static set twoDigitCutoffYear(e){wJ=e%100}static get throwOnInvalid(){return mJ}static set throwOnInvalid(e){mJ=e}static resetCaches(){aJ.resetCache(),jZ.resetCache(),v2.resetCache(),pJ.clear()}}class NJ{constructor(e,t){this.reason=e,this.explanation=t}toMessage(){return this.explanation?`${this.reason}: ${this.explanation}`:this.reason}}const IJ=[0,31,59,90,120,151,181,212,243,273,304,334],CJ=[0,31,60,91,121,152,182,213,244,274,305,335];function TJ(e,t){return new NJ("unit out of range",`you specified ${t} (of type ${typeof t}) as a ${e}, which is invalid`)}function AJ(e,t,n){const r=new Date(Date.UTC(e,t-1,n));e<100&&e>=0&&r.setUTCFullYear(r.getUTCFullYear()-1900);const s=r.getUTCDay();return 0===s?7:s}function EJ(e,t,n){return n+(JJ(e)?CJ:IJ)[t-1]}function $J(e,t){const n=JJ(e)?CJ:IJ,r=n.findIndex((e=>e<t));return{month:r+1,day:t-n[r]}}function RJ(e,t){return(e-t+7)%7+1}function DJ(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:4,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;const{year:r,month:s,day:a}=e,i=EJ(r,s,a),o=RJ(AJ(r,s,a),n);let l,u=Math.floor((i-o+14-t)/7);return u<1?(l=r-1,u=s0(l,t,n)):u>s0(r,t,n)?(l=r+1,u=1):l=r,{weekYear:l,weekNumber:u,weekday:o,...h0(e)}}function OJ(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:4,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;const{weekYear:r,weekNumber:s,weekday:a}=e,i=RJ(AJ(r,1,t),n),o=e0(r);let l,u=7*s+a-i-7+t;u<1?(l=r-1,u+=e0(l)):u>o?(l=r+1,u-=e0(r)):l=r;const{month:c,day:h}=$J(l,u);return{year:l,month:c,day:h,...h0(e)}}function _J(e){const{year:t,month:n,day:r}=e;return{year:t,ordinal:EJ(t,n,r),...h0(e)}}function FJ(e){const{year:t,ordinal:n}=e,{month:r,day:s}=$J(t,n);return{year:t,month:r,day:s,...h0(e)}}function MJ(e,t){if(!zJ(e.localWeekday)||!zJ(e.localWeekNumber)||!zJ(e.localWeekYear)){if(!zJ(e.weekday)||!zJ(e.weekNumber)||!zJ(e.weekYear))throw new uZ("Cannot mix locale-based week fields with ISO-based week fields");return zJ(e.localWeekday)||(e.weekday=e.localWeekday),zJ(e.localWeekNumber)||(e.weekNumber=e.localWeekNumber),zJ(e.localWeekYear)||(e.weekYear=e.localWeekYear),delete e.localWeekday,delete e.localWeekNumber,delete e.localWeekYear,{minDaysInFirstWeek:t.getMinDaysInFirstWeek(),startOfWeek:t.getStartOfWeek()}}return{minDaysInFirstWeek:4,startOfWeek:1}}function LJ(e){const t=VJ(e.year),n=qJ(e.month,1,12),r=qJ(e.day,1,t0(e.year,e.month));return t?n?!r&&TJ("day",e.day):TJ("month",e.month):TJ("year",e.year)}function PJ(e){const{hour:t,minute:n,second:r,millisecond:s}=e,a=qJ(t,0,23)||24===t&&0===n&&0===r&&0===s,i=qJ(n,0,59),o=qJ(r,0,59),l=qJ(s,0,999);return a?i?o?!l&&TJ("millisecond",s):TJ("second",r):TJ("minute",n):TJ("hour",t)}function zJ(e){return"undefined"===typeof e}function BJ(e){return"number"===typeof e}function VJ(e){return"number"===typeof e&&e%1===0}function WJ(){try{return"undefined"!==typeof Intl&&!!Intl.RelativeTimeFormat}catch(E9){return!1}}function UJ(){try{return"undefined"!==typeof Intl&&!!Intl.Locale&&("weekInfo"in Intl.Locale.prototype||"getWeekInfo"in Intl.Locale.prototype)}catch(E9){return!1}}function jJ(e,t,n){if(0!==e.length)return e.reduce(((e,r)=>{const s=[t(r),r];return e&&n(e[0],s[0])===e[0]?e:s}),null)[1]}function GJ(e,t){return Object.prototype.hasOwnProperty.call(e,t)}function HJ(e){if(null==e)return null;if("object"!==typeof e)throw new hZ("Week settings must be an object");if(!qJ(e.firstDay,1,7)||!qJ(e.minimalDays,1,7)||!Array.isArray(e.weekend)||e.weekend.some((e=>!qJ(e,1,7))))throw new hZ("Invalid week settings");return{firstDay:e.firstDay,minimalDays:e.minimalDays,weekend:Array.from(e.weekend)}}function qJ(e,t,n){return VJ(e)&&e>=t&&e<=n}function KJ(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2;let n;return n=e<0?"-"+(""+-e).padStart(t,"0"):(""+e).padStart(t,"0"),n}function XJ(e){return zJ(e)||null===e||""===e?void 0:parseInt(e,10)}function QJ(e){return zJ(e)||null===e||""===e?void 0:parseFloat(e)}function YJ(e){if(!zJ(e)&&null!==e&&""!==e){const t=1e3*parseFloat("0."+e);return Math.floor(t)}}function ZJ(e,t){const n=10**t;return(arguments.length>2&&void 0!==arguments[2]&&arguments[2]?Math.trunc:Math.round)(e*n)/n}function JJ(e){return e%4===0&&(e%100!==0||e%400===0)}function e0(e){return JJ(e)?366:365}function t0(e,t){const n=function(e,t){return e-t*Math.floor(e/t)}(t-1,12)+1;return 2===n?JJ(e+(t-n)/12)?29:28:[31,null,31,30,31,30,31,31,30,31,30,31][n-1]}function n0(e){let t=Date.UTC(e.year,e.month-1,e.day,e.hour,e.minute,e.second,e.millisecond);return e.year<100&&e.year>=0&&(t=new Date(t),t.setUTCFullYear(e.year,e.month-1,e.day)),+t}function r0(e,t,n){return-RJ(AJ(e,1,t),n)+t-1}function s0(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:4,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;const r=r0(e,t,n),s=r0(e+1,t,n);return(e0(e)-r+s)/7}function a0(e){return e>99?e:e>SJ.twoDigitCutoffYear?1900+e:2e3+e}function i0(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const s=new Date(e),a={hourCycle:"h23",year:"numeric",month:"2-digit",day:"2-digit",hour:"2-digit",minute:"2-digit"};r&&(a.timeZone=r);const i={timeZoneName:t,...a},o=new Intl.DateTimeFormat(n,i).formatToParts(s).find((e=>"timezonename"===e.type.toLowerCase()));return o?o.value:null}function o0(e,t){let n=parseInt(e,10);Number.isNaN(n)&&(n=0);const r=parseInt(t,10)||0;return 60*n+(n<0||Object.is(n,-0)?-r:r)}function l0(e){const t=Number(e);if("boolean"===typeof e||""===e||Number.isNaN(t))throw new hZ(`Invalid unit value ${e}`);return t}function u0(e,t){const n={};for(const r in e)if(GJ(e,r)){const s=e[r];if(void 0===s||null===s)continue;n[t(r)]=l0(s)}return n}function c0(e,t){const n=Math.trunc(Math.abs(e/60)),r=Math.trunc(Math.abs(e%60)),s=e>=0?"+":"-";switch(t){case"short":return`${s}${KJ(n,2)}:${KJ(r,2)}`;case"narrow":return`${s}${n}${r>0?`:${r}`:""}`;case"techie":return`${s}${KJ(n,2)}${KJ(r,2)}`;default:throw new RangeError(`Value format ${t} is out of range for property format`)}}function h0(e){return function(e,t){return t.reduce(((t,n)=>(t[n]=e[n],t)),{})}(e,["hour","minute","second","millisecond"])}const d0=["January","February","March","April","May","June","July","August","September","October","November","December"],p0=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],f0=["J","F","M","A","M","J","J","A","S","O","N","D"];function m0(e){switch(e){case"narrow":return[...f0];case"short":return[...p0];case"long":return[...d0];case"numeric":return["1","2","3","4","5","6","7","8","9","10","11","12"];case"2-digit":return["01","02","03","04","05","06","07","08","09","10","11","12"];default:return null}}const g0=["Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday"],y0=["Mon","Tue","Wed","Thu","Fri","Sat","Sun"],b0=["M","T","W","T","F","S","S"];function v0(e){switch(e){case"narrow":return[...b0];case"short":return[...y0];case"long":return[...g0];case"numeric":return["1","2","3","4","5","6","7"];default:return null}}const x0=["AM","PM"],w0=["Before Christ","Anno Domini"],k0=["BC","AD"],S0=["B","A"];function N0(e){switch(e){case"narrow":return[...S0];case"short":return[...k0];case"long":return[...w0];default:return null}}function I0(e,t){let n="";for(const r of e)r.literal?n+=r.val:n+=t(r.val);return n}const C0={D:gZ,DD:yZ,DDD:vZ,DDDD:xZ,t:wZ,tt:kZ,ttt:SZ,tttt:NZ,T:IZ,TT:CZ,TTT:TZ,TTTT:AZ,f:EZ,ff:RZ,fff:_Z,ffff:MZ,F:$Z,FF:DZ,FFF:FZ,FFFF:LZ};class T0{static create(e){return new T0(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:{})}static parseFormat(e){let t=null,n="",r=!1;const s=[];for(let a=0;a<e.length;a++){const i=e.charAt(a);"'"===i?(n.length>0&&s.push({literal:r||/^\s+$/.test(n),val:n}),t=null,n="",r=!r):r||i===t?n+=i:(n.length>0&&s.push({literal:/^\s+$/.test(n),val:n}),n=i,t=i)}return n.length>0&&s.push({literal:r||/^\s+$/.test(n),val:n}),s}static macroTokenToFormatOpts(e){return C0[e]}constructor(e,t){this.opts=t,this.loc=e,this.systemLoc=null}formatWithSystemDefault(e,t){null===this.systemLoc&&(this.systemLoc=this.loc.redefaultToSystem());return this.systemLoc.dtFormatter(e,{...this.opts,...t}).format()}dtFormatter(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return this.loc.dtFormatter(e,{...this.opts,...t})}formatDateTime(e,t){return this.dtFormatter(e,t).format()}formatDateTimeParts(e,t){return this.dtFormatter(e,t).formatToParts()}formatInterval(e,t){return this.dtFormatter(e.start,t).dtf.formatRange(e.start.toJSDate(),e.end.toJSDate())}resolvedOptions(e,t){return this.dtFormatter(e,t).resolvedOptions()}num(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(this.opts.forceSimple)return KJ(e,t);const n={...this.opts};return t>0&&(n.padTo=t),this.loc.numberFormatter(n).format(e)}formatDateTimeFromString(e,t){const n="en"===this.loc.listingMode(),r=this.loc.outputCalendar&&"gregory"!==this.loc.outputCalendar,s=(t,n)=>this.loc.extract(e,t,n),a=t=>e.isOffsetFixed&&0===e.offset&&t.allowZ?"Z":e.isValid?e.zone.formatOffset(e.ts,t.format):"",i=()=>n?function(e){return x0[e.hour<12?0:1]}(e):s({hour:"numeric",hourCycle:"h12"},"dayperiod"),o=(t,r)=>n?function(e,t){return m0(t)[e.month-1]}(e,t):s(r?{month:t}:{month:t,day:"numeric"},"month"),l=(t,r)=>n?function(e,t){return v0(t)[e.weekday-1]}(e,t):s(r?{weekday:t}:{weekday:t,month:"long",day:"numeric"},"weekday"),u=t=>{const n=T0.macroTokenToFormatOpts(t);return n?this.formatWithSystemDefault(e,n):t},c=t=>n?function(e,t){return N0(t)[e.year<0?0:1]}(e,t):s({era:t},"era");return I0(T0.parseFormat(t),(t=>{switch(t){case"S":return this.num(e.millisecond);case"u":case"SSS":return this.num(e.millisecond,3);case"s":return this.num(e.second);case"ss":return this.num(e.second,2);case"uu":return this.num(Math.floor(e.millisecond/10),2);case"uuu":return this.num(Math.floor(e.millisecond/100));case"m":return this.num(e.minute);case"mm":return this.num(e.minute,2);case"h":return this.num(e.hour%12===0?12:e.hour%12);case"hh":return this.num(e.hour%12===0?12:e.hour%12,2);case"H":return this.num(e.hour);case"HH":return this.num(e.hour,2);case"Z":return a({format:"narrow",allowZ:this.opts.allowZ});case"ZZ":return a({format:"short",allowZ:this.opts.allowZ});case"ZZZ":return a({format:"techie",allowZ:this.opts.allowZ});case"ZZZZ":return e.zone.offsetName(e.ts,{format:"short",locale:this.loc.locale});case"ZZZZZ":return e.zone.offsetName(e.ts,{format:"long",locale:this.loc.locale});case"z":return e.zoneName;case"a":return i();case"d":return r?s({day:"numeric"},"day"):this.num(e.day);case"dd":return r?s({day:"2-digit"},"day"):this.num(e.day,2);case"c":case"E":return this.num(e.weekday);case"ccc":return l("short",!0);case"cccc":return l("long",!0);case"ccccc":return l("narrow",!0);case"EEE":return l("short",!1);case"EEEE":return l("long",!1);case"EEEEE":return l("narrow",!1);case"L":return r?s({month:"numeric",day:"numeric"},"month"):this.num(e.month);case"LL":return r?s({month:"2-digit",day:"numeric"},"month"):this.num(e.month,2);case"LLL":return o("short",!0);case"LLLL":return o("long",!0);case"LLLLL":return o("narrow",!0);case"M":return r?s({month:"numeric"},"month"):this.num(e.month);case"MM":return r?s({month:"2-digit"},"month"):this.num(e.month,2);case"MMM":return o("short",!1);case"MMMM":return o("long",!1);case"MMMMM":return o("narrow",!1);case"y":return r?s({year:"numeric"},"year"):this.num(e.year);case"yy":return r?s({year:"2-digit"},"year"):this.num(e.year.toString().slice(-2),2);case"yyyy":return r?s({year:"numeric"},"year"):this.num(e.year,4);case"yyyyyy":return r?s({year:"numeric"},"year"):this.num(e.year,6);case"G":return c("short");case"GG":return c("long");case"GGGGG":return c("narrow");case"kk":return this.num(e.weekYear.toString().slice(-2),2);case"kkkk":return this.num(e.weekYear,4);case"W":return this.num(e.weekNumber);case"WW":return this.num(e.weekNumber,2);case"n":return this.num(e.localWeekNumber);case"nn":return this.num(e.localWeekNumber,2);case"ii":return this.num(e.localWeekYear.toString().slice(-2),2);case"iiii":return this.num(e.localWeekYear,4);case"o":return this.num(e.ordinal);case"ooo":return this.num(e.ordinal,3);case"q":return this.num(e.quarter);case"qq":return this.num(e.quarter,2);case"X":return this.num(Math.floor(e.ts/1e3));case"x":return this.num(e.ts);default:return u(t)}}))}formatDurationFromString(e,t){const n=e=>{switch(e[0]){case"S":return"millisecond";case"s":return"second";case"m":return"minute";case"h":return"hour";case"d":return"day";case"w":return"week";case"M":return"month";case"y":return"year";default:return null}},r=T0.parseFormat(t),s=r.reduce(((e,t)=>{let{literal:n,val:r}=t;return n?e:e.concat(r)}),[]),a=e.shiftTo(...s.map(n).filter((e=>e)));return I0(r,(e=>t=>{const r=n(t);return r?this.num(e.get(r),t.length):t})(a))}}const A0=/[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;function E0(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];const r=t.reduce(((e,t)=>e+t.source),"");return RegExp(`^${r}$`)}function $0(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return e=>t.reduce(((t,n)=>{let[r,s,a]=t;const[i,o,l]=n(e,a);return[{...r,...i},o||s,l]}),[{},null,1]).slice(0,2)}function R0(e){if(null==e)return[null,null];for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];for(const[s,a]of n){const t=s.exec(e);if(t)return a(t)}return[null,null]}function D0(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return(e,n)=>{const r={};let s;for(s=0;s<t.length;s++)r[t[s]]=XJ(e[n+s]);return[r,null,n+s]}}const O0=/(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/,_0=/(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/,F0=RegExp(`${_0.source}${`(?:${O0.source}?(?:\\[(${A0.source})\\])?)?`}`),M0=RegExp(`(?:T${F0.source})?`),L0=D0("weekYear","weekNumber","weekDay"),P0=D0("year","ordinal"),z0=RegExp(`${_0.source} ?(?:${O0.source}|(${A0.source}))?`),B0=RegExp(`(?: ${z0.source})?`);function V0(e,t,n){const r=e[t];return zJ(r)?n:XJ(r)}function W0(e,t){return[{hours:V0(e,t,0),minutes:V0(e,t+1,0),seconds:V0(e,t+2,0),milliseconds:YJ(e[t+3])},null,t+4]}function U0(e,t){const n=!e[t]&&!e[t+1],r=o0(e[t+1],e[t+2]);return[{},n?null:oJ.instance(r),t+3]}function j0(e,t){return[{},e[t]?jZ.create(e[t]):null,t+1]}const G0=RegExp(`^T?${_0.source}$`),H0=/^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;function q0(e){const[t,n,r,s,a,i,o,l,u]=e,c="-"===t[0],h=l&&"-"===l[0],d=function(e){return void 0!==e&&(arguments.length>1&&void 0!==arguments[1]&&arguments[1]||e&&c)?-e:e};return[{years:d(QJ(n)),months:d(QJ(r)),weeks:d(QJ(s)),days:d(QJ(a)),hours:d(QJ(i)),minutes:d(QJ(o)),seconds:d(QJ(l),"-0"===l),milliseconds:d(YJ(u),h)}]}const K0={GMT:0,EDT:-240,EST:-300,CDT:-300,CST:-360,MDT:-360,MST:-420,PDT:-420,PST:-480};function X0(e,t,n,r,s,a,i){const o={year:2===t.length?a0(XJ(t)):XJ(t),month:p0.indexOf(n)+1,day:XJ(r),hour:XJ(s),minute:XJ(a)};return i&&(o.second=XJ(i)),e&&(o.weekday=e.length>3?g0.indexOf(e)+1:y0.indexOf(e)+1),o}const Q0=/^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;function Y0(e){const[,t,n,r,s,a,i,o,l,u,c,h]=e,d=X0(t,s,r,n,a,i,o);let p;return p=l?K0[l]:u?0:o0(c,h),[d,new oJ(p)]}const Z0=/^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/,J0=/^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/,e1=/^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;function t1(e){const[,t,n,r,s,a,i,o]=e;return[X0(t,s,r,n,a,i,o),oJ.utcInstance]}function n1(e){const[,t,n,r,s,a,i,o]=e;return[X0(t,o,n,r,s,a,i),oJ.utcInstance]}const r1=E0(/([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/,M0),s1=E0(/(\d{4})-?W(\d\d)(?:-?(\d))?/,M0),a1=E0(/(\d{4})-?(\d{3})/,M0),i1=E0(F0),o1=$0((function(e,t){return[{year:V0(e,t),month:V0(e,t+1,1),day:V0(e,t+2,1)},null,t+3]}),W0,U0,j0),l1=$0(L0,W0,U0,j0),u1=$0(P0,W0,U0,j0),c1=$0(W0,U0,j0);const h1=$0(W0);const d1=E0(/(\d{4})-(\d\d)-(\d\d)/,B0),p1=E0(z0),f1=$0(W0,U0,j0);const m1="Invalid Duration",g1={weeks:{days:7,hours:168,minutes:10080,seconds:604800,milliseconds:6048e5},days:{hours:24,minutes:1440,seconds:86400,milliseconds:864e5},hours:{minutes:60,seconds:3600,milliseconds:36e5},minutes:{seconds:60,milliseconds:6e4},seconds:{milliseconds:1e3}},y1={years:{quarters:4,months:12,weeks:52,days:365,hours:8760,minutes:525600,seconds:31536e3,milliseconds:31536e6},quarters:{months:3,weeks:13,days:91,hours:2184,minutes:131040,seconds:7862400,milliseconds:78624e5},months:{weeks:4,days:30,hours:720,minutes:43200,seconds:2592e3,milliseconds:2592e6},...g1},b1=365.2425,v1=30.436875,x1={years:{quarters:4,months:12,weeks:52.1775,days:b1,hours:8765.82,minutes:525949.2,seconds:525949.2*60,milliseconds:525949.2*60*1e3},quarters:{months:3,weeks:13.044375,days:91.310625,hours:2191.455,minutes:131487.3,seconds:525949.2*60/4,milliseconds:7889237999.999999},months:{weeks:4.3481250000000005,days:v1,hours:730.485,minutes:43829.1,seconds:2629746,milliseconds:2629746e3},...g1},w1=["years","quarters","months","weeks","days","hours","minutes","seconds","milliseconds"],k1=w1.slice(0).reverse();function S1(e,t){const n={values:arguments.length>2&&void 0!==arguments[2]&&arguments[2]?t.values:{...e.values,...t.values||{}},loc:e.loc.clone(t.loc),conversionAccuracy:t.conversionAccuracy||e.conversionAccuracy,matrix:t.matrix||e.matrix};return new C1(n)}function N1(e,t){let n=t.milliseconds??0;for(const r of k1.slice(1))t[r]&&(n+=t[r]*e[r].milliseconds);return n}function I1(e,t){const n=N1(e,t)<0?-1:1;w1.reduceRight(((r,s)=>{if(zJ(t[s]))return r;if(r){const a=t[r]*n,i=e[s][r],o=Math.floor(a/i);t[s]+=o*n,t[r]-=o*i*n}return s}),null),w1.reduce(((n,r)=>{if(zJ(t[r]))return n;if(n){const s=t[n]%1;t[n]-=s,t[r]+=s*e[n][r]}return r}),null)}class C1{constructor(e){const t="longterm"===e.conversionAccuracy||!1;let n=t?x1:y1;e.matrix&&(n=e.matrix),this.values=e.values,this.loc=e.loc||aJ.create(),this.conversionAccuracy=t?"longterm":"casual",this.invalid=e.invalid||null,this.matrix=n,this.isLuxonDuration=!0}static fromMillis(e,t){return C1.fromObject({milliseconds:e},t)}static fromObject(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(null==e||"object"!==typeof e)throw new hZ("Duration.fromObject: argument expected to be an object, got "+(null===e?"null":typeof e));return new C1({values:u0(e,C1.normalizeUnit),loc:aJ.fromObject(t),conversionAccuracy:t.conversionAccuracy,matrix:t.matrix})}static fromDurationLike(e){if(BJ(e))return C1.fromMillis(e);if(C1.isDuration(e))return e;if("object"===typeof e)return C1.fromObject(e);throw new hZ(`Unknown duration argument ${e} of type ${typeof e}`)}static fromISO(e,t){const[n]=function(e){return R0(e,[H0,q0])}(e);return n?C1.fromObject(n,t):C1.invalid("unparsable",`the input "${e}" can't be parsed as ISO 8601`)}static fromISOTime(e,t){const[n]=function(e){return R0(e,[G0,h1])}(e);return n?C1.fromObject(n,t):C1.invalid("unparsable",`the input "${e}" can't be parsed as ISO 8601`)}static invalid(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(!e)throw new hZ("need to specify a reason the Duration is invalid");const n=e instanceof NJ?e:new NJ(e,t);if(SJ.throwOnInvalid)throw new lZ(n);return new C1({invalid:n})}static normalizeUnit(e){const t={year:"years",years:"years",quarter:"quarters",quarters:"quarters",month:"months",months:"months",week:"weeks",weeks:"weeks",day:"days",days:"days",hour:"hours",hours:"hours",minute:"minutes",minutes:"minutes",second:"seconds",seconds:"seconds",millisecond:"milliseconds",milliseconds:"milliseconds"}[e?e.toLowerCase():e];if(!t)throw new cZ(e);return t}static isDuration(e){return e&&e.isLuxonDuration||!1}get locale(){return this.isValid?this.loc.locale:null}get numberingSystem(){return this.isValid?this.loc.numberingSystem:null}toFormat(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n={...t,floor:!1!==t.round&&!1!==t.floor};return this.isValid?T0.create(this.loc,n).formatDurationFromString(this,e):m1}toHuman(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(!this.isValid)return m1;const t=w1.map((t=>{const n=this.values[t];return zJ(n)?null:this.loc.numberFormatter({style:"unit",unitDisplay:"long",...e,unit:t.slice(0,-1)}).format(n)})).filter((e=>e));return this.loc.listFormatter({type:"conjunction",style:e.listStyle||"narrow",...e}).format(t)}toObject(){return this.isValid?{...this.values}:{}}toISO(){if(!this.isValid)return null;let e="P";return 0!==this.years&&(e+=this.years+"Y"),0===this.months&&0===this.quarters||(e+=this.months+3*this.quarters+"M"),0!==this.weeks&&(e+=this.weeks+"W"),0!==this.days&&(e+=this.days+"D"),0===this.hours&&0===this.minutes&&0===this.seconds&&0===this.milliseconds||(e+="T"),0!==this.hours&&(e+=this.hours+"H"),0!==this.minutes&&(e+=this.minutes+"M"),0===this.seconds&&0===this.milliseconds||(e+=ZJ(this.seconds+this.milliseconds/1e3,3)+"S"),"P"===e&&(e+="T0S"),e}toISOTime(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(!this.isValid)return null;const t=this.toMillis();if(t<0||t>=864e5)return null;e={suppressMilliseconds:!1,suppressSeconds:!1,includePrefix:!1,format:"extended",...e,includeOffset:!1};return v2.fromMillis(t,{zone:"UTC"}).toISOTime(e)}toJSON(){return this.toISO()}toString(){return this.toISO()}[Symbol.for("nodejs.util.inspect.custom")](){return this.isValid?`Duration { values: ${JSON.stringify(this.values)} }`:`Duration { Invalid, reason: ${this.invalidReason} }`}toMillis(){return this.isValid?N1(this.matrix,this.values):NaN}valueOf(){return this.toMillis()}plus(e){if(!this.isValid)return this;const t=C1.fromDurationLike(e),n={};for(const r of w1)(GJ(t.values,r)||GJ(this.values,r))&&(n[r]=t.get(r)+this.get(r));return S1(this,{values:n},!0)}minus(e){if(!this.isValid)return this;const t=C1.fromDurationLike(e);return this.plus(t.negate())}mapUnits(e){if(!this.isValid)return this;const t={};for(const n of Object.keys(this.values))t[n]=l0(e(this.values[n],n));return S1(this,{values:t},!0)}get(e){return this[C1.normalizeUnit(e)]}set(e){if(!this.isValid)return this;return S1(this,{values:{...this.values,...u0(e,C1.normalizeUnit)}})}reconfigure(){let{locale:e,numberingSystem:t,conversionAccuracy:n,matrix:r}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return S1(this,{loc:this.loc.clone({locale:e,numberingSystem:t}),matrix:r,conversionAccuracy:n})}as(e){return this.isValid?this.shiftTo(e).get(e):NaN}normalize(){if(!this.isValid)return this;const e=this.toObject();return I1(this.matrix,e),S1(this,{values:e},!0)}rescale(){if(!this.isValid)return this;const e=function(e){const t={};for(const[n,r]of Object.entries(e))0!==r&&(t[n]=r);return t}(this.normalize().shiftToAll().toObject());return S1(this,{values:e},!0)}shiftTo(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];if(!this.isValid)return this;if(0===t.length)return this;t=t.map((e=>C1.normalizeUnit(e)));const r={},s={},a=this.toObject();let i;for(const o of w1)if(t.indexOf(o)>=0){i=o;let e=0;for(const n in s)e+=this.matrix[n][o]*s[n],s[n]=0;BJ(a[o])&&(e+=a[o]);const t=Math.trunc(e);r[o]=t,s[o]=(1e3*e-1e3*t)/1e3}else BJ(a[o])&&(s[o]=a[o]);for(const o in s)0!==s[o]&&(r[i]+=o===i?s[o]:s[o]/this.matrix[i][o]);return I1(this.matrix,r),S1(this,{values:r},!0)}shiftToAll(){return this.isValid?this.shiftTo("years","months","weeks","days","hours","minutes","seconds","milliseconds"):this}negate(){if(!this.isValid)return this;const e={};for(const t of Object.keys(this.values))e[t]=0===this.values[t]?0:-this.values[t];return S1(this,{values:e},!0)}get years(){return this.isValid?this.values.years||0:NaN}get quarters(){return this.isValid?this.values.quarters||0:NaN}get months(){return this.isValid?this.values.months||0:NaN}get weeks(){return this.isValid?this.values.weeks||0:NaN}get days(){return this.isValid?this.values.days||0:NaN}get hours(){return this.isValid?this.values.hours||0:NaN}get minutes(){return this.isValid?this.values.minutes||0:NaN}get seconds(){return this.isValid?this.values.seconds||0:NaN}get milliseconds(){return this.isValid?this.values.milliseconds||0:NaN}get isValid(){return null===this.invalid}get invalidReason(){return this.invalid?this.invalid.reason:null}get invalidExplanation(){return this.invalid?this.invalid.explanation:null}equals(e){if(!this.isValid||!e.isValid)return!1;if(!this.loc.equals(e.loc))return!1;for(const r of w1)if(t=this.values[r],n=e.values[r],!(void 0===t||0===t?void 0===n||0===n:t===n))return!1;var t,n;return!0}}const T1="Invalid Interval";class A1{constructor(e){this.s=e.start,this.e=e.end,this.invalid=e.invalid||null,this.isLuxonInterval=!0}static invalid(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(!e)throw new hZ("need to specify a reason the Interval is invalid");const n=e instanceof NJ?e:new NJ(e,t);if(SJ.throwOnInvalid)throw new oZ(n);return new A1({invalid:n})}static fromDateTimes(e,t){const n=x2(e),r=x2(t),s=function(e,t){return e&&e.isValid?t&&t.isValid?t<e?A1.invalid("end before start",`The end of an interval must be after its start, but you had start=${e.toISO()} and end=${t.toISO()}`):null:A1.invalid("missing or invalid end"):A1.invalid("missing or invalid start")}(n,r);return null==s?new A1({start:n,end:r}):s}static after(e,t){const n=C1.fromDurationLike(t),r=x2(e);return A1.fromDateTimes(r,r.plus(n))}static before(e,t){const n=C1.fromDurationLike(t),r=x2(e);return A1.fromDateTimes(r.minus(n),r)}static fromISO(e,t){const[n,r]=(e||"").split("/",2);if(n&&r){let e,s,a,i;try{e=v2.fromISO(n,t),s=e.isValid}catch(r){s=!1}try{a=v2.fromISO(r,t),i=a.isValid}catch(r){i=!1}if(s&&i)return A1.fromDateTimes(e,a);if(s){const n=C1.fromISO(r,t);if(n.isValid)return A1.after(e,n)}else if(i){const e=C1.fromISO(n,t);if(e.isValid)return A1.before(a,e)}}return A1.invalid("unparsable",`the input "${e}" can't be parsed as ISO 8601`)}static isInterval(e){return e&&e.isLuxonInterval||!1}get start(){return this.isValid?this.s:null}get end(){return this.isValid?this.e:null}get lastDateTime(){return this.isValid&&this.e?this.e.minus(1):null}get isValid(){return null===this.invalidReason}get invalidReason(){return this.invalid?this.invalid.reason:null}get invalidExplanation(){return this.invalid?this.invalid.explanation:null}length(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"milliseconds";return this.isValid?this.toDuration(e).get(e):NaN}count(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"milliseconds",t=arguments.length>1?arguments[1]:void 0;if(!this.isValid)return NaN;const n=this.start.startOf(e,t);let r;return r=t?.useLocaleWeeks?this.end.reconfigure({locale:n.locale}):this.end,r=r.startOf(e,t),Math.floor(r.diff(n,e).get(e))+(r.valueOf()!==this.end.valueOf())}hasSame(e){return!!this.isValid&&(this.isEmpty()||this.e.minus(1).hasSame(this.s,e))}isEmpty(){return this.s.valueOf()===this.e.valueOf()}isAfter(e){return!!this.isValid&&this.s>e}isBefore(e){return!!this.isValid&&this.e<=e}contains(e){return!!this.isValid&&(this.s<=e&&this.e>e)}set(){let{start:e,end:t}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return this.isValid?A1.fromDateTimes(e||this.s,t||this.e):this}splitAt(){if(!this.isValid)return[];for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];const r=t.map(x2).filter((e=>this.contains(e))).sort(((e,t)=>e.toMillis()-t.toMillis())),s=[];let{s:a}=this,i=0;for(;a<this.e;){const e=r[i]||this.e,t=+e>+this.e?this.e:e;s.push(A1.fromDateTimes(a,t)),a=t,i+=1}return s}splitBy(e){const t=C1.fromDurationLike(e);if(!this.isValid||!t.isValid||0===t.as("milliseconds"))return[];let n,{s:r}=this,s=1;const a=[];for(;r<this.e;){const e=this.start.plus(t.mapUnits((e=>e*s)));n=+e>+this.e?this.e:e,a.push(A1.fromDateTimes(r,n)),r=n,s+=1}return a}divideEqually(e){return this.isValid?this.splitBy(this.length()/e).slice(0,e):[]}overlaps(e){return this.e>e.s&&this.s<e.e}abutsStart(e){return!!this.isValid&&+this.e===+e.s}abutsEnd(e){return!!this.isValid&&+e.e===+this.s}engulfs(e){return!!this.isValid&&(this.s<=e.s&&this.e>=e.e)}equals(e){return!(!this.isValid||!e.isValid)&&(this.s.equals(e.s)&&this.e.equals(e.e))}intersection(e){if(!this.isValid)return this;const t=this.s>e.s?this.s:e.s,n=this.e<e.e?this.e:e.e;return t>=n?null:A1.fromDateTimes(t,n)}union(e){if(!this.isValid)return this;const t=this.s<e.s?this.s:e.s,n=this.e>e.e?this.e:e.e;return A1.fromDateTimes(t,n)}static merge(e){const[t,n]=e.sort(((e,t)=>e.s-t.s)).reduce(((e,t)=>{let[n,r]=e;return r?r.overlaps(t)||r.abutsStart(t)?[n,r.union(t)]:[n.concat([r]),t]:[n,t]}),[[],null]);return n&&t.push(n),t}static xor(e){let t=null,n=0;const r=[],s=e.map((e=>[{time:e.s,type:"s"},{time:e.e,type:"e"}])),a=Array.prototype.concat(...s).sort(((e,t)=>e.time-t.time));for(const i of a)n+="s"===i.type?1:-1,1===n?t=i.time:(t&&+t!==+i.time&&r.push(A1.fromDateTimes(t,i.time)),t=null);return A1.merge(r)}difference(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return A1.xor([this].concat(t)).map((e=>this.intersection(e))).filter((e=>e&&!e.isEmpty()))}toString(){return this.isValid?`[${this.s.toISO()} \u2013 ${this.e.toISO()})`:T1}[Symbol.for("nodejs.util.inspect.custom")](){return this.isValid?`Interval { start: ${this.s.toISO()}, end: ${this.e.toISO()} }`:`Interval { Invalid, reason: ${this.invalidReason} }`}toLocaleString(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:gZ,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return this.isValid?T0.create(this.s.loc.clone(t),e).formatInterval(this):T1}toISO(e){return this.isValid?`${this.s.toISO(e)}/${this.e.toISO(e)}`:T1}toISODate(){return this.isValid?`${this.s.toISODate()}/${this.e.toISODate()}`:T1}toISOTime(e){return this.isValid?`${this.s.toISOTime(e)}/${this.e.toISOTime(e)}`:T1}toFormat(e){let{separator:t=" \u2013 "}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return this.isValid?`${this.s.toFormat(e)}${t}${this.e.toFormat(e)}`:T1}toDuration(e,t){return this.isValid?this.e.diff(this.s,e,t):C1.invalid(this.invalidReason)}mapEndpoints(e){return A1.fromDateTimes(e(this.s),e(this.e))}}class E1{static hasDST(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:SJ.defaultZone;const t=v2.now().setZone(e).set({month:12});return!e.isUniversal&&t.offset!==t.set({month:6}).offset}static isValidIANAZone(e){return jZ.isValidZone(e)}static normalizeZone(e){return uJ(e,SJ.defaultZone)}static getStartOfWeek(){let{locale:e=null,locObj:t=null}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return(t||aJ.create(e)).getStartOfWeek()}static getMinimumDaysInFirstWeek(){let{locale:e=null,locObj:t=null}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return(t||aJ.create(e)).getMinDaysInFirstWeek()}static getWeekendWeekdays(){let{locale:e=null,locObj:t=null}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return(t||aJ.create(e)).getWeekendDays().slice()}static months(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"long",{locale:t=null,numberingSystem:n=null,locObj:r=null,outputCalendar:s="gregory"}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return(r||aJ.create(t,n,s)).months(e)}static monthsFormat(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"long",{locale:t=null,numberingSystem:n=null,locObj:r=null,outputCalendar:s="gregory"}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return(r||aJ.create(t,n,s)).months(e,!0)}static weekdays(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"long",{locale:t=null,numberingSystem:n=null,locObj:r=null}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return(r||aJ.create(t,n,null)).weekdays(e)}static weekdaysFormat(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"long",{locale:t=null,numberingSystem:n=null,locObj:r=null}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return(r||aJ.create(t,n,null)).weekdays(e,!0)}static meridiems(){let{locale:e=null}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return aJ.create(e).meridiems()}static eras(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"short",{locale:t=null}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return aJ.create(t,null,"gregory").eras(e)}static features(){return{relative:WJ(),localeWeek:UJ()}}}function $1(e,t){const n=e=>e.toUTC(0,{keepLocalTime:!0}).startOf("day").valueOf(),r=n(t)-n(e);return Math.floor(C1.fromMillis(r).as("days"))}function R1(e,t,n,r){let[s,a,i,o]=function(e,t,n){const r=[["years",(e,t)=>t.year-e.year],["quarters",(e,t)=>t.quarter-e.quarter+4*(t.year-e.year)],["months",(e,t)=>t.month-e.month+12*(t.year-e.year)],["weeks",(e,t)=>{const n=$1(e,t);return(n-n%7)/7}],["days",$1]],s={},a=e;let i,o;for(const[l,u]of r)n.indexOf(l)>=0&&(i=l,s[l]=u(e,t),o=a.plus(s),o>t?(s[l]--,(e=a.plus(s))>t&&(o=e,s[l]--,e=a.plus(s))):e=o);return[e,s,o,i]}(e,t,n);const l=t-s,u=n.filter((e=>["hours","minutes","seconds","milliseconds"].indexOf(e)>=0));0===u.length&&(i<t&&(i=s.plus({[o]:1})),i!==s&&(a[o]=(a[o]||0)+l/(i-s)));const c=C1.fromObject(a,r);return u.length>0?C1.fromMillis(l,r).shiftTo(...u).plus(c):c}function D1(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e=>e;return{regex:e,deser:e=>{let[n]=e;return t(function(e){let t=parseInt(e,10);if(isNaN(t)){t="";for(let n=0;n<e.length;n++){const r=e.charCodeAt(n);if(-1!==e[n].search(cJ.hanidec))t+=dJ.indexOf(e[n]);else for(const e in hJ){const[n,s]=hJ[e];r>=n&&r<=s&&(t+=r-n)}}return parseInt(t,10)}return t}(n))}}}const O1=`[ ${String.fromCharCode(160)}]`,_1=new RegExp(O1,"g");function F1(e){return e.replace(/\./g,"\\.?").replace(_1,O1)}function M1(e){return e.replace(/\./g,"").replace(_1," ").toLowerCase()}function L1(e,t){return null===e?null:{regex:RegExp(e.map(F1).join("|")),deser:n=>{let[r]=n;return e.findIndex((e=>M1(r)===M1(e)))+t}}}function P1(e,t){return{regex:e,deser:e=>{let[,t,n]=e;return o0(t,n)},groups:t}}function z1(e){return{regex:e,deser:e=>{let[t]=e;return t}}}function B1(e){return e.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&")}const V1={year:{"2-digit":"yy",numeric:"yyyyy"},month:{numeric:"M","2-digit":"MM",short:"MMM",long:"MMMM"},day:{numeric:"d","2-digit":"dd"},weekday:{short:"EEE",long:"EEEE"},dayperiod:"a",dayPeriod:"a",hour12:{numeric:"h","2-digit":"hh"},hour24:{numeric:"H","2-digit":"HH"},minute:{numeric:"m","2-digit":"mm"},second:{numeric:"s","2-digit":"ss"},timeZoneName:{long:"ZZZZZ",short:"ZZZ"}};let W1=null;function U1(e,t){return Array.prototype.concat(...e.map((e=>function(e,t){if(e.literal)return e;const n=H1(T0.macroTokenToFormatOpts(e.val),t);return null==n||n.includes(void 0)?e:n}(e,t))))}class j1{constructor(e,t){if(this.locale=e,this.format=t,this.tokens=U1(T0.parseFormat(t),e),this.units=this.tokens.map((t=>function(e,t){const n=fJ(t),r=fJ(t,"{2}"),s=fJ(t,"{3}"),a=fJ(t,"{4}"),i=fJ(t,"{6}"),o=fJ(t,"{1,2}"),l=fJ(t,"{1,3}"),u=fJ(t,"{1,6}"),c=fJ(t,"{1,9}"),h=fJ(t,"{2,4}"),d=fJ(t,"{4,6}"),p=e=>({regex:RegExp(B1(e.val)),deser:e=>{let[t]=e;return t},literal:!0}),f=(f=>{if(e.literal)return p(f);switch(f.val){case"G":return L1(t.eras("short"),0);case"GG":return L1(t.eras("long"),0);case"y":return D1(u);case"yy":case"kk":return D1(h,a0);case"yyyy":case"kkkk":return D1(a);case"yyyyy":return D1(d);case"yyyyyy":return D1(i);case"M":case"L":case"d":case"H":case"h":case"m":case"q":case"s":case"W":return D1(o);case"MM":case"LL":case"dd":case"HH":case"hh":case"mm":case"qq":case"ss":case"WW":return D1(r);case"MMM":return L1(t.months("short",!0),1);case"MMMM":return L1(t.months("long",!0),1);case"LLL":return L1(t.months("short",!1),1);case"LLLL":return L1(t.months("long",!1),1);case"o":case"S":return D1(l);case"ooo":case"SSS":return D1(s);case"u":return z1(c);case"uu":return z1(o);case"uuu":case"E":case"c":return D1(n);case"a":return L1(t.meridiems(),0);case"EEE":return L1(t.weekdays("short",!1),1);case"EEEE":return L1(t.weekdays("long",!1),1);case"ccc":return L1(t.weekdays("short",!0),1);case"cccc":return L1(t.weekdays("long",!0),1);case"Z":case"ZZ":return P1(new RegExp(`([+-]${o.source})(?::(${r.source}))?`),2);case"ZZZ":return P1(new RegExp(`([+-]${o.source})(${r.source})?`),2);case"z":return z1(/[a-z_+-/]{1,256}?/i);case" ":return z1(/[^\S\n\r]/);default:return p(f)}})(e)||{invalidReason:"missing Intl.DateTimeFormat.formatToParts support"};return f.token=e,f}(t,e))),this.disqualifyingUnit=this.units.find((e=>e.invalidReason)),!this.disqualifyingUnit){const[e,t]=function(e){const t=e.map((e=>e.regex)).reduce(((e,t)=>`${e}(${t.source})`),"");return[`^${t}$`,e]}(this.units);this.regex=RegExp(e,"i"),this.handlers=t}}explainFromTokens(e){if(this.isValid){const[t,n]=function(e,t,n){const r=e.match(t);if(r){const e={};let t=1;for(const s in n)if(GJ(n,s)){const a=n[s],i=a.groups?a.groups+1:1;!a.literal&&a.token&&(e[a.token.val[0]]=a.deser(r.slice(t,t+i))),t+=i}return[r,e]}return[r,{}]}(e,this.regex,this.handlers),[r,s,a]=n?function(e){let t,n=null;zJ(e.z)||(n=jZ.create(e.z)),zJ(e.Z)||(n||(n=new oJ(e.Z)),t=e.Z),zJ(e.q)||(e.M=3*(e.q-1)+1),zJ(e.h)||(e.h<12&&1===e.a?e.h+=12:12===e.h&&0===e.a&&(e.h=0)),0===e.G&&e.y&&(e.y=-e.y),zJ(e.u)||(e.S=YJ(e.u));const r=Object.keys(e).reduce(((t,n)=>{const r=(e=>{switch(e){case"S":return"millisecond";case"s":return"second";case"m":return"minute";case"h":case"H":return"hour";case"d":return"day";case"o":return"ordinal";case"L":case"M":return"month";case"y":return"year";case"E":case"c":return"weekday";case"W":return"weekNumber";case"k":return"weekYear";case"q":return"quarter";default:return null}})(n);return r&&(t[r]=e[n]),t}),{});return[r,n,t]}(n):[null,null,void 0];if(GJ(n,"a")&&GJ(n,"H"))throw new uZ("Can't include meridiem when specifying 24-hour format");return{input:e,tokens:this.tokens,regex:this.regex,rawMatches:t,matches:n,result:r,zone:s,specificOffset:a}}return{input:e,tokens:this.tokens,invalidReason:this.invalidReason}}get isValid(){return!this.disqualifyingUnit}get invalidReason(){return this.disqualifyingUnit?this.disqualifyingUnit.invalidReason:null}}function G1(e,t,n){return new j1(e,n).explainFromTokens(t)}function H1(e,t){if(!e)return null;const n=T0.create(t,e).dtFormatter((W1||(W1=v2.fromMillis(1555555555555)),W1)),r=n.formatToParts(),s=n.resolvedOptions();return r.map((t=>function(e,t,n){const{type:r,value:s}=e;if("literal"===r){const e=/^\s+$/.test(s);return{literal:!e,val:e?" ":s}}const a=t[r];let i=r;"hour"===r&&(i=null!=t.hour12?t.hour12?"hour12":"hour24":null!=t.hourCycle?"h11"===t.hourCycle||"h12"===t.hourCycle?"hour12":"hour24":n.hour12?"hour12":"hour24");let o=V1[i];if("object"===typeof o&&(o=o[a]),o)return{literal:!1,val:o}}(t,e,s)))}const q1="Invalid DateTime",K1=864e13;function X1(e){return new NJ("unsupported zone",`the zone "${e.name}" is not supported`)}function Q1(e){return null===e.weekData&&(e.weekData=DJ(e.c)),e.weekData}function Y1(e){return null===e.localWeekData&&(e.localWeekData=DJ(e.c,e.loc.getMinDaysInFirstWeek(),e.loc.getStartOfWeek())),e.localWeekData}function Z1(e,t){const n={ts:e.ts,zone:e.zone,c:e.c,o:e.o,loc:e.loc,invalid:e.invalid};return new v2({...n,...t,old:n})}function J1(e,t,n){let r=e-60*t*1e3;const s=n.offset(r);if(t===s)return[r,t];r-=60*(s-t)*1e3;const a=n.offset(r);return s===a?[r,s]:[e-60*Math.min(s,a)*1e3,Math.max(s,a)]}function e2(e,t){const n=new Date(e+=60*t*1e3);return{year:n.getUTCFullYear(),month:n.getUTCMonth()+1,day:n.getUTCDate(),hour:n.getUTCHours(),minute:n.getUTCMinutes(),second:n.getUTCSeconds(),millisecond:n.getUTCMilliseconds()}}function t2(e,t,n){return J1(n0(e),t,n)}function n2(e,t){const n=e.o,r=e.c.year+Math.trunc(t.years),s=e.c.month+Math.trunc(t.months)+3*Math.trunc(t.quarters),a={...e.c,year:r,month:s,day:Math.min(e.c.day,t0(r,s))+Math.trunc(t.days)+7*Math.trunc(t.weeks)},i=C1.fromObject({years:t.years-Math.trunc(t.years),quarters:t.quarters-Math.trunc(t.quarters),months:t.months-Math.trunc(t.months),weeks:t.weeks-Math.trunc(t.weeks),days:t.days-Math.trunc(t.days),hours:t.hours,minutes:t.minutes,seconds:t.seconds,milliseconds:t.milliseconds}).as("milliseconds"),o=n0(a);let[l,u]=J1(o,n,e.zone);return 0!==i&&(l+=i,u=e.zone.offset(l)),{ts:l,o:u}}function r2(e,t,n,r,s,a){const{setZone:i,zone:o}=n;if(e&&0!==Object.keys(e).length||t){const r=t||o,s=v2.fromObject(e,{...n,zone:r,specificOffset:a});return i?s:s.setZone(o)}return v2.invalid(new NJ("unparsable",`the input "${s}" can't be parsed as ${r}`))}function s2(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];return e.isValid?T0.create(aJ.create("en-US"),{allowZ:n,forceSimple:!0}).formatDateTimeFromString(e,t):null}function a2(e,t){const n=e.c.year>9999||e.c.year<0;let r="";return n&&e.c.year>=0&&(r+="+"),r+=KJ(e.c.year,n?6:4),t?(r+="-",r+=KJ(e.c.month),r+="-",r+=KJ(e.c.day)):(r+=KJ(e.c.month),r+=KJ(e.c.day)),r}function i2(e,t,n,r,s,a){let i=KJ(e.c.hour);return t?(i+=":",i+=KJ(e.c.minute),0===e.c.millisecond&&0===e.c.second&&n||(i+=":")):i+=KJ(e.c.minute),0===e.c.millisecond&&0===e.c.second&&n||(i+=KJ(e.c.second),0===e.c.millisecond&&r||(i+=".",i+=KJ(e.c.millisecond,3))),s&&(e.isOffsetFixed&&0===e.offset&&!a?i+="Z":e.o<0?(i+="-",i+=KJ(Math.trunc(-e.o/60)),i+=":",i+=KJ(Math.trunc(-e.o%60))):(i+="+",i+=KJ(Math.trunc(e.o/60)),i+=":",i+=KJ(Math.trunc(e.o%60)))),a&&(i+="["+e.zone.ianaName+"]"),i}const o2={month:1,day:1,hour:0,minute:0,second:0,millisecond:0},l2={weekNumber:1,weekday:1,hour:0,minute:0,second:0,millisecond:0},u2={ordinal:1,hour:0,minute:0,second:0,millisecond:0},c2=["year","month","day","hour","minute","second","millisecond"],h2=["weekYear","weekNumber","weekday","hour","minute","second","millisecond"],d2=["year","ordinal","hour","minute","second","millisecond"];function p2(e){switch(e.toLowerCase()){case"localweekday":case"localweekdays":return"localWeekday";case"localweeknumber":case"localweeknumbers":return"localWeekNumber";case"localweekyear":case"localweekyears":return"localWeekYear";default:return function(e){const t={year:"year",years:"year",month:"month",months:"month",day:"day",days:"day",hour:"hour",hours:"hour",minute:"minute",minutes:"minute",quarter:"quarter",quarters:"quarter",second:"second",seconds:"second",millisecond:"millisecond",milliseconds:"millisecond",weekday:"weekday",weekdays:"weekday",weeknumber:"weekNumber",weeksnumber:"weekNumber",weeknumbers:"weekNumber",weekyear:"weekYear",weekyears:"weekYear",ordinal:"ordinal"}[e.toLowerCase()];if(!t)throw new cZ(e);return t}(e)}}function f2(e,t){const n=uJ(t.zone,SJ.defaultZone);if(!n.isValid)return v2.invalid(X1(n));const r=aJ.fromObject(t);let s,a;if(zJ(e.year))s=SJ.now();else{for(const n of c2)zJ(e[n])&&(e[n]=o2[n]);const t=LJ(e)||PJ(e);if(t)return v2.invalid(t);const r=function(e){if(void 0===y2&&(y2=SJ.now()),"iana"!==e.type)return e.offset(y2);const t=e.name;let n=b2.get(t);return void 0===n&&(n=e.offset(y2),b2.set(t,n)),n}(n);[s,a]=t2(e,r,n)}return new v2({ts:s,zone:n,loc:r,o:a})}function m2(e,t,n){const r=!!zJ(n.round)||n.round,s=(e,s)=>{e=ZJ(e,r||n.calendary?0:2,!0);return t.loc.clone(n).relFormatter(n).format(e,s)},a=r=>n.calendary?t.hasSame(e,r)?0:t.startOf(r).diff(e.startOf(r),r).get(r):t.diff(e,r).get(r);if(n.unit)return s(a(n.unit),n.unit);for(const i of n.units){const e=a(i);if(Math.abs(e)>=1)return s(e,i)}return s(e>t?-0:0,n.units[n.units.length-1])}function g2(e){let t,n={};return e.length>0&&"object"===typeof e[e.length-1]?(n=e[e.length-1],t=Array.from(e).slice(0,e.length-1)):t=Array.from(e),[n,t]}let y2;const b2=new Map;class v2{constructor(e){const t=e.zone||SJ.defaultZone;let n=e.invalid||(Number.isNaN(e.ts)?new NJ("invalid input"):null)||(t.isValid?null:X1(t));this.ts=zJ(e.ts)?SJ.now():e.ts;let r=null,s=null;if(!n){if(e.old&&e.old.ts===this.ts&&e.old.zone.equals(t))[r,s]=[e.old.c,e.old.o];else{const a=BJ(e.o)&&!e.old?e.o:t.offset(this.ts);r=e2(this.ts,a),n=Number.isNaN(r.year)?new NJ("invalid input"):null,r=n?null:r,s=n?null:a}}this._zone=t,this.loc=e.loc||aJ.create(),this.invalid=n,this.weekData=null,this.localWeekData=null,this.c=r,this.o=s,this.isLuxonDateTime=!0}static now(){return new v2({})}static local(){const[e,t]=g2(arguments),[n,r,s,a,i,o,l]=t;return f2({year:n,month:r,day:s,hour:a,minute:i,second:o,millisecond:l},e)}static utc(){const[e,t]=g2(arguments),[n,r,s,a,i,o,l]=t;return e.zone=oJ.utcInstance,f2({year:n,month:r,day:s,hour:a,minute:i,second:o,millisecond:l},e)}static fromJSDate(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=(r=e,"[object Date]"===Object.prototype.toString.call(r)?e.valueOf():NaN);var r;if(Number.isNaN(n))return v2.invalid("invalid input");const s=uJ(t.zone,SJ.defaultZone);return s.isValid?new v2({ts:n,zone:s,loc:aJ.fromObject(t)}):v2.invalid(X1(s))}static fromMillis(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(BJ(e))return e<-K1||e>K1?v2.invalid("Timestamp out of range"):new v2({ts:e,zone:uJ(t.zone,SJ.defaultZone),loc:aJ.fromObject(t)});throw new hZ(`fromMillis requires a numerical input, but received a ${typeof e} with value ${e}`)}static fromSeconds(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(BJ(e))return new v2({ts:1e3*e,zone:uJ(t.zone,SJ.defaultZone),loc:aJ.fromObject(t)});throw new hZ("fromSeconds requires a numerical input")}static fromObject(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};e=e||{};const n=uJ(t.zone,SJ.defaultZone);if(!n.isValid)return v2.invalid(X1(n));const r=aJ.fromObject(t),s=u0(e,p2),{minDaysInFirstWeek:a,startOfWeek:i}=MJ(s,r),o=SJ.now(),l=zJ(t.specificOffset)?n.offset(o):t.specificOffset,u=!zJ(s.ordinal),c=!zJ(s.year),h=!zJ(s.month)||!zJ(s.day),d=c||h,p=s.weekYear||s.weekNumber;if((d||u)&&p)throw new uZ("Can't mix weekYear/weekNumber units with year/month/day or ordinals");if(h&&u)throw new uZ("Can't mix ordinal dates with month/day");const f=p||s.weekday&&!d;let m,g,y=e2(o,l);f?(m=h2,g=l2,y=DJ(y,a,i)):u?(m=d2,g=u2,y=_J(y)):(m=c2,g=o2);let b=!1;for(const I of m){zJ(s[I])?s[I]=b?g[I]:y[I]:b=!0}const v=f?function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:4,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;const r=VJ(e.weekYear),s=qJ(e.weekNumber,1,s0(e.weekYear,t,n)),a=qJ(e.weekday,1,7);return r?s?!a&&TJ("weekday",e.weekday):TJ("week",e.weekNumber):TJ("weekYear",e.weekYear)}(s,a,i):u?function(e){const t=VJ(e.year),n=qJ(e.ordinal,1,e0(e.year));return t?!n&&TJ("ordinal",e.ordinal):TJ("year",e.year)}(s):LJ(s),x=v||PJ(s);if(x)return v2.invalid(x);const w=f?OJ(s,a,i):u?FJ(s):s,[k,S]=t2(w,l,n),N=new v2({ts:k,zone:n,o:S,loc:r});return s.weekday&&d&&e.weekday!==N.weekday?v2.invalid("mismatched weekday",`you can't specify both a weekday of ${s.weekday} and a date of ${N.toISO()}`):N.isValid?N:v2.invalid(N.invalid)}static fromISO(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const[n,r]=function(e){return R0(e,[r1,o1],[s1,l1],[a1,u1],[i1,c1])}(e);return r2(n,r,t,"ISO 8601",e)}static fromRFC2822(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const[n,r]=function(e){return R0(function(e){return e.replace(/\([^()]*\)|[\n\t]/g," ").replace(/(\s\s+)/g," ").trim()}(e),[Q0,Y0])}(e);return r2(n,r,t,"RFC 2822",e)}static fromHTTP(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const[n,r]=function(e){return R0(e,[Z0,t1],[J0,t1],[e1,n1])}(e);return r2(n,r,t,"HTTP",t)}static fromFormat(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(zJ(e)||zJ(t))throw new hZ("fromFormat requires an input string and a format");const{locale:r=null,numberingSystem:s=null}=n,a=aJ.fromOpts({locale:r,numberingSystem:s,defaultToEN:!0}),[i,o,l,u]=function(e,t,n){const{result:r,zone:s,specificOffset:a,invalidReason:i}=G1(e,t,n);return[r,s,a,i]}(a,e,t);return u?v2.invalid(u):r2(i,o,n,`format ${t}`,e,l)}static fromString(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return v2.fromFormat(e,t,n)}static fromSQL(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const[n,r]=function(e){return R0(e,[d1,o1],[p1,f1])}(e);return r2(n,r,t,"SQL",e)}static invalid(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(!e)throw new hZ("need to specify a reason the DateTime is invalid");const n=e instanceof NJ?e:new NJ(e,t);if(SJ.throwOnInvalid)throw new iZ(n);return new v2({invalid:n})}static isDateTime(e){return e&&e.isLuxonDateTime||!1}static parseFormatForOpts(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=H1(e,aJ.fromObject(t));return n?n.map((e=>e?e.val:null)).join(""):null}static expandFormat(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return U1(T0.parseFormat(e),aJ.fromObject(t)).map((e=>e.val)).join("")}static resetCache(){y2=void 0,b2.clear()}get(e){return this[e]}get isValid(){return null===this.invalid}get invalidReason(){return this.invalid?this.invalid.reason:null}get invalidExplanation(){return this.invalid?this.invalid.explanation:null}get locale(){return this.isValid?this.loc.locale:null}get numberingSystem(){return this.isValid?this.loc.numberingSystem:null}get outputCalendar(){return this.isValid?this.loc.outputCalendar:null}get zone(){return this._zone}get zoneName(){return this.isValid?this.zone.name:null}get year(){return this.isValid?this.c.year:NaN}get quarter(){return this.isValid?Math.ceil(this.c.month/3):NaN}get month(){return this.isValid?this.c.month:NaN}get day(){return this.isValid?this.c.day:NaN}get hour(){return this.isValid?this.c.hour:NaN}get minute(){return this.isValid?this.c.minute:NaN}get second(){return this.isValid?this.c.second:NaN}get millisecond(){return this.isValid?this.c.millisecond:NaN}get weekYear(){return this.isValid?Q1(this).weekYear:NaN}get weekNumber(){return this.isValid?Q1(this).weekNumber:NaN}get weekday(){return this.isValid?Q1(this).weekday:NaN}get isWeekend(){return this.isValid&&this.loc.getWeekendDays().includes(this.weekday)}get localWeekday(){return this.isValid?Y1(this).weekday:NaN}get localWeekNumber(){return this.isValid?Y1(this).weekNumber:NaN}get localWeekYear(){return this.isValid?Y1(this).weekYear:NaN}get ordinal(){return this.isValid?_J(this.c).ordinal:NaN}get monthShort(){return this.isValid?E1.months("short",{locObj:this.loc})[this.month-1]:null}get monthLong(){return this.isValid?E1.months("long",{locObj:this.loc})[this.month-1]:null}get weekdayShort(){return this.isValid?E1.weekdays("short",{locObj:this.loc})[this.weekday-1]:null}get weekdayLong(){return this.isValid?E1.weekdays("long",{locObj:this.loc})[this.weekday-1]:null}get offset(){return this.isValid?+this.o:NaN}get offsetNameShort(){return this.isValid?this.zone.offsetName(this.ts,{format:"short",locale:this.locale}):null}get offsetNameLong(){return this.isValid?this.zone.offsetName(this.ts,{format:"long",locale:this.locale}):null}get isOffsetFixed(){return this.isValid?this.zone.isUniversal:null}get isInDST(){return!this.isOffsetFixed&&(this.offset>this.set({month:1,day:1}).offset||this.offset>this.set({month:5}).offset)}getPossibleOffsets(){if(!this.isValid||this.isOffsetFixed)return[this];const e=864e5,t=6e4,n=n0(this.c),r=this.zone.offset(n-e),s=this.zone.offset(n+e),a=this.zone.offset(n-r*t),i=this.zone.offset(n-s*t);if(a===i)return[this];const o=n-a*t,l=n-i*t,u=e2(o,a),c=e2(l,i);return u.hour===c.hour&&u.minute===c.minute&&u.second===c.second&&u.millisecond===c.millisecond?[Z1(this,{ts:o}),Z1(this,{ts:l})]:[this]}get isInLeapYear(){return JJ(this.year)}get daysInMonth(){return t0(this.year,this.month)}get daysInYear(){return this.isValid?e0(this.year):NaN}get weeksInWeekYear(){return this.isValid?s0(this.weekYear):NaN}get weeksInLocalWeekYear(){return this.isValid?s0(this.localWeekYear,this.loc.getMinDaysInFirstWeek(),this.loc.getStartOfWeek()):NaN}resolvedLocaleOptions(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{locale:t,numberingSystem:n,calendar:r}=T0.create(this.loc.clone(e),e).resolvedOptions(this);return{locale:t,numberingSystem:n,outputCalendar:r}}toUTC(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return this.setZone(oJ.instance(e),t)}toLocal(){return this.setZone(SJ.defaultZone)}setZone(e){let{keepLocalTime:t=!1,keepCalendarTime:n=!1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if((e=uJ(e,SJ.defaultZone)).equals(this.zone))return this;if(e.isValid){let r=this.ts;if(t||n){const t=e.offset(this.ts),n=this.toObject();[r]=t2(n,t,e)}return Z1(this,{ts:r,zone:e})}return v2.invalid(X1(e))}reconfigure(){let{locale:e,numberingSystem:t,outputCalendar:n}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return Z1(this,{loc:this.loc.clone({locale:e,numberingSystem:t,outputCalendar:n})})}setLocale(e){return this.reconfigure({locale:e})}set(e){if(!this.isValid)return this;const t=u0(e,p2),{minDaysInFirstWeek:n,startOfWeek:r}=MJ(t,this.loc),s=!zJ(t.weekYear)||!zJ(t.weekNumber)||!zJ(t.weekday),a=!zJ(t.ordinal),i=!zJ(t.year),o=!zJ(t.month)||!zJ(t.day),l=i||o,u=t.weekYear||t.weekNumber;if((l||a)&&u)throw new uZ("Can't mix weekYear/weekNumber units with year/month/day or ordinals");if(o&&a)throw new uZ("Can't mix ordinal dates with month/day");let c;s?c=OJ({...DJ(this.c,n,r),...t},n,r):zJ(t.ordinal)?(c={...this.toObject(),...t},zJ(t.day)&&(c.day=Math.min(t0(c.year,c.month),c.day))):c=FJ({..._J(this.c),...t});const[h,d]=t2(c,this.o,this.zone);return Z1(this,{ts:h,o:d})}plus(e){if(!this.isValid)return this;return Z1(this,n2(this,C1.fromDurationLike(e)))}minus(e){if(!this.isValid)return this;return Z1(this,n2(this,C1.fromDurationLike(e).negate()))}startOf(e){let{useLocaleWeeks:t=!1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!this.isValid)return this;const n={},r=C1.normalizeUnit(e);switch(r){case"years":n.month=1;case"quarters":case"months":n.day=1;case"weeks":case"days":n.hour=0;case"hours":n.minute=0;case"minutes":n.second=0;case"seconds":n.millisecond=0}if("weeks"===r)if(t){const e=this.loc.getStartOfWeek(),{weekday:t}=this;t<e&&(n.weekNumber=this.weekNumber-1),n.weekday=e}else n.weekday=1;if("quarters"===r){const e=Math.ceil(this.month/3);n.month=3*(e-1)+1}return this.set(n)}endOf(e,t){return this.isValid?this.plus({[e]:1}).startOf(e,t).minus(1):this}toFormat(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return this.isValid?T0.create(this.loc.redefaultToEN(t)).formatDateTimeFromString(this,e):q1}toLocaleString(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:gZ,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return this.isValid?T0.create(this.loc.clone(t),e).formatDateTime(this):q1}toLocaleParts(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return this.isValid?T0.create(this.loc.clone(e),e).formatDateTimeParts(this):[]}toISO(){let{format:e="extended",suppressSeconds:t=!1,suppressMilliseconds:n=!1,includeOffset:r=!0,extendedZone:s=!1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(!this.isValid)return null;const a="extended"===e;let i=a2(this,a);return i+="T",i+=i2(this,a,t,n,r,s),i}toISODate(){let{format:e="extended"}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return this.isValid?a2(this,"extended"===e):null}toISOWeekDate(){return s2(this,"kkkk-'W'WW-c")}toISOTime(){let{suppressMilliseconds:e=!1,suppressSeconds:t=!1,includeOffset:n=!0,includePrefix:r=!1,extendedZone:s=!1,format:a="extended"}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return this.isValid?(r?"T":"")+i2(this,"extended"===a,t,e,n,s):null}toRFC2822(){return s2(this,"EEE, dd LLL yyyy HH:mm:ss ZZZ",!1)}toHTTP(){return s2(this.toUTC(),"EEE, dd LLL yyyy HH:mm:ss 'GMT'")}toSQLDate(){return this.isValid?a2(this,!0):null}toSQLTime(){let{includeOffset:e=!0,includeZone:t=!1,includeOffsetSpace:n=!0}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r="HH:mm:ss.SSS";return(t||e)&&(n&&(r+=" "),t?r+="z":e&&(r+="ZZ")),s2(this,r,!0)}toSQL(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return this.isValid?`${this.toSQLDate()} ${this.toSQLTime(e)}`:null}toString(){return this.isValid?this.toISO():q1}[Symbol.for("nodejs.util.inspect.custom")](){return this.isValid?`DateTime { ts: ${this.toISO()}, zone: ${this.zone.name}, locale: ${this.locale} }`:`DateTime { Invalid, reason: ${this.invalidReason} }`}valueOf(){return this.toMillis()}toMillis(){return this.isValid?this.ts:NaN}toSeconds(){return this.isValid?this.ts/1e3:NaN}toUnixInteger(){return this.isValid?Math.floor(this.ts/1e3):NaN}toJSON(){return this.toISO()}toBSON(){return this.toJSDate()}toObject(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(!this.isValid)return{};const t={...this.c};return e.includeConfig&&(t.outputCalendar=this.outputCalendar,t.numberingSystem=this.loc.numberingSystem,t.locale=this.loc.locale),t}toJSDate(){return new Date(this.isValid?this.ts:NaN)}diff(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"milliseconds",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.isValid||!e.isValid)return C1.invalid("created by diffing an invalid DateTime");const r={locale:this.locale,numberingSystem:this.numberingSystem,...n},s=(o=t,Array.isArray(o)?o:[o]).map(C1.normalizeUnit),a=e.valueOf()>this.valueOf(),i=R1(a?this:e,a?e:this,s,r);var o;return a?i.negate():i}diffNow(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"milliseconds",t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return this.diff(v2.now(),e,t)}until(e){return this.isValid?A1.fromDateTimes(this,e):this}hasSame(e,t,n){if(!this.isValid)return!1;const r=e.valueOf(),s=this.setZone(e.zone,{keepLocalTime:!0});return s.startOf(t,n)<=r&&r<=s.endOf(t,n)}equals(e){return this.isValid&&e.isValid&&this.valueOf()===e.valueOf()&&this.zone.equals(e.zone)&&this.loc.equals(e.loc)}toRelative(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(!this.isValid)return null;const t=e.base||v2.fromObject({},{zone:this.zone}),n=e.padding?this<t?-e.padding:e.padding:0;let r=["years","months","days","hours","minutes","seconds"],s=e.unit;return Array.isArray(e.unit)&&(r=e.unit,s=void 0),m2(t,this.plus(n),{...e,numeric:"always",units:r,unit:s})}toRelativeCalendar(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return this.isValid?m2(e.base||v2.fromObject({},{zone:this.zone}),this,{...e,numeric:"auto",units:["years","months","days"],calendary:!0}):null}static min(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];if(!t.every(v2.isDateTime))throw new hZ("min requires all arguments be DateTimes");return jJ(t,(e=>e.valueOf()),Math.min)}static max(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];if(!t.every(v2.isDateTime))throw new hZ("max requires all arguments be DateTimes");return jJ(t,(e=>e.valueOf()),Math.max)}static fromFormatExplain(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const{locale:r=null,numberingSystem:s=null}=n;return G1(aJ.fromOpts({locale:r,numberingSystem:s,defaultToEN:!0}),e,t)}static fromStringExplain(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return v2.fromFormatExplain(e,t,n)}static buildFormatParser(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{locale:n=null,numberingSystem:r=null}=t,s=aJ.fromOpts({locale:n,numberingSystem:r,defaultToEN:!0});return new j1(s,e)}static fromFormatParser(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(zJ(e)||zJ(t))throw new hZ("fromFormatParser requires an input string and a format parser");const{locale:r=null,numberingSystem:s=null}=n,a=aJ.fromOpts({locale:r,numberingSystem:s,defaultToEN:!0});if(!a.equals(t.locale))throw new hZ(`fromFormatParser called with a locale of ${a}, but the format parser was created for ${t.locale}`);const{result:i,zone:o,specificOffset:l,invalidReason:u}=t.explainFromTokens(e);return u?v2.invalid(u):r2(i,o,n,`format ${t.format}`,e,l)}static get DATE_SHORT(){return gZ}static get DATE_MED(){return yZ}static get DATE_MED_WITH_WEEKDAY(){return bZ}static get DATE_FULL(){return vZ}static get DATE_HUGE(){return xZ}static get TIME_SIMPLE(){return wZ}static get TIME_WITH_SECONDS(){return kZ}static get TIME_WITH_SHORT_OFFSET(){return SZ}static get TIME_WITH_LONG_OFFSET(){return NZ}static get TIME_24_SIMPLE(){return IZ}static get TIME_24_WITH_SECONDS(){return CZ}static get TIME_24_WITH_SHORT_OFFSET(){return TZ}static get TIME_24_WITH_LONG_OFFSET(){return AZ}static get DATETIME_SHORT(){return EZ}static get DATETIME_SHORT_WITH_SECONDS(){return $Z}static get DATETIME_MED(){return RZ}static get DATETIME_MED_WITH_SECONDS(){return DZ}static get DATETIME_MED_WITH_WEEKDAY(){return OZ}static get DATETIME_FULL(){return _Z}static get DATETIME_FULL_WITH_SECONDS(){return FZ}static get DATETIME_HUGE(){return MZ}static get DATETIME_HUGE_WITH_SECONDS(){return LZ}}function x2(e){if(v2.isDateTime(e))return e;if(e&&e.valueOf&&BJ(e.valueOf()))return v2.fromJSDate(e);if(e&&"object"===typeof e)return v2.fromObject(e);throw new hZ(`Unknown datetime argument: ${e}, of type ${typeof e}`)}function w2(){const[e,t]=(0,T.useState)(""),[n,r]=(0,T.useState)(""),{setDataset:s}=OU();return(0,tr.jsxs)("div",{className:"space-y-4 p-4 w-full bg-gray-900 rounded-md border border-gray-700",children:[(0,tr.jsxs)("label",{className:"block text-sm font-medium text-gray-300",children:["Upload ",(0,tr.jsx)("code",{children:"MyActivity.html"})," file:"]}),(0,tr.jsx)("input",{type:"file",accept:".html",onChange:async e=>{var n;t(""),r("");const a=null===(n=e.target.files)||void 0===n?void 0:n[0];if(a)try{const e=function(e){const t=(new DOMParser).parseFromString(e,"text/html"),n=Array.from(t.querySelectorAll("div.content-cell.mdl-typography--body-1")).filter((e=>e.textContent.includes("Searched for\xa0"))),r=Array.from(t.querySelectorAll("div.content-cell.mdl-typography--caption")),s=[];return n.forEach(((e,t)=>{const n=e.querySelector("a"),a=(null===n||void 0===n?void 0:n.textContent.trim())||"";let i="",o=!1;for(let r of e.childNodes)if(o||r!==n){if(o&&r.nodeType===Node.TEXT_NODE){const e=r.nodeValue.trim();if(e){i=e;break}}}else o=!0;let l=null;if(i){const e=i.replace(/\s+/g," ").replace(/\s[A-Z]{2,4}$/,""),t=v2.fromFormat(e,"LLL d, yyyy, h:mm:ss a");t.isValid?l=t.toISO():(console.warn("Failed to parse timestamp:",i),l=null)}const u=sZ.find((e=>"12"===e.id)),c=r[t];let h="",d="";if(c){const e=c.querySelector('a[href*="maps"]');if(e){const t=new URL(e.href).searchParams.get("center");t&&([h,d]=t.split(","))}}s.push({id:void 0,category:u,query:a,timestamp:l,coords:{lat:h,lon:d}})})),s}(await a.text());if(0===e.length)return void t("\u26a0\ufe0f No valid search records found in the file.");await(async e=>{try{const t=await nZ();await t.clear(rZ);const n=t.transaction(rZ,"readwrite"),a=n.objectStore(rZ);for(let r of e){const{id:e,...t}=r,n=await a.add(t);r.id=n}await n.done,console.log(e[0]),s({source:"user",label:"Your Google History",records:e}),r(`\u2705 Stored ${e.length} search entries.`);const i=prompt("Name this dataset (e.g. 'Session 1', 'May Upload'):");if(null!==i&&void 0!==i&&i.trim()){const t=await nZ();await t.put("savedDatasets",{id:`${Date.now()}-${Math.random().toString(36).slice(2)}`,name:i.trim(),records:e,date:(new Date).toISOString()})}}catch($9){console.error("DB Error:",$9),t("\u26a0\ufe0f Failed to store data in IndexedDB.")}})(e)}catch($9){console.error($9),t("\u26a0\ufe0f Failed to parse or store the uploaded file.")}else t("\u26a0\ufe0f No file selected.")},className:"w-full file:py-2 file:px-4 file:rounded file:border-0 file:text-sm file:font-semibold file:bg-blue-600 file:text-white hover:file:bg-blue-700 text-gray-300"}),e&&(0,tr.jsx)("p",{className:"text-red-500 text-sm",children:e}),n&&(0,tr.jsx)("p",{className:"text-green-500 text-sm",children:n}),(0,tr.jsx)("p",{className:"text-xs text-gray-400",children:'Only Google Takeout "My Activity" HTML files are supported.'})]})}const k2=e=>e.replace(/([a-z0-9])([A-Z])/g,"$1-$2").toLowerCase(),S2=e=>{const t=(e=>e.replace(/^([A-Z])|[\s-_]+(\w)/g,((e,t,n)=>n?n.toUpperCase():t.toLowerCase())))(e);return t.charAt(0).toUpperCase()+t.slice(1)},N2=function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return t.filter(((e,t,n)=>Boolean(e)&&""!==e.trim()&&n.indexOf(e)===t)).join(" ").trim()},I2=e=>{for(const t in e)if(t.startsWith("aria-")||"role"===t||"title"===t)return!0};var C2={xmlns:"http://www.w3.org/2000/svg",width:24,height:24,viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:2,strokeLinecap:"round",strokeLinejoin:"round"};const T2=(0,T.forwardRef)(((e,t)=>{let{color:n="currentColor",size:r=24,strokeWidth:s=2,absoluteStrokeWidth:a,className:i="",children:o,iconNode:l,...u}=e;return(0,T.createElement)("svg",{ref:t,...C2,width:r,height:r,stroke:n,strokeWidth:a?24*Number(s)/Number(r):s,className:N2("lucide",i),...!o&&!I2(u)&&{"aria-hidden":"true"},...u},[...l.map((e=>{let[t,n]=e;return(0,T.createElement)(t,n)})),...Array.isArray(o)?o:[o]])})),A2=(e,t)=>{const n=(0,T.forwardRef)(((n,r)=>{let{className:s,...a}=n;return(0,T.createElement)(T2,{ref:r,iconNode:t,className:N2(`lucide-${k2(S2(e))}`,`lucide-${e}`,s),...a})}));return n.displayName=S2(e),n},E2=A2("pencil",[["path",{d:"M21.174 6.812a1 1 0 0 0-3.986-3.987L3.842 16.174a2 2 0 0 0-.5.83l-1.321 4.352a.5.5 0 0 0 .623.622l4.353-1.32a2 2 0 0 0 .83-.497z",key:"1a8usu"}],["path",{d:"m15 5 4 4",key:"1mk7zo"}]]),$2=e=>{let{value:t,onChange:n,label:r="Category",className:s="",noLabel:a=!1}=e;const[i,o]=(0,T.useState)(!1),[l,u]=(0,T.useState)(0),c=(0,T.useRef)(),h=sZ.find((e=>e.id===t));(0,T.useEffect)((()=>{const e=e=>{c.current&&!c.current.contains(e.target)&&o(!1)};return document.addEventListener("mousedown",e),()=>document.removeEventListener("mousedown",e)}),[]),(0,T.useEffect)((()=>{if(i){const e=sZ.findIndex((e=>e.id===t));u(-1!==e?e:0),document.body.style.overflow="hidden"}else document.body.style.overflow="";return()=>{document.body.style.overflow=""}}),[i,t]);return(0,tr.jsxs)("div",{className:`relative ${s}`,ref:c,children:[!a&&(0,tr.jsx)("label",{className:"text-sm font-medium mb-1 block",children:r}),(0,tr.jsxs)("button",{onClick:()=>o(!i),onKeyDown:e=>{if(i)if("ArrowDown"===e.key)e.preventDefault(),u((e=>(e+1)%sZ.length));else if("ArrowUp"===e.key)e.preventDefault(),u((e=>(e-1+sZ.length)%sZ.length));else if("Enter"===e.key){e.preventDefault();const t=sZ[l];t&&(n(t.id),o(!1))}else"Escape"===e.key&&o(!1)},className:"w-full pr-2 pl-3 py-2 bg-gray-900 border border-gray-700 rounded-md text-left flex items-center gap-2 text-sm text-white hover:border-blue-500 focus:outline-none focus:ring-2 focus:ring-blue-500",children:[(0,tr.jsx)("span",{className:"truncate flex-1",children:(null===h||void 0===h?void 0:h.name)||"Select category"}),(0,tr.jsx)(E2,{className:"w-4 h-4 opacity-70 hover:opacity-100 transition-opacity"})]}),(0,tr.jsx)("div",{className:"absolute mt-1 w-full z-50 bg-gray-800 border border-gray-700 rounded-md shadow-lg max-h-72 overflow-y-auto custom-scrollbar text-sm transition-all duration-200 origin-top "+(i?"scale-100 opacity-100":"scale-95 opacity-0 pointer-events-none"),children:sZ.map(((e,t)=>(0,tr.jsxs)("div",{onClick:()=>{n(e.id),o(!1)},onMouseEnter:()=>u(t),className:"cursor-pointer px-3 py-2 flex items-center gap-2 text-white "+(l===t?"bg-gray-700":""),children:[(0,tr.jsx)("span",{className:"inline-block w-2.5 h-2.5 rounded-full",style:{backgroundColor:e.color}}),(0,tr.jsx)("span",{className:"truncate",children:e.name})]},e.id)))}),(0,tr.jsx)("style",{jsx:!0,children:"\n        .custom-scrollbar::-webkit-scrollbar {\n          width: 6px;\n        }\n\n        .custom-scrollbar::-webkit-scrollbar-track {\n          background: transparent;\n        }\n\n        .custom-scrollbar::-webkit-scrollbar-thumb {\n          background-color: rgba(255, 255, 255, 0.2);\n          border-radius: 10px;\n          transition: background-color 0.2s;\n        }\n\n        .custom-scrollbar:hover::-webkit-scrollbar-thumb {\n          background-color: rgba(255, 255, 255, 0.4);\n        }\n      "})]})};function R2(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:2;const r=[],s=Math.max(2,e-n),a=Math.min(t-1,e+n);for(let i=s;i<=a;i++)r.push(i);return s>2&&r.unshift("..."),a<t-1&&r.push("..."),r.unshift(1),t>1&&r.push(t),[...new Set(r)]}const D2=()=>{const{dataset:e,setDataset:t}=OU(),[n,r]=(0,T.useState)(1),[s,a]=(0,T.useState)(!1),i=(0,T.useRef)(null),o=(null===e||void 0===e?void 0:e.records)||[],l=Math.ceil(o.length/40),u=o.slice(40*(n-1),40*n);(0,T.useEffect)((()=>{const e=new IntersectionObserver((e=>{let[t]=e;return a(!t.isIntersecting)}),{threshold:0});return i.current&&e.observe(i.current),()=>e.disconnect()}),[]);const c=e=>{e<1||e>l||r(e)},h=40*(n-1)+1,d=Math.min(40*n,o.length);return(0,tr.jsxs)("div",{className:"mt-10",children:[(0,tr.jsx)("div",{ref:i}),(0,tr.jsx)(XU,{children:s&&(0,tr.jsx)(EY.div,{initial:{y:-30,opacity:0},animate:{y:0,opacity:1},exit:{y:-20,opacity:0},className:"fixed top-0 left-0 z-40 w-full",children:(0,tr.jsx)("div",{className:"max-w-screen-xl mx-auto px-6",children:(0,tr.jsxs)("div",{className:"mx-auto bg-[#1e1f22] px-1 py-3 border-b border-l border-r border-gray-700 text-xs sm:text-sm ",children:[(0,tr.jsxs)("div",{className:"text-green-400 font-mono mb-1 text-xl max-w-screen-xl mx-auto px-6",children:["\ud83d\udcc4 ",(null===e||void 0===e?void 0:e.label)||"Unnamed Dataset"]}),(0,tr.jsxs)("div",{className:" grid-cols-12 text-gray-400 font-mono text-xs max-w-screen-xl mx-auto pl-8 hidden md:grid",children:[(0,tr.jsx)("span",{className:"col-span-3",children:"Timestamp"}),(0,tr.jsx)("span",{className:"col-span-5",children:"Query"}),(0,tr.jsx)("span",{className:"col-span-2",children:"Category"}),(0,tr.jsx)("span",{className:"col-span-2",children:"Edit"})]})]})})})}),(0,tr.jsxs)("div",{className:"flex items-center justify-between mb-2",children:[(0,tr.jsxs)("h2",{className:"text-xl font-semibold text-white",children:["Search History (",(null===e||void 0===e?void 0:e.label)||"Unnamed Dataset",")"]}),(0,tr.jsx)(EY.button,{onClick:()=>function(e){const t=[["Timestamp","Query","Category ID","Category Name"],...e.map((e=>[new Date(e.timestamp).toISOString(),`"${e.query.replace(/"/g,'""')}"`,e.category.id,e.category.name]))].map((e=>e.join(","))).join("\n"),n=new Blob([t],{type:"text/csv;charset=utf-8;"}),r=URL.createObjectURL(n),s=document.createElement("a");s.setAttribute("href",r),s.setAttribute("download","search_dataset_export.csv"),s.click()}(o),whileHover:{scale:1.05},className:"px-3 py-1 text-sm bg-blue-700 text-white rounded shadow hover:bg-blue-500",children:"Export to CSV"})]}),(0,tr.jsxs)("div",{className:"grid grid-cols-12 text-gray-400 font-mono text-xs px-2 sticky top-[104px] z-30 bg-[#1e1f22] py-1 border-b border-gray-700",children:[(0,tr.jsx)("span",{className:"col-span-3",children:"Timestamp"}),(0,tr.jsx)("span",{className:"col-span-5",children:"Query"}),(0,tr.jsx)("span",{className:"col-span-2",children:"Category"}),(0,tr.jsx)("span",{className:"col-span-2",children:"Edit"})]}),(0,tr.jsx)("div",{className:"border border-gray-700 rounded-lg divide-y divide-gray-700",children:(0,tr.jsx)(XU,{mode:"wait",children:u.map((n=>(0,tr.jsxs)(EY.div,{initial:{opacity:0,y:10},animate:{opacity:1,y:0},exit:{opacity:0,y:10},transition:{duration:.2,ease:"easeOut"},className:"bg-gray-800 p-3 grid grid-cols-1 md:grid-cols-12 gap-y-2 md:gap-4 items-center",children:[(0,tr.jsx)("div",{className:"text-sm text-gray-400 md:col-span-3",children:new Date(n.timestamp).toLocaleString()}),(0,tr.jsx)("div",{className:"text-white text-sm md:col-span-5",children:n.query}),(0,tr.jsx)("div",{className:"md:col-span-2",children:(0,tr.jsx)("span",{className:"text-xs font-semibold px-2 py-1 rounded-full",style:{backgroundColor:n.category.color,color:"#111"},children:n.category.name})}),(0,tr.jsx)("div",{className:"md:col-span-2",children:(0,tr.jsx)($2,{noLabel:!0,value:n.category.id,onChange:r=>{const s=sZ.find((e=>e.id===r));s&&(async(n,r)=>{const s=o.map((e=>e.id===n?{...e,category:r}:e));t((e=>({...e,records:s})));const a=await nZ();if("user"===e.source){const e=await a.get("searchResults",n);e&&await a.put("searchResults",{...e,category:r})}else if("saved"===e.source){const t=(await a.getAll("savedDatasets")).find((t=>t.name===e.label));t&&await a.put("savedDatasets",{...t,records:s,date:(new Date).toISOString()})}})(n.id,s)}})})]},n.id)))})}),l>1&&(0,tr.jsxs)("div",{className:"mt-4 flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4 text-white font-mono",children:[(0,tr.jsxs)("div",{className:"text-sm text-gray-400 text-center sm:text-left",children:["Showing ",h,"\u2013",d," of ",o.length]}),(0,tr.jsx)("div",{className:"flex flex-wrap justify-center gap-2",children:R2(n,l).map(((e,t)=>"..."===e?(0,tr.jsx)("span",{className:"px-2 text-gray-500 select-none",children:"..."},t):(0,tr.jsx)(EY.button,{whileTap:{scale:.95},whileHover:{scale:1.05},onClick:()=>c(e),className:"px-3 py-1 rounded "+(e===n?"bg-blue-600 text-white font-bold":"bg-gray-700 hover:bg-blue-600"),children:e},e)))}),(0,tr.jsxs)("div",{className:"text-sm text-gray-300 flex items-center gap-2 justify-center sm:justify-end",children:["Jump to:",(0,tr.jsx)("select",{value:n,onChange:e=>{const t=Number(e.target.value);t>=1&&t<=l&&c(t)},className:"bg-gray-800 border border-gray-600 rounded px-2 py-1 text-white",children:Array.from({length:l},((e,t)=>(0,tr.jsxs)("option",{value:t+1,children:["Page ",t+1]},t+1)))})]})]})]})},O2=JSON.parse('[{"id":1,"query":"boruto staffeln alle wo","timestamp":"2023-06-21T17:13:29","category":{"id":"IAB22","name":"Shopping","color":"#ffb703"},"coords":{"lat":"","lon":""}},{"id":2,"query":"ebay kleinanzeigen","timestamp":"2023-06-21T16:53:49","category":{"id":"IAB22","name":"Shopping","color":"#ffb703"},"coords":{"lat":"","lon":""}},{"id":3,"query":"ebay","timestamp":"2023-06-21T16:53:31","category":{"id":"IAB22","name":"Shopping","color":"#ffb703"},"coords":{"lat":"","lon":""}},{"id":4,"query":"ebay posaune","timestamp":"2023-06-21T16:52:54","category":{"id":"IAB22","name":"Shopping","color":"#ffb703"},"coords":{"lat":"","lon":""}},{"id":5,"query":"posaune yamaha","timestamp":"2023-06-21T16:52:23","category":{"id":"IAB9","name":"Hobbies & Interests","color":"#3a86ff"},"coords":{"lat":"","lon":""}},{"id":6,"query":"warp punkt griefer games orb","timestamp":"2023-06-21T14:56:12","category":{"id":"IAB1","name":"Arts & Entertainment","color":"#ff4b5c"},"coords":{"lat":"","lon":""}},{"id":8,"query":"Busfahrplan Reiterweg","timestamp":"2023-06-20T20:02:46","category":{"id":"IAB20","name":"Travel","color":"#8ecae6"},"coords":{"lat":"","lon":""}},{"id":9,"query":"Ghostsitter Staffel 14","timestamp":"2023-06-20T17:21:53","category":{"id":"IAB1","name":"Arts & Entertainment","color":"#ff4b5c"},"coords":{"lat":"","lon":""}},{"id":10,"query":"Wann kommt Ghostsitter Staffel 13","timestamp":"2023-06-20T17:21:35","category":{"id":"IAB1","name":"Arts & Entertainment","color":"#ff4b5c"},"coords":{"lat":"","lon":""}},{"id":11,"query":"wie viele ghostsitter staffeln gibt es","timestamp":"2023-06-20T17:20:11","category":{"id":"IAB1","name":"Arts & Entertainment","color":"#ff4b5c"},"coords":{"lat":"","lon":""}},{"id":13,"query":"sch\xfctze eigenschaften","timestamp":"2023-06-13T11:10:20","category":{"id":"IAB9","name":"Hobbies & Interests","color":"#3a86ff"},"coords":{"lat":"","lon":""}},{"id":14,"query":"skorpion eigenschaften","timestamp":"2023-06-13T11:07:18","category":{"id":"IAB1","name":"Arts & Entertainment","color":"#ff4b5c"},"coords":{"lat":"","lon":""}},{"id":16,"query":"ab wie vielen abonnenten auf youtube bekommt man geld","timestamp":"2023-05-28T20:15:39","category":{"id":"IAB1","name":"Arts & Entertainment","color":"#ff4b5c"},"coords":{"lat":"","lon":""}},{"id":17,"query":"unbreaking minecraft deutsch","timestamp":"2023-05-28T10:51:27","category":{"id":"IAB1","name":"Arts & Entertainment","color":"#ff4b5c"},"coords":{"lat":"","lon":""}},{"id":18,"query":"NaT","timestamp":"NaT","category":{"id":"IAB1","name":"Arts & Entertainment","color":"#ff4b5c"},"coords":{"lat":"","lon":""}},{"id":19,"query":"erz\xe4hl mir einen Witz zum wegschmei\xdfen","timestamp":"2023-05-26T18:24:28","category":{"id":"IAB1","name":"Arts & Entertainment","color":"#ff4b5c"},"coords":{"lat":"","lon":""}},{"id":20,"query":"erz\xe4hl mir einen Witz","timestamp":"2023-05-26T18:23:36","category":{"id":"IAB1","name":"Arts & Entertainment","color":"#ff4b5c"},"coords":{"lat":"","lon":""}},{"id":21,"query":"wann und wie kann man sich f\xfcr Ninja Warrior kids 2023 bewerben","timestamp":"2023-05-26T12:27:57","category":{"id":"IAB17","name":"Sports","color":"#8338ec"},"coords":{"lat":"","lon":""}},{"id":22,"query":"ninja warrior kids 2023 anmelden","timestamp":"2023-05-26T12:26:19","category":{"id":"IAB17","name":"Sports","color":"#8338ec"},"coords":{"lat":"","lon":""}},{"id":23,"query":"ninja warrior bewerbung voraussetzungen","timestamp":"2023-05-26T12:25:27","category":{"id":"IAB1","name":"Arts & Entertainment","color":"#ff4b5c"},"coords":{"lat":"","lon":""}},{"id":24,"query":"ninja warrior kids 2022","timestamp":"2023-05-26T12:23:08","category":{"id":"IAB17","name":"Sports","color":"#8338ec"},"coords":{"lat":"","lon":""}},{"id":25,"query":"wie lange sollte man baby mollys von den anderen fischen vernhalten","timestamp":"2023-05-26T11:46:42","category":{"id":"IAB1","name":"Arts & Entertainment","color":"#ff4b5c"},"coords":{"lat":"","lon":""}},{"id":26,"query":"ab wann steht bei baby mollys das geschlecht","timestamp":"2023-05-26T11:41:56","category":{"id":"IAB1","name":"Arts & Entertainment","color":"#ff4b5c"},"coords":{"lat":"","lon":""}},{"id":27,"query":"ab wann steht das geschlecht beim baby fest","timestamp":"2023-05-26T11:41:21","category":{"id":"IAB1","name":"Arts & Entertainment","color":"#ff4b5c"},"coords":{"lat":"","lon":""}},{"id":28,"query":"H\xfchner im Garten halten \u2013 Diese Vor\xfcberlegungen sind wichtig","timestamp":"2023-05-26T15:29:32","category":{"id":"IAB1","name":"Arts & Entertainment","color":"#ff4b5c"},"coords":{"lat":"","lon":""}},{"id":29,"query":"h\xfchner im garten ","timestamp":"2023-05-26T15:28:03","category":{"id":"IAB22","name":"Shopping","color":"#ffb703"},"coords":{"lat":"","lon":""}},{"id":30,"query":"ist noob das gegenteil von pro","timestamp":"2023-05-26T14:30:26","category":{"id":"IAB1","name":"Arts & Entertainment","color":"#ff4b5c"},"coords":{"lat":"","lon":""}},{"id":31,"query":"was ist das Gegenteil von pro","timestamp":"2023-05-26T14:29:38","category":{"id":"IAB1","name":"Arts & Entertainment","color":"#ff4b5c"},"coords":{"lat":"","lon":""}},{"id":32,"query":"NaT","timestamp":"NaT","category":{"id":"IAB1","name":"Arts & Entertainment","color":"#ff4b5c"},"coords":{"lat":"","lon":""}},{"id":33,"query":"sind ballaststoffe gut","timestamp":"2023-04-21T21:16:40","category":{"id":"IAB1","name":"Arts & Entertainment","color":"#ff4b5c"},"coords":{"lat":"","lon":""}},{"id":34,"query":"wie hei\xdft es der die das nutella","timestamp":"2023-04-21T19:02:09","category":{"id":"IAB1","name":"Arts & Entertainment","color":"#ff4b5c"},"coords":{"lat":"","lon":""}},{"id":35,"query":"NaT","timestamp":"NaT","category":{"id":"IAB1","name":"Arts & Entertainment","color":"#ff4b5c"},"coords":{"lat":"","lon":""}},{"id":36,"query":"akinator","timestamp":"2023-03-23T08:09:17","category":{"id":"IAB8","name":"Food & Drink","color":"#ff6f61"},"coords":{"lat":"","lon":""}},{"id":37,"query":"NaT","timestamp":"NaT","category":{"id":"IAB1","name":"Arts & Entertainment","color":"#ff4b5c"},"coords":{"lat":"","lon":""}},{"id":38,"query":"Harry Styles Watermelon Sugar","timestamp":"2023-03-22T20:19:55","category":{"id":"IAB8","name":"Food & Drink","color":"#ff6f61"},"coords":{"lat":"","lon":""}},{"id":39,"query":"the voice kids","timestamp":"2023-03-22T20:08:29","category":{"id":"IAB1","name":"Arts & Entertainment","color":"#ff4b5c"},"coords":{"lat":"","lon":""}},{"id":40,"query":"ps4 lenkrad","timestamp":"2023-03-22T16:40:18","category":{"id":"IAB19","name":"Technology & Computing","color":"#3cba54"},"coords":{"lat":"","lon":""}},{"id":41,"query":"deutsch-latein text \xfcbersetzer","timestamp":"2023-03-22T15:20:33","category":{"id":"IAB22","name":"Shopping","color":"#ffb703"},"coords":{"lat":"","lon":""}},{"id":42,"query":"deutsch latein","timestamp":"2023-03-22T15:20:00","category":{"id":"IAB7","name":"Health & Fitness","color":"#4ade80"},"coords":{"lat":"","lon":""}},{"id":43,"query":"Madara Uchiha","timestamp":"2023-03-22T19:45:25","category":{"id":"IAB8","name":"Food & Drink","color":"#ff6f61"},"coords":{"lat":"","lon":""}},{"id":44,"query":"Jiraiya","timestamp":"2023-03-22T19:44:41","category":{"id":"IAB8","name":"Food & Drink","color":"#ff6f61"},"coords":{"lat":"","lon":""}},{"id":45,"query":"Kushina Uzumaki","timestamp":"2023-03-22T19:43:50","category":{"id":"IAB1","name":"Arts & Entertainment","color":"#ff4b5c"},"coords":{"lat":"","lon":""}},{"id":46,"query":"Minato Namikaze","timestamp":"2023-03-22T19:42:23","category":{"id":"IAB1","name":"Arts & Entertainment","color":"#ff4b5c"},"coords":{"lat":"","lon":""}},{"id":47,"query":"NaT","timestamp":"NaT","category":{"id":"IAB1","name":"Arts & Entertainment","color":"#ff4b5c"},"coords":{"lat":"","lon":""}},{"id":48,"query":"scooter im bus mitnehmen","timestamp":"2023-01-11T06:18:31","category":{"id":"IAB20","name":"Travel","color":"#8ecae6"},"coords":{"lat":"","lon":""}},{"id":49,"query":"df man mit einem scooter bus fahren","timestamp":"2023-01-11T06:17:42","category":{"id":"IAB2","name":"Automotive","color":"#f9cb40"},"coords":{"lat":"","lon":""}}]'),_2=A2("book-open",[["path",{d:"M12 7v14",key:"1akyts"}],["path",{d:"M3 18a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h5a4 4 0 0 1 4 4 4 4 0 0 1 4-4h5a1 1 0 0 1 1 1v13a1 1 0 0 1-1 1h-6a3 3 0 0 0-3 3 3 3 0 0 0-3-3z",key:"ruj8y"}]]),F2=[{name:"OvGU Sample Dataset",data:O2,description:"Contains IAB-labeled search queries from the OvGU batch collection."}];function M2(){const{setDataset:e,dataset:t}=OU();return(0,tr.jsx)("div",{className:"grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4",children:F2.map((n=>(0,tr.jsxs)("button",{onClick:()=>((t,n)=>{e({source:"sample",label:n,records:t})})(n.data,n.name),className:"p-4 rounded-md text-white transition shadow-sm text-left border "+((null===t||void 0===t?void 0:t.label)===n.name?"bg-blue-700 border-blue-400 ring-2":"bg-gray-800 hover:bg-gray-700 border-gray-700"),children:[(0,tr.jsxs)("div",{className:"flex items-center mb-2",children:[(0,tr.jsx)(_2,{className:"h-5 w-5 text-blue-300 mr-2"}),(0,tr.jsx)("span",{className:"text-lg font-semibold",children:n.name})]}),(0,tr.jsx)("p",{className:"text-sm text-gray-400",children:n.description}),(0,tr.jsx)("div",{className:"mt-3 text-xs text-blue-300 font-mono",children:"\ud83d\udcc1 Source: Sample"}),(0,tr.jsxs)("div",{className:"text-xs text-gray-500",children:["\ud83e\uddfe ",n.data.length," records"]})]},n.name)))})}const L2=A2("save",[["path",{d:"M15.2 3a2 2 0 0 1 1.4.6l3.8 3.8a2 2 0 0 1 .6 1.4V19a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2z",key:"1c8476"}],["path",{d:"M17 21v-7a1 1 0 0 0-1-1H8a1 1 0 0 0-1 1v7",key:"1ydtos"}],["path",{d:"M7 3v4a1 1 0 0 0 1 1h7",key:"t51u73"}]]),P2=A2("clock",[["circle",{cx:"12",cy:"12",r:"10",key:"1mglay"}],["polyline",{points:"12 6 12 12 16 14",key:"68esgv"}]]);function z2(){const[e,t]=(0,T.useState)([]),{setDataset:n,dataset:r}=OU();return(0,T.useEffect)((()=>{(async()=>{try{const e=await nZ(),n=await e.getAll("savedDatasets");t(n.reverse())}catch($9){console.error("\u26a0\ufe0f Could not load saved datasets:",$9)}})()}),[]),(0,tr.jsx)("div",{className:"grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4",children:0===e.length?(0,tr.jsx)("p",{className:"text-gray-400 text-sm",children:"No saved datasets yet."}):e.map((e=>(0,tr.jsxs)("button",{onClick:()=>n({source:"saved",label:e.name,records:e.records}),className:"p-4 rounded-md text-white transition shadow-sm text-left border "+((null===r||void 0===r?void 0:r.label)===e.name?"bg-blue-700 border-blue-400 ring-2":"bg-gray-800 hover:bg-gray-700 border-gray-700"),children:[(0,tr.jsxs)("div",{className:"flex items-center mb-2",children:[(0,tr.jsx)(L2,{className:"h-5 w-5 text-green-300 mr-2"}),(0,tr.jsx)("span",{className:"text-lg font-semibold",children:e.name})]}),(0,tr.jsx)("p",{className:"text-sm text-gray-400",children:"Your custom labeled dataset. Loaded from local DB."}),(0,tr.jsx)("div",{className:"mt-3 text-xs text-green-300 font-mono",children:"\ud83d\udcc1 Source: Saved"}),(0,tr.jsxs)("div",{className:"flex items-center text-xs text-gray-500",children:[(0,tr.jsx)(P2,{className:"w-4 h-4 mr-1"}),new Date(e.date).toLocaleString()]}),(0,tr.jsxs)("div",{className:"text-xs text-gray-500",children:["\ud83e\uddfe ",e.records.length," records"]})]},e.id)))})}const B2=A2("chart-column",[["path",{d:"M3 3v16a2 2 0 0 0 2 2h16",key:"c24i48"}],["path",{d:"M18 17V9",key:"2bz60n"}],["path",{d:"M13 17V5",key:"1frdt8"}],["path",{d:"M8 17v-3",key:"17ska0"}]]),V2=A2("folder-input",[["path",{d:"M2 9V5a2 2 0 0 1 2-2h3.9a2 2 0 0 1 1.69.9l.81 1.2a2 2 0 0 0 1.67.9H20a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2v-1",key:"fm4g5t"}],["path",{d:"M2 13h10",key:"pgb2dq"}],["path",{d:"m9 16 3-3-3-3",key:"6m91ic"}]]),W2=A2("history",[["path",{d:"M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8",key:"1357e3"}],["path",{d:"M3 3v5h5",key:"1xhq8a"}],["path",{d:"M12 7v5l4 2",key:"1fdv2h"}]]);const U2=function(){const[e,t]=(0,T.useState)(!1),{dataset:n}=OU(),r=!(null===n||void 0===n||!n.label);return(0,tr.jsxs)("div",{className:"max-w-screen-xl py-6 px-6 mx-auto relative text-white",children:[(0,tr.jsx)(XU,{children:r&&(0,tr.jsx)(EY.div,{initial:{opacity:0,y:-20},animate:{opacity:1,y:0},exit:{opacity:0,y:-20},transition:{duration:.3},className:"fixed top-4 right-4 z-50",children:(0,tr.jsxs)(St,{to:"/visualise",className:"flex items-center gap-2 bg-blue-600 hover:bg-blue-500 text-white font-mono px-4 py-2 rounded-full shadow-lg shadow-blue-900 transition",children:[(0,tr.jsx)(B2,{className:"w-5 h-5"}),(0,tr.jsx)("span",{className:"hidden sm:inline",children:"Visualize Dataset"})]})})}),(0,tr.jsxs)("div",{className:"flex flex-col space-y-8",children:[(0,tr.jsxs)(EY.div,{initial:{opacity:0,y:20},animate:{opacity:1,y:0},transition:{delay:.1,duration:.3},className:"px-2 md:px-0",children:[(0,tr.jsxs)("div",{className:"flex items-center gap-2 mb-2 text-blue-300 font-bold text-lg",children:[(0,tr.jsx)(V2,{className:"w-5 h-5"}),"Sample Datasets"]}),(0,tr.jsx)(M2,{})]}),(0,tr.jsx)("div",{className:"w-full bg-gray-700 h-[1px]"}),(0,tr.jsxs)(EY.div,{initial:{opacity:0,y:20},animate:{opacity:1,y:0},transition:{delay:.2,duration:.3},className:"px-2 md:px-0",children:[(0,tr.jsxs)("div",{className:"flex items-center gap-2 mb-2 text-green-300 font-bold text-lg",children:[(0,tr.jsx)(L2,{className:"w-5 h-5"}),"Saved Datasets"]}),(0,tr.jsx)(z2,{})]}),(0,tr.jsx)("div",{className:"w-full bg-gray-700 h-[1px]"}),(0,tr.jsxs)(EY.div,{layout:!0,initial:{opacity:0},animate:{opacity:1},transition:{delay:.3,duration:.3},className:"bg-gray-800 rounded-lg shadow-md overflow-hidden px-2 md:px-0",children:[(0,tr.jsx)("button",{onClick:()=>t(!e),className:"w-full text-left px-5 py-3 font-mono font-semibold bg-gray-900 hover:bg-gray-700 transition",children:(0,tr.jsxs)("div",{className:"flex items-center gap-2",children:[(0,tr.jsx)(W2,{className:"w-4 h-4 text-yellow-300"}),e?"\u25bc Use your own Google History (Hide)":"\u25b6 Use your own Google History"]})}),(0,tr.jsx)(XU,{children:e&&(0,tr.jsxs)(EY.div,{initial:{height:0,opacity:0},animate:{height:"auto",opacity:1},exit:{height:0,opacity:0},transition:{type:"spring",damping:20,stiffness:200},className:"overflow-hidden px-5 py-4 border-t border-gray-700",children:[(0,tr.jsxs)("p",{className:"text-sm text-gray-400 mb-3",children:["Download your search activity from"," ",(0,tr.jsx)("a",{href:"https://takeout.google.com",target:"_blank",rel:"noopener noreferrer",className:"underline text-blue-400",children:"Google Takeout"})," ","\\u2014 select only the ",(0,tr.jsx)("strong",{children:'"Search"'})," history in"," ",(0,tr.jsx)("strong",{children:"HTML format"}),"."]}),(0,tr.jsx)(w2,{})]},"expanded-content")})]}),(0,tr.jsx)(XU,{children:(null===n||void 0===n?void 0:n.label)&&(0,tr.jsxs)(EY.p,{initial:{opacity:0,y:6},animate:{opacity:1,y:0},exit:{opacity:0,y:6},transition:{duration:.3},className:"text-sm text-green-400 font-mono mt-2 px-2 md:px-0",children:["\\u2705 Currently selected: ",(0,tr.jsx)("span",{className:"italic",children:n.label})]})}),(0,tr.jsx)("div",{className:"px-2 md:px-0",children:(0,tr.jsx)(D2,{})})]})]})};class j2 extends Map{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:K2;if(super(),Object.defineProperties(this,{_intern:{value:new Map},_key:{value:t}}),null!=e)for(const[n,r]of e)this.set(n,r)}get(e){return super.get(G2(this,e))}has(e){return super.has(G2(this,e))}set(e,t){return super.set(H2(this,e),t)}delete(e){return super.delete(q2(this,e))}}Set;function G2(e,t){let{_intern:n,_key:r}=e;const s=r(t);return n.has(s)?n.get(s):t}function H2(e,t){let{_intern:n,_key:r}=e;const s=r(t);return n.has(s)?n.get(s):(n.set(s,t),t)}function q2(e,t){let{_intern:n,_key:r}=e;const s=r(t);return n.has(s)&&(t=n.get(s),n.delete(s)),t}function K2(e){return null!==e&&"object"===typeof e?e.valueOf():e}function X2(e){return e}function Q2(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return Y2(e,X2,X2,n)}function Y2(e,t,n,r){return function e(s,a){if(a>=r.length)return n(s);const i=new j2,o=r[a++];let l=-1;for(const t of s){const e=o(t,++l,s),n=i.get(e);n?n.push(t):i.set(e,[t])}for(const[t,n]of i)i.set(t,e(n,a));return t(i)}(e,0)}function Z2(e){return e}var J2=1e-6;function e3(e){return"translate("+e+",0)"}function t3(e){return"translate(0,"+e+")"}function n3(e){return t=>+e(t)}function r3(e,t){return t=Math.max(0,e.bandwidth()-2*t)/2,e.round()&&(t=Math.round(t)),n=>+e(n)+t}function s3(){return!this.__axis}function a3(e,t){var n=[],r=null,s=null,a=6,i=6,o=3,l="undefined"!==typeof window&&window.devicePixelRatio>1?0:.5,u=1===e||4===e?-1:1,c=4===e||2===e?"x":"y",h=1===e||3===e?e3:t3;function d(d){var p=null==r?t.ticks?t.ticks.apply(t,n):t.domain():r,f=null==s?t.tickFormat?t.tickFormat.apply(t,n):Z2:s,m=Math.max(a,0)+o,g=t.range(),y=+g[0]+l,b=+g[g.length-1]+l,v=(t.bandwidth?r3:n3)(t.copy(),l),x=d.selection?d.selection():d,w=x.selectAll(".domain").data([null]),k=x.selectAll(".tick").data(p,t).order(),S=k.exit(),N=k.enter().append("g").attr("class","tick"),I=k.select("line"),C=k.select("text");w=w.merge(w.enter().insert("path",".tick").attr("class","domain").attr("stroke","currentColor")),k=k.merge(N),I=I.merge(N.append("line").attr("stroke","currentColor").attr(c+"2",u*a)),C=C.merge(N.append("text").attr("fill","currentColor").attr(c,u*m).attr("dy",1===e?"0em":3===e?"0.71em":"0.32em")),d!==x&&(w=w.transition(d),k=k.transition(d),I=I.transition(d),C=C.transition(d),S=S.transition(d).attr("opacity",J2).attr("transform",(function(e){return isFinite(e=v(e))?h(e+l):this.getAttribute("transform")})),N.attr("opacity",J2).attr("transform",(function(e){var t=this.parentNode.__axis;return h((t&&isFinite(t=t(e))?t:v(e))+l)}))),S.remove(),w.attr("d",4===e||2===e?i?"M"+u*i+","+y+"H"+l+"V"+b+"H"+u*i:"M"+l+","+y+"V"+b:i?"M"+y+","+u*i+"V"+l+"H"+b+"V"+u*i:"M"+y+","+l+"H"+b),k.attr("opacity",1).attr("transform",(function(e){return h(v(e)+l)})),I.attr(c+"2",u*a),C.attr(c,u*m).text(f),x.filter(s3).attr("fill","none").attr("font-size",10).attr("font-family","sans-serif").attr("text-anchor",2===e?"start":4===e?"end":"middle"),x.each((function(){this.__axis=v}))}return d.scale=function(e){return arguments.length?(t=e,d):t},d.ticks=function(){return n=Array.from(arguments),d},d.tickArguments=function(e){return arguments.length?(n=null==e?[]:Array.from(e),d):n.slice()},d.tickValues=function(e){return arguments.length?(r=null==e?null:Array.from(e),d):r&&r.slice()},d.tickFormat=function(e){return arguments.length?(s=e,d):s},d.tickSize=function(e){return arguments.length?(a=i=+e,d):a},d.tickSizeInner=function(e){return arguments.length?(a=+e,d):a},d.tickSizeOuter=function(e){return arguments.length?(i=+e,d):i},d.tickPadding=function(e){return arguments.length?(o=+e,d):o},d.offset=function(e){return arguments.length?(l=+e,d):l},d}function i3(){}function o3(e){return null==e?i3:function(){return this.querySelector(e)}}function l3(){return[]}function u3(e){return null==e?l3:function(){return this.querySelectorAll(e)}}function c3(e){return function(){return null==(t=e.apply(this,arguments))?[]:Array.isArray(t)?t:Array.from(t);var t}}function h3(e){return function(){return this.matches(e)}}function d3(e){return function(t){return t.matches(e)}}var p3=Array.prototype.find;function f3(){return this.firstElementChild}var m3=Array.prototype.filter;function g3(){return Array.from(this.children)}function y3(e){return new Array(e.length)}function b3(e,t){this.ownerDocument=e.ownerDocument,this.namespaceURI=e.namespaceURI,this._next=null,this._parent=e,this.__data__=t}function v3(e,t,n,r,s,a){for(var i,o=0,l=t.length,u=a.length;o<u;++o)(i=t[o])?(i.__data__=a[o],r[o]=i):n[o]=new b3(e,a[o]);for(;o<l;++o)(i=t[o])&&(s[o]=i)}function x3(e,t,n,r,s,a,i){var o,l,u,c=new Map,h=t.length,d=a.length,p=new Array(h);for(o=0;o<h;++o)(l=t[o])&&(p[o]=u=i.call(l,l.__data__,o,t)+"",c.has(u)?s[o]=l:c.set(u,l));for(o=0;o<d;++o)u=i.call(e,a[o],o,a)+"",(l=c.get(u))?(r[o]=l,l.__data__=a[o],c.delete(u)):n[o]=new b3(e,a[o]);for(o=0;o<h;++o)(l=t[o])&&c.get(p[o])===l&&(s[o]=l)}function w3(e){return e.__data__}function k3(e){return"object"===typeof e&&"length"in e?e:Array.from(e)}function S3(e,t){return e<t?-1:e>t?1:e>=t?0:NaN}b3.prototype={constructor:b3,appendChild:function(e){return this._parent.insertBefore(e,this._next)},insertBefore:function(e,t){return this._parent.insertBefore(e,t)},querySelector:function(e){return this._parent.querySelector(e)},querySelectorAll:function(e){return this._parent.querySelectorAll(e)}};var N3="http://www.w3.org/1999/xhtml";const I3={svg:"http://www.w3.org/2000/svg",xhtml:N3,xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/"};function C3(e){var t=e+="",n=t.indexOf(":");return n>=0&&"xmlns"!==(t=e.slice(0,n))&&(e=e.slice(n+1)),I3.hasOwnProperty(t)?{space:I3[t],local:e}:e}function T3(e){return function(){this.removeAttribute(e)}}function A3(e){return function(){this.removeAttributeNS(e.space,e.local)}}function E3(e,t){return function(){this.setAttribute(e,t)}}function $3(e,t){return function(){this.setAttributeNS(e.space,e.local,t)}}function R3(e,t){return function(){var n=t.apply(this,arguments);null==n?this.removeAttribute(e):this.setAttribute(e,n)}}function D3(e,t){return function(){var n=t.apply(this,arguments);null==n?this.removeAttributeNS(e.space,e.local):this.setAttributeNS(e.space,e.local,n)}}function O3(e){return e.ownerDocument&&e.ownerDocument.defaultView||e.document&&e||e.defaultView}function _3(e){return function(){this.style.removeProperty(e)}}function F3(e,t,n){return function(){this.style.setProperty(e,t,n)}}function M3(e,t,n){return function(){var r=t.apply(this,arguments);null==r?this.style.removeProperty(e):this.style.setProperty(e,r,n)}}function L3(e,t){return e.style.getPropertyValue(t)||O3(e).getComputedStyle(e,null).getPropertyValue(t)}function P3(e){return function(){delete this[e]}}function z3(e,t){return function(){this[e]=t}}function B3(e,t){return function(){var n=t.apply(this,arguments);null==n?delete this[e]:this[e]=n}}function V3(e){return e.trim().split(/^|\s+/)}function W3(e){return e.classList||new U3(e)}function U3(e){this._node=e,this._names=V3(e.getAttribute("class")||"")}function j3(e,t){for(var n=W3(e),r=-1,s=t.length;++r<s;)n.add(t[r])}function G3(e,t){for(var n=W3(e),r=-1,s=t.length;++r<s;)n.remove(t[r])}function H3(e){return function(){j3(this,e)}}function q3(e){return function(){G3(this,e)}}function K3(e,t){return function(){(t.apply(this,arguments)?j3:G3)(this,e)}}function X3(){this.textContent=""}function Q3(e){return function(){this.textContent=e}}function Y3(e){return function(){var t=e.apply(this,arguments);this.textContent=null==t?"":t}}function Z3(){this.innerHTML=""}function J3(e){return function(){this.innerHTML=e}}function e4(e){return function(){var t=e.apply(this,arguments);this.innerHTML=null==t?"":t}}function t4(){this.nextSibling&&this.parentNode.appendChild(this)}function n4(){this.previousSibling&&this.parentNode.insertBefore(this,this.parentNode.firstChild)}function r4(e){return function(){var t=this.ownerDocument,n=this.namespaceURI;return n===N3&&t.documentElement.namespaceURI===N3?t.createElement(e):t.createElementNS(n,e)}}function s4(e){return function(){return this.ownerDocument.createElementNS(e.space,e.local)}}function a4(e){var t=C3(e);return(t.local?s4:r4)(t)}function i4(){return null}function o4(){var e=this.parentNode;e&&e.removeChild(this)}function l4(){var e=this.cloneNode(!1),t=this.parentNode;return t?t.insertBefore(e,this.nextSibling):e}function u4(){var e=this.cloneNode(!0),t=this.parentNode;return t?t.insertBefore(e,this.nextSibling):e}function c4(e){return function(){var t=this.__on;if(t){for(var n,r=0,s=-1,a=t.length;r<a;++r)n=t[r],e.type&&n.type!==e.type||n.name!==e.name?t[++s]=n:this.removeEventListener(n.type,n.listener,n.options);++s?t.length=s:delete this.__on}}}function h4(e,t,n){return function(){var r,s=this.__on,a=function(e){return function(t){e.call(this,t,this.__data__)}}(t);if(s)for(var i=0,o=s.length;i<o;++i)if((r=s[i]).type===e.type&&r.name===e.name)return this.removeEventListener(r.type,r.listener,r.options),this.addEventListener(r.type,r.listener=a,r.options=n),void(r.value=t);this.addEventListener(e.type,a,n),r={type:e.type,name:e.name,value:t,listener:a,options:n},s?s.push(r):this.__on=[r]}}function d4(e,t,n){var r=O3(e),s=r.CustomEvent;"function"===typeof s?s=new s(t,n):(s=r.document.createEvent("Event"),n?(s.initEvent(t,n.bubbles,n.cancelable),s.detail=n.detail):s.initEvent(t,!1,!1)),e.dispatchEvent(s)}function p4(e,t){return function(){return d4(this,e,t)}}function f4(e,t){return function(){return d4(this,e,t.apply(this,arguments))}}U3.prototype={add:function(e){this._names.indexOf(e)<0&&(this._names.push(e),this._node.setAttribute("class",this._names.join(" ")))},remove:function(e){var t=this._names.indexOf(e);t>=0&&(this._names.splice(t,1),this._node.setAttribute("class",this._names.join(" ")))},contains:function(e){return this._names.indexOf(e)>=0}};var m4=[null];function g4(e,t){this._groups=e,this._parents=t}function y4(){return new g4([[document.documentElement]],m4)}g4.prototype=y4.prototype={constructor:g4,select:function(e){"function"!==typeof e&&(e=o3(e));for(var t=this._groups,n=t.length,r=new Array(n),s=0;s<n;++s)for(var a,i,o=t[s],l=o.length,u=r[s]=new Array(l),c=0;c<l;++c)(a=o[c])&&(i=e.call(a,a.__data__,c,o))&&("__data__"in a&&(i.__data__=a.__data__),u[c]=i);return new g4(r,this._parents)},selectAll:function(e){e="function"===typeof e?c3(e):u3(e);for(var t=this._groups,n=t.length,r=[],s=[],a=0;a<n;++a)for(var i,o=t[a],l=o.length,u=0;u<l;++u)(i=o[u])&&(r.push(e.call(i,i.__data__,u,o)),s.push(i));return new g4(r,s)},selectChild:function(e){return this.select(null==e?f3:function(e){return function(){return p3.call(this.children,e)}}("function"===typeof e?e:d3(e)))},selectChildren:function(e){return this.selectAll(null==e?g3:function(e){return function(){return m3.call(this.children,e)}}("function"===typeof e?e:d3(e)))},filter:function(e){"function"!==typeof e&&(e=h3(e));for(var t=this._groups,n=t.length,r=new Array(n),s=0;s<n;++s)for(var a,i=t[s],o=i.length,l=r[s]=[],u=0;u<o;++u)(a=i[u])&&e.call(a,a.__data__,u,i)&&l.push(a);return new g4(r,this._parents)},data:function(e,t){if(!arguments.length)return Array.from(this,w3);var n,r=t?x3:v3,s=this._parents,a=this._groups;"function"!==typeof e&&(n=e,e=function(){return n});for(var i=a.length,o=new Array(i),l=new Array(i),u=new Array(i),c=0;c<i;++c){var h=s[c],d=a[c],p=d.length,f=k3(e.call(h,h&&h.__data__,c,s)),m=f.length,g=l[c]=new Array(m),y=o[c]=new Array(m);r(h,d,g,y,u[c]=new Array(p),f,t);for(var b,v,x=0,w=0;x<m;++x)if(b=g[x]){for(x>=w&&(w=x+1);!(v=y[w])&&++w<m;);b._next=v||null}}return(o=new g4(o,s))._enter=l,o._exit=u,o},enter:function(){return new g4(this._enter||this._groups.map(y3),this._parents)},exit:function(){return new g4(this._exit||this._groups.map(y3),this._parents)},join:function(e,t,n){var r=this.enter(),s=this,a=this.exit();return"function"===typeof e?(r=e(r))&&(r=r.selection()):r=r.append(e+""),null!=t&&(s=t(s))&&(s=s.selection()),null==n?a.remove():n(a),r&&s?r.merge(s).order():s},merge:function(e){for(var t=e.selection?e.selection():e,n=this._groups,r=t._groups,s=n.length,a=r.length,i=Math.min(s,a),o=new Array(s),l=0;l<i;++l)for(var u,c=n[l],h=r[l],d=c.length,p=o[l]=new Array(d),f=0;f<d;++f)(u=c[f]||h[f])&&(p[f]=u);for(;l<s;++l)o[l]=n[l];return new g4(o,this._parents)},selection:function(){return this},order:function(){for(var e=this._groups,t=-1,n=e.length;++t<n;)for(var r,s=e[t],a=s.length-1,i=s[a];--a>=0;)(r=s[a])&&(i&&4^r.compareDocumentPosition(i)&&i.parentNode.insertBefore(r,i),i=r);return this},sort:function(e){function t(t,n){return t&&n?e(t.__data__,n.__data__):!t-!n}e||(e=S3);for(var n=this._groups,r=n.length,s=new Array(r),a=0;a<r;++a){for(var i,o=n[a],l=o.length,u=s[a]=new Array(l),c=0;c<l;++c)(i=o[c])&&(u[c]=i);u.sort(t)}return new g4(s,this._parents).order()},call:function(){var e=arguments[0];return arguments[0]=this,e.apply(null,arguments),this},nodes:function(){return Array.from(this)},node:function(){for(var e=this._groups,t=0,n=e.length;t<n;++t)for(var r=e[t],s=0,a=r.length;s<a;++s){var i=r[s];if(i)return i}return null},size:function(){let e=0;for(const t of this)++e;return e},empty:function(){return!this.node()},each:function(e){for(var t=this._groups,n=0,r=t.length;n<r;++n)for(var s,a=t[n],i=0,o=a.length;i<o;++i)(s=a[i])&&e.call(s,s.__data__,i,a);return this},attr:function(e,t){var n=C3(e);if(arguments.length<2){var r=this.node();return n.local?r.getAttributeNS(n.space,n.local):r.getAttribute(n)}return this.each((null==t?n.local?A3:T3:"function"===typeof t?n.local?D3:R3:n.local?$3:E3)(n,t))},style:function(e,t,n){return arguments.length>1?this.each((null==t?_3:"function"===typeof t?M3:F3)(e,t,null==n?"":n)):L3(this.node(),e)},property:function(e,t){return arguments.length>1?this.each((null==t?P3:"function"===typeof t?B3:z3)(e,t)):this.node()[e]},classed:function(e,t){var n=V3(e+"");if(arguments.length<2){for(var r=W3(this.node()),s=-1,a=n.length;++s<a;)if(!r.contains(n[s]))return!1;return!0}return this.each(("function"===typeof t?K3:t?H3:q3)(n,t))},text:function(e){return arguments.length?this.each(null==e?X3:("function"===typeof e?Y3:Q3)(e)):this.node().textContent},html:function(e){return arguments.length?this.each(null==e?Z3:("function"===typeof e?e4:J3)(e)):this.node().innerHTML},raise:function(){return this.each(t4)},lower:function(){return this.each(n4)},append:function(e){var t="function"===typeof e?e:a4(e);return this.select((function(){return this.appendChild(t.apply(this,arguments))}))},insert:function(e,t){var n="function"===typeof e?e:a4(e),r=null==t?i4:"function"===typeof t?t:o3(t);return this.select((function(){return this.insertBefore(n.apply(this,arguments),r.apply(this,arguments)||null)}))},remove:function(){return this.each(o4)},clone:function(e){return this.select(e?u4:l4)},datum:function(e){return arguments.length?this.property("__data__",e):this.node().__data__},on:function(e,t,n){var r,s,a=function(e){return e.trim().split(/^|\s+/).map((function(e){var t="",n=e.indexOf(".");return n>=0&&(t=e.slice(n+1),e=e.slice(0,n)),{type:e,name:t}}))}(e+""),i=a.length;if(!(arguments.length<2)){for(o=t?h4:c4,r=0;r<i;++r)this.each(o(a[r],t,n));return this}var o=this.node().__on;if(o)for(var l,u=0,c=o.length;u<c;++u)for(r=0,l=o[u];r<i;++r)if((s=a[r]).type===l.type&&s.name===l.name)return l.value},dispatch:function(e,t){return this.each(("function"===typeof t?f4:p4)(e,t))},[Symbol.iterator]:function*(){for(var e=this._groups,t=0,n=e.length;t<n;++t)for(var r,s=e[t],a=0,i=s.length;a<i;++a)(r=s[a])&&(yield r)}};const b4=y4;var v4={value:()=>{}};function x4(){for(var e,t=0,n=arguments.length,r={};t<n;++t){if(!(e=arguments[t]+"")||e in r||/[\s.]/.test(e))throw new Error("illegal type: "+e);r[e]=[]}return new w4(r)}function w4(e){this._=e}function k4(e,t){for(var n,r=0,s=e.length;r<s;++r)if((n=e[r]).name===t)return n.value}function S4(e,t,n){for(var r=0,s=e.length;r<s;++r)if(e[r].name===t){e[r]=v4,e=e.slice(0,r).concat(e.slice(r+1));break}return null!=n&&e.push({name:t,value:n}),e}w4.prototype=x4.prototype={constructor:w4,on:function(e,t){var n,r,s=this._,a=(r=s,(e+"").trim().split(/^|\s+/).map((function(e){var t="",n=e.indexOf(".");if(n>=0&&(t=e.slice(n+1),e=e.slice(0,n)),e&&!r.hasOwnProperty(e))throw new Error("unknown type: "+e);return{type:e,name:t}}))),i=-1,o=a.length;if(!(arguments.length<2)){if(null!=t&&"function"!==typeof t)throw new Error("invalid callback: "+t);for(;++i<o;)if(n=(e=a[i]).type)s[n]=S4(s[n],e.name,t);else if(null==t)for(n in s)s[n]=S4(s[n],e.name,null);return this}for(;++i<o;)if((n=(e=a[i]).type)&&(n=k4(s[n],e.name)))return n},copy:function(){var e={},t=this._;for(var n in t)e[n]=t[n].slice();return new w4(e)},call:function(e,t){if((n=arguments.length-2)>0)for(var n,r,s=new Array(n),a=0;a<n;++a)s[a]=arguments[a+2];if(!this._.hasOwnProperty(e))throw new Error("unknown type: "+e);for(a=0,n=(r=this._[e]).length;a<n;++a)r[a].value.apply(t,s)},apply:function(e,t,n){if(!this._.hasOwnProperty(e))throw new Error("unknown type: "+e);for(var r=this._[e],s=0,a=r.length;s<a;++s)r[s].value.apply(t,n)}};const N4=x4;var I4,C4,T4=0,A4=0,E4=0,$4=0,R4=0,D4=0,O4="object"===typeof performance&&performance.now?performance:Date,_4="object"===typeof window&&window.requestAnimationFrame?window.requestAnimationFrame.bind(window):function(e){setTimeout(e,17)};function F4(){return R4||(_4(M4),R4=O4.now()+D4)}function M4(){R4=0}function L4(){this._call=this._time=this._next=null}function P4(e,t,n){var r=new L4;return r.restart(e,t,n),r}function z4(){R4=($4=O4.now())+D4,T4=A4=0;try{!function(){F4(),++T4;for(var e,t=I4;t;)(e=R4-t._time)>=0&&t._call.call(void 0,e),t=t._next;--T4}()}finally{T4=0,function(){var e,t,n=I4,r=1/0;for(;n;)n._call?(r>n._time&&(r=n._time),e=n,n=n._next):(t=n._next,n._next=null,n=e?e._next=t:I4=t);C4=e,V4(r)}(),R4=0}}function B4(){var e=O4.now(),t=e-$4;t>1e3&&(D4-=t,$4=e)}function V4(e){T4||(A4&&(A4=clearTimeout(A4)),e-R4>24?(e<1/0&&(A4=setTimeout(z4,e-O4.now()-D4)),E4&&(E4=clearInterval(E4))):(E4||($4=O4.now(),E4=setInterval(B4,1e3)),T4=1,_4(z4)))}function W4(e,t,n){var r=new L4;return t=null==t?0:+t,r.restart((n=>{r.stop(),e(n+t)}),t,n),r}L4.prototype=P4.prototype={constructor:L4,restart:function(e,t,n){if("function"!==typeof e)throw new TypeError("callback is not a function");n=(null==n?F4():+n)+(null==t?0:+t),this._next||C4===this||(C4?C4._next=this:I4=this,C4=this),this._call=e,this._time=n,V4()},stop:function(){this._call&&(this._call=null,this._time=1/0,V4())}};var U4=N4("start","end","cancel","interrupt"),j4=[];function G4(e,t,n,r,s,a){var i=e.__transition;if(i){if(n in i)return}else e.__transition={};!function(e,t,n){var r,s=e.__transition;function a(e){n.state=1,n.timer.restart(i,n.delay,n.time),n.delay<=e&&i(e-n.delay)}function i(a){var u,c,h,d;if(1!==n.state)return l();for(u in s)if((d=s[u]).name===n.name){if(3===d.state)return W4(i);4===d.state?(d.state=6,d.timer.stop(),d.on.call("interrupt",e,e.__data__,d.index,d.group),delete s[u]):+u<t&&(d.state=6,d.timer.stop(),d.on.call("cancel",e,e.__data__,d.index,d.group),delete s[u])}if(W4((function(){3===n.state&&(n.state=4,n.timer.restart(o,n.delay,n.time),o(a))})),n.state=2,n.on.call("start",e,e.__data__,n.index,n.group),2===n.state){for(n.state=3,r=new Array(h=n.tween.length),u=0,c=-1;u<h;++u)(d=n.tween[u].value.call(e,e.__data__,n.index,n.group))&&(r[++c]=d);r.length=c+1}}function o(t){for(var s=t<n.duration?n.ease.call(null,t/n.duration):(n.timer.restart(l),n.state=5,1),a=-1,i=r.length;++a<i;)r[a].call(e,s);5===n.state&&(n.on.call("end",e,e.__data__,n.index,n.group),l())}function l(){for(var r in n.state=6,n.timer.stop(),delete s[t],s)return;delete e.__transition}s[t]=n,n.timer=P4(a,0,n.time)}(e,n,{name:t,index:r,group:s,on:U4,tween:j4,time:a.time,delay:a.delay,duration:a.duration,ease:a.ease,timer:null,state:0})}function H4(e,t){var n=K4(e,t);if(n.state>0)throw new Error("too late; already scheduled");return n}function q4(e,t){var n=K4(e,t);if(n.state>3)throw new Error("too late; already running");return n}function K4(e,t){var n=e.__transition;if(!n||!(n=n[t]))throw new Error("transition not found");return n}function X4(e,t){return e=+e,t=+t,function(n){return e*(1-n)+t*n}}var Q4,Y4=180/Math.PI,Z4={translateX:0,translateY:0,rotate:0,skewX:0,scaleX:1,scaleY:1};function J4(e,t,n,r,s,a){var i,o,l;return(i=Math.sqrt(e*e+t*t))&&(e/=i,t/=i),(l=e*n+t*r)&&(n-=e*l,r-=t*l),(o=Math.sqrt(n*n+r*r))&&(n/=o,r/=o,l/=o),e*r<t*n&&(e=-e,t=-t,l=-l,i=-i),{translateX:s,translateY:a,rotate:Math.atan2(t,e)*Y4,skewX:Math.atan(l)*Y4,scaleX:i,scaleY:o}}function e5(e,t,n,r){function s(e){return e.length?e.pop()+" ":""}return function(a,i){var o=[],l=[];return a=e(a),i=e(i),function(e,r,s,a,i,o){if(e!==s||r!==a){var l=i.push("translate(",null,t,null,n);o.push({i:l-4,x:X4(e,s)},{i:l-2,x:X4(r,a)})}else(s||a)&&i.push("translate("+s+t+a+n)}(a.translateX,a.translateY,i.translateX,i.translateY,o,l),function(e,t,n,a){e!==t?(e-t>180?t+=360:t-e>180&&(e+=360),a.push({i:n.push(s(n)+"rotate(",null,r)-2,x:X4(e,t)})):t&&n.push(s(n)+"rotate("+t+r)}(a.rotate,i.rotate,o,l),function(e,t,n,a){e!==t?a.push({i:n.push(s(n)+"skewX(",null,r)-2,x:X4(e,t)}):t&&n.push(s(n)+"skewX("+t+r)}(a.skewX,i.skewX,o,l),function(e,t,n,r,a,i){if(e!==n||t!==r){var o=a.push(s(a)+"scale(",null,",",null,")");i.push({i:o-4,x:X4(e,n)},{i:o-2,x:X4(t,r)})}else 1===n&&1===r||a.push(s(a)+"scale("+n+","+r+")")}(a.scaleX,a.scaleY,i.scaleX,i.scaleY,o,l),a=i=null,function(e){for(var t,n=-1,r=l.length;++n<r;)o[(t=l[n]).i]=t.x(e);return o.join("")}}}var t5=e5((function(e){const t=new("function"===typeof DOMMatrix?DOMMatrix:WebKitCSSMatrix)(e+"");return t.isIdentity?Z4:J4(t.a,t.b,t.c,t.d,t.e,t.f)}),"px, ","px)","deg)"),n5=e5((function(e){return null==e?Z4:(Q4||(Q4=document.createElementNS("http://www.w3.org/2000/svg","g")),Q4.setAttribute("transform",e),(e=Q4.transform.baseVal.consolidate())?J4((e=e.matrix).a,e.b,e.c,e.d,e.e,e.f):Z4)}),", ",")",")");function r5(e,t){var n,r;return function(){var s=q4(this,e),a=s.tween;if(a!==n)for(var i=0,o=(r=n=a).length;i<o;++i)if(r[i].name===t){(r=r.slice()).splice(i,1);break}s.tween=r}}function s5(e,t,n){var r,s;if("function"!==typeof n)throw new Error;return function(){var a=q4(this,e),i=a.tween;if(i!==r){s=(r=i).slice();for(var o={name:t,value:n},l=0,u=s.length;l<u;++l)if(s[l].name===t){s[l]=o;break}l===u&&s.push(o)}a.tween=s}}function a5(e,t,n){var r=e._id;return e.each((function(){var e=q4(this,r);(e.value||(e.value={}))[t]=n.apply(this,arguments)})),function(e){return K4(e,r).value[t]}}function i5(e,t,n){e.prototype=t.prototype=n,n.constructor=e}function o5(e,t){var n=Object.create(e.prototype);for(var r in t)n[r]=t[r];return n}function l5(){}var u5=.7,c5=1/u5,h5="\\s*([+-]?\\d+)\\s*",d5="\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",p5="\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",f5=/^#([0-9a-f]{3,8})$/,m5=new RegExp(`^rgb\\(${h5},${h5},${h5}\\)$`),g5=new RegExp(`^rgb\\(${p5},${p5},${p5}\\)$`),y5=new RegExp(`^rgba\\(${h5},${h5},${h5},${d5}\\)$`),b5=new RegExp(`^rgba\\(${p5},${p5},${p5},${d5}\\)$`),v5=new RegExp(`^hsl\\(${d5},${p5},${p5}\\)$`),x5=new RegExp(`^hsla\\(${d5},${p5},${p5},${d5}\\)$`),w5={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074};function k5(){return this.rgb().formatHex()}function S5(){return this.rgb().formatRgb()}function N5(e){var t,n;return e=(e+"").trim().toLowerCase(),(t=f5.exec(e))?(n=t[1].length,t=parseInt(t[1],16),6===n?I5(t):3===n?new A5(t>>8&15|t>>4&240,t>>4&15|240&t,(15&t)<<4|15&t,1):8===n?C5(t>>24&255,t>>16&255,t>>8&255,(255&t)/255):4===n?C5(t>>12&15|t>>8&240,t>>8&15|t>>4&240,t>>4&15|240&t,((15&t)<<4|15&t)/255):null):(t=m5.exec(e))?new A5(t[1],t[2],t[3],1):(t=g5.exec(e))?new A5(255*t[1]/100,255*t[2]/100,255*t[3]/100,1):(t=y5.exec(e))?C5(t[1],t[2],t[3],t[4]):(t=b5.exec(e))?C5(255*t[1]/100,255*t[2]/100,255*t[3]/100,t[4]):(t=v5.exec(e))?_5(t[1],t[2]/100,t[3]/100,1):(t=x5.exec(e))?_5(t[1],t[2]/100,t[3]/100,t[4]):w5.hasOwnProperty(e)?I5(w5[e]):"transparent"===e?new A5(NaN,NaN,NaN,0):null}function I5(e){return new A5(e>>16&255,e>>8&255,255&e,1)}function C5(e,t,n,r){return r<=0&&(e=t=n=NaN),new A5(e,t,n,r)}function T5(e,t,n,r){return 1===arguments.length?((s=e)instanceof l5||(s=N5(s)),s?new A5((s=s.rgb()).r,s.g,s.b,s.opacity):new A5):new A5(e,t,n,null==r?1:r);var s}function A5(e,t,n,r){this.r=+e,this.g=+t,this.b=+n,this.opacity=+r}function E5(){return`#${O5(this.r)}${O5(this.g)}${O5(this.b)}`}function $5(){const e=R5(this.opacity);return`${1===e?"rgb(":"rgba("}${D5(this.r)}, ${D5(this.g)}, ${D5(this.b)}${1===e?")":`, ${e})`}`}function R5(e){return isNaN(e)?1:Math.max(0,Math.min(1,e))}function D5(e){return Math.max(0,Math.min(255,Math.round(e)||0))}function O5(e){return((e=D5(e))<16?"0":"")+e.toString(16)}function _5(e,t,n,r){return r<=0?e=t=n=NaN:n<=0||n>=1?e=t=NaN:t<=0&&(e=NaN),new M5(e,t,n,r)}function F5(e){if(e instanceof M5)return new M5(e.h,e.s,e.l,e.opacity);if(e instanceof l5||(e=N5(e)),!e)return new M5;if(e instanceof M5)return e;var t=(e=e.rgb()).r/255,n=e.g/255,r=e.b/255,s=Math.min(t,n,r),a=Math.max(t,n,r),i=NaN,o=a-s,l=(a+s)/2;return o?(i=t===a?(n-r)/o+6*(n<r):n===a?(r-t)/o+2:(t-n)/o+4,o/=l<.5?a+s:2-a-s,i*=60):o=l>0&&l<1?0:i,new M5(i,o,l,e.opacity)}function M5(e,t,n,r){this.h=+e,this.s=+t,this.l=+n,this.opacity=+r}function L5(e){return(e=(e||0)%360)<0?e+360:e}function P5(e){return Math.max(0,Math.min(1,e||0))}function z5(e,t,n){return 255*(e<60?t+(n-t)*e/60:e<180?n:e<240?t+(n-t)*(240-e)/60:t)}function B5(e,t,n,r,s){var a=e*e,i=a*e;return((1-3*e+3*a-i)*t+(4-6*a+3*i)*n+(1+3*e+3*a-3*i)*r+i*s)/6}i5(l5,N5,{copy(e){return Object.assign(new this.constructor,this,e)},displayable(){return this.rgb().displayable()},hex:k5,formatHex:k5,formatHex8:function(){return this.rgb().formatHex8()},formatHsl:function(){return F5(this).formatHsl()},formatRgb:S5,toString:S5}),i5(A5,T5,o5(l5,{brighter(e){return e=null==e?c5:Math.pow(c5,e),new A5(this.r*e,this.g*e,this.b*e,this.opacity)},darker(e){return e=null==e?u5:Math.pow(u5,e),new A5(this.r*e,this.g*e,this.b*e,this.opacity)},rgb(){return this},clamp(){return new A5(D5(this.r),D5(this.g),D5(this.b),R5(this.opacity))},displayable(){return-.5<=this.r&&this.r<255.5&&-.5<=this.g&&this.g<255.5&&-.5<=this.b&&this.b<255.5&&0<=this.opacity&&this.opacity<=1},hex:E5,formatHex:E5,formatHex8:function(){return`#${O5(this.r)}${O5(this.g)}${O5(this.b)}${O5(255*(isNaN(this.opacity)?1:this.opacity))}`},formatRgb:$5,toString:$5})),i5(M5,(function(e,t,n,r){return 1===arguments.length?F5(e):new M5(e,t,n,null==r?1:r)}),o5(l5,{brighter(e){return e=null==e?c5:Math.pow(c5,e),new M5(this.h,this.s,this.l*e,this.opacity)},darker(e){return e=null==e?u5:Math.pow(u5,e),new M5(this.h,this.s,this.l*e,this.opacity)},rgb(){var e=this.h%360+360*(this.h<0),t=isNaN(e)||isNaN(this.s)?0:this.s,n=this.l,r=n+(n<.5?n:1-n)*t,s=2*n-r;return new A5(z5(e>=240?e-240:e+120,s,r),z5(e,s,r),z5(e<120?e+240:e-120,s,r),this.opacity)},clamp(){return new M5(L5(this.h),P5(this.s),P5(this.l),R5(this.opacity))},displayable(){return(0<=this.s&&this.s<=1||isNaN(this.s))&&0<=this.l&&this.l<=1&&0<=this.opacity&&this.opacity<=1},formatHsl(){const e=R5(this.opacity);return`${1===e?"hsl(":"hsla("}${L5(this.h)}, ${100*P5(this.s)}%, ${100*P5(this.l)}%${1===e?")":`, ${e})`}`}}));const V5=e=>()=>e;function W5(e,t){return function(n){return e+n*t}}function U5(e){return 1===(e=+e)?j5:function(t,n){return n-t?function(e,t,n){return e=Math.pow(e,n),t=Math.pow(t,n)-e,n=1/n,function(r){return Math.pow(e+r*t,n)}}(t,n,e):V5(isNaN(t)?n:t)}}function j5(e,t){var n=t-e;return n?W5(e,n):V5(isNaN(e)?t:e)}const G5=function e(t){var n=U5(t);function r(e,t){var r=n((e=T5(e)).r,(t=T5(t)).r),s=n(e.g,t.g),a=n(e.b,t.b),i=j5(e.opacity,t.opacity);return function(t){return e.r=r(t),e.g=s(t),e.b=a(t),e.opacity=i(t),e+""}}return r.gamma=e,r}(1);function H5(e){return function(t){var n,r,s=t.length,a=new Array(s),i=new Array(s),o=new Array(s);for(n=0;n<s;++n)r=T5(t[n]),a[n]=r.r||0,i[n]=r.g||0,o[n]=r.b||0;return a=e(a),i=e(i),o=e(o),r.opacity=1,function(e){return r.r=a(e),r.g=i(e),r.b=o(e),r+""}}}H5((function(e){var t=e.length-1;return function(n){var r=n<=0?n=0:n>=1?(n=1,t-1):Math.floor(n*t),s=e[r],a=e[r+1],i=r>0?e[r-1]:2*s-a,o=r<t-1?e[r+2]:2*a-s;return B5((n-r/t)*t,i,s,a,o)}})),H5((function(e){var t=e.length;return function(n){var r=Math.floor(((n%=1)<0?++n:n)*t),s=e[(r+t-1)%t],a=e[r%t],i=e[(r+1)%t],o=e[(r+2)%t];return B5((n-r/t)*t,s,a,i,o)}}));var q5=/[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,K5=new RegExp(q5.source,"g");function X5(e,t){var n,r,s,a=q5.lastIndex=K5.lastIndex=0,i=-1,o=[],l=[];for(e+="",t+="";(n=q5.exec(e))&&(r=K5.exec(t));)(s=r.index)>a&&(s=t.slice(a,s),o[i]?o[i]+=s:o[++i]=s),(n=n[0])===(r=r[0])?o[i]?o[i]+=r:o[++i]=r:(o[++i]=null,l.push({i:i,x:X4(n,r)})),a=K5.lastIndex;return a<t.length&&(s=t.slice(a),o[i]?o[i]+=s:o[++i]=s),o.length<2?l[0]?function(e){return function(t){return e(t)+""}}(l[0].x):function(e){return function(){return e}}(t):(t=l.length,function(e){for(var n,r=0;r<t;++r)o[(n=l[r]).i]=n.x(e);return o.join("")})}function Q5(e,t){var n;return("number"===typeof t?X4:t instanceof N5?G5:(n=N5(t))?(t=n,G5):X5)(e,t)}function Y5(e){return function(){this.removeAttribute(e)}}function Z5(e){return function(){this.removeAttributeNS(e.space,e.local)}}function J5(e,t,n){var r,s,a=n+"";return function(){var i=this.getAttribute(e);return i===a?null:i===r?s:s=t(r=i,n)}}function e6(e,t,n){var r,s,a=n+"";return function(){var i=this.getAttributeNS(e.space,e.local);return i===a?null:i===r?s:s=t(r=i,n)}}function t6(e,t,n){var r,s,a;return function(){var i,o,l=n(this);if(null!=l)return(i=this.getAttribute(e))===(o=l+"")?null:i===r&&o===s?a:(s=o,a=t(r=i,l));this.removeAttribute(e)}}function n6(e,t,n){var r,s,a;return function(){var i,o,l=n(this);if(null!=l)return(i=this.getAttributeNS(e.space,e.local))===(o=l+"")?null:i===r&&o===s?a:(s=o,a=t(r=i,l));this.removeAttributeNS(e.space,e.local)}}function r6(e,t){var n,r;function s(){var s=t.apply(this,arguments);return s!==r&&(n=(r=s)&&function(e,t){return function(n){this.setAttributeNS(e.space,e.local,t.call(this,n))}}(e,s)),n}return s._value=t,s}function s6(e,t){var n,r;function s(){var s=t.apply(this,arguments);return s!==r&&(n=(r=s)&&function(e,t){return function(n){this.setAttribute(e,t.call(this,n))}}(e,s)),n}return s._value=t,s}function a6(e,t){return function(){H4(this,e).delay=+t.apply(this,arguments)}}function i6(e,t){return t=+t,function(){H4(this,e).delay=t}}function o6(e,t){return function(){q4(this,e).duration=+t.apply(this,arguments)}}function l6(e,t){return t=+t,function(){q4(this,e).duration=t}}var u6=b4.prototype.constructor;function c6(e){return function(){this.style.removeProperty(e)}}var h6=0;function d6(e,t,n,r){this._groups=e,this._parents=t,this._name=n,this._id=r}function p6(){return++h6}var f6=b4.prototype;d6.prototype=function(e){return b4().transition(e)}.prototype={constructor:d6,select:function(e){var t=this._name,n=this._id;"function"!==typeof e&&(e=o3(e));for(var r=this._groups,s=r.length,a=new Array(s),i=0;i<s;++i)for(var o,l,u=r[i],c=u.length,h=a[i]=new Array(c),d=0;d<c;++d)(o=u[d])&&(l=e.call(o,o.__data__,d,u))&&("__data__"in o&&(l.__data__=o.__data__),h[d]=l,G4(h[d],t,n,d,h,K4(o,n)));return new d6(a,this._parents,t,n)},selectAll:function(e){var t=this._name,n=this._id;"function"!==typeof e&&(e=u3(e));for(var r=this._groups,s=r.length,a=[],i=[],o=0;o<s;++o)for(var l,u=r[o],c=u.length,h=0;h<c;++h)if(l=u[h]){for(var d,p=e.call(l,l.__data__,h,u),f=K4(l,n),m=0,g=p.length;m<g;++m)(d=p[m])&&G4(d,t,n,m,p,f);a.push(p),i.push(l)}return new d6(a,i,t,n)},selectChild:f6.selectChild,selectChildren:f6.selectChildren,filter:function(e){"function"!==typeof e&&(e=h3(e));for(var t=this._groups,n=t.length,r=new Array(n),s=0;s<n;++s)for(var a,i=t[s],o=i.length,l=r[s]=[],u=0;u<o;++u)(a=i[u])&&e.call(a,a.__data__,u,i)&&l.push(a);return new d6(r,this._parents,this._name,this._id)},merge:function(e){if(e._id!==this._id)throw new Error;for(var t=this._groups,n=e._groups,r=t.length,s=n.length,a=Math.min(r,s),i=new Array(r),o=0;o<a;++o)for(var l,u=t[o],c=n[o],h=u.length,d=i[o]=new Array(h),p=0;p<h;++p)(l=u[p]||c[p])&&(d[p]=l);for(;o<r;++o)i[o]=t[o];return new d6(i,this._parents,this._name,this._id)},selection:function(){return new u6(this._groups,this._parents)},transition:function(){for(var e=this._name,t=this._id,n=p6(),r=this._groups,s=r.length,a=0;a<s;++a)for(var i,o=r[a],l=o.length,u=0;u<l;++u)if(i=o[u]){var c=K4(i,t);G4(i,e,n,u,o,{time:c.time+c.delay+c.duration,delay:0,duration:c.duration,ease:c.ease})}return new d6(r,this._parents,e,n)},call:f6.call,nodes:f6.nodes,node:f6.node,size:f6.size,empty:f6.empty,each:f6.each,on:function(e,t){var n=this._id;return arguments.length<2?K4(this.node(),n).on.on(e):this.each(function(e,t,n){var r,s,a=function(e){return(e+"").trim().split(/^|\s+/).every((function(e){var t=e.indexOf(".");return t>=0&&(e=e.slice(0,t)),!e||"start"===e}))}(t)?H4:q4;return function(){var i=a(this,e),o=i.on;o!==r&&(s=(r=o).copy()).on(t,n),i.on=s}}(n,e,t))},attr:function(e,t){var n=C3(e),r="transform"===n?n5:Q5;return this.attrTween(e,"function"===typeof t?(n.local?n6:t6)(n,r,a5(this,"attr."+e,t)):null==t?(n.local?Z5:Y5)(n):(n.local?e6:J5)(n,r,t))},attrTween:function(e,t){var n="attr."+e;if(arguments.length<2)return(n=this.tween(n))&&n._value;if(null==t)return this.tween(n,null);if("function"!==typeof t)throw new Error;var r=C3(e);return this.tween(n,(r.local?r6:s6)(r,t))},style:function(e,t,n){var r="transform"===(e+="")?t5:Q5;return null==t?this.styleTween(e,function(e,t){var n,r,s;return function(){var a=L3(this,e),i=(this.style.removeProperty(e),L3(this,e));return a===i?null:a===n&&i===r?s:s=t(n=a,r=i)}}(e,r)).on("end.style."+e,c6(e)):"function"===typeof t?this.styleTween(e,function(e,t,n){var r,s,a;return function(){var i=L3(this,e),o=n(this),l=o+"";return null==o&&(this.style.removeProperty(e),l=o=L3(this,e)),i===l?null:i===r&&l===s?a:(s=l,a=t(r=i,o))}}(e,r,a5(this,"style."+e,t))).each(function(e,t){var n,r,s,a,i="style."+t,o="end."+i;return function(){var l=q4(this,e),u=l.on,c=null==l.value[i]?a||(a=c6(t)):void 0;u===n&&s===c||(r=(n=u).copy()).on(o,s=c),l.on=r}}(this._id,e)):this.styleTween(e,function(e,t,n){var r,s,a=n+"";return function(){var i=L3(this,e);return i===a?null:i===r?s:s=t(r=i,n)}}(e,r,t),n).on("end.style."+e,null)},styleTween:function(e,t,n){var r="style."+(e+="");if(arguments.length<2)return(r=this.tween(r))&&r._value;if(null==t)return this.tween(r,null);if("function"!==typeof t)throw new Error;return this.tween(r,function(e,t,n){var r,s;function a(){var a=t.apply(this,arguments);return a!==s&&(r=(s=a)&&function(e,t,n){return function(r){this.style.setProperty(e,t.call(this,r),n)}}(e,a,n)),r}return a._value=t,a}(e,t,null==n?"":n))},text:function(e){return this.tween("text","function"===typeof e?function(e){return function(){var t=e(this);this.textContent=null==t?"":t}}(a5(this,"text",e)):function(e){return function(){this.textContent=e}}(null==e?"":e+""))},textTween:function(e){var t="text";if(arguments.length<1)return(t=this.tween(t))&&t._value;if(null==e)return this.tween(t,null);if("function"!==typeof e)throw new Error;return this.tween(t,function(e){var t,n;function r(){var r=e.apply(this,arguments);return r!==n&&(t=(n=r)&&function(e){return function(t){this.textContent=e.call(this,t)}}(r)),t}return r._value=e,r}(e))},remove:function(){return this.on("end.remove",function(e){return function(){var t=this.parentNode;for(var n in this.__transition)if(+n!==e)return;t&&t.removeChild(this)}}(this._id))},tween:function(e,t){var n=this._id;if(e+="",arguments.length<2){for(var r,s=K4(this.node(),n).tween,a=0,i=s.length;a<i;++a)if((r=s[a]).name===e)return r.value;return null}return this.each((null==t?r5:s5)(n,e,t))},delay:function(e){var t=this._id;return arguments.length?this.each(("function"===typeof e?a6:i6)(t,e)):K4(this.node(),t).delay},duration:function(e){var t=this._id;return arguments.length?this.each(("function"===typeof e?o6:l6)(t,e)):K4(this.node(),t).duration},ease:function(e){var t=this._id;return arguments.length?this.each(function(e,t){if("function"!==typeof t)throw new Error;return function(){q4(this,e).ease=t}}(t,e)):K4(this.node(),t).ease},easeVarying:function(e){if("function"!==typeof e)throw new Error;return this.each(function(e,t){return function(){var n=t.apply(this,arguments);if("function"!==typeof n)throw new Error;q4(this,e).ease=n}}(this._id,e))},end:function(){var e,t,n=this,r=n._id,s=n.size();return new Promise((function(a,i){var o={value:i},l={value:function(){0===--s&&a()}};n.each((function(){var n=q4(this,r),s=n.on;s!==e&&((t=(e=s).copy())._.cancel.push(o),t._.interrupt.push(o),t._.end.push(l)),n.on=t})),0===s&&a()}))},[Symbol.iterator]:f6[Symbol.iterator]};var m6={time:null,delay:0,duration:250,ease:function(e){return((e*=2)<=1?e*e*e:(e-=2)*e*e+2)/2}};function g6(e,t){for(var n;!(n=e.__transition)||!(n=n[t]);)if(!(e=e.parentNode))throw new Error(`transition ${t} not found`);return n}b4.prototype.interrupt=function(e){return this.each((function(){!function(e,t){var n,r,s,a=e.__transition,i=!0;if(a){for(s in t=null==t?null:t+"",a)(n=a[s]).name===t?(r=n.state>2&&n.state<5,n.state=6,n.timer.stop(),n.on.call(r?"interrupt":"cancel",e,e.__data__,n.index,n.group),delete a[s]):i=!1;i&&delete e.__transition}}(this,e)}))},b4.prototype.transition=function(e){var t,n;e instanceof d6?(t=e._id,e=e._name):(t=p6(),(n=m6).time=F4(),e=null==e?null:e+"");for(var r=this._groups,s=r.length,a=0;a<s;++a)for(var i,o=r[a],l=o.length,u=0;u<l;++u)(i=o[u])&&G4(i,e,t,u,o,n||g6(i,t));return new d6(r,this._parents,e,t)};const{abs:y6,max:b6,min:v6}=Math;function x6(e){return[+e[0],+e[1]]}function w6(e){return[x6(e[0]),x6(e[1])]}["w","e"].map(k6),["n","s"].map(k6),["n","w","e","s","nw","ne","sw","se"].map(k6);function k6(e){return{type:e}}function S6(e,t){return null==e||null==t?NaN:e<t?-1:e>t?1:e>=t?0:NaN}function N6(e,t){return null==e||null==t?NaN:t<e?-1:t>e?1:t>=e?0:NaN}function I6(e){let t,n,r;function s(e,r){let s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:e.length;if(s<a){if(0!==t(r,r))return a;do{const t=s+a>>>1;n(e[t],r)<0?s=t+1:a=t}while(s<a)}return s}return 2!==e.length?(t=S6,n=(t,n)=>S6(e(t),n),r=(t,n)=>e(t)-n):(t=e===S6||e===N6?e:C6,n=e,r=e),{left:s,center:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const a=s(e,t,n,(arguments.length>3&&void 0!==arguments[3]?arguments[3]:e.length)-1);return a>n&&r(e[a-1],t)>-r(e[a],t)?a-1:a},right:function(e,r){let s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:e.length;if(s<a){if(0!==t(r,r))return a;do{const t=s+a>>>1;n(e[t],r)<=0?s=t+1:a=t}while(s<a)}return s}}}function C6(){return 0}const T6=Math.sqrt(50),A6=Math.sqrt(10),E6=Math.sqrt(2);function $6(e,t,n){const r=(t-e)/Math.max(0,n),s=Math.floor(Math.log10(r)),a=r/Math.pow(10,s),i=a>=T6?10:a>=A6?5:a>=E6?2:1;let o,l,u;return s<0?(u=Math.pow(10,-s)/i,o=Math.round(e*u),l=Math.round(t*u),o/u<e&&++o,l/u>t&&--l,u=-u):(u=Math.pow(10,s)*i,o=Math.round(e/u),l=Math.round(t/u),o*u<e&&++o,l*u>t&&--l),l<o&&.5<=n&&n<2?$6(e,t,2*n):[o,l,u]}function R6(e,t,n){return $6(e=+e,t=+t,n=+n)[2]}function D6(e,t,n){n=+n;const r=(t=+t)<(e=+e),s=r?R6(t,e,n):R6(e,t,n);return(r?-1:1)*(s<0?1/-s:s)}const O6=1e3,_6=6e4,F6=36e5,M6=864e5,L6=6048e5,P6=2592e6,z6=31536e6,B6=new Date,V6=new Date;function W6(e,t,n,r){function s(t){return e(t=0===arguments.length?new Date:new Date(+t)),t}return s.floor=t=>(e(t=new Date(+t)),t),s.ceil=n=>(e(n=new Date(n-1)),t(n,1),e(n),n),s.round=e=>{const t=s(e),n=s.ceil(e);return e-t<n-e?t:n},s.offset=(e,n)=>(t(e=new Date(+e),null==n?1:Math.floor(n)),e),s.range=(n,r,a)=>{const i=[];if(n=s.ceil(n),a=null==a?1:Math.floor(a),!(n<r)||!(a>0))return i;let o;do{i.push(o=new Date(+n)),t(n,a),e(n)}while(o<n&&n<r);return i},s.filter=n=>W6((t=>{if(t>=t)for(;e(t),!n(t);)t.setTime(t-1)}),((e,r)=>{if(e>=e)if(r<0)for(;++r<=0;)for(;t(e,-1),!n(e););else for(;--r>=0;)for(;t(e,1),!n(e););})),n&&(s.count=(t,r)=>(B6.setTime(+t),V6.setTime(+r),e(B6),e(V6),Math.floor(n(B6,V6))),s.every=e=>(e=Math.floor(e),isFinite(e)&&e>0?e>1?s.filter(r?t=>r(t)%e===0:t=>s.count(0,t)%e===0):s:null)),s}const U6=W6((()=>{}),((e,t)=>{e.setTime(+e+t)}),((e,t)=>t-e));U6.every=e=>(e=Math.floor(e),isFinite(e)&&e>0?e>1?W6((t=>{t.setTime(Math.floor(t/e)*e)}),((t,n)=>{t.setTime(+t+n*e)}),((t,n)=>(n-t)/e)):U6:null);U6.range;const j6=W6((e=>{e.setTime(e-e.getMilliseconds())}),((e,t)=>{e.setTime(+e+t*O6)}),((e,t)=>(t-e)/O6),(e=>e.getUTCSeconds())),G6=(j6.range,W6((e=>{e.setTime(e-e.getMilliseconds()-e.getSeconds()*O6)}),((e,t)=>{e.setTime(+e+t*_6)}),((e,t)=>(t-e)/_6),(e=>e.getMinutes()))),H6=(G6.range,W6((e=>{e.setUTCSeconds(0,0)}),((e,t)=>{e.setTime(+e+t*_6)}),((e,t)=>(t-e)/_6),(e=>e.getUTCMinutes()))),q6=(H6.range,W6((e=>{e.setTime(e-e.getMilliseconds()-e.getSeconds()*O6-e.getMinutes()*_6)}),((e,t)=>{e.setTime(+e+t*F6)}),((e,t)=>(t-e)/F6),(e=>e.getHours()))),K6=(q6.range,W6((e=>{e.setUTCMinutes(0,0,0)}),((e,t)=>{e.setTime(+e+t*F6)}),((e,t)=>(t-e)/F6),(e=>e.getUTCHours()))),X6=(K6.range,W6((e=>e.setHours(0,0,0,0)),((e,t)=>e.setDate(e.getDate()+t)),((e,t)=>(t-e-(t.getTimezoneOffset()-e.getTimezoneOffset())*_6)/M6),(e=>e.getDate()-1))),Q6=(X6.range,W6((e=>{e.setUTCHours(0,0,0,0)}),((e,t)=>{e.setUTCDate(e.getUTCDate()+t)}),((e,t)=>(t-e)/M6),(e=>e.getUTCDate()-1))),Y6=(Q6.range,W6((e=>{e.setUTCHours(0,0,0,0)}),((e,t)=>{e.setUTCDate(e.getUTCDate()+t)}),((e,t)=>(t-e)/M6),(e=>Math.floor(e/M6))));Y6.range;function Z6(e){return W6((t=>{t.setDate(t.getDate()-(t.getDay()+7-e)%7),t.setHours(0,0,0,0)}),((e,t)=>{e.setDate(e.getDate()+7*t)}),((e,t)=>(t-e-(t.getTimezoneOffset()-e.getTimezoneOffset())*_6)/L6))}const J6=Z6(0),e8=Z6(1),t8=Z6(2),n8=Z6(3),r8=Z6(4),s8=Z6(5),a8=Z6(6);J6.range,e8.range,t8.range,n8.range,r8.range,s8.range,a8.range;function i8(e){return W6((t=>{t.setUTCDate(t.getUTCDate()-(t.getUTCDay()+7-e)%7),t.setUTCHours(0,0,0,0)}),((e,t)=>{e.setUTCDate(e.getUTCDate()+7*t)}),((e,t)=>(t-e)/L6))}const o8=i8(0),l8=i8(1),u8=i8(2),c8=i8(3),h8=i8(4),d8=i8(5),p8=i8(6),f8=(o8.range,l8.range,u8.range,c8.range,h8.range,d8.range,p8.range,W6((e=>{e.setDate(1),e.setHours(0,0,0,0)}),((e,t)=>{e.setMonth(e.getMonth()+t)}),((e,t)=>t.getMonth()-e.getMonth()+12*(t.getFullYear()-e.getFullYear())),(e=>e.getMonth()))),m8=(f8.range,W6((e=>{e.setUTCDate(1),e.setUTCHours(0,0,0,0)}),((e,t)=>{e.setUTCMonth(e.getUTCMonth()+t)}),((e,t)=>t.getUTCMonth()-e.getUTCMonth()+12*(t.getUTCFullYear()-e.getUTCFullYear())),(e=>e.getUTCMonth()))),g8=(m8.range,W6((e=>{e.setMonth(0,1),e.setHours(0,0,0,0)}),((e,t)=>{e.setFullYear(e.getFullYear()+t)}),((e,t)=>t.getFullYear()-e.getFullYear()),(e=>e.getFullYear())));g8.every=e=>isFinite(e=Math.floor(e))&&e>0?W6((t=>{t.setFullYear(Math.floor(t.getFullYear()/e)*e),t.setMonth(0,1),t.setHours(0,0,0,0)}),((t,n)=>{t.setFullYear(t.getFullYear()+n*e)})):null;g8.range;const y8=W6((e=>{e.setUTCMonth(0,1),e.setUTCHours(0,0,0,0)}),((e,t)=>{e.setUTCFullYear(e.getUTCFullYear()+t)}),((e,t)=>t.getUTCFullYear()-e.getUTCFullYear()),(e=>e.getUTCFullYear()));y8.every=e=>isFinite(e=Math.floor(e))&&e>0?W6((t=>{t.setUTCFullYear(Math.floor(t.getUTCFullYear()/e)*e),t.setUTCMonth(0,1),t.setUTCHours(0,0,0,0)}),((t,n)=>{t.setUTCFullYear(t.getUTCFullYear()+n*e)})):null;y8.range;function b8(e,t,n,r,s,a){const i=[[j6,1,O6],[j6,5,5e3],[j6,15,15e3],[j6,30,3e4],[a,1,_6],[a,5,3e5],[a,15,9e5],[a,30,18e5],[s,1,F6],[s,3,108e5],[s,6,216e5],[s,12,432e5],[r,1,M6],[r,2,1728e5],[n,1,L6],[t,1,P6],[t,3,7776e6],[e,1,z6]];function o(t,n,r){const s=Math.abs(n-t)/r,a=I6((e=>{let[,,t]=e;return t})).right(i,s);if(a===i.length)return e.every(D6(t/z6,n/z6,r));if(0===a)return U6.every(Math.max(D6(t,n,r),1));const[o,l]=i[s/i[a-1][2]<i[a][2]/s?a-1:a];return o.every(l)}return[function(e,t,n){const r=t<e;r&&([e,t]=[t,e]);const s=n&&"function"===typeof n.range?n:o(e,t,n),a=s?s.range(e,+t+1):[];return r?a.reverse():a},o]}const[v8,x8]=b8(y8,m8,o8,Y6,K6,H6),[w8,k8]=b8(g8,f8,J6,X6,q6,G6);function S8(e){if(0<=e.y&&e.y<100){var t=new Date(-1,e.m,e.d,e.H,e.M,e.S,e.L);return t.setFullYear(e.y),t}return new Date(e.y,e.m,e.d,e.H,e.M,e.S,e.L)}function N8(e){if(0<=e.y&&e.y<100){var t=new Date(Date.UTC(-1,e.m,e.d,e.H,e.M,e.S,e.L));return t.setUTCFullYear(e.y),t}return new Date(Date.UTC(e.y,e.m,e.d,e.H,e.M,e.S,e.L))}function I8(e,t,n){return{y:e,m:t,d:n,H:0,M:0,S:0,L:0}}var C8,T8,A8={"-":"",_:" ",0:"0"},E8=/^\s*\d+/,$8=/^%/,R8=/[\\^$*+?|[\]().{}]/g;function D8(e,t,n){var r=e<0?"-":"",s=(r?-e:e)+"",a=s.length;return r+(a<n?new Array(n-a+1).join(t)+s:s)}function O8(e){return e.replace(R8,"\\$&")}function _8(e){return new RegExp("^(?:"+e.map(O8).join("|")+")","i")}function F8(e){return new Map(e.map(((e,t)=>[e.toLowerCase(),t])))}function M8(e,t,n){var r=E8.exec(t.slice(n,n+1));return r?(e.w=+r[0],n+r[0].length):-1}function L8(e,t,n){var r=E8.exec(t.slice(n,n+1));return r?(e.u=+r[0],n+r[0].length):-1}function P8(e,t,n){var r=E8.exec(t.slice(n,n+2));return r?(e.U=+r[0],n+r[0].length):-1}function z8(e,t,n){var r=E8.exec(t.slice(n,n+2));return r?(e.V=+r[0],n+r[0].length):-1}function B8(e,t,n){var r=E8.exec(t.slice(n,n+2));return r?(e.W=+r[0],n+r[0].length):-1}function V8(e,t,n){var r=E8.exec(t.slice(n,n+4));return r?(e.y=+r[0],n+r[0].length):-1}function W8(e,t,n){var r=E8.exec(t.slice(n,n+2));return r?(e.y=+r[0]+(+r[0]>68?1900:2e3),n+r[0].length):-1}function U8(e,t,n){var r=/^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(t.slice(n,n+6));return r?(e.Z=r[1]?0:-(r[2]+(r[3]||"00")),n+r[0].length):-1}function j8(e,t,n){var r=E8.exec(t.slice(n,n+1));return r?(e.q=3*r[0]-3,n+r[0].length):-1}function G8(e,t,n){var r=E8.exec(t.slice(n,n+2));return r?(e.m=r[0]-1,n+r[0].length):-1}function H8(e,t,n){var r=E8.exec(t.slice(n,n+2));return r?(e.d=+r[0],n+r[0].length):-1}function q8(e,t,n){var r=E8.exec(t.slice(n,n+3));return r?(e.m=0,e.d=+r[0],n+r[0].length):-1}function K8(e,t,n){var r=E8.exec(t.slice(n,n+2));return r?(e.H=+r[0],n+r[0].length):-1}function X8(e,t,n){var r=E8.exec(t.slice(n,n+2));return r?(e.M=+r[0],n+r[0].length):-1}function Q8(e,t,n){var r=E8.exec(t.slice(n,n+2));return r?(e.S=+r[0],n+r[0].length):-1}function Y8(e,t,n){var r=E8.exec(t.slice(n,n+3));return r?(e.L=+r[0],n+r[0].length):-1}function Z8(e,t,n){var r=E8.exec(t.slice(n,n+6));return r?(e.L=Math.floor(r[0]/1e3),n+r[0].length):-1}function J8(e,t,n){var r=$8.exec(t.slice(n,n+1));return r?n+r[0].length:-1}function e7(e,t,n){var r=E8.exec(t.slice(n));return r?(e.Q=+r[0],n+r[0].length):-1}function t7(e,t,n){var r=E8.exec(t.slice(n));return r?(e.s=+r[0],n+r[0].length):-1}function n7(e,t){return D8(e.getDate(),t,2)}function r7(e,t){return D8(e.getHours(),t,2)}function s7(e,t){return D8(e.getHours()%12||12,t,2)}function a7(e,t){return D8(1+X6.count(g8(e),e),t,3)}function i7(e,t){return D8(e.getMilliseconds(),t,3)}function o7(e,t){return i7(e,t)+"000"}function l7(e,t){return D8(e.getMonth()+1,t,2)}function u7(e,t){return D8(e.getMinutes(),t,2)}function c7(e,t){return D8(e.getSeconds(),t,2)}function h7(e){var t=e.getDay();return 0===t?7:t}function d7(e,t){return D8(J6.count(g8(e)-1,e),t,2)}function p7(e){var t=e.getDay();return t>=4||0===t?r8(e):r8.ceil(e)}function f7(e,t){return e=p7(e),D8(r8.count(g8(e),e)+(4===g8(e).getDay()),t,2)}function m7(e){return e.getDay()}function g7(e,t){return D8(e8.count(g8(e)-1,e),t,2)}function y7(e,t){return D8(e.getFullYear()%100,t,2)}function b7(e,t){return D8((e=p7(e)).getFullYear()%100,t,2)}function v7(e,t){return D8(e.getFullYear()%1e4,t,4)}function x7(e,t){var n=e.getDay();return D8((e=n>=4||0===n?r8(e):r8.ceil(e)).getFullYear()%1e4,t,4)}function w7(e){var t=e.getTimezoneOffset();return(t>0?"-":(t*=-1,"+"))+D8(t/60|0,"0",2)+D8(t%60,"0",2)}function k7(e,t){return D8(e.getUTCDate(),t,2)}function S7(e,t){return D8(e.getUTCHours(),t,2)}function N7(e,t){return D8(e.getUTCHours()%12||12,t,2)}function I7(e,t){return D8(1+Q6.count(y8(e),e),t,3)}function C7(e,t){return D8(e.getUTCMilliseconds(),t,3)}function T7(e,t){return C7(e,t)+"000"}function A7(e,t){return D8(e.getUTCMonth()+1,t,2)}function E7(e,t){return D8(e.getUTCMinutes(),t,2)}function $7(e,t){return D8(e.getUTCSeconds(),t,2)}function R7(e){var t=e.getUTCDay();return 0===t?7:t}function D7(e,t){return D8(o8.count(y8(e)-1,e),t,2)}function O7(e){var t=e.getUTCDay();return t>=4||0===t?h8(e):h8.ceil(e)}function _7(e,t){return e=O7(e),D8(h8.count(y8(e),e)+(4===y8(e).getUTCDay()),t,2)}function F7(e){return e.getUTCDay()}function M7(e,t){return D8(l8.count(y8(e)-1,e),t,2)}function L7(e,t){return D8(e.getUTCFullYear()%100,t,2)}function P7(e,t){return D8((e=O7(e)).getUTCFullYear()%100,t,2)}function z7(e,t){return D8(e.getUTCFullYear()%1e4,t,4)}function B7(e,t){var n=e.getUTCDay();return D8((e=n>=4||0===n?h8(e):h8.ceil(e)).getUTCFullYear()%1e4,t,4)}function V7(){return"+0000"}function W7(){return"%"}function U7(e){return+e}function j7(e){return Math.floor(+e/1e3)}C8=function(e){var t=e.dateTime,n=e.date,r=e.time,s=e.periods,a=e.days,i=e.shortDays,o=e.months,l=e.shortMonths,u=_8(s),c=F8(s),h=_8(a),d=F8(a),p=_8(i),f=F8(i),m=_8(o),g=F8(o),y=_8(l),b=F8(l),v={a:function(e){return i[e.getDay()]},A:function(e){return a[e.getDay()]},b:function(e){return l[e.getMonth()]},B:function(e){return o[e.getMonth()]},c:null,d:n7,e:n7,f:o7,g:b7,G:x7,H:r7,I:s7,j:a7,L:i7,m:l7,M:u7,p:function(e){return s[+(e.getHours()>=12)]},q:function(e){return 1+~~(e.getMonth()/3)},Q:U7,s:j7,S:c7,u:h7,U:d7,V:f7,w:m7,W:g7,x:null,X:null,y:y7,Y:v7,Z:w7,"%":W7},x={a:function(e){return i[e.getUTCDay()]},A:function(e){return a[e.getUTCDay()]},b:function(e){return l[e.getUTCMonth()]},B:function(e){return o[e.getUTCMonth()]},c:null,d:k7,e:k7,f:T7,g:P7,G:B7,H:S7,I:N7,j:I7,L:C7,m:A7,M:E7,p:function(e){return s[+(e.getUTCHours()>=12)]},q:function(e){return 1+~~(e.getUTCMonth()/3)},Q:U7,s:j7,S:$7,u:R7,U:D7,V:_7,w:F7,W:M7,x:null,X:null,y:L7,Y:z7,Z:V7,"%":W7},w={a:function(e,t,n){var r=p.exec(t.slice(n));return r?(e.w=f.get(r[0].toLowerCase()),n+r[0].length):-1},A:function(e,t,n){var r=h.exec(t.slice(n));return r?(e.w=d.get(r[0].toLowerCase()),n+r[0].length):-1},b:function(e,t,n){var r=y.exec(t.slice(n));return r?(e.m=b.get(r[0].toLowerCase()),n+r[0].length):-1},B:function(e,t,n){var r=m.exec(t.slice(n));return r?(e.m=g.get(r[0].toLowerCase()),n+r[0].length):-1},c:function(e,n,r){return N(e,t,n,r)},d:H8,e:H8,f:Z8,g:W8,G:V8,H:K8,I:K8,j:q8,L:Y8,m:G8,M:X8,p:function(e,t,n){var r=u.exec(t.slice(n));return r?(e.p=c.get(r[0].toLowerCase()),n+r[0].length):-1},q:j8,Q:e7,s:t7,S:Q8,u:L8,U:P8,V:z8,w:M8,W:B8,x:function(e,t,r){return N(e,n,t,r)},X:function(e,t,n){return N(e,r,t,n)},y:W8,Y:V8,Z:U8,"%":J8};function k(e,t){return function(n){var r,s,a,i=[],o=-1,l=0,u=e.length;for(n instanceof Date||(n=new Date(+n));++o<u;)37===e.charCodeAt(o)&&(i.push(e.slice(l,o)),null!=(s=A8[r=e.charAt(++o)])?r=e.charAt(++o):s="e"===r?" ":"0",(a=t[r])&&(r=a(n,s)),i.push(r),l=o+1);return i.push(e.slice(l,o)),i.join("")}}function S(e,t){return function(n){var r,s,a=I8(1900,void 0,1);if(N(a,e,n+="",0)!=n.length)return null;if("Q"in a)return new Date(a.Q);if("s"in a)return new Date(1e3*a.s+("L"in a?a.L:0));if(t&&!("Z"in a)&&(a.Z=0),"p"in a&&(a.H=a.H%12+12*a.p),void 0===a.m&&(a.m="q"in a?a.q:0),"V"in a){if(a.V<1||a.V>53)return null;"w"in a||(a.w=1),"Z"in a?(s=(r=N8(I8(a.y,0,1))).getUTCDay(),r=s>4||0===s?l8.ceil(r):l8(r),r=Q6.offset(r,7*(a.V-1)),a.y=r.getUTCFullYear(),a.m=r.getUTCMonth(),a.d=r.getUTCDate()+(a.w+6)%7):(s=(r=S8(I8(a.y,0,1))).getDay(),r=s>4||0===s?e8.ceil(r):e8(r),r=X6.offset(r,7*(a.V-1)),a.y=r.getFullYear(),a.m=r.getMonth(),a.d=r.getDate()+(a.w+6)%7)}else("W"in a||"U"in a)&&("w"in a||(a.w="u"in a?a.u%7:"W"in a?1:0),s="Z"in a?N8(I8(a.y,0,1)).getUTCDay():S8(I8(a.y,0,1)).getDay(),a.m=0,a.d="W"in a?(a.w+6)%7+7*a.W-(s+5)%7:a.w+7*a.U-(s+6)%7);return"Z"in a?(a.H+=a.Z/100|0,a.M+=a.Z%100,N8(a)):S8(a)}}function N(e,t,n,r){for(var s,a,i=0,o=t.length,l=n.length;i<o;){if(r>=l)return-1;if(37===(s=t.charCodeAt(i++))){if(s=t.charAt(i++),!(a=w[s in A8?t.charAt(i++):s])||(r=a(e,n,r))<0)return-1}else if(s!=n.charCodeAt(r++))return-1}return r}return v.x=k(n,v),v.X=k(r,v),v.c=k(t,v),x.x=k(n,x),x.X=k(r,x),x.c=k(t,x),{format:function(e){var t=k(e+="",v);return t.toString=function(){return e},t},parse:function(e){var t=S(e+="",!1);return t.toString=function(){return e},t},utcFormat:function(e){var t=k(e+="",x);return t.toString=function(){return e},t},utcParse:function(e){var t=S(e+="",!0);return t.toString=function(){return e},t}}}({dateTime:"%x, %X",date:"%-m/%-d/%Y",time:"%-I:%M:%S %p",periods:["AM","PM"],days:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],shortDays:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],months:["January","February","March","April","May","June","July","August","September","October","November","December"],shortMonths:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"]}),T8=C8.format,C8.parse,C8.utcFormat,C8.utcParse;const G7=I6(S6),H7=G7.right,q7=(G7.left,I6((function(e){return null===e?NaN:+e})).center,H7);function K7(e,t){var n,r=t?t.length:0,s=e?Math.min(r,e.length):0,a=new Array(s),i=new Array(r);for(n=0;n<s;++n)a[n]=Z7(e[n],t[n]);for(;n<r;++n)i[n]=t[n];return function(e){for(n=0;n<s;++n)i[n]=a[n](e);return i}}function X7(e,t){var n=new Date;return e=+e,t=+t,function(r){return n.setTime(e*(1-r)+t*r),n}}function Q7(e,t){var n,r={},s={};for(n in null!==e&&"object"===typeof e||(e={}),null!==t&&"object"===typeof t||(t={}),t)n in e?r[n]=Z7(e[n],t[n]):s[n]=t[n];return function(e){for(n in r)s[n]=r[n](e);return s}}function Y7(e,t){t||(t=[]);var n,r=e?Math.min(t.length,e.length):0,s=t.slice();return function(a){for(n=0;n<r;++n)s[n]=e[n]*(1-a)+t[n]*a;return s}}function Z7(e,t){var n,r,s=typeof t;return null==t||"boolean"===s?V5(t):("number"===s?X4:"string"===s?(n=N5(t))?(t=n,G5):X5:t instanceof N5?G5:t instanceof Date?X7:(r=t,!ArrayBuffer.isView(r)||r instanceof DataView?Array.isArray(t)?K7:"function"!==typeof t.valueOf&&"function"!==typeof t.toString||isNaN(t)?Q7:X4:Y7))(e,t)}function J7(e,t){return e=+e,t=+t,function(n){return Math.round(e*(1-n)+t*n)}}function e9(e){return+e}var t9=[0,1];function n9(e){return e}function r9(e,t){return(t-=e=+e)?function(n){return(n-e)/t}:(n=isNaN(t)?NaN:.5,function(){return n});var n}function s9(e,t,n){var r=e[0],s=e[1],a=t[0],i=t[1];return s<r?(r=r9(s,r),a=n(i,a)):(r=r9(r,s),a=n(a,i)),function(e){return a(r(e))}}function a9(e,t,n){var r=Math.min(e.length,t.length)-1,s=new Array(r),a=new Array(r),i=-1;for(e[r]<e[0]&&(e=e.slice().reverse(),t=t.slice().reverse());++i<r;)s[i]=r9(e[i],e[i+1]),a[i]=n(t[i],t[i+1]);return function(t){var n=q7(e,t,1,r)-1;return a[n](s[n](t))}}function i9(){var e,t,n,r,s,a,i=t9,o=t9,l=Z7,u=n9;function c(){var e=Math.min(i.length,o.length);return u!==n9&&(u=function(e,t){var n;return e>t&&(n=e,e=t,t=n),function(n){return Math.max(e,Math.min(t,n))}}(i[0],i[e-1])),r=e>2?a9:s9,s=a=null,h}function h(t){return null==t||isNaN(t=+t)?n:(s||(s=r(i.map(e),o,l)))(e(u(t)))}return h.invert=function(n){return u(t((a||(a=r(o,i.map(e),X4)))(n)))},h.domain=function(e){return arguments.length?(i=Array.from(e,e9),c()):i.slice()},h.range=function(e){return arguments.length?(o=Array.from(e),c()):o.slice()},h.rangeRound=function(e){return o=Array.from(e),l=J7,c()},h.clamp=function(e){return arguments.length?(u=!!e||n9,c()):u!==n9},h.interpolate=function(e){return arguments.length?(l=e,c()):l},h.unknown=function(e){return arguments.length?(n=e,h):n},function(n,r){return e=n,t=r,c()}}function o9(e,t){switch(arguments.length){case 0:break;case 1:this.range(e);break;default:this.range(t).domain(e)}return this}function l9(e){return new Date(e)}function u9(e){return e instanceof Date?+e:+new Date(+e)}function c9(e,t,n,r,s,a,i,o,l,u){var c=i9()(n9,n9),h=c.invert,d=c.domain,p=u(".%L"),f=u(":%S"),m=u("%I:%M"),g=u("%I %p"),y=u("%a %d"),b=u("%b %d"),v=u("%B"),x=u("%Y");function w(e){return(l(e)<e?p:o(e)<e?f:i(e)<e?m:a(e)<e?g:r(e)<e?s(e)<e?y:b:n(e)<e?v:x)(e)}return c.invert=function(e){return new Date(h(e))},c.domain=function(e){return arguments.length?d(Array.from(e,u9)):d().map(l9)},c.ticks=function(t){var n=d();return e(n[0],n[n.length-1],null==t?10:t)},c.tickFormat=function(e,t){return null==t?w:u(t)},c.nice=function(e){var n=d();return e&&"function"===typeof e.range||(e=t(n[0],n[n.length-1],null==e?10:e)),e?d(function(e,t){var n,r=0,s=(e=e.slice()).length-1,a=e[r],i=e[s];return i<a&&(n=r,r=s,s=n,n=a,a=i,i=n),e[r]=t.floor(a),e[s]=t.ceil(i),e}(n,e)):c},c.copy=function(){return h=c,c9(e,t,n,r,s,a,i,o,l,u).domain(h.domain()).range(h.range()).interpolate(h.interpolate()).clamp(h.clamp()).unknown(h.unknown());var h},c}function h9(){return o9.apply(c9(w8,k8,g8,f8,J6,X6,q6,G6,j6,T8).domain([new Date(2e3,0,1),new Date(2e3,0,2)]),arguments)}function d9(e){return"string"===typeof e?new g4([[document.querySelector(e)]],[document.documentElement]):new g4([[e]],m4)}function p9(e,t,n){this.k=e,this.x=t,this.y=n}p9.prototype={constructor:p9,scale:function(e){return 1===e?this:new p9(this.k*e,this.x,this.y)},translate:function(e,t){return 0===e&0===t?this:new p9(this.k,this.x+this.k*e,this.y+this.k*t)},apply:function(e){return[e[0]*this.k+this.x,e[1]*this.k+this.y]},applyX:function(e){return e*this.k+this.x},applyY:function(e){return e*this.k+this.y},invert:function(e){return[(e[0]-this.x)/this.k,(e[1]-this.y)/this.k]},invertX:function(e){return(e-this.x)/this.k},invertY:function(e){return(e-this.y)/this.k},rescaleX:function(e){return e.copy().domain(e.range().map(this.invertX,this).map(e.invert,e))},rescaleY:function(e){return e.copy().domain(e.range().map(this.invertY,this).map(e.invert,e))},toString:function(){return"translate("+this.x+","+this.y+") scale("+this.k+")"}};new p9(1,0,0);p9.prototype;const f9=e=>{var t,n;let{point:r,radius:s,position:a,onClose:i,onCategoryChange:o}=e;const l=(0,T.useRef)(null),[u,c]=(0,T.useState)(80);if((0,T.useEffect)((()=>{l.current&&c(l.current.offsetHeight)}),[r]),!r||!a)return null;const{x:h,y:d,isBeforeNoon:p}=a;return(0,tr.jsx)("foreignObject",{x:h-125,y:p?d+s+8:d-s-u-8,width:"300px",height:u+100,className:"z-90 px-4 overflow-visible",onClick:e=>e.stopPropagation(),style:{overflow:"visible"},children:(0,tr.jsxs)("div",{ref:l,className:"rounded-md text-xs leading-tight shadow-md z-90 animate-tooltipFadeIn overflow-visible",style:{backgroundColor:r.category.color,transformOrigin:p?"top center":"bottom center"},children:[(0,tr.jsxs)("div",{className:"py-2 px-8",children:[(0,tr.jsxs)("div",{className:"flex justify-between",children:[(0,tr.jsxs)("p",{className:"text-xs",children:["SEARCHED AT ",null===(t=r.fullDate)||void 0===t?void 0:t.toLocaleTimeString()]}),(0,tr.jsx)("button",{onClick:i,className:"text-white bg-red-600 w-5 h-5 text-xs rounded-full text-center",children:"\xd7"})]}),(0,tr.jsxs)("p",{className:"text-lg font-medium my-2",children:['"',r.query,'"']})]}),(0,tr.jsx)("div",{className:"h-[0.3px] w-full bg-[#444]"}),(0,tr.jsx)("div",{className:"py-2 px-5",children:(0,tr.jsx)($2,{value:null===(n=r.category)||void 0===n?void 0:n.id,onChange:e=>{null!==r&&void 0!==r&&r.id&&(null===o||void 0===o||o(r,e))},label:"Category"})})]})})},m9=e=>{let{scale:t,height:n,width:r,margin:s}=e;const a=(0,T.useRef)();return(0,T.useEffect)((()=>{a.current&&(d9(a.current).call(function(e){return a3(3,e)}(t).ticks(X6.every(1)).tickFormat(T8("%b %d, %Y"))).selectAll("text").style("font-size","15px").style("color","white").style("font-family","Noto Sans JP"),d9(a.current).selectAll("path, line").style("stroke","#131818"))}),[t]),(0,tr.jsx)("g",{ref:a,transform:`translate(0, ${s.top})`})},g9=e=>{let{scale:t,margin:n}=e;const r=(0,T.useRef)();return(0,T.useEffect)((()=>{r.current&&(d9(r.current).call(function(e){return a3(4,e)}(t).ticks(q6.every(6)).tickFormat(T8("%H:%M"))).selectAll("text").style("font-size","12px").style("color","white").style("font-family","Noto Sans JP"),d9(r.current).selectAll("path, line").style("stroke","#ded").style("stroke-width","2px"))}),[t]),(0,tr.jsx)("g",{ref:r,transform:`translate(${n.left}, 0)`})},y9=e=>{var t;let{point:n,radius:r,obscure:s,onSelect:a,selectedPoint:i}=e;const o=(null===i||void 0===i?void 0:i.query)===n.query&&(null===i||void 0===i||null===(t=i.fullDate)||void 0===t?void 0:t.getTime())===n.fullDate.getTime(),l=window.matchMedia("(pointer: coarse)").matches;return(0,tr.jsx)(tr.Fragment,{children:(0,tr.jsxs)("g",{onMouseEnter:()=>{l||(clearTimeout(window.__tooltipLeaveTimeout),a(n))},onMouseLeave:()=>{l||(window.__tooltipLeaveTimeout=setTimeout((()=>{a(null)}),200))},onClick:()=>{l&&a(n)},children:[o&&(0,tr.jsx)("circle",{cx:n.clusteredX,cy:n.clusteredY,r:3.5*r,fill:"none",stroke:n.category.color,strokeWidth:2,className:"animate-growRing",style:{transformOrigin:`${n.clusteredX}px ${n.clusteredY}px`}}),(0,tr.jsx)("circle",{cx:n.clusteredX,cy:n.clusteredY,r:o?1.2*r:r,fill:n.category.color,opacity:s?o?.85:.6:.85,style:{filter:!o&&s?"blur(1px)":"none"},className:"cursor-pointer transition-all duration-200"})]})})},b9=e=>{let{entries:t,startDate:n,numDays:r}=e;const s={top:20,right:20,bottom:10,left:50},a=(0,T.useRef)(),i=(0,T.useRef)(),{dataset:o,setDataset:l}=OU(),[u,c]=(0,T.useState)({width:0,height:0}),[h,d]=(0,T.useState)([]),[p,f]=(0,T.useState)(null);(0,T.useEffect)((()=>{const e=new ResizeObserver((e=>{let[t]=e;const{width:n,height:r}=t.contentRect;c({width:n,height:r})}));return i.current&&e.observe(i.current),()=>e.disconnect()}),[]);const m=(0,T.useMemo)((()=>{const e=new Date(n);return e.setDate(e.getDate()+(r||1)-1),e}),[n,r]),{xScale:g,yScale:y}=(0,T.useMemo)((()=>{const e=432e5;return{xScale:h9().domain([new Date((null===n||void 0===n?void 0:n.getTime())-e),new Date((null===m||void 0===m?void 0:m.getTime())+e)]).range([s.left,u.width-s.right]),yScale:h9().domain([new Date(1970,0,1,0,0),new Date(1970,0,1,23,59)]).range([s.top+35,u.height-s.bottom])}}),[n,m,u,s.bottom,s.left,s.right,s.top]);(0,T.useEffect)((()=>{if(!n||!m||0===u.width)return;const e=t.filter((e=>{const t=new Date(e.timestamp);return t>=n&&t<=new Date(m).setHours(23,59,59,999)})),r=e.map((e=>{const t=new Date(e.timestamp),n=new Date(t);return n.setFullYear(1970,0,1),{...e,fullDate:t,timeOnly:n}})),a=12.5,i=(u.width-s.left-s.right)/5/21;r.forEach((e=>{e.rawY=y(e.timeOnly),e.clusterY=Math.floor(e.rawY/a)*a}));const o=Q2(r,(e=>e.clusterY)),l=[];o.forEach((e=>{Q2(e,(e=>X6.floor(e.fullDate).getTime())).forEach(((e,t)=>{const n=g(new Date(Number(t)));e.forEach(((e,t)=>{const r=Math.floor(t/i),s=e.clusterY+r*a,o=12.5*(t%i-Math.floor(i/2));l.push({...e,clusteredX:n+o,clusteredY:s})}))}))})),d(l)}),[t,n,m,u,g,y,s.bottom,s.left,s.right,s.top]);const b=(0,T.useRef)(null),v=e=>{b.current&&clearTimeout(b.current),e?f(e):b.current=setTimeout((()=>f(null)),100)};return(0,tr.jsx)("div",{ref:i,className:"flex-grow",children:u.width>0&&u.height>0&&(0,tr.jsxs)("svg",{ref:a,width:u.width,height:u.height,children:[(0,tr.jsx)(m9,{scale:g,height:u.height,width:u.width,margin:s}),(0,tr.jsx)(g9,{scale:y,margin:s}),(0,tr.jsx)("g",{children:q6.range(new Date(1970,0,1,6),new Date(1970,0,2,0),6).map(((e,t)=>(0,tr.jsx)("line",{x1:1.2*s.left,y1:y(e),x2:u.width-s.right,y2:y(e),opacity:.5,stroke:"#9db",strokeWidth:1,strokeDasharray:"4 4"},t)))}),(0,tr.jsxs)("g",{children:[X6.range(n,m,1).map(((e,t)=>{const n=(t+1)*(u.width-s.left-s.right)/r+s.left;return(0,tr.jsx)("line",{x1:n,y1:s.top,x2:n,y2:u.height-s.top,stroke:"#cd5",strokeWidth:2},t)})),(0,tr.jsx)("line",{x1:u.width-s.right,y1:s.top,x2:u.width-s.right,y2:u.height-s.top,stroke:"#cd5",strokeWidth:2})]}),h.map(((e,t)=>(0,tr.jsx)(y9,{point:e,obscure:null===p||void 0===p?void 0:p.query,radius:5,selectedPoint:p,onSelect:v},t))),p&&(0,tr.jsx)(f9,{point:p,radius:5,position:{x:p.clusteredX,y:p.clusteredY,isBeforeNoon:p.fullDate.getHours()<12},onClose:()=>v(null),onCategoryChange:async(e,t)=>{const n=sZ.find((e=>e.id===t));if(!n||null===e||void 0===e||!e.id)return;const r={...e,category:n},s=o.records.map((t=>t.id===e.id?r:t));l({...o,records:s});const a=await nZ();if("user"===o.source){const t=await a.get(rZ,e.id);t&&await a.put(rZ,{...t,category:n})}else if("saved"===o.source){const e=(await a.getAll("savedDatasets")).find((e=>e.name===o.label));e&&await a.put("savedDatasets",{...e,records:s,date:(new Date).toISOString()})}f(r),d((t=>t.map((t=>t.id===e.id?r:t))))}})]})})},v9=e=>{let{startDate:t,onToggle:n,numDays:r=7}=e;const s=new Date(t);s.setDate(t.getDate()+(r-1));const a=t?`${T8("%b %d, %Y")(t)}${r>1?` - ${T8("%b %d, %Y")(s)}`:""}`:"Select Date";return(0,tr.jsx)("h3",{onClick:n,className:"text-md text-white font-semibold text-center cursor-pointer",style:{fontFamily:"Noto Sans JP"},children:a})};function x9(e){var t,n,r="";if("string"==typeof e||"number"==typeof e)r+=e;else if("object"==typeof e)if(Array.isArray(e)){var s=e.length;for(t=0;t<s;t++)e[t]&&(n=x9(e[t]))&&(r&&(r+=" "),r+=n)}else for(n in e)e[n]&&(r&&(r+=" "),r+=n);return r}const w9=function(){for(var e,t,n=0,r="",s=arguments.length;n<s;n++)(e=arguments[n])&&(t=x9(e))&&(r&&(r+=" "),r+=t);return r},k9=(e,t)=>(null===e||void 0===e?void 0:e.toDateString())===(null===t||void 0===t?void 0:t.toDateString()),S9=e=>{let{monthStart:t,startDate:n,numDays:r,annotations:s,onSelectDate:a}=e;const i=new Date;i.setHours(0,0,0,0);const o=t.getMonth(),l=t.getFullYear(),u=new Date(l,o,1),c=new Date(l,o+1,0),h=[];for(let p=u.getDay();p>0;p--){const e=new Date(u);e.setDate(e.getDate()-p),h.push({date:e,isCurrentMonth:!1})}for(let p=1;p<=c.getDate();p++)h.push({date:new Date(l,o,p),isCurrentMonth:!0});for(;h.length%7!==0;){const e=h[h.length-1].date,t=new Date(e);t.setDate(e.getDate()+1),h.push({date:t,isCurrentMonth:!1})}const d=new Date(n);return d.setDate(n.getDate()+(r-1)),(0,tr.jsxs)("div",{className:" max-w-xs border rounded p-2",children:[(0,tr.jsx)("div",{className:"text-center font-semibold mb-1",children:u.toLocaleString("default",{month:"long",year:"numeric"})}),(0,tr.jsx)("div",{className:"grid grid-cols-7 text-xs font-medium text-gray-500 mb-1",children:["S","M","T","W","T","F","S"].map(((e,t)=>(0,tr.jsx)("div",{children:e},`${e}-${t}`)))}),(0,tr.jsx)("div",{className:"grid grid-cols-7 gap-1",children:h.map(((e,t)=>{var r,o;let{date:l,isCurrentMonth:u}=e;const c=l.toISOString().split("T")[0],h=k9(l,n),p=l>n&&l<d,f=k9(l,d),m=null!==(r=null===(o=s[c])||void 0===o?void 0:o.strength)&&void 0!==r?r:0,g=h?"border-l border-t border-b rounded-l":f?"border-r border-t border-b rounded-r":p?"border-t border-b":"";return(0,tr.jsx)("button",{onClick:()=>a(l),disabled:l>i||l<new Date(2020,0,1),className:w9("text-xs p-1 border text-center transition font-semibold",{"text-gray-400":!u,"hover:bg-indigo-100":u},g),style:{backgroundColor:m?`rgba(79, 70, 229, ${Math.min(m,1)})`:void 0},children:l.getDate()},t)}))})]})},N9=e=>{let{startDate:t,onSelectDate:n,numDays:r,annotations:s={},onClose:a}=e;const i=[],o=(new Date).getFullYear();for(let l=2020;l<=o;l++)for(let e=0;e<12;e++)i.push(new Date(l,e,1));return(0,tr.jsxs)("div",{className:"h-full overflow-y-scroll bg-white z-40 shadow-inner px-4 py-6",children:[(0,tr.jsxs)("div",{className:"flex justify-between items-center mb-4",children:[(0,tr.jsx)("h2",{className:"text-xl font-semibold",children:"Select Start Date"}),(0,tr.jsx)("button",{className:"text-indigo-600 hover:underline text-sm font-medium",onClick:a,children:"Close"})]}),(0,tr.jsx)("div",{className:"grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4",children:i.map(((e,a)=>(0,tr.jsx)(S9,{monthStart:e,startDate:t,numDays:r,annotations:s,onSelectDate:n},a)))})]})},I9=()=>(0,tr.jsx)("div",{className:"w-full overflow-x-auto py-2 px-4 border-t border-b border-gray-200",children:(0,tr.jsx)("div",{className:"flex flex-wrap gap-x-6 gap-y-2 items-center text-sm whitespace-nowrap",children:sZ.map((e=>(0,tr.jsxs)("div",{className:"flex items-center gap-2",children:[(0,tr.jsx)("span",{className:"w-3 h-3 rounded-full inline-block",style:{backgroundColor:e.color}}),(0,tr.jsx)("span",{className:"text-md text-white font-semibold text-center",style:{fontFamily:"Noto Sans JP"},children:e.name})]},e.id)))})});const C9=()=>{var e;const{dataset:t,setDataset:n}=OU(),[r,s]=(0,T.useState)((()=>new Date)),[a,i]=(0,T.useState)(1),[o,l]=(0,T.useState)("calendar"),[u,c]=(0,T.useState)(!1),[h,d]=(0,T.useState)(!1),p=(0,T.useRef)(null);(0,T.useEffect)((()=>{const e=new ResizeObserver((e=>{let[t]=e;const n=t.contentRect.width,r=n<=768?1:Math.max(1,Math.floor(n/300));i(r)}));return p.current&&e.observe(p.current),()=>e.disconnect()}),[]);return null!==t&&void 0!==t&&null!==(e=t.records)&&void 0!==e&&e.length?(0,tr.jsxs)("div",{ref:p,className:"flex flex-col h-screen overflow-hidden relative",children:[(0,tr.jsx)("div",{className:"absolute top-4 right-4 z-50 bg-black bg-opacity-60 text-white rounded shadow-lg",children:["calendar","monthGrid","view3","view4"].map((e=>(0,tr.jsx)("button",{onClick:()=>l(e),className:"px-3 py-1 block text-left w-full hover:bg-white hover:text-black "+(o===e?"bg-white text-black font-bold":""),children:e},e)))}),(0,tr.jsx)("div",{className:"absolute top-4 left-4 z-50",children:(0,tr.jsx)("button",{onClick:()=>c(!0),className:"bg-blue-500 text-white px-4 py-2 rounded shadow hover:bg-blue-600",children:"Classify"})}),u&&(0,tr.jsx)("div",{className:"absolute inset-0 z-50 flex items-center justify-center bg-black bg-opacity-60",children:(0,tr.jsxs)("div",{className:"bg-white p-6 rounded shadow-md text-black space-y-4 w-[300px]",children:[(0,tr.jsx)("p",{children:"Classify queries in the selected date range?"}),(0,tr.jsxs)("div",{className:"flex justify-end gap-2",children:[(0,tr.jsx)("button",{onClick:()=>c(!1),className:"px-3 py-1 bg-gray-300 rounded",children:"Cancel"}),(0,tr.jsx)("button",{onClick:async()=>{c(!1),d(!0);try{const e=function(e,t,n){const r=v2.fromJSDate(t).startOf("day"),s=r.plus({days:n});return e.filter((e=>{if(!e.timestamp)return!1;const t=v2.fromISO(e.timestamp);return t>=r&&t<s}))}(t.records,r,a),s=e.map((e=>e.query)),i=await(async e=>{const t=await fetch("http://backend:6000/classify",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({queries:e})});if(!t.ok)throw new Error("API call failed");return await t.json()})(s);console.log("\ud83d\udd0d Classification results:",i);const o=t.records.map((e=>{const t=i.find((t=>t.query===e.query));return t?{...e,category:{id:t.category,name:t.category,color:t.color}}:e})),l=(await nZ()).transaction(rZ,"readwrite"),u=l.objectStore(rZ);for(const t of o)void 0!==t.id&&await u.put(t);await l.done,n({...t,records:o})}catch($9){console.error("\u274c Classification failed:",$9),alert("Classification failed. See console for details.")}finally{d(!1)}},className:"px-3 py-1 bg-blue-500 text-white rounded hover:bg-blue-600",children:h?"Classifying...":"Continue"})]})]})}),(0,tr.jsx)("div",{className:"h-full pt-10 min-h-0 overflow-hidden",children:"monthGrid"===o?(0,tr.jsx)(N9,{startDate:r,onSelectDate:e=>s(e),numDays:a,onClose:()=>l("calendar")}):"calendar"===o?(0,tr.jsxs)("div",{className:"w-full h-full flex-col flex",children:[(0,tr.jsx)(b9,{startDate:r,entries:t.records,numDays:a}),(0,tr.jsx)(I9,{})]}):(0,tr.jsxs)("div",{className:"h-full flex items-center justify-center text-white text-xl",children:["Placeholder for ",o]})}),(0,tr.jsx)("div",{className:"flex justify-center py-3 bg-black bg-opacity-80",children:(0,tr.jsx)(v9,{startDate:r,onToggle:()=>l((e=>"monthGrid"===e?"calendar":"monthGrid")),numDays:a})})]}):(0,tr.jsx)("p",{className:"text-white text-center mt-10",children:"\u26a0\ufe0f No dataset selected. Please select or upload a dataset."})};const T9=function(){return(0,tr.jsx)(wt,{children:(0,tr.jsxs)("div",{className:"bg-[#131818] flex flex-col min-h-dvh items-center w-full overflow-y-auto",children:[(0,tr.jsx)(nr,{}),(0,tr.jsx)("main",{className:"w-full flex-grow flex",children:(0,tr.jsxs)(Ve,{children:[(0,tr.jsx)(ze,{path:"/",element:(0,tr.jsx)(EU,{})}),(0,tr.jsx)(ze,{path:"/about",element:(0,tr.jsx)($U,{})}),(0,tr.jsx)(ze,{path:"/datasets",element:(0,tr.jsx)(U2,{})}),(0,tr.jsx)(ze,{path:"/visualise",element:(0,tr.jsx)(C9,{})})]})}),(0,tr.jsx)(or,{})]})})},A9=e=>{e&&e instanceof Function&&n.e(453).then(n.bind(n,453)).then((t=>{let{getCLS:n,getFID:r,getFCP:s,getLCP:a,getTTFB:i}=t;n(e),r(e),s(e),a(e),i(e)}))};A.createRoot(document.getElementById("root")).render((0,tr.jsx)(T.StrictMode,{children:(0,tr.jsx)(DU,{children:(0,tr.jsx)(T9,{})})})),A9()})()})();
//# sourceMappingURL=main.55234c0e.js.map